<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>数据容器 - Learning Programming Book</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="The example book covers examples.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../theme/pagetoc.css">
        <!-- MathJax -->
        <!-- <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script> -->
        <script async type="text/javascript" src="theme/MathJax.js"></script>
        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../prefix.html">Prefix</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">程序设计语言</li><li class="chapter-item expanded "><a href="../Python/Python编程基础.html">Python</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Python/Python编程基础.html">编程基础</a></li><li class="chapter-item expanded "><a href="../Python/Python开发环境.html">开发环境</a></li><li class="chapter-item expanded "><a href="../Python/Python数据类型.html">数据类型</a></li><li class="chapter-item expanded "><a href="../Python/Python输入输出.html">输入输出</a></li><li class="chapter-item expanded "><a href="../Python/Python编程应用.html">编程应用</a></li><li class="chapter-item expanded "><a href="../Python/Python数值计算.html">数值计算</a></li><li class="chapter-item expanded "><a href="../Python/Python系统编程.html">系统编程</a></li><li class="chapter-item expanded "><a href="../Python/Python高级编程.html">高级编程</a></li></ol></li><li class="chapter-item expanded "><a href="../Java/JAVA编程基础.html">Java</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Java/JAVA编程基础.html">编程基础</a></li><li class="chapter-item expanded "><a href="../Java/Java开发环境.html">开发环境</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Java/Maven POM.html">Maven 配置</a></li></ol></li><li class="chapter-item expanded "><a href="../Java/JAVA数据类型.html">数据类型</a></li><li class="chapter-item expanded "><a href="../Java/JAVA输入输出.html">输入输出</a></li><li class="chapter-item expanded "><a href="../Java/JAVA系统编程.html">系统编程</a></li><li class="chapter-item expanded "><a href="../Java/Scala.html">Scala</a></li><li class="chapter-item expanded "><a href="../Java/ScalaFrameworks.html">Scala 框架</a></li></ol></li><li class="chapter-item expanded "><a href="../CSharp.NET/CSharp编程基础.html">C#/.NET</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../CSharp.NET/CSharp编程基础.html">编程基础</a></li><li class="chapter-item expanded "><a href="../CSharp.NET/CSharp输入输出.html">输入输出</a></li><li class="chapter-item expanded "><a href="../CSharp.NET/CSharp数据容器.html">数据容器</a></li><li class="chapter-item expanded "><a href="../CSharp.NET/CSharp数值计算.html">数值计算</a></li><li class="chapter-item expanded "><a href="../CSharp.NET/dotnet开发.html">.NET 开发</a></li></ol></li><li class="chapter-item expanded "><a href="../CC++/Modern C++.html">C and C++</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../CC++/Modern C++.html">Modern C++</a></li><li class="chapter-item expanded "><a href="../CC++/C++开发环境.html">开发环境</a></li><li class="chapter-item expanded "><a href="../CC++/C++容器.html" class="active">数据容器</a></li><li class="chapter-item expanded "><a href="../CC++/输入输出.html">输入输出</a></li><li class="chapter-item expanded "><a href="../CC++/标准函数库.html">标准库</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../CC++/数学函数.html">数学函数</a></li></ol></li></ol></li><li class="chapter-item expanded "><div>Web开发</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../JavaScript/JavaScript.html">JavaScript</a></li><li class="chapter-item expanded "><a href="../JavaScript/TypeScript.html">TypeScript</a></li><li class="chapter-item expanded "><a href="../JavaScript/JS开发环境.html">开发环境</a></li></ol></li><li class="chapter-item expanded "><div>开发工具</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../开发环境/git.html">Git</a></li><li class="chapter-item expanded "><a href="../笔记/正则表达式.html">正则表达式</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><li class="part-title">操作系统</li><li class="chapter-item expanded "><a href="../Linux/Linux配置和管理.html">Linux</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Linux/Linux配置和管理.html">配置管理</a></li><li class="chapter-item expanded "><a href="../Linux/Linux-Shell.html">Shell Script</a></li><li class="chapter-item expanded "><a href="../Linux/Linux发行版.html">Linux 发行版</a></li><li class="chapter-item expanded "><a href="../Linux/操作系统原理.html">操作系统原理</a></li></ol></li><li class="chapter-item expanded "><a href="../Windows/Windows配置管理.html">Windows</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Windows/Windows配置管理.html">配置管理</a></li><li class="chapter-item expanded "><a href="../Windows/Windows Shell.html">Shell</a></li><li class="chapter-item expanded "><a href="../Windows/Windows Applications.html">应用软件</a></li></ol></li><li class="chapter-item expanded "><div>应用软件</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../应用软件/程序开发软件.html">程序开发</a></li><li class="chapter-item expanded "><a href="../应用软件/服务器管理软件.html">服务器管理</a></li><li class="chapter-item expanded "><a href="../应用软件/网络访问软件.html">网络访问</a></li><li class="chapter-item expanded "><a href="../应用软件/网络服务软件.html">网络服务</a></li><li class="chapter-item expanded "><a href="../应用软件/文档生成软件.html">文档生成</a></li><li class="chapter-item expanded "><a href="../应用软件/文件处理软件.html">文件处理</a></li><li class="chapter-item expanded "><a href="../应用软件/协作办公软件.html">协作办公</a></li><li class="chapter-item expanded "><a href="../应用软件/知识管理软件.html">知识管理</a></li><li class="chapter-item expanded "><a href="../应用软件/多媒体编辑软件.html">多媒体编辑</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><li class="part-title">机器学习</li><li class="chapter-item expanded "><a href="../机器学习/机器学习实践.html">机器学习实践</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../机器学习/ScikitLearn.html">scikit-learn</a></li><li class="chapter-item expanded "><a href="../机器学习/TensorFlow.html">TensorFlow</a></li><li class="chapter-item expanded "><a href="../机器学习/Pytorch.html">Pytorch</a></li><li class="chapter-item expanded "><a href="../机器学习/图神经网络.html">图神经网络</a></li></ol></li><li class="chapter-item expanded "><a href="../机器学习/机器学习原理与算法.html">原理与算法</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../机器学习/统计学习算法.html">统计学习算法</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><li class="part-title">数据库</li><li class="chapter-item expanded "><a href="../数据库/SQL语法.html">SQL</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../数据库/SQL DDL.html">SQL DDL</a></li><li class="chapter-item expanded "><a href="../数据库/SQL DML.html">SQL DML</a></li><li class="chapter-item expanded "><a href="../数据库/SQL数据类型.html">数据类型</a></li></ol></li><li class="chapter-item expanded "><a href="../数据库/MySQL.html">MySQL</a></li><li class="chapter-item expanded "><a href="../数据库/PostgreSQL.html">PostgreSQL</a></li><li class="chapter-item expanded "><a href="../数据库/HiveSQL.html">Hive SQL</a></li><li class="chapter-item expanded "><a href="../数据库/Elasticsearch.html">Elasticsearch</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../数据库/Elastic Datasource.html">数据源</a></li></ol></li><li class="chapter-item expanded "><a href="../数据库/Mongodb.html">Mongodb</a></li><li class="chapter-item expanded "><a href="../数据库/GraphDatabase.html">图数据库</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">服务和大数据平台</li><li class="chapter-item expanded "><a href="../服务器/分布式大数据处理.html">分布式大数据处理</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../服务器/CDH6大数据集群离线安装.html">CDH6 安装教程</a></li><li class="chapter-item expanded "><a href="../服务器/Spark Python API.html">Pyspark</a></li><li class="chapter-item expanded "><a href="../服务器/流数据处理.html">流数据处理</a></li></ol></li><li class="chapter-item expanded "><a href="../服务器/容器编排.html">容器编排</a></li><li class="chapter-item expanded "><a href="../服务器/虚拟化.html">虚拟化</a></li><li class="chapter-item expanded "><div>任务编排</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../服务器/Airflow.html">Airflow</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><li class="part-title">其他</li><li class="chapter-item expanded "><div>数据标记语言</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../数据交换语言/JSON and YAML.html">JSON and YAML</a></li><li class="chapter-item expanded "><a href="../数据交换语言/XML.html">XML</a></li><li class="chapter-item expanded "><a href="../数据交换语言/HTML.html">HTML</a></li></ol></li><li class="chapter-item expanded "><div>网络协议</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Protocols/http.html">HTTP</a></li><li class="chapter-item expanded "><a href="../Protocols/DNS.html">DNS</a></li><li class="chapter-item expanded "><a href="../Protocols/端口分配.html">端口分配</a></li><li class="chapter-item expanded "><a href="../Protocols/IP protocol numbers.html">IP 承载协议</a></li><li class="chapter-item expanded "><a href="../Protocols/RPC.html">RPC</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Learning Programming Book</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <!-- Page table of contents -->
                        <div class="sidetoc"><nav class="pagetoc"></nav></div>

                        <h1 id="c容器"><a class="header" href="#c容器">C++容器</a></h1>
<h2 id="概述"><a class="header" href="#概述">概述</a></h2>
<p>标准容器都是模板类型，可以指定自定义的数据类型。</p>
<p>容器分为三类：序列容器、关联容器、容器适配器。</p>
<p><strong>序列容器</strong>保持元素添加的顺序，允许指定插入元素的位置。序列容器类型包括，<code>vector</code>、<code>list</code>和<code>deque</code>（双端队列）。<code>string</code>类具有与序列容器相同的基本操作。</p>
<p><strong>关联容器</strong>的元素以预先给定的顺序插入，例如排序顺序，分为两个子类：<code>map</code>(dictionary)和<code>set</code>。<code>map</code>(dictionary)由key/value组成，其中key用于排序。<code>set</code>中的元素按升序排列。</p>
<p>容器适配器包括：<code>stack</code>，<code>queue</code>，<code>priority_queue</code>。容器适配器不支持迭代，不能用于STL算法。</p>
<h3 id="迭代器"><a class="header" href="#迭代器">迭代器</a></h3>
<p>标准库为每一种标准容器定义了<strong>迭代器类型</strong><code>container&lt;type&gt;::iterator</code>（常量迭代器类型<code>container&lt;type&gt;::const_iterator</code>）。</p>
<pre><code class="language-c++">container.begin();     // → @first_element
container.end();       // → @one_behind_last_element
std::begin(container); // → @first_element
std::end(container);   // → @one_behind_last_element
</code></pre>
<blockquote>
<p>使用<code>@pos</code>代表迭代器。</p>
</blockquote>
<p><code>rbegin()</code>，<code>rend()</code>用于反向迭代。</p>
<p><code>const_iterator</code>类型只能用于读取容器内元素，但不能改变其值，返回迭代器的函数以<code>c</code>开头，与<code>iterator</code>类型的返回函数对应。</p>
<h4 id="迭代器运算"><a class="header" href="#迭代器运算">迭代器运算</a></h4>
<pre><code class="language-c++">vector&lt;int&gt; v {1,2,3,4,5,6,7}
auto i = begin(v);   // 获取迭代器
auto e = end(v);
cout &lt;&lt; *i;    // 访问容器元素
++i;   // =&gt; pos=std::next(pos);     // move to end() by 1 element
--i;   // =&gt; pos=std::prev(pos);     // move to begin() by 1 element
i+=2;  // =&gt; pos=std::next(pos,2);   // move forward
i-=3;  // =&gt; pos=std::next(pos, -3); // move backward
</code></pre>
<blockquote>
<p><code>end()</code>返回的迭代器不指向任何元素。迭代器的移动运算结果只有在<code>begin()</code>到<code>end()</code>之间才是有效的。</p>
</blockquote>
<p>同指针一样，可以<strong>使用解引用操作符（<code>*, -&gt;</code>）来访问容器中的元素</strong>。</p>
<p>用<code>==</code>或<code>!=</code>运算符来比较两个迭代器，如果两个迭代器对象指向同一个元素，则它们相等，否则就不相等。</p>
<h4 id="迭代区间"><a class="header" href="#迭代区间">迭代区间</a></h4>
<p>容器的部分操作支持以迭代区间作为参数。</p>
<pre><code class="language-c++">vector&lt;int&gt; v (begin(u)+i, begin(u)+j);   // [i,j)
w.assign(begin(u)+i, end(u)+j);
</code></pre>
<h3 id="容器初始化类型推断-c17"><a class="header" href="#容器初始化类型推断-c17">容器初始化类型推断 <code>C++17</code></a></h3>
<pre><code class="language-c++">std::vector v {1, 2, 3, 4};   // std::vector&lt;int&gt;
</code></pre>
<h3 id="容器属性"><a class="header" href="#容器属性">容器属性</a></h3>
<p><code>size</code>，获取容器的长度（元素数量）；<code>empty</code>，判断容器是否为空。</p>
<pre><code class="language-c++">size_type n = v.size();
bool tf = v.empty();   // [c++17] std::empty(container)
</code></pre>
<h3 id="容器方法"><a class="header" href="#容器方法">容器方法</a></h3>
<h5 id="赋值"><a class="header" href="#赋值">赋值</a></h5>
<p><code>assign</code>，为容器重新赋值；“<code>=</code>”操作符。</p>
<pre><code class="language-c++">v.assign(@First, @Last); 
</code></pre>
<h5 id="比较"><a class="header" href="#比较">比较</a></h5>
<p>同类型容器间比较，对于<code>==</code>，元素数量相同且对应值相等返回<code>true</code>。其他运算符包括<code>!=</code>，<code>&lt;</code>，<code>&gt;</code>，<code>&gt;=</code>，<code>&lt;=</code>。</p>
<pre><code class="language-c++">bool values_same = s1 == s2;  // true
</code></pre>
<h5 id="删除"><a class="header" href="#删除">删除</a></h5>
<pre><code class="language-c++">c.erase(@pos)        // → @behind_deleted
c.erase(@begin,@end) // → @behind_last_deleted
</code></pre>
<p><code>clear</code>，删除容器中的所有元素，等价于调用<code>erase(begin(),end())</code>。</p>
<pre><code class="language-c++">void clear( );  
</code></pre>
<h5 id="遍历访问"><a class="header" href="#遍历访问">遍历访问</a></h5>
<p>适用于所有序列容器和关联容器。</p>
<pre><code class="language-c++">for(type variable : container){}// no out-of-bounds access possible
</code></pre>
<blockquote>
<p>迭代变量声明：</p>
<ul>
<li><code>type variable</code>：read-only, type cheap to copy；</li>
<li><code>type const &amp; variable</code>：read-only, type expensive to copy；</li>
<li><code>type &amp; variable</code>：modify values；</li>
<li><code>auto</code>：支持自动类型推导。</li>
</ul>
</blockquote>
<pre><code class="language-c++">range::for_each(v, func);       // c++20: no out-of-bounds access possible
range::for_each(@begin, @end, func); 
range::for_each_n(@begin, n, func);  // c++17: only for n elements
</code></pre>
<p>在循环中使用迭代器。</p>
<h6 id="反向遍历"><a class="header" href="#反向遍历">反向遍历</a></h6>
<pre><code class="language-c++">for(type variable : container | std::views::reverse){} // c++20
#include &lt;ranges&gt;  // std::ranges::for_each
namespace ranges = std::ranges;        // alias
namespace views = std::ranges::views;  // alias
ranges::for_each(views::reverse(v), [](auto x){ cout &lt;&lt; x; }); 
</code></pre>
<blockquote>
<p>works for all bidirectional containers.</p>
</blockquote>
<p>使用反向迭代器<code>rbegin(), rend()</code>。</p>
<h2 id="简单容器"><a class="header" href="#简单容器">简单容器</a></h2>
<pre><code class="language-c++">#include &lt;utility&gt;
pair&lt;int, double&gt; p {4, 2.0};
tuple&lt;int, double, vector&lt;int&gt;&gt; t = {4,2.0, vector&lt;int&gt;{1,2,3}} //c++11
</code></pre>
<blockquote>
<p><code>c++17</code>支持类型自动推导。</p>
<pre><code class="language-c++">std::tie(i,j,k) = func_return_tuple();  // 展开返回参数
auto [i,j,k] = func_return_tuple_or_struct();  //c++17
</code></pre>
</blockquote>
<h2 id="序列容器"><a class="header" href="#序列容器">序列容器</a></h2>
<h5 id="array"><a class="header" href="#array">array</a></h5>
<p><img src="hackingcpp/sequence_containers_array.png" alt="" /></p>
<p><code>array</code>类型不支持更改容器的容量。</p>
<pre><code class="language-c++">#include &lt;array&gt;
std::array&lt;int,6&gt; a {4,8,15,16,23,42}; // array长度必须在编译期间确定（常量）
</code></pre>
<h3 id="序列容器支持的操作"><a class="header" href="#序列容器支持的操作">序列容器支持的操作</a></h3>
<h5 id="赋值-1"><a class="header" href="#赋值-1">赋值</a></h5>
<pre><code class="language-c++">v.assign(count, value);
</code></pre>
<h5 id="属性"><a class="header" href="#属性">属性</a></h5>
<p><code>max_size</code>，在不断分配内存情况下，允许存储的元素最大数量；。</p>
<pre><code class="language-c++">size_type n = v.max_size();  
</code></pre>
<p><code>resize</code>：更改容器的长度，如果没有指定初始值，新增加的值被设为默认初始值。</p>
<pre><code class="language-c++">v.resize(size_type n);  
v.resize(size_type n, value);  
</code></pre>
<blockquote>
<p>将容器长度设置为0等价于<code>v.clear()</code>。</p>
</blockquote>
<h5 id="访问"><a class="header" href="#访问">访问</a></h5>
<p>返回容器中最后一个/第一个元素。</p>
<pre><code class="language-c++">[const_]reference back( ) [const];
[const_]reference front( ) [const];  
</code></pre>
<p>如果容器为空，则返回结果不确定。如果将返回值赋值给常量引用，则返回值不能被修改，如果赋值给普通引用，则返回值可以修改。</p>
<h5 id="插入"><a class="header" href="#插入">插入</a></h5>
<p><code>insert</code>，<code>emplace</code>*，在迭代器指定位置插入单个，多个值或连续的一列值；</p>
<pre><code class="language-c++">v.insert(@pos, value);         // return 
v.insert(@pos, T&amp;&amp;value); 
v.insert(@pos, count, value);
v.insert(@pos, @first, @Last);
v.insert(@pos, list);
v.emplace(@pos, Args&amp;&amp;...args); //[c++11]
</code></pre>
<p>返回插入的首个元素的迭代器，如果未插入任何元素，返回<code>@pos</code>。<code>emplace</code>直接用参数构造的对象插入容器（<a href="https://hackingcpp.com/cpp/lang/perfect_forwarding.html">完美转发</a>）。</p>
<blockquote>
<ul>
<li>引用容器的位置参数<code>@pos</code>从普通迭代器变为常量迭代器<code>c++11</code>；</li>
<li>插入容器的值支持移动语义<code>c++11</code>；</li>
<li>返回值类型从迭代器变为常量迭代器<code>c++20</code>。</li>
</ul>
</blockquote>
<p><code>push_back</code>，<code>emplace_back</code>，在容器末端插入元素；</p>
<pre><code class="language-c++">void push_back(value);
void emplace_back(Args&amp;&amp;...args);  
</code></pre>
<blockquote>
<p><code>emplace_back</code>提供可变参数列表适配构造函数，当参数是容器元素引用时，调用移动构造函数，和其他容器的调用方法一致。</p>
</blockquote>
<h5 id="删除-1"><a class="header" href="#删除-1">删除</a></h5>
<p><code>pop_back</code>，从容器末端删除一个元素；</p>
<pre><code class="language-c++">void pop_back( );  
</code></pre>
<p>其他操作：交换，释放额外存储空间，保留最小存储空间。</p>
<h4 id="序列容器的特殊操作"><a class="header" href="#序列容器的特殊操作">序列容器的特殊操作</a></h4>
<h5 id="随机访问"><a class="header" href="#随机访问">随机访问</a></h5>
<p><code>vector</code>和<code>deque</code>支持随机访问，因此可以使用<code>at()</code>、操作符“<code>[]</code>”返回指定位置的元素，如果索引值大于容器的大小，则<code>at</code>抛出异常，而运算符“<code>[]</code>”的返回值是不确定的。如果将返回值赋值给常量引用，则返回值不能被修改，如果赋值给普通引用，则返回值可以修改。</p>
<pre><code class="language-c++">[const_]reference at(size_type _Pos) [const];
[const_]reference operator[](size_type _Pos)  [const];  
</code></pre>
<p>利用随机访问特性，可以使用序号遍历容器元素。</p>
<pre><code class="language-c++">for (int i = 0; i &lt; v.size(); ++i){cout &lt;&lt; v[i];}
</code></pre>
<h5 id="插入和删除"><a class="header" href="#插入和删除">插入和删除</a></h5>
<p><code>push_front，pop_front，emplace_front</code>，由于<code>list</code>支持在任意位置快速插入/删除元素，<code>deque</code>支持在首尾快速插入，因此这两个插入函数为<code>list</code>和<code>deque</code>提供更高效的插入方式。</p>
<h3 id="vector"><a class="header" href="#vector">vector</a></h3>
<p><img src="hackingcpp/sequence_containers_vector.png" alt="" /></p>
<p><code>vector</code>是序列容器（Array/List），元素按照线性方式存储，允许快速地随机访问。<code>vector</code>不提供查找功能。</p>
<pre><code class="language-c++">#include &lt;vector&gt;
using namespace std;
template &lt;
   		class Type, 					//元素数据类型
   		class Allocator = allocator&lt;Type&gt; 
&gt; class vector;
vector&lt;int&gt; v {2, 7, 9}; 
</code></pre>
<p>在<code>vector</code>末端进行插入和删除只需花费常数时间，在中间插入或删除需要线性时间。</p>
<blockquote>
<p><code>dequeue</code>容器优先用于在队列的首尾插入以及随机访问，<code>list</code>容器优先用于在任意位置插入或删除。</p>
</blockquote>
<p>当<code>vector</code>中的元素数目达到其容量时，<code>vector</code>就会重新分配存储空间，插入和删除也会造成元素存储地址的改变，这种情况下==先前创建的迭代器可能会失效==。</p>
<h4 id="构造函数"><a class="header" href="#构造函数">构造函数</a></h4>
<pre><code class="language-c++">vector&lt;int&gt; v2;     // vector(); =&gt; vector&lt;int&gt; v2{};  空向量
vector&lt;int&gt; v2(v1); // vector(const vector&amp; v);   拷贝构造函数
</code></pre>
<blockquote>
<p><strong>Copies Are Always <em>Deep</em>!</strong> Most types in the C++ standard library and ecosystem are <em>regular</em>.</p>
</blockquote>
<pre><code class="language-c++">vector&lt;int&gt; v2(5);    // explicit vector(count);   
vector&lt;int&gt; v2(5,2);  // vector(count, value); 
</code></pre>
<p>创建一个空的<code>vector</code>或创建大小为<code>count</code>的向量，指定<code>vector</code>的元素，如果没有指定元素的值，则元素值为类型的默认值。</p>
<pre><code class="language-c++">vector&lt;int&gt; v2 (@start, @end);  // vector(@First, @Last);
</code></pre>
<p>用指定的<code>vector</code>的一段来初始化新的<code>vector</code>。<code>First</code>是指向被拷贝段的第一个元素的迭代器，<code>Last</code>指向被拷贝元素后的一个元素。</p>
<h4 id="成员函数"><a class="header" href="#成员函数">成员函数</a></h4>
<pre><code class="language-c++">int n = v.capacity();
</code></pre>
<p>在目前不增加分配内存时，容器可储存的最大元素数量。</p>
<p>预留容量：与构造函数初始化指定数量的元素不同，预留的容量未被使用，而是用于后续添加的元素。</p>
<pre><code class="language-c++">v.reserve(new_capacity);
</code></pre>
<blockquote>
<p>缩小容量：</p>
<pre><code class="language-c++">shrink_to_fit 
v = vector&lt;int&gt;(v); // C++11-20
</code></pre>
</blockquote>
<h3 id="deque"><a class="header" href="#deque">deque</a></h3>
<p><img src="hackingcpp/sequence_containers_deque.png" alt="" /></p>
<p><code>deque</code>类（<u>D</u>ouble <u>E</u>nded <u>Q</u>ueue）以线性方式组织数据元素，与<code>vector</code>一样允许快速的随机访问以及高效地在末端插入和删除元素。但与<code>vector</code>不一样的，<code>deque</code>也支持==高效地在首端插入和删除元素==。</p>
<pre><code class="language-c++">#include &lt;deque&gt;
using namespace std;
template &lt;
   		class Type, 
   		class Allocator=allocator&lt;Type&gt; 
&gt; class deque
</code></pre>
<p>当成员函数需要插入或删除元素时，<code>deque</code>将会重新分配内存：</p>
<blockquote>
<ul>
<li>如果向空容器中插入元素，或将元素移除后容器为空，则先前返回的begin()或end()迭代器都会变成无效的。</li>
<li>如果在首端插入一个元素，则指向元素的所有迭代器（并非引用）将变成无效的。</li>
<li>如果在末端插入一个元素，则指向元素的所有迭代器（并非引用）将编程无效的。</li>
<li>如果<code>deque</code>容器首端的元素被移除，则只有被移除元素的引用和指针变为无效。</li>
<li>如果<code>deque</code>容器末端的元素被移除，则只有被移除元素的引用和指针变为无效。</li>
<li>其他情况，插入或删除将会导致所有迭代器和指针都变为无效的。</li>
</ul>
</blockquote>
<h4 id="构造函数-1"><a class="header" href="#构造函数-1">构造函数</a></h4>
<pre><code class="language-c++">deque();                // 空的deque容器
explicit deque(count);  // 大小为count的deque容器(默认值)
deque(count, value);    // 大小为count值为value的deque容器
deque(const deque&amp; d);  // 拷贝构造
deque(@first, @last);
</code></pre>
<h4 id="成员函数-1"><a class="header" href="#成员函数-1">成员函数</a></h4>
<p>在容器前端插入/删除元素：</p>
<pre><code class="language-c++">d.push_front(2);
d.pop_front();
</code></pre>
<h3 id="list"><a class="header" href="#list">list</a></h3>
<p><img src="hackingcpp/sequence_containers_list.png" alt="" /></p>
<p><code>list</code>使用双向链表存储，支持高效的插入和删除。</p>
<pre><code class="language-c++">#include &lt;list&gt;
using namespace std;
template&lt;class Type, class Allocator=allocator&lt;Type&gt;&gt; class list
</code></pre>
<h4 id="构造函数-2"><a class="header" href="#构造函数-2">构造函数</a></h4>
<pre><code class="language-c++">list();               // 创建空列表
explicit list(count); // 创建大小为count的列表
list(count, value);   // 创建的元素都被初始化为value。
list(const list&amp; li); // 使用已有列表创建新的列表
list(@first, @last);
</code></pre>
<h4 id="成员函数-2"><a class="header" href="#成员函数-2">成员函数</a></h4>
<h5 id="删除-2"><a class="header" href="#删除-2">删除</a></h5>
<p>删除所有匹配值对应的元素或满足条件的元素。</p>
<pre><code class="language-c++">li.remove(value);
template&lt;class UnaryPredicate&gt; // [](int n){return n&gt;10;}
    void remove_if(UnaryPredicate pred);
</code></pre>
<blockquote>
<p><code>C++20</code>：返回移除的元素数量。</p>
</blockquote>
<p>删除重复或满足条件的<strong>连续</strong>元素。</p>
<pre><code class="language-c++">li.unique();
template&lt;class BinaryPredicate&gt; void unique(BinaryPredicate _Pred);
</code></pre>
<blockquote>
<p><code>unique</code>假设列表经过了排序，所以重复元素都可以被检测到，而不连续的重复元素不能被检测到。</p>
<p>在<code>&lt;functional&gt;</code>和<code>&lt;xfunctional&gt;</code>中定义了部分比较条件，也可以自己定义比较条件。</p>
</blockquote>
<h5 id="排序"><a class="header" href="#排序">排序</a></h5>
<pre><code class="language-c++">li.sort();  // 默认升序
template&lt;class Compare&gt; void sort(Compare comp);
</code></pre>
<blockquote>
<p><code>comp</code>：比较函数对象。可以是一个返回<code>bool</code>值的二元比较函数，或者是一个重载了“<code>()</code>”运算符作为比较函数。</p>
<pre><code class="language-c++">class compare{
    public: bool operator()(left, right)const{
        return left.val&gt;_Right.val;
    }
};
</code></pre>
</blockquote>
<p>将队列反向排列：</p>
<pre><code class="language-c++">void reverse();
</code></pre>
<h5 id="合并操作"><a class="header" href="#合并操作">合并操作</a></h5>
<p>从一个列表将元素转移到另一个列表（移除另一个列表中的元素）。</p>
<pre><code class="language-c++">li.splice(@where, list&amp; other); //移动所有元素，other!=*this
li.splice(@where, list&amp; other, @first); //仅移动迭代器指向的元素
li.splice(@where, list&amp; other, @first, @last); //移动一个区间的元素(@where不应该位于区间内)
</code></pre>
<p>将转移的元素插入到<code>@where</code>引用的元素之前。</p>
<blockquote>
<p>不会复制或移动任何元素，仅修改内部指针；迭代器不会失效，但指向当前容器中的元素。</p>
<p>The behavior is undefined if: <code>get_allocator() != other.get_allocator()</code>.</p>
<p><code>C++11</code>列表参数支持移动语义（<code>list &amp;&amp;other</code>）</p>
</blockquote>
<p><code>merge</code>合并两个有序列表。</p>
<pre><code class="language-c++">li.merge(list&amp; other); 
template&lt;class Compare&gt;
    void merge(list&amp; other, Compare comp); 
</code></pre>
<p>合并规则：根据比较规则<code>comp</code>（默认为<code>&lt;</code>运算符，即升序），取出两个队列队首较小的元素放入新的队列（实际上不需要改变<code>*this</code>，而是将<code>other</code>的元素插入到<code>*this</code>中）。</p>
<p><code>merge</code>适用于已经排序的列表（<code>li.sort()</code>）的合并，合并后的结果仍然有序；反之，元素排列结果不确定（根据合并规则与实际值有关）。</p>
<h3 id="forward_list"><a class="header" href="#forward_list">forward_list</a></h3>
<p>单向链表（只能前向遍历）。</p>
<p><img src="hackingcpp/sequence_containers_forward_list.png" alt="" /></p>
<blockquote>
<p>somewhat cumbersome interface due to forward-only links</p>
<ul>
<li>no: <code>size()</code>, <code>back()</code>, <code>push_back()</code>, <code>pop_back()</code>, <code>insert()</code></li>
<li>instead: <code>insert_after()</code>, <code>splice_after()</code>, <code>before_begin()</code></li>
</ul>
</blockquote>
<h3 id="string"><a class="header" href="#string">string</a></h3>
<p>字符串动态数组，基本元素为<code>char</code>的<code>basic_string</code>具体类（类似于<code>vector&lt;char&gt;</code>）。<code>wstring</code>是基本元素为<code>wchar_t</code>的<code>basic_string</code>具体类。</p>
<pre><code class="language-c++">#include &lt;string&gt;
using namespace std;
typedef basic_string
         &lt;char,char_traits&lt;char&gt;,allocator&lt;char&gt;&gt; string;
typedef basic_string
         &lt;wchar_t,char_traits&lt;wchar_t&gt;,allocator&lt;wchar_t&gt;&gt; wstring;
</code></pre>
<h4 id="初始化"><a class="header" href="#初始化">初始化</a></h4>
<p>使用[字符串数组](Modern C++.md#字符串常量)初始化：没有指定字符数的函数则表示用整个字符串来初始化<code>string</code>。</p>
<pre><code class="language-c++">string s0;          // string();  empty string
string s1 = &quot;xyz&quot;;  // string(char const* ptr_cstr);
string(char const* ptr_cstr, count);
</code></pre>
<p>使用字符初始化。</p>
<pre><code class="language-c++">string(size_type count, char ch);
</code></pre>
<p>使用<code>string</code>类型字面值（后缀<code>s</code>）初始化：</p>
<pre><code class="language-c++">using namespace std::string_literals;
string s2 = &quot;std string literal&quot;s;   // string类型字面值[c++14]
string(str, @first, count);
string(@first, @last);
string s = R&quot;(raw &quot;std&quot;-string c:\users\moe )&quot;s;  // raw string literal[C++14]
</code></pre>
<h4 id="访问-1"><a class="header" href="#访问-1">访问</a></h4>
<p>除了<code>size()</code>之外，还有<code>length()</code>函数可返回<code>string</code>的元素总数（底层字符串的字节长度<code>size=length</code>）。</p>
<pre><code class="language-c++">char ch = str[index];
</code></pre>
<h5 id="底层数据"><a class="header" href="#底层数据">底层数据</a></h5>
<p>C-style字符串可以通过<code>string</code>的构造函数自动转换为<code>string</code>，但是<code>string</code>不能自动转换为C-style的字符串，需要使用以下函数。</p>
<pre><code class="language-c++">const char *c_str( ) const;	
const char *data( ) const;	
</code></pre>
<p>由于返回的是常量指针，所以不能通过返回的指针修改字符串。</p>
<p>返回指向<code>string</code>的字符内容的C-style字符串常量指针，当调用<code>string</code>的非<code>const</code>函数时，会导致指针变为无效。<code>string</code>的数据不会以“<code>\0</code>”结尾，“<code>\0</code>”在<code>string</code>对象中只是一个普通字符，但是返回的C-style字符串是以“<code>\0</code>”结尾的。</p>
<p><strong>复制字符串的内容</strong>：拷贝字符到字符数组，返回实际拷贝的字符数，不会在拷贝结果后面自动添加<code>null</code>字符，所以在拷贝前最好将源数组先初始化为全0。</p>
<pre><code class="language-c++">size_type copy(char* _Ptr, size_type _Count, size_type _Off = 0) const;
size_type _Copy_s(value_type *_Dest, size_type _Dest_size, 
                  size_type _Count, size_type _Off = 0) const;
</code></pre>
<h4 id="查找"><a class="header" href="#查找">查找</a></h4>
<p><code>find</code>：指向查找指定字符或字符串，返回首个符合条件的子串的首字符位置，如果没找到则返回<code>string::npos</code>(<code>=-1</code>)。</p>
<pre><code class="language-c++">s.find(&quot;r&quot;);
s.rfind(&quot;r&quot;);
</code></pre>
<p><code>find_first_of</code>：寻找首个属于制指定字符串的字符，找到返回其索引，否则返回<code>npos</code>。</p>
<p><code>find_first_not_of</code>：返回首个不属于指定子串的字符的位置，没找到则返回<code>npos</code>。</p>
<p><code>find_last_not_of</code>：寻找最后一个不在字串中的字符。</p>
<p><code>find_last_of</code>：寻找最后一个在字串中的字符。</p>
<p>查找子串：</p>
<pre><code class="language-c++">s.substr(idx, len)
</code></pre>
<h4 id="修改"><a class="header" href="#修改">修改</a></h4>
<p>==直接在目标字符串上作修改==。</p>
<h5 id="拼接"><a class="header" href="#拼接">拼接</a></h5>
<p>运算符<code>+</code>、<code>+=</code>：将字符、C-style字符串或<code>string</code>的部分或全部内容追加到目标字符串，返回目标字符串的引用。</p>
<pre><code class="language-c++">string&amp; append(const char* ptr);
string&amp; append(const char* ptr, count);
string&amp; append(other);
string&amp; append(other, offset, count);
string&amp; append(count, char ch);
string&amp; append(&amp;First, &amp;Last);
string&amp; append(@First, @Last);
</code></pre>
<blockquote>
<p>参数意义参考构造函数。</p>
<p>这里的迭代器或指针“<code>_Last</code>”是指要插入的最后一个元素的后一个位置，如果是整个插入一个<code>string</code>，则<code>_Last=string.end()</code>，如果插入整个C-style字符串，则<code>_Last=&amp;cstring[strlen(cstring)]</code>。</p>
</blockquote>
<h5 id="插入-1"><a class="header" href="#插入-1">插入</a></h5>
<p>在指定位置插入内容。</p>
<pre><code class="language-c++">str.insert(int idx, &quot;new content&quot;);
str.insert(@pos, &amp;first, &amp;last);
str.insert(@pos, @first, @last);
</code></pre>
<h5 id="删除-3"><a class="header" href="#删除-3">删除</a></h5>
<p><code>erase</code>（参考容器方法）：从字符串的指定位置删除一个元素或一部分元素。</p>
<pre><code class="language-c++">s.erase(index, count)
</code></pre>
<h5 id="替换"><a class="header" href="#替换">替换</a></h5>
<pre><code class="language-c++">s.replace(idx, len, &quot;contents&quot;)
</code></pre>
<h5 id="转换为数值"><a class="header" href="#转换为数值">转换为数值</a></h5>
<pre><code class="language-c++">#include &lt;string&gt; C++11
int    stoi (s);
long   stol (s);
float  stof (s);
double stod (s);
</code></pre>
<h3 id="序列类型视图"><a class="header" href="#序列类型视图">序列类型视图</a></h3>
<p>试图不负责资源的管理，仅是资源的一种表示方式。</p>
<ul>
<li>视图主要用于函数参数（轻量级复制），易于获取序列类型的子序列，总是引用有效内存，且使用<code>view</code>的对象不会破坏对象所有者的内存。</li>
<li>避免返回视图，容易产生无效视图，且不清楚该视图引用的是什么对象/内存。</li>
</ul>
<h4 id="string_view"><a class="header" href="#string_view">string_view</a></h4>
<p>==只读==访问：常量引用（<code>C++98/11/14</code>）；视图（<code>c++17/20</code>）；</p>
<pre><code class="language-c++">#include &lt;string_view&gt;  //c++17
std::string_view sv1 { str };
std::string_view sv2 {@pos, count}; //从@pos起连续count个字符
std::string_view sv3 {@start, @end};
</code></pre>
<blockquote>
<p>注意避免<code>string_view</code>比其初始化的字符串生命周期更长（例如在其初始化列表中构造的字符串对象）；</p>
</blockquote>
<h4 id="span"><a class="header" href="#span">span</a></h4>
<p>连续的内存区块（如<code>vector</code>，<code>array</code>）。</p>
<pre><code class="language-c++">span&lt;type&gt; s {v}; // c++20
span&lt;type const&gt; s {v};  // read-only access
span&lt;type&gt; s {@pos, count}; //从@pos起连续count个元素
span&lt;type&gt; s {@start, @end};
</code></pre>
<blockquote>
<p>支持自动类型推导，可省略模板类型。</p>
</blockquote>
<pre><code class="language-c++">tf = s.empty();
int n = s.size();
x = s[i];   //indexed access
s.begin(), s.end();  // iterator access
</code></pre>
<p>内存数据比较：</p>
<pre><code class="language-c++">bool memory_same = s1.data() == s2.data();  // false
</code></pre>
<blockquote>
<p>容器元素比较<code>s1==s2</code>。</p>
</blockquote>
<h5 id="subspan"><a class="header" href="#subspan">subspan</a></h5>
<pre><code class="language-c++">auto first3elements = s.first(3);
auto last3elements  = s.last(3);
auto subs = s.subspan(offset, count);
std::span&lt;std::byte const&gt; b = s.as_bytes();
std::span&lt;std::byte&gt; wb = s.as_writable_bytes();
</code></pre>
<h3 id="其他容器"><a class="header" href="#其他容器">其他容器</a></h3>
<h4 id="queue类"><a class="header" href="#queue类">queue类</a></h4>
<p>为底层的容器类型提供访问限制，元素只能从末端插入，从首端移除（FIFO），元素可以从queue的两端查看。</p>
<pre><code class="language-c++">template &lt;       
	class Type,           //元素类型       
	class Container = deque&lt;Type&gt; //容器类型  
 &gt; class queue  
</code></pre>
<p>合适的底层容器包括deque和list或其他支持front, back, push_back, and pop_front操作的线性容器。容器的元素类型必须与第一个参数一致。底层容器被封装在容器适配器中，容器适配器只提供了有限的线性容器成员函数。</p>
<h4 id="stack类"><a class="header" href="#stack类">stack类</a></h4>
<p>为底层的容器类型提供访问限制，使的只能对底层容器进行栈操作（后进先出，LIFO）。</p>
<pre><code class="language-c++">template &lt;class  Type, class Container=deque&lt;Type&gt; &gt; class stack;  
</code></pre>
<p>合适的底层容器包括deque、list和vector或其他支持back, push_back, and pop_back操作的线性容器。底层容器被封装在容器适配器中，容器适配器只提供了有限的线性容器成员函数。</p>
<h4 id="priority_queue类"><a class="header" href="#priority_queue类">priority_queue类</a></h4>
<p>为底层的容器类型提供访问限制，使底层容器具有priority queue的性质。容器中的元素是按值的性质排序的，即具有某种优先级。该类只支持在顶端插入、删除或查看元素。</p>
<pre><code class="language-c++">template &lt;
   class Type, 
   class Container=vector&lt;Type&gt;, 
   class Compare=less&lt;typename Container::value_type&gt;
&gt; class priority_queue  
</code></pre>
<h2 id="关联容器"><a class="header" href="#关联容器">关联容器</a></h2>
<p>关联容器分为集合（set）和映射（map），每种类型包括有序和无序两种类型。</p>
<p>有序关联容器的数据结构是平衡二叉树（<em>balanced binary tree</em>）。</p>
<img src="hackingcpp/map_layout.svg" style="zoom: 55%;" />
<p>无序关联容器的数据结构是哈希表（<em>hash table</em>，默认使用<code>std::hash&lt;Key&gt;</code>计算哈希值）。</p>
<img src="hackingcpp/unordered_map_layout.svg" style="zoom:55%;" />
<p>节点之间通过指针链接，集合类型节点（<code>container::node_type</code>）仅包含<code>key</code>，映射类型的每个节点包含<code>key</code>和<code>value</code>（<code>std::pair</code>）。</p>
<pre><code class="language-c++">#include &lt;set&gt;   // #include &lt;unordered_set&gt;
#include &lt;map&gt;   // #include &lt;unordered_map&gt;
</code></pre>
<h3 id="关联类型构造"><a class="header" href="#关联类型构造">关联类型构造</a></h3>
<h5 id="空容器"><a class="header" href="#空容器">空容器</a></h5>
<pre><code class="language-c++">std::set&lt;int&gt; s1;   // =&gt; std::set&lt;int&gt; s2 {};
std::map&lt;int&gt; m1;   // =&gt; std::map&lt;int&gt; m2 {};
</code></pre>
<h5 id="从数据构造集合"><a class="header" href="#从数据构造集合">从数据构造集合</a></h5>
<pre><code class="language-c++">std::set&lt;int&gt; s2 {3,2,1,4,5}; 
std::set&lt;int&gt; s {s1};          // set(other)
std::set&lt;int&gt; s (s1);          // set(other)
std::set&lt;int&gt; s (@start,@end); // set(@start, @end)
</code></pre>
<blockquote>
<p><code>c++17</code>支持自动类型推导。</p>
</blockquote>
<h3 id="关联类型支持的操作"><a class="header" href="#关联类型支持的操作">关联类型支持的操作</a></h3>
<h5 id="查找-1"><a class="header" href="#查找-1">查找</a></h5>
<pre><code class="language-c++">pos = s.find(7);      // return end() if not found
tf = s.contains(7);   // c++20
</code></pre>
<h5 id="删除-4"><a class="header" href="#删除-4">删除</a></h5>
<pre><code class="language-c++">s.erase(key);
</code></pre>
<h5 id="移动节点"><a class="header" href="#移动节点">移动节点</a></h5>
<pre><code class="language-c++">node = m.extract(key);       //→ node
node = m.extract(@position); //→ node
node.key() = &quot;new key&quot;;      // change key
m.insert(node);             // transfer node
</code></pre>
<h5 id="合并"><a class="header" href="#合并">合并</a></h5>
<pre><code class="language-c++">s.merge(t);      // 将t的元素转移至s中，t成为空容器。
</code></pre>
<h3 id="集合类型操作"><a class="header" href="#集合类型操作">集合类型操作</a></h3>
<h5 id="迭代"><a class="header" href="#迭代">迭代</a></h5>
<p>迭代器：<code>begin(s)</code>、<code>end(s)</code>、<code>rbegin(s)</code>、<code>rend(s)</code>。</p>
<pre><code class="language-c++">pair = s.insert(const Type&amp; value);  //return std::pair&lt;iterator, bool&gt;
pair = s.insert(Type&amp;&amp; value);  
it = s.insert(@hint, const value_type&amp; value ); 
s.insert(@first, @last);
s.insert(ilist);
</code></pre>
<blockquote>
<p>插入值位置<code>hint</code>从普通迭代器变为常量迭代器<code>c++11</code>；</p>
</blockquote>
<pre><code class="language-c++">pair = s.emplace(Args&amp;&amp;... args);
s.emplace_hint(@hint, Args&amp;&amp;... args)
</code></pre>
<p><code>set.emplace(args)</code>：使用参数直接构造集合元素并加入集合，避免不必要的复制操作。</p>
<h3 id="映射类型操作"><a class="header" href="#映射类型操作">映射类型操作</a></h3>
<h5 id="迭代-1"><a class="header" href="#迭代-1">迭代</a></h5>
<pre><code class="language-c++">for(auto const&amp; keyValuePair : myMap) {/*...*/}
for(auto const&amp; [key,value] : myMap) {/*...*/}   // c++17
</code></pre>
<p>迭代器：<code>begin(m)</code>、<code>end(m)</code>、<code>rbegin(m)</code>、<code>rend(m)</code>。</p>
<h5 id="插入-2"><a class="header" href="#插入-2">插入</a></h5>
<pre><code class="language-c++">pair = m.insert({key, value});   // return pair&lt;@pos,insert_success&gt;    
pair = m.insert(@hint, {key,value});
m.insert(@kv_pairs_begin,@kv_pairs_end);  
pair = m.emplace(key, value);            // c++11
pair = m.emplace_hint(@hint,key,value);  // c++11
pair = m.try_emplace(key,Arg1,Arg2,...); // c++17
m[key] = value;    // insert key if not found
m.at(key) = value; // throws out_of_range if key not found
m.insert_or_assign(key,value); // c++17
</code></pre>
<blockquote>
<p><code>emplace</code>使用参数直接构造要插入的节点，<code>try_emplace</code>使用参数列表直接构造要插入的节点的值<code>value</code>。</p>
</blockquote>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../CC++/C++开发环境.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="../CC++/输入输出.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../CC++/C++开发环境.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="../CC++/输入输出.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="../theme/pagetoc.js"></script>
        <script type="text/javascript" src="../theme/MathJax.js"></script>
    </body>
</html>