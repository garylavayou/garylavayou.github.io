<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Learning Programming Book</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="The example book covers examples.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/pagetoc.css">
        <!-- MathJax -->
        <!-- <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script> -->
        <script async type="text/javascript" src="theme/MathJax.js"></script>
        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="prefix.html">Prefix</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">程序设计语言</li><li class="chapter-item expanded "><a href="Python/Python编程基础.html">Python</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Python/Python编程基础.html">编程基础</a></li><li class="chapter-item expanded "><a href="Python/Python开发环境.html">开发环境</a></li><li class="chapter-item expanded "><a href="Python/Python数据类型.html">数据类型</a></li><li class="chapter-item expanded "><a href="Python/Python输入输出.html">输入输出</a></li><li class="chapter-item expanded "><a href="Python/Python编程应用.html">编程应用</a></li><li class="chapter-item expanded "><a href="Python/Python数值计算.html">数值计算</a></li><li class="chapter-item expanded "><a href="Python/Python系统编程.html">系统编程</a></li><li class="chapter-item expanded "><a href="Python/Python高级编程.html">高级编程</a></li></ol></li><li class="chapter-item expanded "><a href="Java/JAVA编程基础.html">Java</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Java/JAVA编程基础.html">编程基础</a></li><li class="chapter-item expanded "><a href="Java/Java开发环境.html">开发环境</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Java/Maven POM.html">Maven 配置</a></li></ol></li><li class="chapter-item expanded "><a href="Java/JAVA数据类型.html">数据类型</a></li><li class="chapter-item expanded "><a href="Java/JAVA输入输出.html">输入输出</a></li><li class="chapter-item expanded "><a href="Java/JAVA系统编程.html">系统编程</a></li><li class="chapter-item expanded "><a href="Java/Scala.html">Scala</a></li><li class="chapter-item expanded "><a href="Java/ScalaFrameworks.html">Scala 框架</a></li></ol></li><li class="chapter-item expanded "><a href="CSharp.NET/CSharp编程基础.html">C#/.NET</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="CSharp.NET/CSharp编程基础.html">编程基础</a></li><li class="chapter-item expanded "><a href="CSharp.NET/CSharp输入输出.html">输入输出</a></li><li class="chapter-item expanded "><a href="CSharp.NET/CSharp数据容器.html">数据容器</a></li><li class="chapter-item expanded "><a href="CSharp.NET/CSharp数值计算.html">数值计算</a></li><li class="chapter-item expanded "><a href="CSharp.NET/dotnet开发.html">.NET 开发</a></li></ol></li><li class="chapter-item expanded "><a href="CC++/Modern C++.html">C and C++</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="CC++/Modern C++.html">Modern C++</a></li><li class="chapter-item expanded "><a href="CC++/C++开发环境.html">开发环境</a></li><li class="chapter-item expanded "><a href="CC++/C++容器.html">数据容器</a></li><li class="chapter-item expanded "><a href="CC++/输入输出.html">输入输出</a></li><li class="chapter-item expanded "><a href="CC++/标准函数库.html">标准库</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="CC++/数学函数.html">数学函数</a></li></ol></li></ol></li><li class="chapter-item expanded "><div>Web开发</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="JavaScript/JavaScript.html">JavaScript</a></li><li class="chapter-item expanded "><a href="JavaScript/TypeScript.html">TypeScript</a></li><li class="chapter-item expanded "><a href="JavaScript/JS开发环境.html">开发环境</a></li></ol></li><li class="chapter-item expanded "><div>开发工具</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="开发环境/git.html">Git</a></li><li class="chapter-item expanded "><a href="笔记/正则表达式.html">正则表达式</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><li class="part-title">操作系统</li><li class="chapter-item expanded "><a href="Linux/Linux配置和管理.html">Linux</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Linux/Linux配置和管理.html">配置管理</a></li><li class="chapter-item expanded "><a href="Linux/Linux-Shell.html">Shell Script</a></li><li class="chapter-item expanded "><a href="Linux/Linux发行版.html">Linux 发行版</a></li><li class="chapter-item expanded "><a href="Linux/操作系统原理.html">操作系统原理</a></li></ol></li><li class="chapter-item expanded "><a href="Windows/Windows配置管理.html">Windows</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Windows/Windows配置管理.html">配置管理</a></li><li class="chapter-item expanded "><a href="Windows/Windows Shell.html">Shell</a></li><li class="chapter-item expanded "><a href="Windows/Windows Applications.html">应用软件</a></li></ol></li><li class="chapter-item expanded "><div>应用软件</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="应用软件/程序开发软件.html">程序开发</a></li><li class="chapter-item expanded "><a href="应用软件/服务器管理软件.html">服务器管理</a></li><li class="chapter-item expanded "><a href="应用软件/网络访问软件.html">网络访问</a></li><li class="chapter-item expanded "><a href="应用软件/网络服务软件.html">网络服务</a></li><li class="chapter-item expanded "><a href="应用软件/文档生成软件.html">文档生成</a></li><li class="chapter-item expanded "><a href="应用软件/文件处理软件.html">文件处理</a></li><li class="chapter-item expanded "><a href="应用软件/协作办公软件.html">协作办公</a></li><li class="chapter-item expanded "><a href="应用软件/知识管理软件.html">知识管理</a></li><li class="chapter-item expanded "><a href="应用软件/多媒体编辑软件.html">多媒体编辑</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><li class="part-title">机器学习</li><li class="chapter-item expanded "><a href="机器学习/机器学习实践.html">机器学习实践</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="机器学习/ScikitLearn.html">scikit-learn</a></li><li class="chapter-item expanded "><a href="机器学习/TensorFlow.html">TensorFlow</a></li><li class="chapter-item expanded "><a href="机器学习/Pytorch.html">Pytorch</a></li><li class="chapter-item expanded "><a href="机器学习/图神经网络.html">图神经网络</a></li></ol></li><li class="chapter-item expanded "><a href="机器学习/机器学习原理与算法.html">原理与算法</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="机器学习/统计学习算法.html">统计学习算法</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><li class="part-title">数据库</li><li class="chapter-item expanded "><a href="数据库/SQL语法.html">SQL</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="数据库/SQL DDL.html">SQL DDL</a></li><li class="chapter-item expanded "><a href="数据库/SQL DML.html">SQL DML</a></li><li class="chapter-item expanded "><a href="数据库/SQL数据类型.html">数据类型</a></li></ol></li><li class="chapter-item expanded "><a href="数据库/MySQL.html">MySQL</a></li><li class="chapter-item expanded "><a href="数据库/PostgreSQL.html">PostgreSQL</a></li><li class="chapter-item expanded "><a href="数据库/HiveSQL.html">Hive SQL</a></li><li class="chapter-item expanded "><a href="数据库/Elasticsearch.html">Elasticsearch</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="数据库/Elastic Datasource.html">数据源</a></li></ol></li><li class="chapter-item expanded "><a href="数据库/Mongodb.html">Mongodb</a></li><li class="chapter-item expanded "><a href="数据库/GraphDatabase.html">图数据库</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">服务和大数据平台</li><li class="chapter-item expanded "><a href="服务器/分布式大数据处理.html">分布式大数据处理</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="服务器/CDH6大数据集群离线安装.html">CDH6 安装教程</a></li><li class="chapter-item expanded "><a href="服务器/Spark Python API.html">Pyspark</a></li><li class="chapter-item expanded "><a href="服务器/流数据处理.html">流数据处理</a></li></ol></li><li class="chapter-item expanded "><a href="服务器/容器编排.html">容器编排</a></li><li class="chapter-item expanded "><a href="服务器/虚拟化.html">虚拟化</a></li><li class="chapter-item expanded "><div>任务编排</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="服务器/Airflow.html">Airflow</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><li class="part-title">其他</li><li class="chapter-item expanded "><div>数据标记语言</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="数据交换语言/JSON and YAML.html">JSON and YAML</a></li><li class="chapter-item expanded "><a href="数据交换语言/XML.html">XML</a></li><li class="chapter-item expanded "><a href="数据交换语言/HTML.html">HTML</a></li></ol></li><li class="chapter-item expanded "><div>网络协议</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="Protocols/http.html">HTTP</a></li><li class="chapter-item expanded "><a href="Protocols/DNS.html">DNS</a></li><li class="chapter-item expanded "><a href="Protocols/端口分配.html">端口分配</a></li><li class="chapter-item expanded "><a href="Protocols/IP protocol numbers.html">IP 承载协议</a></li><li class="chapter-item expanded "><a href="Protocols/RPC.html">RPC</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Learning Programming Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <!-- Page table of contents -->
                        <div class="sidetoc"><nav class="pagetoc"></nav></div>

                        <h1 id="preface"><a class="header" href="#preface">Preface</a></h1>
<p>Learning Programming Book!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="python基础"><a class="header" href="#python基础">Python基础</a></h1>
<p>Python是一种解释型、面向对象、动态数据类型的高级程序设计语言。</p>
<p>Python 本身也是由诸多其他语言发展而来的,这包括ABC、 Modula-3、 C、 C++、 Algol-68、 SmallTalk、 Unix shell 和其他的脚本语言等等。</p>
<h2 id="环境配置"><a class="header" href="#环境配置">环境配置</a></h2>
<h3 id="python解释程序"><a class="header" href="#python解释程序">Python解释程序</a></h3>
<h4 id="运行python程序"><a class="header" href="#运行python程序">运行Python程序</a></h4>
<h5 id="1-交互式编程"><a class="header" href="#1-交互式编程">(1) 交互式编程</a></h5>
<p>进入Python解释器环境，交互式执行命令语句。</p>
<pre><code class="language-shell">$ python [options]  # enter python environment
</code></pre>
<p><code>-q</code>：进入交互式命令环境后，不输出提示信息。</p>
<p>安装<code>pyreadline</code>可以为终端启用<code>tab</code>命令自动补全功能。</p>
<h5 id="2-脚本式编程"><a class="header" href="#2-脚本式编程">(2) 脚本式编程</a></h5>
<p><strong>脚本是语句的集合</strong>，Python解释器会创建一个Python运行环境从而执行脚本中的语句。脚本执行完后，解释器退出运行环境。</p>
<pre><code class="language-shell">python [options] -c &quot;python_command&quot;  # 命令使用&quot;;&quot;分隔
python [options] script.py [args] # execute python script
python [options] -m module_name [args] # 执行指定模块的内容（__main__）
</code></pre>
<p><code>-E</code>：忽略所有<code>PYTHON*</code><a href="https://docs.python.org/3/using/cmdline.html#environment-variables">环境变量</a>（<a href="Python/Python%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80.html#%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83">运行环境</a>）。</p>
<p>当Python脚本首行指定了Python解释器路径，且该脚本具有可执行权限时，可直接运行该脚本。</p>
<pre><code class="language-python">#!/usr/bin/python   # 指定执行该脚本的程序
#!/usr/bin/env python  # 从路径中查找Python解释器以执行该脚本
</code></pre>
<pre><code class="language-shell">python -m json.tool demo.json  # 格式化JSON文本
python -m http.server 8080
python -m pydoc -p 8088   # python文档
python -m mimetypes filename
python -m tarfile -c demo.tar demo   # tar
python -m gzip filename   # =&gt; input only file, output filename.gz
python -m zipfile -c demo.zip demo
python -m telnetlib -d 192.168.56.200 22
</code></pre>
<h5 id="运行环境"><a class="header" href="#运行环境"><a href="Python/Python%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B.html#Python%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83">运行环境</a></a></h5>
<ul>
<li><code>PYTHONPATH</code>用于指定除系统的附加库搜索路径，程序启动后将加载到<code>sys.path</code>中。默认搜索顺序为当前路径、用户指定附加搜索路径、Python内置库路径、第三方Python库路径。</li>
<li><code>PYTHONHOME</code>指定Python标准库位置（<code>prefix/lib/pythonversion</code> and <code>exec_prefix/lib/pythonversion</code>）；当<code>PYTHONHOME</code>为单个路径时，代替<code>prefix</code>和<code>exec_prefix</code>；反之，可以将<code>PYTHONHOME</code>设置为<code>'prefix:exec_prefix'</code>。<code>PYTHONHOME</code>==不是Python环境的安装目录==。</li>
<li><code>PYTHONSTARTUP</code>：启动Python Shell时需要执行的脚本路径。</li>
</ul>
<blockquote>
<p>如果使用<a href="Python/Python%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83.html#%E8%99%9A%E6%8B%9FPython%E7%8E%AF%E5%A2%83">虚拟环境</a>，则通过激活命令（如<code>conda activate</code>）可保证相关环境变量正确设置。</p>
</blockquote>
<h2 id="基本语法"><a class="header" href="#基本语法">基本语法</a></h2>
<h3 id="标识符"><a class="header" href="#标识符">标识符</a></h3>
<p>所有标识符可以包括英文、数字以及下划线(_)，但不能以数字开头，<strong>区分大小写</strong>。</p>
<p>以下划线开头的标识符是有特殊意义的。</p>
<ul>
<li>以单下划线开头（<code>_foo</code>）的代表不能直接访问的类属性，需通过类提供的接口进行访问，不能用 <code>from xxx import *</code> 而导入；</li>
<li>以双下划线开头（<code>__foo</code>）代表类的私有成员；</li>
<li>以双下划线开头和结尾的（<code>__foo__</code>）代表 Python 里特殊方法专用的标识，如<code>__init__()</code>代表类的构造函数。</li>
</ul>
<h3 id="运算符"><a class="header" href="#运算符">运算符</a></h3>
<p>数值运算符参看<a href="Python/./Python%E6%95%B0%E5%80%BC%E8%AE%A1%E7%AE%97#%E8%BF%90%E7%AE%97%E7%AC%A6">数值计算</a>。</p>
<h4 id="逻辑运算符"><a class="header" href="#逻辑运算符">逻辑运算符</a></h4>
<p>逻辑运算符用于控制流程中的条件语句，包括<code>and</code> 、<code>or</code> 、<code>not</code>。</p>
<blockquote>
<p>Python不支持<code>&amp;&amp;</code>，<code>||</code>。</p>
</blockquote>
<h4 id="成员运算符"><a class="header" href="#成员运算符">成员运算符</a></h4>
<p><code>in</code>， <code>not in</code>：在指定的容器（序列、元组、字典、集合等）中查找到值，返回值<code>True</code>或<code>False</code>；==也可用于判断一个字符串是否为另一个字符串的子串。==</p>
<pre><code class="language-python">list_str = ['--test', '-o output/test', '--debug']
if '--debug' in list_str:
    print('find --debug in parameter list.')
if 'test' not in list_str:
    print('not find test in parameter list.')    
</code></pre>
<blockquote>
<p>取决于容器类型，查询<a href="https://wiki.python.org/moin/TimeComplexity">时间复杂度</a>不同。</p>
</blockquote>
<h4 id="身份运算符"><a class="header" href="#身份运算符">身份运算符</a></h4>
<p><code>is,</code> <code>is not</code>：判断两个标识符是否引用同一个对象，返回<code>True</code>或<code>False</code>。 <code>==</code>用于判断引用变量的==值==是否相等。</p>
<blockquote>
<p><code>id()</code>函数返回一个整数表示变量的标识；CPython实现的<code>id(x)</code>返回<code>x</code>的内存地址。</p>
<p><code>hash(obj)</code>返回基于对象内容的一个映射值，具有相同值的两个对象有相同hash值（不同于<a href="Python/Python%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80.html#%E5%AF%86%E7%A0%81%E5%AD%A6">消息摘要</a>是基于字节序列内容的）。</p>
</blockquote>
<h4 id="对象运算符"><a class="header" href="#对象运算符">对象运算符</a></h4>
<p><code>+</code> 运算符用于拼接序列对象；</p>
<p><code>*</code> 用于重复序列对象：如果对象的元素为值类型，则复制该元素的值并将复制内容拼接；如果<strong>元素为引用类型，则仅复制引用（浅拷贝）</strong>。</p>
<pre><code class="language-python">print str*2       # 输出字符串两次
</code></pre>
<p><code>[]</code>：<a href="Python/Python%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80.html#%E5%BA%8F%E5%88%97%E7%B1%BB%E5%9E%8B%E7%9A%84%E7%B4%A2%E5%BC%95">下标运算符</a>，取字符串、列表或元组元素。</p>
<h4 id="运算符优先级"><a class="header" href="#运算符优先级">运算符优先级</a></h4>
<h3 id="语句"><a class="header" href="#语句">语句</a></h3>
<p>同一行显示多条语句，方法是用分号“<code> ;</code>” 分开。但是我们可以<strong>使用斜杠（</strong> <strong><code>\</code>）将一行的语句分为多行显示</strong>。语句中包含<code>[]</code>,<code>{}</code>或<code>()</code> 括号就不需要使用多行连接符。</p>
<p>用缩进（空格）长度来写语句块。缩进的空白数量是可变的，但是所有代码块语句必须包含相同的缩进空白数量，这个必须严格执行。</p>
<p><code>eval</code>可以执行字符串表示的Python表达式（不支持复杂的代码逻辑，例如赋值操作、循环语句），并返回表达式的值。</p>
<pre><code class="language-python">x = eval('os.path.abspath(os.path.curdir)')
</code></pre>
<p><code>exec</code>执行语句或代码块，不能做表达式求值并返回，但可以通过赋值表达定义新的变量并添加到当前上下文中。</p>
<pre><code class="language-python">exec('x = os.path.abspath(os.path.curdir)')
</code></pre>
<p>https://www.cnblogs.com/pythonista/p/10590682.html。</p>
<h3 id="注释和文档"><a class="header" href="#注释和文档">注释和文档</a></h3>
<p>单行注释：“<code>#</code>”</p>
<p>文件开始的注释内容提供解释器与脚本的相关信息。</p>
<pre><code class="language-python">#!/usr/bin/python
# -*- coding: UTF-8 -*-
</code></pre>
<p>脚本中包含中文时，需要指定文件的编码方式（UTF-8），默认编码方案是（ASCII）。Python3.X 源码文件默认使用utf-8编码，所以可以正常解析中文，无需指定 UTF-8 编码。</p>
<p>空行并不是Python语法的一部分。书写时不插入空行，Python解释器运行也不会出错。</p>
<p>位于类型定义之后的<a href="Python/Python%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80.html#%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%88String%EF%BC%89">三引号文本</a>（<code>'''</code>，docstring）将自动生成为该类型的<a href="https://realpython.com/documenting-python-code/">文档</a>（<code>type.__doc__</code>）。</p>
<blockquote>
<p>Package docstrings should be placed at the top of the package’s <code>__init__.py</code> file. Module docstrings are placed at the top of the file even before any imports. </p>
</blockquote>
<p>使用<code>help()</code>函数可查看当前环境已导入的模块的内容的文档。</p>
<h5 id="文档生成"><a class="header" href="#文档生成">文档生成</a></h5>
<p>使用reStructuredText编写代码注释，可通过<a href="Python/../%E5%BA%94%E7%94%A8%E8%BD%AF%E4%BB%B6/%E6%96%87%E6%A1%A3%E7%94%9F%E6%88%90%E8%BD%AF%E4%BB%B6.html#%E8%A7%A3%E6%9E%90%E5%92%8C%E8%BD%AC%E6%8D%A2Python%E4%BB%A3%E7%A0%81">Sphinx</a>自动转换为参考文档。</p>
<h3 id="流程控制"><a class="header" href="#流程控制">流程控制</a></h3>
<h4 id="条件"><a class="header" href="#条件">条件</a></h4>
<pre><code class="language-python">if expression1:
	statements1……
elif expression2:
	statements2……
else:
	statements4……
    
c = a if &lt;condition&gt; else b
</code></pre>
<p>在Python中没有<code>switch–case</code>语句。</p>
<h4 id="循环"><a class="header" href="#循环">循环</a></h4>
<pre><code class="language-python">while expression1：
	statements……
else:
	statements4……
</code></pre>
<p><code>for</code>循环可以遍历任何序列的项目，例如字符串、列表；</p>
<pre><code class="language-python">for i = 1 to 10:
  statements
for var in sequence:  # 迭代过程不能更改迭代的对象
	statements1(s)
	break
	continue
else:
	statements2……
for idx,item in enumerate(lista): # enumerate构造(i, l(i))迭代元组
  print('{idx} - {item}')
for idx,_ in enumerate(lista):
  print('{idx} - {item}')
</code></pre>
<p>循环<strong>正常</strong>执行完之后，执行<code>else</code>语句。</p>
<p><code>sequence</code>可以是索引集合：<code>range(start,end, step=1)</code></p>
<h4 id="pass语句"><a class="header" href="#pass语句">pass语句</a></h4>
<p><code>pass</code>不做任何事情，一般用做占位语句。特殊变量<code>...</code>（<code>Ellipse</code>），可用于代替<code>pass</code>语句。</p>
<h4 id="异常处理"><a class="header" href="#异常处理">异常处理</a></h4>
<h5 id="触发异常"><a class="header" href="#触发异常">触发异常</a></h5>
<pre><code class="language-python">raise ExceptionObject, args, traceback
</code></pre>
<h5 id="捕捉异常"><a class="header" href="#捕捉异常">捕捉异常</a></h5>
<pre><code class="language-python">try:
  pass
except ExceptionName as e: # e为异常对象，如果不使用可省略as语句
  statements1
except (Exception1, Exception2, ...) as e:
  statements2
except:
	statements3
else:
	statements4
finally:
    statementsN
</code></pre>
<blockquote>
<p>Python 2.x语法：</p>
<pre><code class="language-python">try:
	statements
except ExceptionType, Argument:
	statements
</code></pre>
</blockquote>
<h5 id="异常处理方法"><a class="header" href="#异常处理方法">异常处理方法</a></h5>
<p>处理异常时可使用<code>traceback</code>获取调用栈的信息。打印堆栈追踪信息：</p>
<pre><code class="language-python">traceback.print_exc()                 # 打印stacktrace
traceback.format_exc()                # 返回stacktrace为字符串
traceback.print_tb(err.__traceback__) # stacktrace
</code></pre>
<p>对于捕获到的异常，如果没有合适处理方法可再次抛出异常。</p>
<h5 id="异常类型"><a class="header" href="#异常类型">异常类型</a></h5>
<p>所有异常基于<code>BaseException</code>。<code>Exception</code>类用于定义用户异常。<code>Warning</code>也继承自<code>Exception</code>类，但通常不用于触发异常，而是用于<a href="Python/Python%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA.html#%E8%AD%A6%E5%91%8A%E4%BF%A1%E6%81%AF">产生警告信息</a>。</p>
<p>Exception hierarchy：https://docs.python.org/3/library/exceptions.html#os-exceptions</p>
<p>内置异常类型：</p>
<p>ArithmeticError</p>
<p>BufferError</p>
<p>LookupError： IndexError, KeyError</p>
<p>AssertionError</p>
<p>EOFError</p>
<p>GeneratorExit</p>
<p>ImportError</p>
<p>ModuleNotFoundError</p>
<p>KeyboardInterrupt</p>
<p>MemoryError</p>
<p>NameError, TypeError, UnboundLocalError, ValueError, IOError, WindowsError</p>
<p>NotImplementedError</p>
<p>SystemError, SystemExit, EnvironmentError</p>
<p>OSError</p>
<blockquote>
<p>https://docs.python.org/3/library/exceptions.html#os-exceptions</p>
</blockquote>
<p>OverflowError, ZeroDivisionError</p>
<p>RecursionError</p>
<p>ReferenceError</p>
<p>RuntimeError</p>
<p>StopIteration, StopAsyncIteration</p>
<p>SyntaxError, IndentationError, TabError</p>
<p>UnicodeError, UnicodeEncodeError, UnicodeDecodeError, UnicodeTranslateError</p>
<h4 id="with-as-context-manager"><a class="header" href="#with-as-context-manager">with-as (Context Manager)</a></h4>
<p><a href="https://www.ibm.com/developerworks/cn/opensource/os-cn-pythonwith/index.html">上下文管理协议</a>：实现方法是为一个类定义<code>__enter__</code>和<code>__exit__</code>两个函数。</p>
<pre><code class="language-python">with open_resource(args) [as target(s)]:
    do_something
</code></pre>
<p><code>with-as</code>语句的执行过程是，首先执行<code>__enter__</code>函数，它的返回值会赋给<code>as</code>后面的变量。
然后开始执行<code>with-block</code>中的语句，在<code>with-block</code>执行完成或发生异常或退出，会执行<code>__exit__</code>函数（释放资源或处理可能产生的异常）。</p>
<h5 id="支持上下文管理协议的类"><a class="header" href="#支持上下文管理协议的类">支持上下文管理协议的类</a></h5>
<pre><code class="language-python">class Resource():
  def __enter__(self):  # 实际分配资源的操作在该方法中，而不在__init__()中
    print('===connect to resource===')
    return self
  def __exit__(self, exc_type, exc_val, exc_tb):
    print('===close resource connection===')
    return True
</code></pre>
<h5 id="contextlibcontextmanager装饰器"><a class="header" href="#contextlibcontextmanager装饰器"><code>contextlib.contextmanager</code>装饰器</a></h5>
<p>使用该<a href="Python/Python%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B.html#%E8%A3%85%E9%A5%B0%E5%99%A8">装饰器</a>可将构造资源的函数转换为支持上下文管理协议。</p>
<pre><code class="language-python">import contextlib
@contextlib.contextmanager
def open_func(file_name):
  # __enter__ method
  file_handler = open(file_name, 'r')
  try:
	  yield file_handler
  # __exit__ method
  except Exception as exc: # 如果不需处理异常则无需使用try-except语句
    pass
  finally:
	  file_handler.close()
</code></pre>
<h4 id="exit-handlers"><a class="header" href="#exit-handlers">Exit handlers</a></h4>
<p><code>atexit</code>模块用于注册程序==正常退出==前的清理函数。可以注册多个函数，函数执行顺序与注册顺序相反。</p>
<pre><code class="language-python">atexit.register(func, *args, **kwargs)
atexit.unregister(func)
</code></pre>
<p>如果子进程由<code>os.fork()</code>创建，则继承父进程的退出处理函数；如果子进程由<code>multiprocessing</code>模块创建，则不会继承退出处理函数。</p>
<blockquote>
<p><em>When used with C-API subinterpreters, registered functions are local to the interpreter they were registered in.</em></p>
</blockquote>
<h3 id="函数"><a class="header" href="#函数">函数</a></h3>
<h4 id="定义函数"><a class="header" href="#定义函数">定义函数</a></h4>
<pre><code class="language-python">def function_name(arg1: int, arg2: float) -&gt; float
    &quot;documentation&quot;
    statements
    [return expr1, expr2, ...]
</code></pre>
<p>函数内部可访问全局脚本语句定义的变量。可以为输入输出参数添加<a href="Python/Python%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80.html#%E7%B1%BB%E5%9E%8B%E6%8F%90%E7%A4%BA">类型提示</a>。</p>
<h4 id="参数"><a class="header" href="#参数">参数</a></h4>
<p><strong>参数传递</strong>：不可变类型（数值、字符串、元组等）是值传递，<strong>可变类型</strong>（列表、字典、集合等）是引用传递；</p>
<p><strong>关键字参数</strong>：使得调用函数时传入参数顺序可以与定义时不同，也可以为参数设置默认值（默认值在模块初始化时构造）；关键字参数必须置于所有位置参数之后。</p>
<pre><code class="language-python">def func(arg1, age=50, name=&quot;miki&quot;)
</code></pre>
<p><strong>不定长参数</strong></p>
<p><code>*args</code>用于传递任意数量的位置参数（列表或元组），<code>**kwargs</code>用于传递任意数量的关键字参数（字典）。</p>
<pre><code class="language-python">def functionname(formal_args, *args，**kwargs)
</code></pre>
<blockquote>
<p>在函数调用时，也可以使用<code>*args</code>将参数列表传递到函数中（需要与函数声明的参数个数或<code>*args</code>声明匹配），使用<code>**kwargs</code>将字典传入函数作为关键字参数（将值赋给与键名相同的参数，或与<code>**kwargs</code>声明匹配）。</p>
</blockquote>
<h4 id="返回值"><a class="header" href="#返回值">返回值</a></h4>
<p>通过<code>return</code>语句可以设置一个或多个返回值，或不返回值。</p>
<blockquote>
<p><code>return</code>不用于脚本退出，使用<code>sys.exit()</code>退出。</p>
</blockquote>
<p>当返回多个值时，如果仅提供一个输出参数，则将返回值构造成元组。若提供多个参数存储返回值，则将从元组中一次读取元素给输出参数。</p>
<pre><code class="language-python">a, b, c = function_name(...)  # 等效于 (a,b,c) = func_name(...)
d = function_name(...)  # d = (a,b,c)
</code></pre>
<h4 id="匿名函数-lambda表达式"><a class="header" href="#匿名函数-lambda表达式">匿名函数 （Lambda表达式）</a></h4>
<p>将函数作为<strong>对象</strong>保存和引用，也可以在使用函数的地方直接定义（而非使用<code>def</code>定义普通函数）。</p>
<pre><code class="language-python">add = lambda x, y : x+y
f = lambda x: 1 if x &gt; 0 else -1
the_sum = add(1,2)
</code></pre>
<h2 id="变量"><a class="header" href="#变量">变量</a></h2>
<p>Python的主要内置类型有数值、序列（<code>string</code>、<code>list</code>和<code>tuple</code>）、映射、类、实例和异常，方法也可以看作特殊的对象类型。每个变量（<code>object</code>）具有一个标识、类型和值。</p>
<h3 id="创建和删除变量"><a class="header" href="#创建和删除变量">创建和删除变量</a></h3>
<p>定义变量不需要声明类型，根据赋值的类型确定变量类型。</p>
<pre><code class="language-python">a = b = c = 1
a, b, c = 1, 2, &quot;john&quot; 
</code></pre>
<p>变量可重复赋值，赋值前后类型不需要一致（由赋值类型决定）。</p>
<p>删除变量：</p>
<pre><code class="language-python">del var_a, var_b 
del list[i], dict[name]
</code></pre>
<h4 id="变量作用域"><a class="header" href="#变量作用域">变量作用域</a></h4>
<p>在文件范围中定义的变量具有<strong>文件作用域</strong>，在文件其后的任意位置（包括调用的函数内部）都能访问。各文件中定义的变量属于不同的<strong>命名空间</strong>（模块名），互不影响。要引用其他模块中定义的全局变量，可使用<code>import</code>语句引入其他模块通过模块名访问或直接将该变量引入当前文件的命名空间。</p>
<pre><code class="language-python">import module
print(module.global_var)
from module import global_var
</code></pre>
<blockquote>
<p>在文件中定义的函数引用全局变量时，总是引用该文件作用域中的全局变量，而不会使用调用该函数的文件中的全局变量。</p>
</blockquote>
<h5 id="可见性"><a class="header" href="#可见性">可见性</a></h5>
<p>当函数内部定义了与全局变量同名的局部变量，则全局变量将被隐藏（即使在定义局部变量之前也不能引用该同名全局变量）。使用<code>global</code>用于在函数内部对全部变量的声明和修改。</p>
<pre><code class="language-python">a = 'initialized'
def func()
	global a
    a = 'modified'
</code></pre>
<p>获取作用域中的变量信息：</p>
<pre><code class="language-python">dict_vars = locals()  # 获取当前的局部作用域中的变量
dict_vars = globals() # 获取全局作用域中的变量
</code></pre>
<blockquote>
<p>包括变量、函数、模块等信息。</p>
</blockquote>
<p>在流程控制语句块中定义的变量在离开语句块后仍有效。</p>
<h4 id="类型信息判断"><a class="header" href="#类型信息判断">类型信息判断</a></h4>
<p><code>type()</code>返回变量的==类型信息可以和类型对象进行比较==。</p>
<pre><code class="language-python">type_info = type(var_name)
tf = type(x) == int     # return True if x is int.
</code></pre>
<p><code>get_type_hints()</code>可以查看模块、类、方法或函数的类型信息。</p>
<pre><code class="language-python">from typing import get_type_hints
</code></pre>
<pre><code class="language-python">Vector = list[float]  # type alias
from typing import NewType
UserId = NewType('UserId', int)  # New simple type
</code></pre>
<p><code>isinstance</code>判断实例是否为某个类型（父类）的实例：</p>
<pre><code class="language-python">isinstance(obj, Type)		
isinstance(obj, (Type1, Type2, ...))		#  任意一种类型
</code></pre>
<blockquote>
<p><code>Type</code>是在程序中使用的变量类型，不是字符串，例如<code>pd.DataFrame</code>，<code>np.ndarray</code>。</p>
</blockquote>
<p><code> issubclass</code>判断一种类型是否为某类型的子类：</p>
<pre><code class="language-python">isdubclass(subType, Type)
</code></pre>
<h4 id="类型提示"><a class="header" href="#类型提示">类型提示</a></h4>
<pre><code class="language-python">age: int = 1   # 可不提供初始化值
</code></pre>
<p>容器类型需要使用专门定义的类型修饰变量。</p>
<pre><code class="language-python">from typing import List, Set, Dict, Tuple, Optional, Callable
x: Set[int] = {6, 7}
x: Dict[str, float] = {'field': 2.0}
x: Tuple[int, str, float] = (3, &quot;yes&quot;, 7.5)  # fixed size tuple
x: Tuple[int, ...] = (1, 2, 3)     # variable size tuple
x: Optional[str] = some_function() # values that could be None
x: Callable[[int, float], float] = f # function
</code></pre>
<p>类型别名：</p>
<pre><code class="language-python">vector = List[float]
</code></pre>
<p>迭代器提示。</p>
<p>参数提示仅作为编写程序的辅助工具，在程序运行时并不会做相应的类型检查。</p>
<h5 id="联合类型"><a class="header" href="#联合类型">联合类型</a></h5>
<p>可以为参数指定类型，且可使用<code>typing.Union</code>指定多种类型；</p>
<pre><code class="language-python">from typing import Union
def function_name(arg1:Union[str,int])
</code></pre>
<h5 id="常量类型"><a class="header" href="#常量类型">常量类型</a></h5>
<pre><code class="language-python">from typing import Final    # [Python 3.8]
</code></pre>
<p><a href="https://mypy.readthedocs.io/en/stable/cheat_sheet_py3.html">Type hints cheat sheet (Python 3)</a>。</p>
<h3 id="类"><a class="header" href="#类">类</a></h3>
<p>类的定义：由成员，方法，数据属性组成。</p>
<pre><code class="language-python">class ClassName:
	'''documentation'''   #类文档字符串
    static_var: Type = value
    var1: Type     # Annotate a member does not make it static.
    # 构造函数
    def __init__(self, value1, value2, ...) -&gt; None:
        self.var1 = value1		# 成员变量
        self.var2 = value2
        ...
    # 析构函数
    def __del__(self):
    	release_unmanaged_resources
    # 成员方法
    def method_name(self, arg1, arg2, ...):
      self.xxx        # 调用类的成员变量或方法
    	# statements...
		@staticmethod      # 静态方法
    def method_name(...)
    	statements
    @property					 # read only property
    def prop(self):
    	return self.xxx
    @x.setter
    def x(self, value):
    	self.__x = value
    @x.deleter
    def x(self):
    	del self.__x
</code></pre>
<h4 id="静态变量"><a class="header" href="#静态变量">静态变量</a></h4>
<p>静态成员变量仅能通过类名或静态方法访问。实例可以定义与静态成员同名的成员变量（通过实例引用将隐藏静态变量）。子类可以定义与父类同名的静态变量（隐藏），通过子类名或实例将只能访问子类的静态变量。</p>
<p>==对实例成员的类型注释由于没有初始化，因此不会被视为静态变量==。</p>
<p>静态变量初始化：可在类外部对静态变量进行初始化，从而基于父类的静态变量对子类静态变量进行初始化。在子类内部使用父类静态变量初始化子类静态变量无效（得到<code>None</code>）。</p>
<h4 id="构造"><a class="header" href="#构造">构造</a></h4>
<p>浅拷贝：很多类型（例如<code>list</code>、<code>dict</code>）提供<code>copy()</code>方法，支持对象的浅拷贝。这意味着对象中的成员变量如果是引用类型，则两个对象共享该引用类型成员。</p>
<p>析构函数<code>__del__</code> ，<code>__del__</code>在对象销毁的时候被调用，当对象不再被使用时，<code>__del__</code>方法运行。Python使用了引用计数这一简单技术来跟踪和回收垃圾。</p>
<pre><code class="language-python">obj = ClassName(args) # 创建对象
</code></pre>
<p>使用<code>.</code>运算符来访问对象的属性。</p>
<h4 id="类的成员"><a class="header" href="#类的成员">类的成员</a></h4>
<p>类可以看作由元数据、用户定义数据和方法组成的字典，使用<code>dir(x)</code>（<code>x.__dir__()</code>）返回类包含的属性和方法组成的字典。</p>
<p>类的方法与普通的函数只有一个特别的区别——它们必须有一个额外的第一个参数名称, 按照惯例它的名称是 <code>self</code>（<code>self</code>不是Python关键字，换成其他标识符仍然有效）。<code>self</code>代表的是类的实例，代表当前对象的地址，而<code>self.__class__</code>是类的类型信息。</p>
<p>Python成员不存在<strong>访问控制</strong>，仅通过标识符在语义上区分。</p>
<ul>
<li>
<p><code>__&lt;private_member&gt;</code>：标记为私有属性/方法，其中形如<code>__INNER_MEMBER__</code>的成员为类的元数据。</p>
</li>
<li>
<p><code>_&lt;protected_member&gt;</code>：标记为保护属性/方法。</p>
</li>
<li>
<p><code>&lt;public_member&gt;</code>：标记为公开属性/方法。</p>
</li>
</ul>
<h5 id="类的元数据"><a class="header" href="#类的元数据">类的元数据</a></h5>
<p>通过类或对象均可访问类的元数据（所有对象共享）。</p>
<p><code>__class__</code>：类型元信息（即<code>type</code>类型对象，等效于<code>type(obj)</code>）；</p>
<p><code>__name__</code>：类名（字符串，==不包含类所在的包名==）。</p>
<p><code>__bases__</code> : 类的所有父类元信息构成的元素（包含了一个由所有父类组成的元组） 。</p>
<p><code>__dict__</code>：所有成员变量名与对应的值组成的字典，等效于<code>vars(obj)</code>；</p>
<p><code>__doc__</code>：类的文档字符串 。</p>
<p><code>__module__</code>: 类定义所在的模块（类的全名是<code>__main__.className</code>，如果类位于一个导入模块<code>mymod</code>中，那么<code>className.__module__</code>等于 <code>mymod</code>） </p>
<h5 id="实例的元数据"><a class="header" href="#实例的元数据">实例的元数据</a></h5>
<p><code>obj.__str__(),</code>：类成员信息的字符串表示，自动转换为字符串类型时调用该方法；</p>
<p><code>obj.__repr__()</code>：返回构造该对象的语句，<code>repr(obj)</code>会调用对象的该方法。调用<code>eval(repr(obj))</code>可重新构造该对象。</p>
<h5 id="描述符协议"><a class="header" href="#描述符协议">描述符协议</a></h5>
<p>在类里实现了<code> __get__()</code> 、<code>__set__()</code>、<code>__delete__()</code>其中至少一个方法。</p>
<pre><code class="language-python">class Score:
  def __init__(self, default=0):
    self._score = default
  def __set__(self, instance, value): # 设置属性的值，进行验证
    if not isinstance(value, int):
      raise TypeError('Score must be integer')
    if not 0 &lt;= value &lt;= 100:
      raise ValueError('Valid value must be in [0, 100]')
    self._score = value
  def __get__(self, instance, owner): # 属性不存在、不合法等都可以抛出对应的异常
    return self._score
  def __delete__(self):  # 删除内容
    del self._score
class Student:
  def __init__(math_score):
    self.math = Score(math_score)
  pass
</code></pre>
<h4 id="数据类"><a class="header" href="#数据类">数据类</a></h4>
<p><code>dataclass</code>（<strong>Python 3.7+</strong>）专门用于定义和存储数据的类型（更加适合<a href="Python/Python%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA.html#%E5%AF%B9%E8%B1%A1%E5%BA%8F%E5%88%97%E5%8C%96">序列化</a>），封装了数据的初始化方法和基本运算方法（避免频繁编写这些基础代码）。<code>dataclass</code>继承自<code>object</code>类型，因此，开发者仍可基于<code>dataclass</code>编写自定义方法<sup class="footnote-reference"><a href="#dataclass">1</a></sup>。</p>
<h5 id="定义数据"><a class="header" href="#定义数据">定义数据</a></h5>
<p>基于<strong>类型提示</strong>语法自动生成对应成员的定义，而无需重复在初始化方法中声明和初始化成员。</p>
<pre><code class="language-python">from dataclasses import dataclass
@dataclass
class Persion:
    first_name: str
    last_name: str = &quot;Wang&quot;  # 支持默认值, 但必须在所有非默认值参数后
    age: int
    job: str
    full_name: str = field(init=False, repr=False) # *
</code></pre>
<blockquote>
<p><code>dataclass</code>会自动生成<code>__init__()</code>、<code>__eq__()</code>（自动对比对象的所有成员）和<code>__expr__()</code>方法。由于<code>dataclass</code>的构造方法是自动生成的，也因此无法向父类传递初始化参数，所以通常自定义<code>dataclass</code>类型不再继承其他类。</p>
<p><code>*</code>：当该成员的初始化依赖于其他成员变量时，不在自动生成的构造函数中初始化，而是在<code>__post_init__</code>方法中定义初始化方法。这种方式避免使用属性，在每次调用时需要重复计算值。</p>
</blockquote>
<h5 id="非可变对象"><a class="header" href="#非可变对象">非可变对象</a></h5>
<p>声明<code>@dataclass(frozen=True)</code>，对象初始化后无法被更改。</p>
<h5 id="数据转换"><a class="header" href="#数据转换">数据转换</a></h5>
<p>可轻易转换为元组或字典。</p>
<pre><code class="language-python">from dataclass import astuple,asdict
person:Tuple = astuple(Person(...))
person:Dict = asdict(Persion(...))
</code></pre>
<h5 id="比较接口"><a class="header" href="#比较接口">比较接口</a></h5>
<p><code>@dataclass(order=True)</code>将自动生成<code>__lt__</code>、<code>__le__</code>、<code>__gt__</code>、<code>__ge__</code>方法，从而支持排序比较。默认将对类中所有字段以此进行比较，在类定义中添加特殊的<code>sort_index</code>字段，该字段引用其他成员变量的值以定义<a href="Python/Python%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8Bmd#%E5%88%97%E8%A1%A8%E6%8E%92%E5%BA%8F">排序参考值</a>。</p>
<pre><code class="language-python">@dataclass(order=True)
class Persion:
    # ...
    sort_index: int = field(init=False, repr=False)
    def __post_init__(self):
        self.sort_index = self.age
</code></pre>
<h4 id="继承语法"><a class="header" href="#继承语法">继承语法</a></h4>
<pre><code class="language-python">class ClassName (ParentClass1[, ParentClass2, ...]):  # 支持多重继承
    'Optional class documentation string'
    def __init__(self, args):
      super().__init__(...)  # &lt;=&gt; super(ClassName, self).__init__(args)
      # ...
</code></pre>
<p>在继承中基类的构造（<code>__init__()</code>方法）不会被自动调用，它需要在其派生类的构造中手动。需要通过基类名调用<code>__init_()</code>并且传递<code>self</code>变量。</p>
<h5 id="方法重写override"><a class="header" href="#方法重写override">方法重写（override）</a></h5>
<p>当方法被重写后，==通过对象调用方法时将调用子类的方法==（即使是在父类中）。要通过<code>super()</code>以显式调用父类方法。</p>
<pre><code class="language-python">super().method(args)  # &lt;=&gt; super(ClassName, self).method(args)
</code></pre>
<p>同名函数或成员调用：使用<code>super().member()</code>调用<a href="Python/Python%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80.html#MRO%EF%BC%88Method-Resolution-Order%EF%BC%89">MRO搜索顺序</a>上第一个存在该成员的类。如果要显式调用某一父类的方法，则使用<code>super(SuperClass, self).method(args)</code>。</p>
<blockquote>
<p>在基于<code>pdb</code>的调试环境下，如果在调试窗口调用父类方法，使用<code>super().method(args)</code>会报错（程序中正常执行）。</p>
</blockquote>
<h5 id="运算符重载"><a class="header" href="#运算符重载">运算符重载</a></h5>
<h5 id="mromethod-resolution-order"><a class="header" href="#mromethod-resolution-order">MRO（Method Resolution Order）</a></h5>
<p>父类的初始化顺序：根据继承关系“深度优先—从左至右”搜索父类，确定初始化顺序（调用<code>classname.__mro__</code>查看类的搜索顺序）。</p>
<ul>
<li>深度优先，按继承关系依次调用父类构造函数；</li>
<li>从左至右，当深度搜索到达顶端后，==如果顶层父类包含<code>super().__init__()</code>调用==，则将调用第二条继承关系上的类型，并执行深度优先初始化；</li>
<li>如果两条继承路线存在公共父类，则在第一条继承路线搜索到公共父类前会跳转到第二条继承路线，由第二条继承路线搜索到公共父类；多条继承路线具有公共父类的情况同理。</li>
<li>如果搜索过程中，某父类不存在<code>super().__init__()</code>，则从该父类的代码开始，并按调用栈反向执行初始化。==在构造过程中已经被前面构造函数初始化过的属性会被后调用的构造方法再次初始化==。</li>
</ul>
<blockquote>
<p>如果在MRO搜索顺序中某个直接或间接父类未调用<code>super().__init__()</code>，则==MRO初始化过程中断==（该类及MRO搜索顺序的后续类的构造方法不会被调用）。</p>
</blockquote>
<p>参数传递：</p>
<ul>
<li>
<p>==初始化过程中的参数传递与初始化顺序一致，而非子类分别传递给其各个直接父类==。因此在声明父类时，一定要将能通过<code>super().__init__()</code>传递参数的父类声明在前，否则其后的父类无法获取参数。</p>
</li>
<li>
<p>传递给父类参数通常使用<code>*args</code>和<code>**kwargs</code>代替（除非子类需要对相关参数进行处理）。</p>
<pre><code class="language-python">def __init__(self, a,b,*args,c=1,b='hello',**kwargs)
</code></pre>
<p>位置参数的顺序保持子类参数在前，父类参数在后（从而可以使用<code>*args</code>来统一接收父类参数）。</p>
</li>
</ul>
<p><a href="https://www.journaldev.com/14623/python-multiple-inheritance">Python Multiple Inheritance - JournalDev</a></p>
<h5 id="mixin"><a class="header" href="#mixin">mixin</a></h5>
<p>抽取单一功能，提供给多个类继承，可视为带实现的接口；mixin模式适用于多个类各自有继承主线，但又共享部分功能。这部分功能即可通过mixin类型实现。</p>
<p><code>mixin</code>类型<em>不定义新的成员变量</em>，仅定义关于目标混入对象的计算方法（可使用期望继承的类所包含的成员）。</p>
<p>https://stackoverflow.com/q/533631/6571140。</p>
<h3 id="迭代器"><a class="header" href="#迭代器">迭代器</a></h3>
<p>迭代器<code>Iterator</code>提供<code>__next__()</code>方法以遍历所有元素；使用<code>yield</code>关键字的方法也可以实现简单迭代器。</p>
<pre><code class="language-python">def g(n: int) -&gt; Iterator[int]:
    i = 0
    while i &lt; n:
        yield i
        i += 1
</code></pre>
<p>可迭代对象<code>Iterable</code>提供两个方法:<code>__iter__()</code>和<code>next()</code>。通过<code>iter(Iterable)</code>可获取访问可迭代对象的迭代器。<a href="Python/Python%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80.html#%E5%BE%AA%E7%8E%AF"><code>for</code>语句</a>实际需要传递迭代器对象，通过语法糖简化了对可迭代对象的访问语法。</p>
<p><a href="https://stackoverflow.com/questions/9884132/what-exactly-are-iterator-iterable-and-iteration">python - What exactly are iterator, iterable, and iteration? - Stack Overflow</a></p>
<h3 id="内存占用"><a class="header" href="#内存占用">内存占用</a></h3>
<pre><code class="language-python">import sys
s = sys.getsizeof(var)
</code></pre>
<p>所有内置类型均以对象封装，因此返回的为对象占用的内存（仅计算对象本身占用的内存，而不包括对象引用的内存）。第三方类型类型返回结果不一定准确。</p>
<h2 id="程序结构"><a class="header" href="#程序结构">程序结构</a></h2>
<h3 id="程序入口"><a class="header" href="#程序入口">程序入口</a></h3>
<p>模块中非类、函数定义的代码部分将在引用时被执行。</p>
<p>通过以下方式为程序设置一个入口，从而屏蔽引用模块中的非定义代码：</p>
<pre><code class="language-python">if __name__ == '__main__':
	main_procedure
else:
	module_initialization
</code></pre>
<blockquote>
<p>注意：上述代码并非常规的主函数（<code>main(args</code>))，只是一个普通的条件语句。可以自定义一个<a href="https://codingpy.com/article/guido-shows-how-to-write-main-function/">常规的主函数</a>在上述结构中进行调用。</p>
</blockquote>
<pre><code class="language-python">def main(args=None):
    if args is None:
        args = sys.argv
    # main code

 	return value   
    
if __name__ == '__main__':
    sys.exit(main(sys.argv[1:]))
</code></pre>
<h4 id="命令行参数处理"><a class="header" href="#命令行参数处理">命令行参数处理</a></h4>
<p><code>sys.argv[0]</code>表示程序名，其他元素为传入参数。</p>
<pre><code class="language-python">for argi in sys.argv:
    print(argi)
</code></pre>
<h5 id="getopt"><a class="header" href="#getopt">getopt</a></h5>
<p><code>getopt</code>采用Linux Shell的参数声明规则设置参数。读取参数的方法：</p>
<blockquote>
<p>与UNIX类系统不同，非选项参数后的所有参数都不会被视为选项解析。</p>
</blockquote>
<pre><code class="language-python">from getopt import getopt, GetoptError
options, args = getopt(cmd_args, short_opts, long_opts=[])
</code></pre>
<p><code>short_opts</code>：代表短选项（命令行以<code>-</code>开头）的字母列表，如果一个选项还对应一个值，那么字母后添加<code>:</code>；</p>
<p><code>long_opts</code>：代表长选项（命令行以<code>--</code>开头）的字符串列表，长选项如果需要一个值，则参数需要附加<code>=</code>。</p>
<blockquote>
<p>命令行中，长选项的值可作为一个当都参数，或使用<code>=</code>附加在选项名后。</p>
</blockquote>
<p>返回值：<code>options</code>为选项列表，包括选项名（包括前缀）和对应的值（没有值则为空字符串）；<code>args</code>为非选项参数。</p>
<p>典型用法：</p>
<pre><code class="language-python">def usage():
    # print usage of the program, including options.

def main(sys_args):
    try: 
        optlist, args = getopt(sys_args, short_opts, long_opts=[])
    except GetoptError as err:
        print(err) # will print something like &quot;option -a not recognized&quot;
        usage()
        return(2)
    for option, value in optlist:
        if option == '--test' or option == '-t':
	        # do something
    	...        
</code></pre>
<h5 id="argumentparser"><a class="header" href="#argumentparser"><a href="https://docs.python.org/3.7/library/argparse.html#module-argparse">ArgumentParser</a></a></h5>
<blockquote>
<p><code>ArgumentParser</code>替代了<code>OptionParser</code>（从Python 3.2）。</p>
</blockquote>
<p>创建参数转换实例：</p>
<pre><code class="language-python">from argparse import ArgumentParser
parser = ArgumentParser(
  prog=None,        # program name (default: sys.argv[0])
  description=None, # information before argument help
  usage=None,       # usage syntax (default: auto generate)
  epilog=None,      # information after argument help
  parent=[parent_parsers]  # 继承父解析器实例的解析方法
)
</code></pre>
<blockquote>
<p><code>parent</code>：指定继承的参数解析实例。</p>
</blockquote>
<p>添加参数规则：</p>
<pre><code class="language-python">parser.add_argument(
   names_or_flags,    # 可变参数列表：'--test', '-t', 'argname'
   required=False,
   dest='optname',    # attribute name in return options
   action='store',  
   nargs=1,       # number of option arguments
   const=0,       # 
   default=None,  # default value if not specified from command line
   type=str,      # type of option arguments
   help=None,     # option's usage information
   metavar='NAME' # 帮助信息中作为选项值的标识（默认为长选项名大写）
)
</code></pre>
<p><code>ArgumentParser</code>对参数控制更加严格，如果出现未配置的参数将产生异常。==参数名如果没有前缀，则代表位置参数==；而<code>OptionParser</code>将位置参数存储到一个单独的返回参数中。</p>
<blockquote>
<p>参数解析规则说明：</p>
<ul>
<li>
<p><code>dest</code>：解析参数列表后存储参数值的变量名（参看<code>parse_args()</code>方法）；如果没有指定字段，则会根据选项名生成合法的字段名；</p>
</li>
<li>
<p><code>nargs=N</code>：选项所需要的参数个数，消耗<em>N</em>个参数构成列表。当需要获取位置参数而非选项时，<code>nargs='?'</code>消耗一个位置参数，<code>nargs='*'</code>消耗所有位置参数构成列表，此时<code>names_or_flags</code>作为存储位置参数的变量名。</p>
</li>
<li>
<p><code>type</code>：值的类型，包括：<code>string</code>（默认）、<code>int</code>、<code>float</code>；整数值可以和短选项名组成一个参数，例如<code>-n42</code>等价于<code>-n 42</code>；<code>bool</code>类型参数使用<code>store_true, store_false</code>；</p>
</li>
<li>
<p><code>action</code>：检测到选项后的处理方式</p>
<ul>
<li><code>store</code>：（默认处理方式）储存值，值的类型通过<code>type</code>指定；</li>
<li><code>store_true|store_false</code>：储存<code>bool</code>值<code>True</code>/<code>False</code>，对应的选项不需要另外参数设置值；</li>
<li><code>store_const</code>：<code>'store_const'</code>和<code>'append_const'</code>与<code>const</code>关键字结合使用，用于为选项保存一个常量。</li>
</ul>
</li>
<li>
<p><code>default</code>：选项的默认值（选项未出现在命令行的情况下设置默认值）。</p>
<blockquote>
<p>选项如果不是<code>bool</code>类型，在命令行使用选项时必须提供值；</p>
</blockquote>
</li>
<li>
<p><code>help</code>：选项的帮助信息。当解析参数时，遇到<code>-h</code>或<code>--help</code>（程序退出）或调用<code>parser.print_help()</code>时会自动输出所有帮助信息。</p>
<blockquote>
<p><code> %default</code>可用于在帮助信息中表示输出变量的默认值。<code>ArgumentParser</code>自带<code>-h,--help</code>选项，命令行提供该选项时将输出帮助信息。</p>
</blockquote>
</li>
</ul>
<p>参数解析器默认会添加帮助选项（<code>-h,--help</code>），如果要禁用，设置<code>parser.add_help=False</code>。</p>
</blockquote>
<p>转换命令行参数（默认为<code>sys.argv[1:]</code>，==注意传入给<code>args</code>不要展开==）：</p>
<pre><code class="language-python">options = parser.parse_args(args=None, namespace=None)
</code></pre>
<p>未在命令行提供的选项也会出现在<code>options</code>中，其值为默认值。返回值为<a href="Python/Python%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.html#NameSpace"><code>NameSpace</code>类型</a>。</p>
<h5 id="click"><a class="header" href="#click">click</a></h5>
<p>如果命令行嵌套子命令，可使用<a href="Python/Python%E7%BC%96%E7%A8%8B%E5%BA%94%E7%94%A8.html#click">click</a>进行命令转发。</p>
<h4 id="程序运行信息"><a class="header" href="#程序运行信息">程序运行信息</a></h4>
<pre><code class="language-python">from inspect import currentframe, getframeinfo
frameinfo = getframeinfo(currentframe())
frameinfo.filename  # 当前运行代码所在文件
frameinfo.lineno    # 当前运行代码所在行号
frameinfo.function  # 当前运行代码所在函数
</code></pre>
<h3 id="模块module"><a class="header" href="#模块module">模块(Module)</a></h3>
<p>模块是一个文件，其中包含类，函数等的定义。==模块相当于一个命名空间，其中的定义与其他模块隔离==。</p>
<h5 id="导入模块"><a class="header" href="#导入模块">导入模块</a></h5>
<pre><code class="language-python">import mod                    # modulename &lt;- sys.modules['mod']   
import mod as alias           # aliasname &lt;- sys.modules['mod']   
from mod import name          # objname &lt;- sys.modules['mod'].name 
from module import (name1,name2,...,namen,)
from module import *          # 导入所有内容
from mod import name as alias # aliasname &lt;- sys.modules['mod'].name
import importlib
path = importlib.import_module(&quot;os.path&quot;)  # =&gt; import os.path as path
file, pathname, desc = importlib.find_module('os')  # 查找模块
</code></pre>
<blockquote>
<p><em>不能直接导入模块中的内容并设置别名</em>。</p>
</blockquote>
<p>从模块所在目录导入其他模块：</p>
<pre><code class="language-python">from . import module_name
</code></pre>
<blockquote>
<p>相对路径是<a href="https://stackoverflow.com/a/14132912/6571140">根据导入声明的包名</a><code>package.subpackage.module</code>确定的，因此不可使用相对导入声明路径范围外的模块。由于<code>__main__</code>模块不包含任何路径信息，因此无法使用相对导入。</p>
</blockquote>
<p><a href="https://docs.python.org/3/reference/import.html">5. The import system — Python 3.9.5 documentation</a></p>
<h5 id="引用模块"><a class="header" href="#引用模块">引用模块</a></h5>
<p>当导入整个模块时，使用模块名称访问其中的内容（类、函数等）；也可以直接导入模块中的特定内容。</p>
<pre><code class="language-python">{module|alias}.name     # use module contents via module name/alias
name       # use name/alias to refer an imported class,funcion,...
alias
</code></pre>
<h5 id="重载模块"><a class="header" href="#重载模块">重载模块</a></h5>
<p>检查模块是否导入：<code>sys.modules</code>记录了运行环境已<a href="https://stackoverflow.com/questions/30483246/how-to-check-if-a-python-module-has-been-imported">导入的模块</a>，从而防止模块被重复导入。</p>
<pre><code class="language-python">tf = 'modulename' in sys.modules  # dict
tf = 'importedname' in dir()      # 当前可见名称 
tf = 'importedname' in globals()  # 全局变量
</code></pre>
<p>重新加载修改过的包到当前正在运行的程序：</p>
<pre><code class="language-shell">import importlib
importlib.reload(module)  # &lt;class module&gt; not str
</code></pre>
<h5 id="查看模块的文档"><a class="header" href="#查看模块的文档">查看模块的文档</a></h5>
<pre><code class="language-python">help(len)  # doc for built-in functions
import pandas as pd
help(pd)	# module doc
help(pd.DataFrame) # class doc
help(pd.DataFrame.to_csv)# function doc
</code></pre>
<h5 id="相互引用"><a class="header" href="#相互引用">相互引用</a></h5>
<p><em>注意引用对象顺序，避免先引用未初始化的对象。</em></p>
<pre><code class="language-python"># in module A
from module B import b
def a()
# in module B
from module A import a  
</code></pre>
<h4 id="包package"><a class="header" href="#包package">包(Package)</a></h4>
<p>Package是特殊的模块（包含<code>__path__</code>属性的模块），包含<code>subpackage</code>和<code>module</code>。</p>
<p>常规<code>package</code>通常是一个文件夹中的所有模块以及子文件夹（<code>sub-package</code>）组成。<code>__init__.py</code>文件用于<strong>标识目录是一个package</strong>。当包被导入时，会自动执行<code>__init__.py</code>文件</p>
<pre><code class="language-shell">my_package/
├── __init__.py
├── subpackage1/
│   ├── __init__.py
│   ├── module_x.py
│   └── module_y.py
├── subpackage2/
│   ├── __init__.py
│   └── module_z.py
└── module_a.py
</code></pre>
<h5 id="namespace-packages"><a class="header" href="#namespace-packages">Namespace packages</a></h5>
<blockquote>
<p><em>A <a href="https://docs.python.org/3/reference/import.html#namespace-packages">namespace package</a> is a composite of various portions, where each portion contributes a subpackage to the parent package. Portions may reside in different locations on the file system.</em></p>
</blockquote>
<h5 id="导入包中的模块"><a class="header" href="#导入包中的模块">导入包中的模块</a></h5>
<p>导入包名（相对搜索路径的目录路径）后，通过包名访问其中的内容；或将包名作为前缀导入其中的模块。</p>
<pre><code class="language-python">import pkg
import pkg.mod                # packagename &lt;- sys.modules['pkg']
import pkg.mod as alias       # aliasname &lt;- sys.modules['pkg.mod']  
from pkg import mod           # modulename &lt;- sys.modules['pkg.mod']  
from pkg import mod as alias  # aliasname &lt;- sys.modules['pkg.mod'] 
</code></pre>
<p>导入包名的时候会执行包目录下的<code>__init__.py</code>加载包中的模块。没有在<code>__init__.py</code>中指定加载的模块需要手动加载（<code>import pkg.mod</code>）。</p>
<h5 id="查找路径"><a class="header" href="#查找路径">查找路径</a></h5>
<p><code>sys.path</code> 是一个保存了查找包的路径的列表。Python解释器会自动将==Python程序所在目录==加入路径，从而方便导入同一目录下的其他文件。</p>
<blockquote>
<p><em>==不要在包内部编写测试脚本==，运行该测试脚本时会将该脚本所在路径加入查找路径，从而破坏其所在包的结构</em>。</p>
<p>程序的工作目录（<code>path.abspath(os.curdir)</code>）与程序所在目录可能不同，且不会加入搜索路径。</p>
<p><strong>语法检查的查找路径</strong>：在进行语法检查时（例如在VS Code中使用<code>pylint</code>检查器），检查器的会将当前工作目录加入搜索路径，因此跟程序运行时的情形不同。为了保证程序运行时的路径也在检查器中，可在项目配置文件（<code>settings.json</code>）中配置</p>
<pre><code class="language-json">&quot;python.analysis.extraPaths&quot;: [&quot;E:/Workspace/python&quot;]
</code></pre>
</blockquote>
<p>可以添加自定义搜索路径以导入第三方包：</p>
<pre><code class="language-python">sys.path.insert(0, '/lib/path')  # 添加至头部
sys.path.append('/lib/path')  # 添加至尾部
</code></pre>
<p>查询包是否在本地可加载：</p>
<pre><code class="language-python">import importlib
spec = importlib.util.find_spec(&quot;dask.dataframe&quot;)  # None if not find
</code></pre>
<h5 id="相对导入"><a class="header" href="#相对导入">相对导入</a></h5>
<pre><code class="language-python">from . import module   # 导入同一包内同一层级的子包（或模块）
from .. import module  # 导入同一包内上一层级的子包（或模块）
from .package import module
from ..package import module
</code></pre>
<blockquote>
<p>不要将子包所在路径加入搜索路径，否则不能识别完整包结构，导致相对导入失败。</p>
</blockquote>
<p><a href="https://realpython.com/python-modules-packages/">Python Modules and Packages – An Introduction</a>。</p>
<h2 id="标准库和应用"><a class="header" href="#标准库和应用">标准库和应用</a></h2>
<h3 id="日期和时间"><a class="header" href="#日期和时间">日期和时间</a></h3>
<p><a href="http://www.twinsun.com/tz/tz-link.htm">pytz模块</a></p>
<p><a href="http://labix.org/python-dateutil">dateutil模块</a></p>
<h3 id="cgi"><a class="header" href="#cgi">CGI</a></h3>
<h3 id="密码学"><a class="header" href="#密码学">密码学</a></h3>
<h5 id="消息摘要"><a class="header" href="#消息摘要">消息摘要</a></h5>
<p>Python内置<code>hashlib</code>（消息摘要算法），包括 FIPS 的 SHA1, SHA224, SHA256, SHA384, and SHA512 (定义于 FIPS 180-2) 算法，以及 RSA 的 MD5 算法( 定义于 Internet <a href="https://tools.ietf.org/html/rfc1321.html"><strong>RFC 1321</strong></a>)。消息摘要算法的输入为字节序列</p>
<blockquote>
<p>在 <a href="https://docs.python.org/zh-cn/3/library/zlib.html#module-zlib"><code>zlib</code></a> 模块中包括adler32 或 crc32 哈希函数。</p>
</blockquote>
<pre><code class="language-python">import hashlib
m = hashlib.sha256(b'init_data')
# m.update(a); m.update(b) =&gt; m.update(a+b)
m.update(b&quot;Nobody inspects&quot;)          # 向该对象追加消息(字节序列)
m.update(b&quot; the spammish repetition&quot;)
m.digest()   # 或hexdigest()
</code></pre>
<blockquote>
<p>为了防止黑客通过彩虹表根据哈希值反推原始口令，在计算哈希的时候，不能仅针对原始输入计算，需要增加一个salt来使得相同的输入也能得到不同的哈希，这样，大大增加了黑客破解的难度。</p>
</blockquote>
<h5 id="加密算法"><a class="header" href="#加密算法">加密算法</a></h5>
<p><code>cryptography</code>包含加密、消息摘要以及密钥生成等方法。</p>
<blockquote>
<p><em>The low-level cryptographic primitives are often dangerous and can be used incorrectly. They require making decisions and having an in-depth knowledge of the cryptographic concepts at work.</em></p>
</blockquote>
<p><code>PyCryptodome </code>（代替<a href="https://www.pycrypto.org/"><code>pycrypto</code></a>）：Python Cryptography Toolkit提供加密算法（AES, DES, RSA, ElGamal, ...），同时也提供安全哈希函数（SHA256，MD5等）。</p>
<pre><code class="language-python">from Crypto.Hash import SHA256
hash = SHA256.new()    # update, digest, hexdigest
from Crypto.Cipher import AES
obj = AES.new('This is a key123', AES.MODE_CBC, 'This is an IV456')
message = &quot;The answer is no&quot;
ciphertext = obj.encrypt(message)
obj2 = AES.new('This is a key123', AES.MODE_CBC, 'This is an IV456')
obj2.decrypt(ciphertext)
from Crypto.PublicKey import RSA
from Crypto import Random
random_generator = Random.new().read
key = RSA.generate(1024, random_generator)
signature = key.sign(hash, '')
public_key=key.publickey()
public_key.verify(hash_ver,signature)
</code></pre>
<p><a href="https://python.libhunt.com/compare-cryptography-vs-pycrypto">cryptography vs PyCrypto | LibHunt</a></p>
<h5 id="hmac"><a class="header" href="#hmac">HMAC</a></h5>
<p><a href="https://docs.python.org/3/library/hmac.html#module-hmac">hmac — Keyed-Hashing for Message Authentication — Python 3.10.7 documentation</a></p>
<p><a href="https://datatracker.ietf.org/doc/html/rfc2104.html">RFC 2104 - HMAC: Keyed-Hashing for Message Authentication (ietf.org)</a>：通信双方使用共享密钥对消息的摘要（如MD5、SHA-1等）进行完整性进行校验。</p>
<pre><code class="language-python">import hmac
h = hmac.new(key, message, digestmod='MD5')
</code></pre>
<h2 id="常见问题"><a class="header" href="#常见问题">常见问题</a></h2>
<ol>
<li>
<p>ModuleNotFoundError: No module named 'win32api'</p>
<p>安装<code>pypiwin32</code>包。</p>
</li>
</ol>
<h2 id="参考文献"><a class="header" href="#参考文献">参考文献</a></h2>
<ol>
<li><a href="https://nbviewer.org/github/Nyandwi/machine_learning_complete/blob/main/0_python_for_ml/intro_to_python.ipynb">Basic of Python Programming</a></li>
<li><a href="https://python.libhunt.com/">Awesome Python | LibHunt</a></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="python基础-1"><a class="header" href="#python基础-1">Python基础</a></h1>
<p>Python是一种解释型、面向对象、动态数据类型的高级程序设计语言。</p>
<p>Python 本身也是由诸多其他语言发展而来的,这包括ABC、 Modula-3、 C、 C++、 Algol-68、 SmallTalk、 Unix shell 和其他的脚本语言等等。</p>
<h2 id="环境配置-1"><a class="header" href="#环境配置-1">环境配置</a></h2>
<h3 id="python解释程序-1"><a class="header" href="#python解释程序-1">Python解释程序</a></h3>
<h4 id="运行python程序-1"><a class="header" href="#运行python程序-1">运行Python程序</a></h4>
<h5 id="1-交互式编程-1"><a class="header" href="#1-交互式编程-1">(1) 交互式编程</a></h5>
<p>进入Python解释器环境，交互式执行命令语句。</p>
<pre><code class="language-shell">$ python [options]  # enter python environment
</code></pre>
<p><code>-q</code>：进入交互式命令环境后，不输出提示信息。</p>
<p>安装<code>pyreadline</code>可以为终端启用<code>tab</code>命令自动补全功能。</p>
<h5 id="2-脚本式编程-1"><a class="header" href="#2-脚本式编程-1">(2) 脚本式编程</a></h5>
<p><strong>脚本是语句的集合</strong>，Python解释器会创建一个Python运行环境从而执行脚本中的语句。脚本执行完后，解释器退出运行环境。</p>
<pre><code class="language-shell">python [options] -c &quot;python_command&quot;  # 命令使用&quot;;&quot;分隔
python [options] script.py [args] # execute python script
python [options] -m module_name [args] # 执行指定模块的内容（__main__）
</code></pre>
<p><code>-E</code>：忽略所有<code>PYTHON*</code><a href="https://docs.python.org/3/using/cmdline.html#environment-variables">环境变量</a>（<a href="Python/Python%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80.html#%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83">运行环境</a>）。</p>
<p>当Python脚本首行指定了Python解释器路径，且该脚本具有可执行权限时，可直接运行该脚本。</p>
<pre><code class="language-python">#!/usr/bin/python   # 指定执行该脚本的程序
#!/usr/bin/env python  # 从路径中查找Python解释器以执行该脚本
</code></pre>
<pre><code class="language-shell">python -m json.tool demo.json  # 格式化JSON文本
python -m http.server 8080
python -m pydoc -p 8088   # python文档
python -m mimetypes filename
python -m tarfile -c demo.tar demo   # tar
python -m gzip filename   # =&gt; input only file, output filename.gz
python -m zipfile -c demo.zip demo
python -m telnetlib -d 192.168.56.200 22
</code></pre>
<h5 id="运行环境-1"><a class="header" href="#运行环境-1"><a href="Python/Python%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B.html#Python%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83">运行环境</a></a></h5>
<ul>
<li><code>PYTHONPATH</code>用于指定除系统的附加库搜索路径，程序启动后将加载到<code>sys.path</code>中。默认搜索顺序为当前路径、用户指定附加搜索路径、Python内置库路径、第三方Python库路径。</li>
<li><code>PYTHONHOME</code>指定Python标准库位置（<code>prefix/lib/pythonversion</code> and <code>exec_prefix/lib/pythonversion</code>）；当<code>PYTHONHOME</code>为单个路径时，代替<code>prefix</code>和<code>exec_prefix</code>；反之，可以将<code>PYTHONHOME</code>设置为<code>'prefix:exec_prefix'</code>。<code>PYTHONHOME</code>==不是Python环境的安装目录==。</li>
<li><code>PYTHONSTARTUP</code>：启动Python Shell时需要执行的脚本路径。</li>
</ul>
<blockquote>
<p>如果使用<a href="Python/Python%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83.html#%E8%99%9A%E6%8B%9FPython%E7%8E%AF%E5%A2%83">虚拟环境</a>，则通过激活命令（如<code>conda activate</code>）可保证相关环境变量正确设置。</p>
</blockquote>
<h2 id="基本语法-1"><a class="header" href="#基本语法-1">基本语法</a></h2>
<h3 id="标识符-1"><a class="header" href="#标识符-1">标识符</a></h3>
<p>所有标识符可以包括英文、数字以及下划线(_)，但不能以数字开头，<strong>区分大小写</strong>。</p>
<p>以下划线开头的标识符是有特殊意义的。</p>
<ul>
<li>以单下划线开头（<code>_foo</code>）的代表不能直接访问的类属性，需通过类提供的接口进行访问，不能用 <code>from xxx import *</code> 而导入；</li>
<li>以双下划线开头（<code>__foo</code>）代表类的私有成员；</li>
<li>以双下划线开头和结尾的（<code>__foo__</code>）代表 Python 里特殊方法专用的标识，如<code>__init__()</code>代表类的构造函数。</li>
</ul>
<h3 id="运算符-1"><a class="header" href="#运算符-1">运算符</a></h3>
<p>数值运算符参看<a href="Python/./Python%E6%95%B0%E5%80%BC%E8%AE%A1%E7%AE%97#%E8%BF%90%E7%AE%97%E7%AC%A6">数值计算</a>。</p>
<h4 id="逻辑运算符-1"><a class="header" href="#逻辑运算符-1">逻辑运算符</a></h4>
<p>逻辑运算符用于控制流程中的条件语句，包括<code>and</code> 、<code>or</code> 、<code>not</code>。</p>
<blockquote>
<p>Python不支持<code>&amp;&amp;</code>，<code>||</code>。</p>
</blockquote>
<h4 id="成员运算符-1"><a class="header" href="#成员运算符-1">成员运算符</a></h4>
<p><code>in</code>， <code>not in</code>：在指定的容器（序列、元组、字典、集合等）中查找到值，返回值<code>True</code>或<code>False</code>；==也可用于判断一个字符串是否为另一个字符串的子串。==</p>
<pre><code class="language-python">list_str = ['--test', '-o output/test', '--debug']
if '--debug' in list_str:
    print('find --debug in parameter list.')
if 'test' not in list_str:
    print('not find test in parameter list.')    
</code></pre>
<blockquote>
<p>取决于容器类型，查询<a href="https://wiki.python.org/moin/TimeComplexity">时间复杂度</a>不同。</p>
</blockquote>
<h4 id="身份运算符-1"><a class="header" href="#身份运算符-1">身份运算符</a></h4>
<p><code>is,</code> <code>is not</code>：判断两个标识符是否引用同一个对象，返回<code>True</code>或<code>False</code>。 <code>==</code>用于判断引用变量的==值==是否相等。</p>
<blockquote>
<p><code>id()</code>函数返回一个整数表示变量的标识；CPython实现的<code>id(x)</code>返回<code>x</code>的内存地址。</p>
<p><code>hash(obj)</code>返回基于对象内容的一个映射值，具有相同值的两个对象有相同hash值（不同于<a href="Python/Python%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80.html#%E5%AF%86%E7%A0%81%E5%AD%A6">消息摘要</a>是基于字节序列内容的）。</p>
</blockquote>
<h4 id="对象运算符-1"><a class="header" href="#对象运算符-1">对象运算符</a></h4>
<p><code>+</code> 运算符用于拼接序列对象；</p>
<p><code>*</code> 用于重复序列对象：如果对象的元素为值类型，则复制该元素的值并将复制内容拼接；如果<strong>元素为引用类型，则仅复制引用（浅拷贝）</strong>。</p>
<pre><code class="language-python">print str*2       # 输出字符串两次
</code></pre>
<p><code>[]</code>：<a href="Python/Python%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80.html#%E5%BA%8F%E5%88%97%E7%B1%BB%E5%9E%8B%E7%9A%84%E7%B4%A2%E5%BC%95">下标运算符</a>，取字符串、列表或元组元素。</p>
<h4 id="运算符优先级-1"><a class="header" href="#运算符优先级-1">运算符优先级</a></h4>
<h3 id="语句-1"><a class="header" href="#语句-1">语句</a></h3>
<p>同一行显示多条语句，方法是用分号“<code> ;</code>” 分开。但是我们可以<strong>使用斜杠（</strong> <strong><code>\</code>）将一行的语句分为多行显示</strong>。语句中包含<code>[]</code>,<code>{}</code>或<code>()</code> 括号就不需要使用多行连接符。</p>
<p>用缩进（空格）长度来写语句块。缩进的空白数量是可变的，但是所有代码块语句必须包含相同的缩进空白数量，这个必须严格执行。</p>
<p><code>eval</code>可以执行字符串表示的Python表达式（不支持复杂的代码逻辑，例如赋值操作、循环语句），并返回表达式的值。</p>
<pre><code class="language-python">x = eval('os.path.abspath(os.path.curdir)')
</code></pre>
<p><code>exec</code>执行语句或代码块，不能做表达式求值并返回，但可以通过赋值表达定义新的变量并添加到当前上下文中。</p>
<pre><code class="language-python">exec('x = os.path.abspath(os.path.curdir)')
</code></pre>
<p>https://www.cnblogs.com/pythonista/p/10590682.html。</p>
<h3 id="注释和文档-1"><a class="header" href="#注释和文档-1">注释和文档</a></h3>
<p>单行注释：“<code>#</code>”</p>
<p>文件开始的注释内容提供解释器与脚本的相关信息。</p>
<pre><code class="language-python">#!/usr/bin/python
# -*- coding: UTF-8 -*-
</code></pre>
<p>脚本中包含中文时，需要指定文件的编码方式（UTF-8），默认编码方案是（ASCII）。Python3.X 源码文件默认使用utf-8编码，所以可以正常解析中文，无需指定 UTF-8 编码。</p>
<p>空行并不是Python语法的一部分。书写时不插入空行，Python解释器运行也不会出错。</p>
<p>位于类型定义之后的<a href="Python/Python%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80.html#%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%88String%EF%BC%89">三引号文本</a>（<code>'''</code>，docstring）将自动生成为该类型的<a href="https://realpython.com/documenting-python-code/">文档</a>（<code>type.__doc__</code>）。</p>
<blockquote>
<p>Package docstrings should be placed at the top of the package’s <code>__init__.py</code> file. Module docstrings are placed at the top of the file even before any imports. </p>
</blockquote>
<p>使用<code>help()</code>函数可查看当前环境已导入的模块的内容的文档。</p>
<h5 id="文档生成-1"><a class="header" href="#文档生成-1">文档生成</a></h5>
<p>使用reStructuredText编写代码注释，可通过<a href="Python/../%E5%BA%94%E7%94%A8%E8%BD%AF%E4%BB%B6/%E6%96%87%E6%A1%A3%E7%94%9F%E6%88%90%E8%BD%AF%E4%BB%B6.html#%E8%A7%A3%E6%9E%90%E5%92%8C%E8%BD%AC%E6%8D%A2Python%E4%BB%A3%E7%A0%81">Sphinx</a>自动转换为参考文档。</p>
<h3 id="流程控制-1"><a class="header" href="#流程控制-1">流程控制</a></h3>
<h4 id="条件-1"><a class="header" href="#条件-1">条件</a></h4>
<pre><code class="language-python">if expression1:
	statements1……
elif expression2:
	statements2……
else:
	statements4……
    
c = a if &lt;condition&gt; else b
</code></pre>
<p>在Python中没有<code>switch–case</code>语句。</p>
<h4 id="循环-1"><a class="header" href="#循环-1">循环</a></h4>
<pre><code class="language-python">while expression1：
	statements……
else:
	statements4……
</code></pre>
<p><code>for</code>循环可以遍历任何序列的项目，例如字符串、列表；</p>
<pre><code class="language-python">for i = 1 to 10:
  statements
for var in sequence:  # 迭代过程不能更改迭代的对象
	statements1(s)
	break
	continue
else:
	statements2……
for idx,item in enumerate(lista): # enumerate构造(i, l(i))迭代元组
  print('{idx} - {item}')
for idx,_ in enumerate(lista):
  print('{idx} - {item}')
</code></pre>
<p>循环<strong>正常</strong>执行完之后，执行<code>else</code>语句。</p>
<p><code>sequence</code>可以是索引集合：<code>range(start,end, step=1)</code></p>
<h4 id="pass语句-1"><a class="header" href="#pass语句-1">pass语句</a></h4>
<p><code>pass</code>不做任何事情，一般用做占位语句。特殊变量<code>...</code>（<code>Ellipse</code>），可用于代替<code>pass</code>语句。</p>
<h4 id="异常处理-1"><a class="header" href="#异常处理-1">异常处理</a></h4>
<h5 id="触发异常-1"><a class="header" href="#触发异常-1">触发异常</a></h5>
<pre><code class="language-python">raise ExceptionObject, args, traceback
</code></pre>
<h5 id="捕捉异常-1"><a class="header" href="#捕捉异常-1">捕捉异常</a></h5>
<pre><code class="language-python">try:
  pass
except ExceptionName as e: # e为异常对象，如果不使用可省略as语句
  statements1
except (Exception1, Exception2, ...) as e:
  statements2
except:
	statements3
else:
	statements4
finally:
    statementsN
</code></pre>
<blockquote>
<p>Python 2.x语法：</p>
<pre><code class="language-python">try:
	statements
except ExceptionType, Argument:
	statements
</code></pre>
</blockquote>
<h5 id="异常处理方法-1"><a class="header" href="#异常处理方法-1">异常处理方法</a></h5>
<p>处理异常时可使用<code>traceback</code>获取调用栈的信息。打印堆栈追踪信息：</p>
<pre><code class="language-python">traceback.print_exc()                 # 打印stacktrace
traceback.format_exc()                # 返回stacktrace为字符串
traceback.print_tb(err.__traceback__) # stacktrace
</code></pre>
<p>对于捕获到的异常，如果没有合适处理方法可再次抛出异常。</p>
<h5 id="异常类型-1"><a class="header" href="#异常类型-1">异常类型</a></h5>
<p>所有异常基于<code>BaseException</code>。<code>Exception</code>类用于定义用户异常。<code>Warning</code>也继承自<code>Exception</code>类，但通常不用于触发异常，而是用于<a href="Python/Python%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA.html#%E8%AD%A6%E5%91%8A%E4%BF%A1%E6%81%AF">产生警告信息</a>。</p>
<p>Exception hierarchy：https://docs.python.org/3/library/exceptions.html#os-exceptions</p>
<p>内置异常类型：</p>
<p>ArithmeticError</p>
<p>BufferError</p>
<p>LookupError： IndexError, KeyError</p>
<p>AssertionError</p>
<p>EOFError</p>
<p>GeneratorExit</p>
<p>ImportError</p>
<p>ModuleNotFoundError</p>
<p>KeyboardInterrupt</p>
<p>MemoryError</p>
<p>NameError, TypeError, UnboundLocalError, ValueError, IOError, WindowsError</p>
<p>NotImplementedError</p>
<p>SystemError, SystemExit, EnvironmentError</p>
<p>OSError</p>
<blockquote>
<p>https://docs.python.org/3/library/exceptions.html#os-exceptions</p>
</blockquote>
<p>OverflowError, ZeroDivisionError</p>
<p>RecursionError</p>
<p>ReferenceError</p>
<p>RuntimeError</p>
<p>StopIteration, StopAsyncIteration</p>
<p>SyntaxError, IndentationError, TabError</p>
<p>UnicodeError, UnicodeEncodeError, UnicodeDecodeError, UnicodeTranslateError</p>
<h4 id="with-as-context-manager-1"><a class="header" href="#with-as-context-manager-1">with-as (Context Manager)</a></h4>
<p><a href="https://www.ibm.com/developerworks/cn/opensource/os-cn-pythonwith/index.html">上下文管理协议</a>：实现方法是为一个类定义<code>__enter__</code>和<code>__exit__</code>两个函数。</p>
<pre><code class="language-python">with open_resource(args) [as target(s)]:
    do_something
</code></pre>
<p><code>with-as</code>语句的执行过程是，首先执行<code>__enter__</code>函数，它的返回值会赋给<code>as</code>后面的变量。
然后开始执行<code>with-block</code>中的语句，在<code>with-block</code>执行完成或发生异常或退出，会执行<code>__exit__</code>函数（释放资源或处理可能产生的异常）。</p>
<h5 id="支持上下文管理协议的类-1"><a class="header" href="#支持上下文管理协议的类-1">支持上下文管理协议的类</a></h5>
<pre><code class="language-python">class Resource():
  def __enter__(self):  # 实际分配资源的操作在该方法中，而不在__init__()中
    print('===connect to resource===')
    return self
  def __exit__(self, exc_type, exc_val, exc_tb):
    print('===close resource connection===')
    return True
</code></pre>
<h5 id="contextlibcontextmanager装饰器-1"><a class="header" href="#contextlibcontextmanager装饰器-1"><code>contextlib.contextmanager</code>装饰器</a></h5>
<p>使用该<a href="Python/Python%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B.html#%E8%A3%85%E9%A5%B0%E5%99%A8">装饰器</a>可将构造资源的函数转换为支持上下文管理协议。</p>
<pre><code class="language-python">import contextlib
@contextlib.contextmanager
def open_func(file_name):
  # __enter__ method
  file_handler = open(file_name, 'r')
  try:
	  yield file_handler
  # __exit__ method
  except Exception as exc: # 如果不需处理异常则无需使用try-except语句
    pass
  finally:
	  file_handler.close()
</code></pre>
<h4 id="exit-handlers-1"><a class="header" href="#exit-handlers-1">Exit handlers</a></h4>
<p><code>atexit</code>模块用于注册程序==正常退出==前的清理函数。可以注册多个函数，函数执行顺序与注册顺序相反。</p>
<pre><code class="language-python">atexit.register(func, *args, **kwargs)
atexit.unregister(func)
</code></pre>
<p>如果子进程由<code>os.fork()</code>创建，则继承父进程的退出处理函数；如果子进程由<code>multiprocessing</code>模块创建，则不会继承退出处理函数。</p>
<blockquote>
<p><em>When used with C-API subinterpreters, registered functions are local to the interpreter they were registered in.</em></p>
</blockquote>
<h3 id="函数-1"><a class="header" href="#函数-1">函数</a></h3>
<h4 id="定义函数-1"><a class="header" href="#定义函数-1">定义函数</a></h4>
<pre><code class="language-python">def function_name(arg1: int, arg2: float) -&gt; float
    &quot;documentation&quot;
    statements
    [return expr1, expr2, ...]
</code></pre>
<p>函数内部可访问全局脚本语句定义的变量。可以为输入输出参数添加<a href="Python/Python%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80.html#%E7%B1%BB%E5%9E%8B%E6%8F%90%E7%A4%BA">类型提示</a>。</p>
<h4 id="参数-1"><a class="header" href="#参数-1">参数</a></h4>
<p><strong>参数传递</strong>：不可变类型（数值、字符串、元组等）是值传递，<strong>可变类型</strong>（列表、字典、集合等）是引用传递；</p>
<p><strong>关键字参数</strong>：使得调用函数时传入参数顺序可以与定义时不同，也可以为参数设置默认值（默认值在模块初始化时构造）；关键字参数必须置于所有位置参数之后。</p>
<pre><code class="language-python">def func(arg1, age=50, name=&quot;miki&quot;)
</code></pre>
<p><strong>不定长参数</strong></p>
<p><code>*args</code>用于传递任意数量的位置参数（列表或元组），<code>**kwargs</code>用于传递任意数量的关键字参数（字典）。</p>
<pre><code class="language-python">def functionname(formal_args, *args，**kwargs)
</code></pre>
<blockquote>
<p>在函数调用时，也可以使用<code>*args</code>将参数列表传递到函数中（需要与函数声明的参数个数或<code>*args</code>声明匹配），使用<code>**kwargs</code>将字典传入函数作为关键字参数（将值赋给与键名相同的参数，或与<code>**kwargs</code>声明匹配）。</p>
</blockquote>
<h4 id="返回值-1"><a class="header" href="#返回值-1">返回值</a></h4>
<p>通过<code>return</code>语句可以设置一个或多个返回值，或不返回值。</p>
<blockquote>
<p><code>return</code>不用于脚本退出，使用<code>sys.exit()</code>退出。</p>
</blockquote>
<p>当返回多个值时，如果仅提供一个输出参数，则将返回值构造成元组。若提供多个参数存储返回值，则将从元组中一次读取元素给输出参数。</p>
<pre><code class="language-python">a, b, c = function_name(...)  # 等效于 (a,b,c) = func_name(...)
d = function_name(...)  # d = (a,b,c)
</code></pre>
<h4 id="匿名函数-lambda表达式-1"><a class="header" href="#匿名函数-lambda表达式-1">匿名函数 （Lambda表达式）</a></h4>
<p>将函数作为<strong>对象</strong>保存和引用，也可以在使用函数的地方直接定义（而非使用<code>def</code>定义普通函数）。</p>
<pre><code class="language-python">add = lambda x, y : x+y
f = lambda x: 1 if x &gt; 0 else -1
the_sum = add(1,2)
</code></pre>
<h2 id="变量-1"><a class="header" href="#变量-1">变量</a></h2>
<p>Python的主要内置类型有数值、序列（<code>string</code>、<code>list</code>和<code>tuple</code>）、映射、类、实例和异常，方法也可以看作特殊的对象类型。每个变量（<code>object</code>）具有一个标识、类型和值。</p>
<h3 id="创建和删除变量-1"><a class="header" href="#创建和删除变量-1">创建和删除变量</a></h3>
<p>定义变量不需要声明类型，根据赋值的类型确定变量类型。</p>
<pre><code class="language-python">a = b = c = 1
a, b, c = 1, 2, &quot;john&quot; 
</code></pre>
<p>变量可重复赋值，赋值前后类型不需要一致（由赋值类型决定）。</p>
<p>删除变量：</p>
<pre><code class="language-python">del var_a, var_b 
del list[i], dict[name]
</code></pre>
<h4 id="变量作用域-1"><a class="header" href="#变量作用域-1">变量作用域</a></h4>
<p>在文件范围中定义的变量具有<strong>文件作用域</strong>，在文件其后的任意位置（包括调用的函数内部）都能访问。各文件中定义的变量属于不同的<strong>命名空间</strong>（模块名），互不影响。要引用其他模块中定义的全局变量，可使用<code>import</code>语句引入其他模块通过模块名访问或直接将该变量引入当前文件的命名空间。</p>
<pre><code class="language-python">import module
print(module.global_var)
from module import global_var
</code></pre>
<blockquote>
<p>在文件中定义的函数引用全局变量时，总是引用该文件作用域中的全局变量，而不会使用调用该函数的文件中的全局变量。</p>
</blockquote>
<h5 id="可见性-1"><a class="header" href="#可见性-1">可见性</a></h5>
<p>当函数内部定义了与全局变量同名的局部变量，则全局变量将被隐藏（即使在定义局部变量之前也不能引用该同名全局变量）。使用<code>global</code>用于在函数内部对全部变量的声明和修改。</p>
<pre><code class="language-python">a = 'initialized'
def func()
	global a
    a = 'modified'
</code></pre>
<p>获取作用域中的变量信息：</p>
<pre><code class="language-python">dict_vars = locals()  # 获取当前的局部作用域中的变量
dict_vars = globals() # 获取全局作用域中的变量
</code></pre>
<blockquote>
<p>包括变量、函数、模块等信息。</p>
</blockquote>
<p>在流程控制语句块中定义的变量在离开语句块后仍有效。</p>
<h4 id="类型信息判断-1"><a class="header" href="#类型信息判断-1">类型信息判断</a></h4>
<p><code>type()</code>返回变量的==类型信息可以和类型对象进行比较==。</p>
<pre><code class="language-python">type_info = type(var_name)
tf = type(x) == int     # return True if x is int.
</code></pre>
<p><code>get_type_hints()</code>可以查看模块、类、方法或函数的类型信息。</p>
<pre><code class="language-python">from typing import get_type_hints
</code></pre>
<pre><code class="language-python">Vector = list[float]  # type alias
from typing import NewType
UserId = NewType('UserId', int)  # New simple type
</code></pre>
<p><code>isinstance</code>判断实例是否为某个类型（父类）的实例：</p>
<pre><code class="language-python">isinstance(obj, Type)		
isinstance(obj, (Type1, Type2, ...))		#  任意一种类型
</code></pre>
<blockquote>
<p><code>Type</code>是在程序中使用的变量类型，不是字符串，例如<code>pd.DataFrame</code>，<code>np.ndarray</code>。</p>
</blockquote>
<p><code> issubclass</code>判断一种类型是否为某类型的子类：</p>
<pre><code class="language-python">isdubclass(subType, Type)
</code></pre>
<h4 id="类型提示-1"><a class="header" href="#类型提示-1">类型提示</a></h4>
<pre><code class="language-python">age: int = 1   # 可不提供初始化值
</code></pre>
<p>容器类型需要使用专门定义的类型修饰变量。</p>
<pre><code class="language-python">from typing import List, Set, Dict, Tuple, Optional, Callable
x: Set[int] = {6, 7}
x: Dict[str, float] = {'field': 2.0}
x: Tuple[int, str, float] = (3, &quot;yes&quot;, 7.5)  # fixed size tuple
x: Tuple[int, ...] = (1, 2, 3)     # variable size tuple
x: Optional[str] = some_function() # values that could be None
x: Callable[[int, float], float] = f # function
</code></pre>
<p>类型别名：</p>
<pre><code class="language-python">vector = List[float]
</code></pre>
<p>迭代器提示。</p>
<p>参数提示仅作为编写程序的辅助工具，在程序运行时并不会做相应的类型检查。</p>
<h5 id="联合类型-1"><a class="header" href="#联合类型-1">联合类型</a></h5>
<p>可以为参数指定类型，且可使用<code>typing.Union</code>指定多种类型；</p>
<pre><code class="language-python">from typing import Union
def function_name(arg1:Union[str,int])
</code></pre>
<h5 id="常量类型-1"><a class="header" href="#常量类型-1">常量类型</a></h5>
<pre><code class="language-python">from typing import Final    # [Python 3.8]
</code></pre>
<p><a href="https://mypy.readthedocs.io/en/stable/cheat_sheet_py3.html">Type hints cheat sheet (Python 3)</a>。</p>
<h3 id="类-1"><a class="header" href="#类-1">类</a></h3>
<p>类的定义：由成员，方法，数据属性组成。</p>
<pre><code class="language-python">class ClassName:
	'''documentation'''   #类文档字符串
    static_var: Type = value
    var1: Type     # Annotate a member does not make it static.
    # 构造函数
    def __init__(self, value1, value2, ...) -&gt; None:
        self.var1 = value1		# 成员变量
        self.var2 = value2
        ...
    # 析构函数
    def __del__(self):
    	release_unmanaged_resources
    # 成员方法
    def method_name(self, arg1, arg2, ...):
      self.xxx        # 调用类的成员变量或方法
    	# statements...
		@staticmethod      # 静态方法
    def method_name(...)
    	statements
    @property					 # read only property
    def prop(self):
    	return self.xxx
    @x.setter
    def x(self, value):
    	self.__x = value
    @x.deleter
    def x(self):
    	del self.__x
</code></pre>
<h4 id="静态变量-1"><a class="header" href="#静态变量-1">静态变量</a></h4>
<p>静态成员变量仅能通过类名或静态方法访问。实例可以定义与静态成员同名的成员变量（通过实例引用将隐藏静态变量）。子类可以定义与父类同名的静态变量（隐藏），通过子类名或实例将只能访问子类的静态变量。</p>
<p>==对实例成员的类型注释由于没有初始化，因此不会被视为静态变量==。</p>
<p>静态变量初始化：可在类外部对静态变量进行初始化，从而基于父类的静态变量对子类静态变量进行初始化。在子类内部使用父类静态变量初始化子类静态变量无效（得到<code>None</code>）。</p>
<h4 id="构造-1"><a class="header" href="#构造-1">构造</a></h4>
<p>浅拷贝：很多类型（例如<code>list</code>、<code>dict</code>）提供<code>copy()</code>方法，支持对象的浅拷贝。这意味着对象中的成员变量如果是引用类型，则两个对象共享该引用类型成员。</p>
<p>析构函数<code>__del__</code> ，<code>__del__</code>在对象销毁的时候被调用，当对象不再被使用时，<code>__del__</code>方法运行。Python使用了引用计数这一简单技术来跟踪和回收垃圾。</p>
<pre><code class="language-python">obj = ClassName(args) # 创建对象
</code></pre>
<p>使用<code>.</code>运算符来访问对象的属性。</p>
<h4 id="类的成员-1"><a class="header" href="#类的成员-1">类的成员</a></h4>
<p>类可以看作由元数据、用户定义数据和方法组成的字典，使用<code>dir(x)</code>（<code>x.__dir__()</code>）返回类包含的属性和方法组成的字典。</p>
<p>类的方法与普通的函数只有一个特别的区别——它们必须有一个额外的第一个参数名称, 按照惯例它的名称是 <code>self</code>（<code>self</code>不是Python关键字，换成其他标识符仍然有效）。<code>self</code>代表的是类的实例，代表当前对象的地址，而<code>self.__class__</code>是类的类型信息。</p>
<p>Python成员不存在<strong>访问控制</strong>，仅通过标识符在语义上区分。</p>
<ul>
<li>
<p><code>__&lt;private_member&gt;</code>：标记为私有属性/方法，其中形如<code>__INNER_MEMBER__</code>的成员为类的元数据。</p>
</li>
<li>
<p><code>_&lt;protected_member&gt;</code>：标记为保护属性/方法。</p>
</li>
<li>
<p><code>&lt;public_member&gt;</code>：标记为公开属性/方法。</p>
</li>
</ul>
<h5 id="类的元数据-1"><a class="header" href="#类的元数据-1">类的元数据</a></h5>
<p>通过类或对象均可访问类的元数据（所有对象共享）。</p>
<p><code>__class__</code>：类型元信息（即<code>type</code>类型对象，等效于<code>type(obj)</code>）；</p>
<p><code>__name__</code>：类名（字符串，==不包含类所在的包名==）。</p>
<p><code>__bases__</code> : 类的所有父类元信息构成的元素（包含了一个由所有父类组成的元组） 。</p>
<p><code>__dict__</code>：所有成员变量名与对应的值组成的字典，等效于<code>vars(obj)</code>；</p>
<p><code>__doc__</code>：类的文档字符串 。</p>
<p><code>__module__</code>: 类定义所在的模块（类的全名是<code>__main__.className</code>，如果类位于一个导入模块<code>mymod</code>中，那么<code>className.__module__</code>等于 <code>mymod</code>） </p>
<h5 id="实例的元数据-1"><a class="header" href="#实例的元数据-1">实例的元数据</a></h5>
<p><code>obj.__str__(),</code>：类成员信息的字符串表示，自动转换为字符串类型时调用该方法；</p>
<p><code>obj.__repr__()</code>：返回构造该对象的语句，<code>repr(obj)</code>会调用对象的该方法。调用<code>eval(repr(obj))</code>可重新构造该对象。</p>
<h5 id="描述符协议-1"><a class="header" href="#描述符协议-1">描述符协议</a></h5>
<p>在类里实现了<code> __get__()</code> 、<code>__set__()</code>、<code>__delete__()</code>其中至少一个方法。</p>
<pre><code class="language-python">class Score:
  def __init__(self, default=0):
    self._score = default
  def __set__(self, instance, value): # 设置属性的值，进行验证
    if not isinstance(value, int):
      raise TypeError('Score must be integer')
    if not 0 &lt;= value &lt;= 100:
      raise ValueError('Valid value must be in [0, 100]')
    self._score = value
  def __get__(self, instance, owner): # 属性不存在、不合法等都可以抛出对应的异常
    return self._score
  def __delete__(self):  # 删除内容
    del self._score
class Student:
  def __init__(math_score):
    self.math = Score(math_score)
  pass
</code></pre>
<h4 id="数据类-1"><a class="header" href="#数据类-1">数据类</a></h4>
<p><code>dataclass</code>（<strong>Python 3.7+</strong>）专门用于定义和存储数据的类型（更加适合<a href="Python/Python%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA.html#%E5%AF%B9%E8%B1%A1%E5%BA%8F%E5%88%97%E5%8C%96">序列化</a>），封装了数据的初始化方法和基本运算方法（避免频繁编写这些基础代码）。<code>dataclass</code>继承自<code>object</code>类型，因此，开发者仍可基于<code>dataclass</code>编写自定义方法<sup class="footnote-reference"><a href="#dataclass">1</a></sup>。</p>
<h5 id="定义数据-1"><a class="header" href="#定义数据-1">定义数据</a></h5>
<p>基于<strong>类型提示</strong>语法自动生成对应成员的定义，而无需重复在初始化方法中声明和初始化成员。</p>
<pre><code class="language-python">from dataclasses import dataclass
@dataclass
class Persion:
    first_name: str
    last_name: str = &quot;Wang&quot;  # 支持默认值, 但必须在所有非默认值参数后
    age: int
    job: str
    full_name: str = field(init=False, repr=False) # *
</code></pre>
<blockquote>
<p><code>dataclass</code>会自动生成<code>__init__()</code>、<code>__eq__()</code>（自动对比对象的所有成员）和<code>__expr__()</code>方法。由于<code>dataclass</code>的构造方法是自动生成的，也因此无法向父类传递初始化参数，所以通常自定义<code>dataclass</code>类型不再继承其他类。</p>
<p><code>*</code>：当该成员的初始化依赖于其他成员变量时，不在自动生成的构造函数中初始化，而是在<code>__post_init__</code>方法中定义初始化方法。这种方式避免使用属性，在每次调用时需要重复计算值。</p>
</blockquote>
<h5 id="非可变对象-1"><a class="header" href="#非可变对象-1">非可变对象</a></h5>
<p>声明<code>@dataclass(frozen=True)</code>，对象初始化后无法被更改。</p>
<h5 id="数据转换-1"><a class="header" href="#数据转换-1">数据转换</a></h5>
<p>可轻易转换为元组或字典。</p>
<pre><code class="language-python">from dataclass import astuple,asdict
person:Tuple = astuple(Person(...))
person:Dict = asdict(Persion(...))
</code></pre>
<h5 id="比较接口-1"><a class="header" href="#比较接口-1">比较接口</a></h5>
<p><code>@dataclass(order=True)</code>将自动生成<code>__lt__</code>、<code>__le__</code>、<code>__gt__</code>、<code>__ge__</code>方法，从而支持排序比较。默认将对类中所有字段以此进行比较，在类定义中添加特殊的<code>sort_index</code>字段，该字段引用其他成员变量的值以定义<a href="Python/Python%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8Bmd#%E5%88%97%E8%A1%A8%E6%8E%92%E5%BA%8F">排序参考值</a>。</p>
<pre><code class="language-python">@dataclass(order=True)
class Persion:
    # ...
    sort_index: int = field(init=False, repr=False)
    def __post_init__(self):
        self.sort_index = self.age
</code></pre>
<h4 id="继承语法-1"><a class="header" href="#继承语法-1">继承语法</a></h4>
<pre><code class="language-python">class ClassName (ParentClass1[, ParentClass2, ...]):  # 支持多重继承
    'Optional class documentation string'
    def __init__(self, args):
      super().__init__(...)  # &lt;=&gt; super(ClassName, self).__init__(args)
      # ...
</code></pre>
<p>在继承中基类的构造（<code>__init__()</code>方法）不会被自动调用，它需要在其派生类的构造中手动。需要通过基类名调用<code>__init_()</code>并且传递<code>self</code>变量。</p>
<h5 id="方法重写override-1"><a class="header" href="#方法重写override-1">方法重写（override）</a></h5>
<p>当方法被重写后，==通过对象调用方法时将调用子类的方法==（即使是在父类中）。要通过<code>super()</code>以显式调用父类方法。</p>
<pre><code class="language-python">super().method(args)  # &lt;=&gt; super(ClassName, self).method(args)
</code></pre>
<p>同名函数或成员调用：使用<code>super().member()</code>调用<a href="Python/Python%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80.html#MRO%EF%BC%88Method-Resolution-Order%EF%BC%89">MRO搜索顺序</a>上第一个存在该成员的类。如果要显式调用某一父类的方法，则使用<code>super(SuperClass, self).method(args)</code>。</p>
<blockquote>
<p>在基于<code>pdb</code>的调试环境下，如果在调试窗口调用父类方法，使用<code>super().method(args)</code>会报错（程序中正常执行）。</p>
</blockquote>
<h5 id="运算符重载-1"><a class="header" href="#运算符重载-1">运算符重载</a></h5>
<h5 id="mromethod-resolution-order-1"><a class="header" href="#mromethod-resolution-order-1">MRO（Method Resolution Order）</a></h5>
<p>父类的初始化顺序：根据继承关系“深度优先—从左至右”搜索父类，确定初始化顺序（调用<code>classname.__mro__</code>查看类的搜索顺序）。</p>
<ul>
<li>深度优先，按继承关系依次调用父类构造函数；</li>
<li>从左至右，当深度搜索到达顶端后，==如果顶层父类包含<code>super().__init__()</code>调用==，则将调用第二条继承关系上的类型，并执行深度优先初始化；</li>
<li>如果两条继承路线存在公共父类，则在第一条继承路线搜索到公共父类前会跳转到第二条继承路线，由第二条继承路线搜索到公共父类；多条继承路线具有公共父类的情况同理。</li>
<li>如果搜索过程中，某父类不存在<code>super().__init__()</code>，则从该父类的代码开始，并按调用栈反向执行初始化。==在构造过程中已经被前面构造函数初始化过的属性会被后调用的构造方法再次初始化==。</li>
</ul>
<blockquote>
<p>如果在MRO搜索顺序中某个直接或间接父类未调用<code>super().__init__()</code>，则==MRO初始化过程中断==（该类及MRO搜索顺序的后续类的构造方法不会被调用）。</p>
</blockquote>
<p>参数传递：</p>
<ul>
<li>
<p>==初始化过程中的参数传递与初始化顺序一致，而非子类分别传递给其各个直接父类==。因此在声明父类时，一定要将能通过<code>super().__init__()</code>传递参数的父类声明在前，否则其后的父类无法获取参数。</p>
</li>
<li>
<p>传递给父类参数通常使用<code>*args</code>和<code>**kwargs</code>代替（除非子类需要对相关参数进行处理）。</p>
<pre><code class="language-python">def __init__(self, a,b,*args,c=1,b='hello',**kwargs)
</code></pre>
<p>位置参数的顺序保持子类参数在前，父类参数在后（从而可以使用<code>*args</code>来统一接收父类参数）。</p>
</li>
</ul>
<p><a href="https://www.journaldev.com/14623/python-multiple-inheritance">Python Multiple Inheritance - JournalDev</a></p>
<h5 id="mixin-1"><a class="header" href="#mixin-1">mixin</a></h5>
<p>抽取单一功能，提供给多个类继承，可视为带实现的接口；mixin模式适用于多个类各自有继承主线，但又共享部分功能。这部分功能即可通过mixin类型实现。</p>
<p><code>mixin</code>类型<em>不定义新的成员变量</em>，仅定义关于目标混入对象的计算方法（可使用期望继承的类所包含的成员）。</p>
<p>https://stackoverflow.com/q/533631/6571140。</p>
<h3 id="迭代器-1"><a class="header" href="#迭代器-1">迭代器</a></h3>
<p>迭代器<code>Iterator</code>提供<code>__next__()</code>方法以遍历所有元素；使用<code>yield</code>关键字的方法也可以实现简单迭代器。</p>
<pre><code class="language-python">def g(n: int) -&gt; Iterator[int]:
    i = 0
    while i &lt; n:
        yield i
        i += 1
</code></pre>
<p>可迭代对象<code>Iterable</code>提供两个方法:<code>__iter__()</code>和<code>next()</code>。通过<code>iter(Iterable)</code>可获取访问可迭代对象的迭代器。<a href="Python/Python%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80.html#%E5%BE%AA%E7%8E%AF"><code>for</code>语句</a>实际需要传递迭代器对象，通过语法糖简化了对可迭代对象的访问语法。</p>
<p><a href="https://stackoverflow.com/questions/9884132/what-exactly-are-iterator-iterable-and-iteration">python - What exactly are iterator, iterable, and iteration? - Stack Overflow</a></p>
<h3 id="内存占用-1"><a class="header" href="#内存占用-1">内存占用</a></h3>
<pre><code class="language-python">import sys
s = sys.getsizeof(var)
</code></pre>
<p>所有内置类型均以对象封装，因此返回的为对象占用的内存（仅计算对象本身占用的内存，而不包括对象引用的内存）。第三方类型类型返回结果不一定准确。</p>
<h2 id="程序结构-1"><a class="header" href="#程序结构-1">程序结构</a></h2>
<h3 id="程序入口-1"><a class="header" href="#程序入口-1">程序入口</a></h3>
<p>模块中非类、函数定义的代码部分将在引用时被执行。</p>
<p>通过以下方式为程序设置一个入口，从而屏蔽引用模块中的非定义代码：</p>
<pre><code class="language-python">if __name__ == '__main__':
	main_procedure
else:
	module_initialization
</code></pre>
<blockquote>
<p>注意：上述代码并非常规的主函数（<code>main(args</code>))，只是一个普通的条件语句。可以自定义一个<a href="https://codingpy.com/article/guido-shows-how-to-write-main-function/">常规的主函数</a>在上述结构中进行调用。</p>
</blockquote>
<pre><code class="language-python">def main(args=None):
    if args is None:
        args = sys.argv
    # main code

 	return value   
    
if __name__ == '__main__':
    sys.exit(main(sys.argv[1:]))
</code></pre>
<h4 id="命令行参数处理-1"><a class="header" href="#命令行参数处理-1">命令行参数处理</a></h4>
<p><code>sys.argv[0]</code>表示程序名，其他元素为传入参数。</p>
<pre><code class="language-python">for argi in sys.argv:
    print(argi)
</code></pre>
<h5 id="getopt-1"><a class="header" href="#getopt-1">getopt</a></h5>
<p><code>getopt</code>采用Linux Shell的参数声明规则设置参数。读取参数的方法：</p>
<blockquote>
<p>与UNIX类系统不同，非选项参数后的所有参数都不会被视为选项解析。</p>
</blockquote>
<pre><code class="language-python">from getopt import getopt, GetoptError
options, args = getopt(cmd_args, short_opts, long_opts=[])
</code></pre>
<p><code>short_opts</code>：代表短选项（命令行以<code>-</code>开头）的字母列表，如果一个选项还对应一个值，那么字母后添加<code>:</code>；</p>
<p><code>long_opts</code>：代表长选项（命令行以<code>--</code>开头）的字符串列表，长选项如果需要一个值，则参数需要附加<code>=</code>。</p>
<blockquote>
<p>命令行中，长选项的值可作为一个当都参数，或使用<code>=</code>附加在选项名后。</p>
</blockquote>
<p>返回值：<code>options</code>为选项列表，包括选项名（包括前缀）和对应的值（没有值则为空字符串）；<code>args</code>为非选项参数。</p>
<p>典型用法：</p>
<pre><code class="language-python">def usage():
    # print usage of the program, including options.

def main(sys_args):
    try: 
        optlist, args = getopt(sys_args, short_opts, long_opts=[])
    except GetoptError as err:
        print(err) # will print something like &quot;option -a not recognized&quot;
        usage()
        return(2)
    for option, value in optlist:
        if option == '--test' or option == '-t':
	        # do something
    	...        
</code></pre>
<h5 id="argumentparser-1"><a class="header" href="#argumentparser-1"><a href="https://docs.python.org/3.7/library/argparse.html#module-argparse">ArgumentParser</a></a></h5>
<blockquote>
<p><code>ArgumentParser</code>替代了<code>OptionParser</code>（从Python 3.2）。</p>
</blockquote>
<p>创建参数转换实例：</p>
<pre><code class="language-python">from argparse import ArgumentParser
parser = ArgumentParser(
  prog=None,        # program name (default: sys.argv[0])
  description=None, # information before argument help
  usage=None,       # usage syntax (default: auto generate)
  epilog=None,      # information after argument help
  parent=[parent_parsers]  # 继承父解析器实例的解析方法
)
</code></pre>
<blockquote>
<p><code>parent</code>：指定继承的参数解析实例。</p>
</blockquote>
<p>添加参数规则：</p>
<pre><code class="language-python">parser.add_argument(
   names_or_flags,    # 可变参数列表：'--test', '-t', 'argname'
   required=False,
   dest='optname',    # attribute name in return options
   action='store',  
   nargs=1,       # number of option arguments
   const=0,       # 
   default=None,  # default value if not specified from command line
   type=str,      # type of option arguments
   help=None,     # option's usage information
   metavar='NAME' # 帮助信息中作为选项值的标识（默认为长选项名大写）
)
</code></pre>
<p><code>ArgumentParser</code>对参数控制更加严格，如果出现未配置的参数将产生异常。==参数名如果没有前缀，则代表位置参数==；而<code>OptionParser</code>将位置参数存储到一个单独的返回参数中。</p>
<blockquote>
<p>参数解析规则说明：</p>
<ul>
<li>
<p><code>dest</code>：解析参数列表后存储参数值的变量名（参看<code>parse_args()</code>方法）；如果没有指定字段，则会根据选项名生成合法的字段名；</p>
</li>
<li>
<p><code>nargs=N</code>：选项所需要的参数个数，消耗<em>N</em>个参数构成列表。当需要获取位置参数而非选项时，<code>nargs='?'</code>消耗一个位置参数，<code>nargs='*'</code>消耗所有位置参数构成列表，此时<code>names_or_flags</code>作为存储位置参数的变量名。</p>
</li>
<li>
<p><code>type</code>：值的类型，包括：<code>string</code>（默认）、<code>int</code>、<code>float</code>；整数值可以和短选项名组成一个参数，例如<code>-n42</code>等价于<code>-n 42</code>；<code>bool</code>类型参数使用<code>store_true, store_false</code>；</p>
</li>
<li>
<p><code>action</code>：检测到选项后的处理方式</p>
<ul>
<li><code>store</code>：（默认处理方式）储存值，值的类型通过<code>type</code>指定；</li>
<li><code>store_true|store_false</code>：储存<code>bool</code>值<code>True</code>/<code>False</code>，对应的选项不需要另外参数设置值；</li>
<li><code>store_const</code>：<code>'store_const'</code>和<code>'append_const'</code>与<code>const</code>关键字结合使用，用于为选项保存一个常量。</li>
</ul>
</li>
<li>
<p><code>default</code>：选项的默认值（选项未出现在命令行的情况下设置默认值）。</p>
<blockquote>
<p>选项如果不是<code>bool</code>类型，在命令行使用选项时必须提供值；</p>
</blockquote>
</li>
<li>
<p><code>help</code>：选项的帮助信息。当解析参数时，遇到<code>-h</code>或<code>--help</code>（程序退出）或调用<code>parser.print_help()</code>时会自动输出所有帮助信息。</p>
<blockquote>
<p><code> %default</code>可用于在帮助信息中表示输出变量的默认值。<code>ArgumentParser</code>自带<code>-h,--help</code>选项，命令行提供该选项时将输出帮助信息。</p>
</blockquote>
</li>
</ul>
<p>参数解析器默认会添加帮助选项（<code>-h,--help</code>），如果要禁用，设置<code>parser.add_help=False</code>。</p>
</blockquote>
<p>转换命令行参数（默认为<code>sys.argv[1:]</code>，==注意传入给<code>args</code>不要展开==）：</p>
<pre><code class="language-python">options = parser.parse_args(args=None, namespace=None)
</code></pre>
<p>未在命令行提供的选项也会出现在<code>options</code>中，其值为默认值。返回值为<a href="Python/Python%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.html#NameSpace"><code>NameSpace</code>类型</a>。</p>
<h5 id="click-1"><a class="header" href="#click-1">click</a></h5>
<p>如果命令行嵌套子命令，可使用<a href="Python/Python%E7%BC%96%E7%A8%8B%E5%BA%94%E7%94%A8.html#click">click</a>进行命令转发。</p>
<h4 id="程序运行信息-1"><a class="header" href="#程序运行信息-1">程序运行信息</a></h4>
<pre><code class="language-python">from inspect import currentframe, getframeinfo
frameinfo = getframeinfo(currentframe())
frameinfo.filename  # 当前运行代码所在文件
frameinfo.lineno    # 当前运行代码所在行号
frameinfo.function  # 当前运行代码所在函数
</code></pre>
<h3 id="模块module-1"><a class="header" href="#模块module-1">模块(Module)</a></h3>
<p>模块是一个文件，其中包含类，函数等的定义。==模块相当于一个命名空间，其中的定义与其他模块隔离==。</p>
<h5 id="导入模块-1"><a class="header" href="#导入模块-1">导入模块</a></h5>
<pre><code class="language-python">import mod                    # modulename &lt;- sys.modules['mod']   
import mod as alias           # aliasname &lt;- sys.modules['mod']   
from mod import name          # objname &lt;- sys.modules['mod'].name 
from module import (name1,name2,...,namen,)
from module import *          # 导入所有内容
from mod import name as alias # aliasname &lt;- sys.modules['mod'].name
import importlib
path = importlib.import_module(&quot;os.path&quot;)  # =&gt; import os.path as path
file, pathname, desc = importlib.find_module('os')  # 查找模块
</code></pre>
<blockquote>
<p><em>不能直接导入模块中的内容并设置别名</em>。</p>
</blockquote>
<p>从模块所在目录导入其他模块：</p>
<pre><code class="language-python">from . import module_name
</code></pre>
<blockquote>
<p>相对路径是<a href="https://stackoverflow.com/a/14132912/6571140">根据导入声明的包名</a><code>package.subpackage.module</code>确定的，因此不可使用相对导入声明路径范围外的模块。由于<code>__main__</code>模块不包含任何路径信息，因此无法使用相对导入。</p>
</blockquote>
<p><a href="https://docs.python.org/3/reference/import.html">5. The import system — Python 3.9.5 documentation</a></p>
<h5 id="引用模块-1"><a class="header" href="#引用模块-1">引用模块</a></h5>
<p>当导入整个模块时，使用模块名称访问其中的内容（类、函数等）；也可以直接导入模块中的特定内容。</p>
<pre><code class="language-python">{module|alias}.name     # use module contents via module name/alias
name       # use name/alias to refer an imported class,funcion,...
alias
</code></pre>
<h5 id="重载模块-1"><a class="header" href="#重载模块-1">重载模块</a></h5>
<p>检查模块是否导入：<code>sys.modules</code>记录了运行环境已<a href="https://stackoverflow.com/questions/30483246/how-to-check-if-a-python-module-has-been-imported">导入的模块</a>，从而防止模块被重复导入。</p>
<pre><code class="language-python">tf = 'modulename' in sys.modules  # dict
tf = 'importedname' in dir()      # 当前可见名称 
tf = 'importedname' in globals()  # 全局变量
</code></pre>
<p>重新加载修改过的包到当前正在运行的程序：</p>
<pre><code class="language-shell">import importlib
importlib.reload(module)  # &lt;class module&gt; not str
</code></pre>
<h5 id="查看模块的文档-1"><a class="header" href="#查看模块的文档-1">查看模块的文档</a></h5>
<pre><code class="language-python">help(len)  # doc for built-in functions
import pandas as pd
help(pd)	# module doc
help(pd.DataFrame) # class doc
help(pd.DataFrame.to_csv)# function doc
</code></pre>
<h5 id="相互引用-1"><a class="header" href="#相互引用-1">相互引用</a></h5>
<p><em>注意引用对象顺序，避免先引用未初始化的对象。</em></p>
<pre><code class="language-python"># in module A
from module B import b
def a()
# in module B
from module A import a  
</code></pre>
<h4 id="包package-1"><a class="header" href="#包package-1">包(Package)</a></h4>
<p>Package是特殊的模块（包含<code>__path__</code>属性的模块），包含<code>subpackage</code>和<code>module</code>。</p>
<p>常规<code>package</code>通常是一个文件夹中的所有模块以及子文件夹（<code>sub-package</code>）组成。<code>__init__.py</code>文件用于<strong>标识目录是一个package</strong>。当包被导入时，会自动执行<code>__init__.py</code>文件</p>
<pre><code class="language-shell">my_package/
├── __init__.py
├── subpackage1/
│   ├── __init__.py
│   ├── module_x.py
│   └── module_y.py
├── subpackage2/
│   ├── __init__.py
│   └── module_z.py
└── module_a.py
</code></pre>
<h5 id="namespace-packages-1"><a class="header" href="#namespace-packages-1">Namespace packages</a></h5>
<blockquote>
<p><em>A <a href="https://docs.python.org/3/reference/import.html#namespace-packages">namespace package</a> is a composite of various portions, where each portion contributes a subpackage to the parent package. Portions may reside in different locations on the file system.</em></p>
</blockquote>
<h5 id="导入包中的模块-1"><a class="header" href="#导入包中的模块-1">导入包中的模块</a></h5>
<p>导入包名（相对搜索路径的目录路径）后，通过包名访问其中的内容；或将包名作为前缀导入其中的模块。</p>
<pre><code class="language-python">import pkg
import pkg.mod                # packagename &lt;- sys.modules['pkg']
import pkg.mod as alias       # aliasname &lt;- sys.modules['pkg.mod']  
from pkg import mod           # modulename &lt;- sys.modules['pkg.mod']  
from pkg import mod as alias  # aliasname &lt;- sys.modules['pkg.mod'] 
</code></pre>
<p>导入包名的时候会执行包目录下的<code>__init__.py</code>加载包中的模块。没有在<code>__init__.py</code>中指定加载的模块需要手动加载（<code>import pkg.mod</code>）。</p>
<h5 id="查找路径-1"><a class="header" href="#查找路径-1">查找路径</a></h5>
<p><code>sys.path</code> 是一个保存了查找包的路径的列表。Python解释器会自动将==Python程序所在目录==加入路径，从而方便导入同一目录下的其他文件。</p>
<blockquote>
<p><em>==不要在包内部编写测试脚本==，运行该测试脚本时会将该脚本所在路径加入查找路径，从而破坏其所在包的结构</em>。</p>
<p>程序的工作目录（<code>path.abspath(os.curdir)</code>）与程序所在目录可能不同，且不会加入搜索路径。</p>
<p><strong>语法检查的查找路径</strong>：在进行语法检查时（例如在VS Code中使用<code>pylint</code>检查器），检查器的会将当前工作目录加入搜索路径，因此跟程序运行时的情形不同。为了保证程序运行时的路径也在检查器中，可在项目配置文件（<code>settings.json</code>）中配置</p>
<pre><code class="language-json">&quot;python.analysis.extraPaths&quot;: [&quot;E:/Workspace/python&quot;]
</code></pre>
</blockquote>
<p>可以添加自定义搜索路径以导入第三方包：</p>
<pre><code class="language-python">sys.path.insert(0, '/lib/path')  # 添加至头部
sys.path.append('/lib/path')  # 添加至尾部
</code></pre>
<p>查询包是否在本地可加载：</p>
<pre><code class="language-python">import importlib
spec = importlib.util.find_spec(&quot;dask.dataframe&quot;)  # None if not find
</code></pre>
<h5 id="相对导入-1"><a class="header" href="#相对导入-1">相对导入</a></h5>
<pre><code class="language-python">from . import module   # 导入同一包内同一层级的子包（或模块）
from .. import module  # 导入同一包内上一层级的子包（或模块）
from .package import module
from ..package import module
</code></pre>
<blockquote>
<p>不要将子包所在路径加入搜索路径，否则不能识别完整包结构，导致相对导入失败。</p>
</blockquote>
<p><a href="https://realpython.com/python-modules-packages/">Python Modules and Packages – An Introduction</a>。</p>
<h2 id="标准库和应用-1"><a class="header" href="#标准库和应用-1">标准库和应用</a></h2>
<h3 id="日期和时间-1"><a class="header" href="#日期和时间-1">日期和时间</a></h3>
<p><a href="http://www.twinsun.com/tz/tz-link.htm">pytz模块</a></p>
<p><a href="http://labix.org/python-dateutil">dateutil模块</a></p>
<h3 id="cgi-1"><a class="header" href="#cgi-1">CGI</a></h3>
<h3 id="密码学-1"><a class="header" href="#密码学-1">密码学</a></h3>
<h5 id="消息摘要-1"><a class="header" href="#消息摘要-1">消息摘要</a></h5>
<p>Python内置<code>hashlib</code>（消息摘要算法），包括 FIPS 的 SHA1, SHA224, SHA256, SHA384, and SHA512 (定义于 FIPS 180-2) 算法，以及 RSA 的 MD5 算法( 定义于 Internet <a href="https://tools.ietf.org/html/rfc1321.html"><strong>RFC 1321</strong></a>)。消息摘要算法的输入为字节序列</p>
<blockquote>
<p>在 <a href="https://docs.python.org/zh-cn/3/library/zlib.html#module-zlib"><code>zlib</code></a> 模块中包括adler32 或 crc32 哈希函数。</p>
</blockquote>
<pre><code class="language-python">import hashlib
m = hashlib.sha256(b'init_data')
# m.update(a); m.update(b) =&gt; m.update(a+b)
m.update(b&quot;Nobody inspects&quot;)          # 向该对象追加消息(字节序列)
m.update(b&quot; the spammish repetition&quot;)
m.digest()   # 或hexdigest()
</code></pre>
<blockquote>
<p>为了防止黑客通过彩虹表根据哈希值反推原始口令，在计算哈希的时候，不能仅针对原始输入计算，需要增加一个salt来使得相同的输入也能得到不同的哈希，这样，大大增加了黑客破解的难度。</p>
</blockquote>
<h5 id="加密算法-1"><a class="header" href="#加密算法-1">加密算法</a></h5>
<p><code>cryptography</code>包含加密、消息摘要以及密钥生成等方法。</p>
<blockquote>
<p><em>The low-level cryptographic primitives are often dangerous and can be used incorrectly. They require making decisions and having an in-depth knowledge of the cryptographic concepts at work.</em></p>
</blockquote>
<p><code>PyCryptodome </code>（代替<a href="https://www.pycrypto.org/"><code>pycrypto</code></a>）：Python Cryptography Toolkit提供加密算法（AES, DES, RSA, ElGamal, ...），同时也提供安全哈希函数（SHA256，MD5等）。</p>
<pre><code class="language-python">from Crypto.Hash import SHA256
hash = SHA256.new()    # update, digest, hexdigest
from Crypto.Cipher import AES
obj = AES.new('This is a key123', AES.MODE_CBC, 'This is an IV456')
message = &quot;The answer is no&quot;
ciphertext = obj.encrypt(message)
obj2 = AES.new('This is a key123', AES.MODE_CBC, 'This is an IV456')
obj2.decrypt(ciphertext)
from Crypto.PublicKey import RSA
from Crypto import Random
random_generator = Random.new().read
key = RSA.generate(1024, random_generator)
signature = key.sign(hash, '')
public_key=key.publickey()
public_key.verify(hash_ver,signature)
</code></pre>
<p><a href="https://python.libhunt.com/compare-cryptography-vs-pycrypto">cryptography vs PyCrypto | LibHunt</a></p>
<h5 id="hmac-1"><a class="header" href="#hmac-1">HMAC</a></h5>
<p><a href="https://docs.python.org/3/library/hmac.html#module-hmac">hmac — Keyed-Hashing for Message Authentication — Python 3.10.7 documentation</a></p>
<p><a href="https://datatracker.ietf.org/doc/html/rfc2104.html">RFC 2104 - HMAC: Keyed-Hashing for Message Authentication (ietf.org)</a>：通信双方使用共享密钥对消息的摘要（如MD5、SHA-1等）进行完整性进行校验。</p>
<pre><code class="language-python">import hmac
h = hmac.new(key, message, digestmod='MD5')
</code></pre>
<h2 id="常见问题-1"><a class="header" href="#常见问题-1">常见问题</a></h2>
<ol>
<li>
<p>ModuleNotFoundError: No module named 'win32api'</p>
<p>安装<code>pypiwin32</code>包。</p>
</li>
</ol>
<h2 id="参考文献-1"><a class="header" href="#参考文献-1">参考文献</a></h2>
<ol>
<li><a href="https://nbviewer.org/github/Nyandwi/machine_learning_complete/blob/main/0_python_for_ml/intro_to_python.ipynb">Basic of Python Programming</a></li>
<li><a href="https://python.libhunt.com/">Awesome Python | LibHunt</a></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="python开发环境配置"><a class="header" href="#python开发环境配置">Python开发环境配置</a></h1>
<h2 id="python环境"><a class="header" href="#python环境">Python环境</a></h2>
<h3 id="系统集成python环境"><a class="header" href="#系统集成python环境">系统集成Python环境</a></h3>
<p>以Ubuntu为例，系统自带Python 3，用于支持相关系统组件工作。如果某些软件的运行需要依赖Python软件包而系统并未预装，则可以使用软件源管理工具（<code>apt</code>）安装。</p>
<blockquote>
<p>使用相关python命令时需要注意：系统自带的<code>python3/pip3</code>并没有创建符号链接<code>python/pip</code>，以便可以同时安装Python 2。</p>
</blockquote>
<pre><code class="language-shell">sudo apt install {python-package_name|python3-package_name}
sudo apt install python-is-python3  # 设置默认版本为Python3
</code></pre>
<p>如果软件源中找不到所需软件包，则可以通过<code>pip</code>工具从Python的软件仓库中下载软件包。系统的Python发行版默认未安装安装<code>pip</code>，需手动安装：</p>
<pre><code class="language-shell">sudo apt install {python-pip|python3-pip} # Python package installer
</code></pre>
<p><code>python3-dev</code>：Python软件开发依赖环境（<em>header files and a static library for Python (default).</em>），在Fedora/CentOS中命名为<code>python3-devel</code>。</p>
<h5 id="查找软件包"><a class="header" href="#查找软件包">查找软件包</a></h5>
<pre><code class="language-shell">pip list	          # list installed packages
pip show &lt;package&gt;  # show information about installed packages
</code></pre>
<p>使用<code>pip</code>(<code>pip3</code>)安装和移除软件包：</p>
<pre><code class="language-shell">pip install &lt;pkgs&gt; \
    --user                                 # 仅为当前用户安装，默认为系统范围安装
    -r requirements.txt \                  # 指定安装包声明文件
    -i https://pypi.doubanio.com/simple/ \ # 强制使用镜像站点
    --trusted-host 172.28.76.237           # 如果使用自建的代理站点，添加此选项
pip uninstall -r &lt;requirements_file&gt;
pip cache remove &lt;pattern&gt;|purge
</code></pre>
<blockquote>
<p>使用<code>sudo</code>在系统范围安装。</p>
<p>Ubuntu等Linux发行版已经内置许多python模块，应该优先使用软件源管理工具而非<code>pip</code>进行系统范围的Python软件包更新，否则可能导致系统功能出错。仅使用<code>pip</code>更新手动安装的软件包。如果不小心使用<code>pip</code>更新了<code>pip</code>，可以卸载更新后的版本并使用软件源管理工具重装。</p>
<pre><code class="language-shell">sudo python3 -m pip uninstall pip
sudo apt install python3-pip --reinstall
</code></pre>
<p>如果需要创建开发环境，使用虚拟Python环境（<a href="Python/Python%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83.html#Virtualenv">Virtualenv</a>）</p>
</blockquote>
<h5 id="软件更新"><a class="header" href="#软件更新">软件更新</a></h5>
<pre><code class="language-shell">pip list --outdated
pip install --upgrade package_name # 安装并更新依赖包（默认不更新）
pip-review  # pip install pip-review
# pip install pipupgrade
</code></pre>
<blockquote>
<ol>
<li>
<p><a href="https://github.com/achillesrasquinha/pipupgrade">achillesrasquinha/pipupgrade: 🗽 Like yarn outdated/upgrade, but for pip. Upgrade all your pip packages and automate your Python Dependency Management. (github.com)</a></p>
</li>
<li>
<p><a href="https://github.com/jgonggrijp/pip-review">jgonggrijp/pip-review: A tool to keep track of your Python package updates. (github.com)</a></p>
</li>
</ol>
</blockquote>
<p>使用较近的PyPi镜像站点可以加速软件包下载。</p>
<h5 id="离线安装"><a class="header" href="#离线安装">离线安装</a></h5>
<p>下载（不安装）安装包，默认同时下载依赖包。</p>
<pre><code class="language-shell">pip download [--python-version 3.7.4] package_name[==version]
</code></pre>
<blockquote>
<p><code>-d,--dest &lt;dir&gt;</code>: 下载目标文件夹（默认为当前工作目录）。</p>
<p>指定<code>--python-version</code>时，必须同时指定<code>--no-deps</code>或<code>--only-binary=:all:</code>。</p>
</blockquote>
<p>安装离线包</p>
<pre><code class="language-shell">pip install --no-index --find-links=/local_path package_name
</code></pre>
<blockquote>
<p><code>--find-links</code>：如果指定本地路径或<code>file://url</code>，则优先在本地目录中寻找安装文件。</p>
<p><code>--no-index</code>：不使用在线仓库搜索依赖包；</p>
</blockquote>
<h3 id="anacondaminiconda"><a class="header" href="#anacondaminiconda">Anaconda/Miniconda</a></h3>
<p>Anaconda发行版打包了Python常用的软件包，可以从<a href="https://repo.anaconda.com/archive/Anaconda3-2019.07-Linux-x86_64.sh">官网</a>或<a href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/Anaconda3-5.3.1-Linux-x86_64.sh">镜像</a>站点下载安装包。<a href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/miniconda/Miniconda3-latest-Linux-x86_64.sh">Miniconda</a>是精简发行版，仅包含python语言环境和conda工具，其他软件包均需要在线下载。</p>
<blockquote>
<p>Anaconda/Miniconda可以配置自定义的python环境屏蔽系统的Python，可以任意修改该环境而不会对系统产生影响。</p>
<p>在<code>Linux aarch64</code>平台上，<a href="https://docs.conda.io/en/master/miniconda.html">官方提供的安装包</a>可能安装失败，可尝试使用<a href="https://github.com/conda-forge/miniforge">conda-forge/miniforge: A conda-forge distribution. (github.com)</a>。</p>
<ul>
<li><em><code>version 'GLIBC_2.25' not found</code></em></li>
</ul>
</blockquote>
<blockquote>
<p>Anaconda基础环境的Python版本参考发行注记：https://docs.anaconda.com/anaconda/reference/release-notes/。</p>
</blockquote>
<h4 id="安装conda运行环境"><a class="header" href="#安装conda运行环境">安装conda运行环境</a></h4>
<pre><code class="language-shell">bash conda_installer.sh -b -f -p $INSTALL_PATH  # 静默安装并指定安装路径
# -u更新已有安装；
</code></pre>
<p>静默安装模式不会执行初始化修改路径配置。如果安装期间未执行初始化，则Shell无法直接运行<code>conda</code>（不在路径中）。</p>
<pre><code class="language-python">eval &quot;$($CONDAROOT/bin/conda shell.bash hook)&quot;   # 激活默认环境
conda init   # [yes]
</code></pre>
<p>也可以<a href="https://docs.conda.io/projects/conda/en/latest/user-guide/install/rpm-debian.html">使用包管理器安装</a>，方便<a href="Python/Python%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83.html#%E5%8D%B8%E8%BD%BDAnaconda/Miniconda">卸载</a>。</p>
<h5 id="重新安装anacondaminiconda"><a class="header" href="#重新安装anacondaminiconda">重新安装Anaconda/Miniconda</a></h5>
<p>如果基础环境因为更新问题损坏（网络、杀毒软件拦截）需要重装，而不希望重装已配置的<a href="Python/Python%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83.html#Conda%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83">虚拟环境</a>，可以将虚拟环境目录<code>envs</code>备份，在重装基础环境后还原。</p>
<h5 id="卸载anacondaminiconda"><a class="header" href="#卸载anacondaminiconda">卸载Anaconda/Miniconda</a></h5>
<pre><code class="language-shell">conda install anaconda-clean
anaconda-clean --yes  # backup all files/directories in ~/.anaconda_backup 
rm -rf $CONDA_HOME
</code></pre>
<p>最后清理<code>~/.bashrc</code>中的<code>conda</code>初始化代码。</p>
<h4 id="conda配置"><a class="header" href="#conda配置">conda配置</a></h4>
<p>使用命令行修改配置项，</p>
<pre><code class="language-shell">conda config --{system|env} SUB_COMMAND
</code></pre>
<p><code>conda</code>配置文件包括三类：</p>
<ul>
<li><code>--system</code>：修改系统配置位于<code>$CONDA_HOME/.condarc</code>；</li>
<li><code>--env</code>：修改当前激活环境的配置，位于<code>$CONDA_HOME/envs/$ENV/.condarc</code>；</li>
<li>如果未指定上述选项，则修改当前用户的配置，位于<code>$HOME/.condarc</code>。</li>
</ul>
<p>修改配置：</p>
<pre><code class="language-shell">conda config --append KEY VALUE      # 为配置项KEY追加一个值
             --prepend/add KEY VALUE # 为配置项KEY前端插入一个值
             --remove KEY VALUE      # 从配置项KEY的值列表中删除匹配的VALUE
             --set KEY VALUE         # 更新配置项的值
             --remove-key KEY        # 移除配置项
</code></pre>
<h5 id="列出当前的conda配置"><a class="header" href="#列出当前的conda配置">列出当前的conda配置</a></h5>
<pre><code class="language-shell">conda config --show [CONFIG]
conda config --describe [CONFIG]  # 显示配置项的说明
</code></pre>
<h5 id="自动激活基础conda环境"><a class="header" href="#自动激活基础conda环境">自动激活基础conda环境</a></h5>
<p>是否在shell启动时启动Conda环境：</p>
<pre><code class="language-shell">conda config --set auto_activate_base false  # =&gt; auto_activate_base: false
</code></pre>
<h4 id="使用conda进行包管理"><a class="header" href="#使用conda进行包管理">使用<code>conda</code>进行包管理</a></h4>
<pre><code class="language-shell">conda info	# infomation of conda installation (.condarc)
conda list [package_name] [-n envname]
conda search name --info
conda {update|upgrade} {--all | package_names}
conda [&lt;cmd&gt;] --help
</code></pre>
<p>Anaconda/Miniconda使用<code>conda</code>作为软件包管理工具。更新<code>conda</code>工具：</p>
<pre><code class="language-shell">conda update -n base -c defaults conda
</code></pre>
<blockquote>
<p>Anaconda发布的Python版本中，机器学习库<code>sklearn</code>打包在<code>scikit-learn</code>中。</p>
</blockquote>
<p>固定包的版本：在<code>conda-meta</code>目录中创建一个名为<code>pinned</code>的文件并加入不希望更新的包名以及版本信息（可以使用<code>#</code>注释行）。</p>
<pre><code class="language-shell">numpy 1.7.*     # stay on the 1.7 series
scipy==0.14.2  # fix to 0.14.2
</code></pre>
<pre><code class="language-shell">conda update numpy --no-pin   # 忽略pinned文件中的声明
</code></pre>
<blockquote>
<p>每次执行更新时，conda会检查<code>pinned</code>文件，因此使用<code>--no-pin</code>升级的包会恢复到<code>pinned</code>文件中声明的版本。</p>
</blockquote>
<h5 id="清理缓存"><a class="header" href="#清理缓存">清理缓存</a></h5>
<p>当软件包升级后，旧版本的软件包可能不再有用，因此可以从本地缓存删除。</p>
<pre><code class="language-shell">conda clean \ # Remove unused packages and caches.
      --all \ # index cache, lock files, unused packages and tarballs
      -i,--index-cache  \ # 清除索引缓存，保证用的是镜像站提供的索引。
      -p,--packages     \ # Remove unused packages
      -t,--tarballs     \ # remove cached package tarballs
      -l,--logfiles
      -d,--dry-run
</code></pre>
<h5 id="安装软件包"><a class="header" href="#安装软件包">安装软件包</a></h5>
<pre><code class="language-shell">conda {remove|uninstall} package_names
conda install -c conda-forge vaex=4.0.0 # --dry-run
conda install package_names \
	--file requirements.txt \ # 安装文件给定的包
	--freeze-installed \      # 避免已安装包升级
	-n| --name ENVNAME \      # 目标环境名（未指定则为当前环境，默认为base）
	-p,--prefix ENVPATH \     # 目标环境的目录
</code></pre>
<blockquote>
<p><code>conda</code>尝试安装最新的包，为此将升级其依赖的安装包。使用<code>--freeze-installed</code>避免已安装包自动升级。</p>
</blockquote>
<p><strong>指定仓库名</strong>：<code>-c,--channel</code>指定安装软件包优先使用的仓库；如果未指定该参数或指定仓库不包含相应的软件包，<code>conda</code>会检查<code>.condarc</code>中设定的<a href="Python/Python%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83.html#conda%E8%BD%AF%E4%BB%B6%E6%BA%90"><code>channels</code>中包含的其他仓库</a>。</p>
<p>软件包声明文件格式：</p>
<pre><code class="language-shell">channel::package_name=version=build_string # 使用指定使用*进行模糊匹配
</code></pre>
<blockquote>
<p>声明<code>channel</code>代替当前的默认通道；</p>
</blockquote>
<p>常用声明格式：</p>
<pre><code class="language-shell">pytorch             # 安装最新的兼容版本
cudatoolkit&gt;=11.3   # 限制最低版本 （命令行使用时需要使用&quot;&quot;对&gt;&lt;转义，避免解释为重定向）
cudatoolkit=11.3.*  # 仅接受小版本更新（如果后续无build声明可省略.*）
cudatoolkit=11.3.1  # 安装固定版本
</code></pre>
<h6 id="安装离线包"><a class="header" href="#安装离线包">安装离线包</a></h6>
<pre><code class="language-shell">conda install --use-local   /path/XXX.tar.bz
</code></pre>
<p>在Anaconda/Miniconda的Python环境中也可以使用<code>pip</code>进行软件包管理。</p>
<p><em>使用conda下载离线包</em>：<code>conda</code>只能将软件包加载到本地仓库（缓存）中，而无法下载到指定文件夹。</p>
<blockquote>
<p><code>conda</code>本地仓库中的包无法用于<code>pip</code>安装。</p>
</blockquote>
<h6 id="安装conda软件源中没有的包"><a class="header" href="#安装conda软件源中没有的包">安装Conda软件源中没有的包</a></h6>
<pre><code class="language-shell">pip install --upgrade-strategy &quot;only-if-needed&quot; packname
</code></pre>
<blockquote>
<ul>
<li>在使用conda安装尽可能多的包后，再使用<code>pip</code>安装额外包；</li>
<li>在单独虚拟环境中使用<code>pip</code>(避免使用root环境)；使用<code>pip</code>后，Conda无法识别相应的更改；</li>
<li>如果后续还需要使用Conda进行更新或安装而外包，则使用基本环境再重新创建一个环境后再使用<code>pip</code>；</li>
<li>使用<code>-r, --requirements</code>指定需要使用<code>pip</code>安装的包。</li>
</ul>
</blockquote>
<p>https://www.anaconda.com/using-pip-in-a-conda-environment/</p>
<h3 id="虚拟python环境"><a class="header" href="#虚拟python环境">虚拟Python环境</a></h3>
<h4 id="virtualenv"><a class="header" href="#virtualenv">virtualenv</a></h4>
<p>在指定目录<code>ENV_DIR</code>创建一个虚拟Python环境。</p>
<pre><code class="language-shell">python3 -m venv ENV_DIR
</code></pre>
<blockquote>
<p>创建虚拟环境，默认包含Python解释器（与系统中Python解释版本相同）、标准库等。可以使用<code>pip</code>为虚拟环境安装额外的内容。</p>
<p>在Debian/Ubuntu系统中需要首先安装</p>
<pre><code class="language-shell">apt-get install python3-venv
</code></pre>
</blockquote>
<p>Windows激活虚拟环境：</p>
<pre><code class="language-shell">.\myenv\Scripts\activate.bat  # windows cmd
.\myenv\Scripts\Activate.ps1  # windows powershell
</code></pre>
<p>Linux激活虚拟环境：</p>
<pre><code class="language-shell">source myenv/bin/activate   # on linux
which python  # 查看python路径
</code></pre>
<h5 id="pipenv"><a class="header" href="#pipenv">pipenv</a></h5>
<p><a href="https://realpython.com/pipenv-guide/">Pipenv: A Guide to the New Python Packaging Tool – Real Python</a></p>
<p>consolidate the <code>pip</code> &amp; <code>virtualenv</code> into a single interface. </p>
<h4 id="conda虚拟环境"><a class="header" href="#conda虚拟环境">Conda虚拟环境</a></h4>
<blockquote>
<p><em>It makes your project more self-contained as everything, including the required software, is contained in a single project directory.</em></p>
</blockquote>
<p>基于<code>conda</code>创建的虚拟环境并安装指定的软件包（和安装一样使用<code>--file requirements.txt</code>指定安装包）。Conda默认将虚拟环境置于<code>envs</code>目录下，并通过<code>--names/-n</code>选项指定要使用的环境名。使用<code>--prefix</code>可将虚拟环境置于任何路径下，但访问时也需要通过<code>--prefix</code>选项指定目录。</p>
<pre><code class="language-shell">conda create -n pydev37 python=3.7 &lt;pkgname=ver,...&gt; \ # python=3*
             --prefix ./envs ...          # 指定虚拟环境的安装目录
conda create --name myclone --clone myenv # 复制已有环境
conda env remove --name myenv             # &lt;=&gt; conda remove -n env_name --all 
conda env list                            # &lt;=&gt; conda info --envs
</code></pre>
<blockquote>
<p><code>*</code>：如果创建环境时未指定Python版本，可能导致依赖解析很慢。</p>
<p>支持创建Python 2.x环境。</p>
<p>虚拟环境中不会维护独立的软件包，而是由Conda维护一个统一的包目录（<code>pkgs</code>）。通过<code>conda-meta</code>目录中的信息，可以定位到其引用的包路径，包的档案文件路径以及软件源路径。</p>
<p>复制环境可直接将虚拟环境目录复制到<code>envs</code>目录下（如果虚拟环境路径发生变化，需要使用<code>conda-pack</code>进行<a href="Python/Python%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83.html#%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83%E6%89%93%E5%8C%85%E9%83%A8%E7%BD%B2">打包并在目标系统中解压并修复路径</a>）</p>
</blockquote>
<p>虚拟环境配置默认继承系统和用户配置，可以<a href="Python/Python%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83.html#conda%E9%85%8D%E7%BD%AE">为虚拟环境添加设置覆盖默认配置</a>。</p>
<p>查看conda环境更改历史：</p>
<pre><code class="language-shell">conda list --revision[s]
conda install --revision=REVNUM   # 恢复历史版本
</code></pre>
<p>虚拟环境信息文件：</p>
<pre><code class="language-shell">conda env export [--from-history] &gt; environment.yml
</code></pre>
<p>更新环境</p>
<pre><code class="language-shell">conda env update --prefix | --name --file environment.yml --prune
</code></pre>
<p>复制环境</p>
<pre><code class="language-shell">conda env create -f environment.yml   #从配置文件创建虚拟环境
#=========================================
conda list --explicit &gt; spec-file.txt
conda create --name myenv --file spec-file.txt
conda install --name myenv --file spec-file.txt
</code></pre>
<h5 id="使用conda虚拟环境"><a class="header" href="#使用conda虚拟环境">使用conda虚拟环境</a></h5>
<pre><code class="language-shell">conda activate env_name
conda deactivate
conda config --set env_prompt '({name})'
</code></pre>
<blockquote>
<p>在脚本中尝试激活命令时会出现conda环境未初始化的错误，可在脚本中执行<code>source ~/.bashrc</code>或将<code>~/.bashrc</code>中的conda初始化代码复制到用户脚本中。</p>
</blockquote>
<p><a href="https://stackoverflow.com/questions/55507519/python-activate-conda-env-through-shell-script">Python - Activate conda env through shell script - Stack Overflow</a></p>
<p><a href="https://github.com/conda/conda/issues/7980">Can't execute <code>conda activate</code> from bash script · Issue #7980 · conda/conda (github.com)</a></p>
<h4 id="虚拟python环境损坏"><a class="header" href="#虚拟python环境损坏">虚拟Python环境损坏</a></h4>
<p><code>AttributeError: module 'brotli' has no attribute 'error'</code></p>
<p>解决方法：使用<code>conda remove</code>删除损坏的环境，并删除本地目录；</p>
<h5 id="pipeenv"><a class="header" href="#pipeenv">Pipeenv</a></h5>
<h4 id="虚拟环境打包部署"><a class="header" href="#虚拟环境打包部署">虚拟环境打包部署</a></h4>
<p><code>conda-pack</code>可以将虚拟Python环境打包并部署到其他位置（操作系统相同）。可创建一个包含<code>conda-pack</code>的虚拟环境专门用于打包。</p>
<pre><code class="language-shell">conda create -n pack -c conda-forge &quot;conda-pack&gt;=0.7&quot;  # pip install conda-pack=0.7
</code></pre>
<blockquote>
<p><em><code>CondaPackError: Files managed by conda were found to have been deleted/overwritten...</code></em>：</p>
<ol>
<li>Python升级到3.10后，其模块库目录下会创建一个<code>python3.1-&gt;python3.10</code>的符号链接；这会<a href="https://stackoverflow.com/questions/69992742/conda-pack-condapackerror-files-managed-by-conda-were">导致旧版本的<code>conda-pack</code>无法正常工作</a>，需要使用<code>conda-pack&gt;=0.7</code>。</li>
<li>如果虚拟环境中使用<code>pip</code>安装了额外包，也可能导致上述错误。因此可将pip的安装包单独下载，再在目标环境中执行离线安装。</li>
</ol>
</blockquote>
<p>然后将目标环境打包环境为一个压缩档案文件（<code>tar.gz</code>）：</p>
<pre><code class="language-shell">conda-pack --name my_env \
           --output out_name.tar.gz \ # 指定环境名
           -d target_env_path \   #目标主机上虚拟环境的路径
           --force
conda-pack -p /explicit/path/to/my_env  # 指定环境路径
</code></pre>
<p>在目标位置解压文件，并激活虚拟环境（要求目标环境安装<code>conda</code>）：</p>
<pre><code class="language-shell">tar -xzf my_env.tar.gz -C conda_path/envs/my_env
source my_env/bin/activate # 激活环境 add `my_env/bin` to your path
conda-unpack               # 修复库的路径（可在未激活环境情况下运行，指定路径） 
</code></pre>
<p><code>conda-unpack</code>是<code>conda-pack</code>打包到虚拟环境中的程序（<code>envname/bin</code>目录下），在解压后修复某些库的路径。==如果打包时指定<code>-d</code>选项，则不再打包<code>unpack</code>程序==。</p>
<p><a href="https://conda.github.io/conda-pack/">Conda-Pack — conda-pack 0.6.0 documentation</a>.</p>
<h3 id="arm64版本python"><a class="header" href="#arm64版本python">Arm64版本Python</a></h3>
<p>支持aarch64 (arm64)的Conda环境：</p>
<ul>
<li><a href="https://github.com/conda-forge/miniforge">conda-forge/miniforge: A conda-forge distribution. (github.com)</a></li>
<li>https://repo.anaconda.com/archive/Anaconda3-2021.04-Linux-aarch64.shell</li>
</ul>
<blockquote>
<p>需要使用conda-forge作为默认源（miniforge的默认设置），且不能使用国内镜像源（同步不完整）。</p>
</blockquote>
<h2 id="软件源配置"><a class="header" href="#软件源配置">软件源配置</a></h2>
<h3 id="pip软件源"><a class="header" href="#pip软件源">pip软件源</a></h3>
<p>配置软件源和下载设置：</p>
<pre><code class="language-shell">pip config set global.timeout 6000
pip config set global.index-url https://pypi.doubanio.com/simple/
pip config set install.use-mirrors true
pip config set install.mirrors https://pypi.doubanio.com/simple/
</code></pre>
<p>该配置文件位于<code>$HOME/.pip/pip.conf</code>（系统自带Python的配置文件位于<code>$HOME/.config/pip/pip.conf</code>）。也可以手动创建并编辑该文件（Windows下的配置文件位于<code>%HOMEPATH%\AppData\Roming\pip\pip.ini</code>），在文件中添加以下内容：</p>
<pre><code class="language-shell">[global]
timeout = 6000
index-url = https://pypi.doubanio.com/simple
[install]
use-mirrors = true
mirrors = https://pypi.doubanio.com/simple
</code></pre>
<p>常用软件源包括：</p>
<ul>
<li><code>https://pypi.doubanio.com</code>：豆瓣；</li>
<li><code>http://mirrors.aliyun.com/pypi</code>：阿里；</li>
<li><code>http://pypi.mirrors.ustc.edu.cn</code>：中国科学技术大学；</li>
<li><code>https://pypi.tuna.tsinghua.edu.cn</code>：<a href="https://mirrors.tuna.tsinghua.edu.cn/help/pypi/">清华大学</a>；</li>
</ul>
<p>本地镜像可用<a href="Python/../%E5%BA%94%E7%94%A8%E8%BD%AF%E4%BB%B6/%E7%BD%91%E7%BB%9C%E6%9C%8D%E5%8A%A1%E8%BD%AF%E4%BB%B6.html#pypi%E4%BB%A3%E7%90%86">Nexus配置</a>。</p>
<h3 id="conda软件源"><a class="header" href="#conda软件源">conda软件源</a></h3>
<p>添加默认仓库<code>defaults</code>的地址：</p>
<pre><code class="language-shell">conda config --add default_channels \
    https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/  # add default channel URL
conda config --set show_channel_urls yes  # 显示下载内容的URL
</code></pre>
<p>添加自定义仓库名称和地址：</p>
<pre><code class="language-shell">conda config --{prepend|append} channels &lt;new_channel&gt;
conda config --set custom_channels.conda-forge \
    https://mirror.sjtu.edu.cn/anaconda/cloud/
</code></pre>
<p>直接编辑该文件：</p>
<pre><code class="language-yaml">channels:
  - conda-forge
  - defaults
default_channels:
  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main
  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/r
  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/msys2
custom_channels:
  conda-forge: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud
  pytorch:     https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud
</code></pre>
<p>配置文件中<code>channels</code>可包含多个源，优先级从上到下递减。默认从高优先级的源选择同名软件包（<code>channel_priority=strict</code>）；反之优先选择高版本号的同名软件包。</p>
<pre><code class="language-shell">conda config --set channel_priority strict
</code></pre>
<p>通过<code>default_channels</code>配置<code>defaults</code>仓库的实际地址；通过<code>custom_channels</code>配置其他仓库对应的地址；如果未设定相应的地址信息，则默认连接到<a href="https://conda.anaconda.org/">Anaconda官方仓库</a>。</p>
<p>列出当前的仓库配置</p>
<pre><code class="language-shell">conda config --show channels
conda config --show-sources   # show all sources
conda config --validate       # 验证仓库源
</code></pre>
<h5 id="仓库镜像"><a class="header" href="#仓库镜像">仓库镜像</a></h5>
<ul>
<li><code>https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/</code>：<a href="https://mirrors.tuna.tsinghua.edu.cn/help/anaconda/">清华大学</a>，包含<code>pytorch</code>、<code>conda-forge</code>等多个仓库，其中<code>conda-forge</code>包含<code>linux-aarch64</code>架构的仓库，可用于ARM平台；</li>
<li><code>https://mirrors.bfsu.edu.cn/anaconda/cloud/</code>：<a href="https://mirrors.bfsu.edu.cn/help/anaconda/">北京外国语大学</a>（与清华大学镜像源一致）；</li>
<li><code>https://mirror.sjtu.edu.cn/anaconda/cloud/</code>：<a href="https://mirrors.sjtug.sjtu.edu.cn/docs/anaconda">上海交通大学</a>（不包含<code>conda-forge/linux-aarch64</code>）；</li>
<li><code>https://mirrors.aliyun.com/anaconda/cloud/</code>：<a href="https://developer.aliyun.com/mirror/anaconda">阿里云</a>（不包含<code>conda-forge/linux-aarch64</code>）。</li>
</ul>
<h5 id="使用nexus可创建镜像代理"><a class="header" href="#使用nexus可创建镜像代理">使用<a href="Python/../%E5%BA%94%E7%94%A8%E8%BD%AF%E4%BB%B6/%E7%BD%91%E7%BB%9C%E6%9C%8D%E5%8A%A1%E8%BD%AF%E4%BB%B6.html#conda%E4%BB%A3%E7%90%86">Nexus</a>可创建镜像代理</a></h5>
<blockquote>
<p>Nexus Conda代理不会获取<code>current_repodata.json</code>，因此使用<code>conda</code>时总是会回退使用<code>repodata.json</code>，导致解析速度变慢（直接使用镜像源则不会有此问题）。<code>mamba</code>总是使用<code>repodata.json</code>不会受此影响。</p>
</blockquote>
<p>多数镜像源仅包含最常用的仓库，如<code>conda-forge</code>、<code>pytorch</code>，而一些开源库在Anaconda官方仓库维护了独立的仓库（仅包含开源库相关包），因此要使用这些仓库需要使用Anaconda官方仓库作为代理源。</p>
<pre><code class="language-ini">Name=anaconda-cloud
Remote=https://conda.anaconda.org/
URL=http://192.168.178.52:8081/repository/anaconda-cloud
</code></pre>
<h4 id="软件包下载优化"><a class="header" href="#软件包下载优化">软件包下载优化</a></h4>
<h5 id="安装mambalibmamba加速依赖解析和下载"><a class="header" href="#安装mambalibmamba加速依赖解析和下载">安装mamba/libmamba加速依赖解析和下载</a></h5>
<blockquote>
<p><em><code>mamba</code> is a reimplementation of the conda package manager in C++.</em></p>
</blockquote>
<p><code>mamba</code>支持多线程并行下载仓库数据和包文件，使用<code>libsolv</code>以加速依赖解析（用于RPM包管理器）。</p>
<pre><code class="language-shell">conda install -n base -c conda-forge mamba
</code></pre>
<p>安装完成后，使用<code>mamba</code>代替<code>conda</code>进行包管理，其语法与<code>conda</code>一致。</p>
<blockquote>
<p>最新的<code>conda</code>版本（<code>22.9+</code>）提供<code>--experimental-solver libmamba</code>选项（需要安装<code>conda-libmamba-solver</code>包），使用<code>mamba</code>进行依赖解析，但仍采用<code>conda</code>下载包。</p>
</blockquote>
<p><code>mamba/libmamba</code>虽然加速解析和下载，但不使用本地缓存导致重复下载（<em>虽然检测到本地缓存包但似乎URL不匹配</em>）。如果是通过本地镜像仓库下载，则重复下载没有多大影响；防止，如果通过远程仓库下载，这重复下载比较浪费时间。</p>
<h5 id="配置http代理"><a class="header" href="#配置http代理">配置HTTP代理</a></h5>
<p><code>conda</code>会自动检测系统代理配置，但不支持<code>$no_proxy</code>例外项。如果<code>conda</code>使用的代理配置与系统配置不同，可在<code>.condarc</code>中指定（同样不支持例外项）。</p>
<pre><code class="language-yaml">proxy_servers:
  http: http://172.28.76.4:3128
  https: http://172.28.76.4:3128
</code></pre>
<blockquote>
<p><code>conda</code>/<code>mamba</code>使用<code>urllib3</code>，会读取环境变量<code>$http[s]_proxy</code>；Windows中优先检测环境变量<code>$env:HTTP[s]_PROXY</code>，其次检测<strong>网络设置</strong>中的<strong>代理设置</strong>，可通过代理设置的例外项排除不需要通过代理访问的镜像源地址，例如本地仓库代理。）</p>
</blockquote>
<h5 id="网络超时设置"><a class="header" href="#网络超时设置">网络超时设置</a></h5>
<p>当使用<code>nexus</code>镜像代理时，新内容会首先下载到代理服务器，然后再下载到本地。因此，代理服务器如果下载速度较慢会导致本地<code>conda</code>下载超时。这种情况，可将网络读取的超时限制调大。</p>
<pre><code class="language-yaml">remote_read_timeout_secs: 180.0  # 60.0 by default
</code></pre>
<blockquote>
<p><code>mamba</code>忽略该选项，<em>尝试设置<code>export MAMBA_NO_LOW_SPEED_LIMIT=1</code></em>。</p>
</blockquote>
<h2 id="开发环境"><a class="header" href="#开发环境">开发环境</a></h2>
<h3 id="标准库"><a class="header" href="#标准库">标准库</a></h3>
<ul>
<li>
<p>系统管理：<code>os, sys, shutil</code></p>
</li>
<li>
<p>日期时间：<code>datetime, time, calendar</code></p>
</li>
<li>
<p>高级数据结构：<code>collections, array, enum </code></p>
</li>
<li>
<p>输入输出控制：<code>io, fcntl, logging, getpass, warnings</code></p>
</li>
<li>
<p>数据处理：<code>re</code>, <code>struct</code></p>
</li>
<li>
<p>文件解析：<code>csv, configparser, json, xml, html</code></p>
<p>Python有三种方法解析XML，SAX，DOM，以及ElementTree。ElementTree就像一个轻量级的DOM，具有方便友好的API。代码可用性好，速度快，消耗内存少。</p>
<blockquote>
<p>**注：**因DOM需要将XML数据映射到内存中的树，一是比较慢，二是比较耗内存，而SAX流式读取XML文件，比较快，占用内存少，但需要用户实现回调函数（handler）。</p>
</blockquote>
</li>
<li>
<p>数据持久化：<code>pickle, marshal, sqlite3</code></p>
<p><code>sqlite</code>使用文件保存数据，因此无需运行任何服务。Python内置<code>sqlite3</code>提供sqlite数据库的操作。</p>
</li>
<li>
<p>数据库：<code>mysql-connector-python</code>, <code>psycopg2</code>（PostgreSQL）</p>
<p>DB-API 是一个规范. 它定义了一系列必须的对象和数据库存取方式, 以便为各种各样的底层数据库系统和多种多样的数据库接口程序提供一致的访问接口 。</p>
<p><a href="https://realpython.com/python-sql-libraries/">Introduction to Python SQL Libraries</a>.</p>
</li>
<li>
<p>网络通信：<code>socket,ipaddress</code>,  <code>xmlrpc</code>, <code>email,smtpd,smtplib,imaplib,poplib</code>,  <code>cgi</code>, <code>ftplib</code>, <code>uuid,base64,urllib.parse</code></p>
</li>
<li>
<p>HTTP：<code>http</code>, <code>urllib.request</code></p>
<blockquote>
<p><a href="https://docs.python.org/3.1/library/urllib.request.html#module-urllib.request">urllib</a>是一个内置在Python标准库中的模块，并使用<code>http.client</code>来实现HTTP和HTTPS协议的客户端。</p>
</blockquote>
</li>
<li>
<p>密码学：<code>hashlib, hmac</code></p>
</li>
<li>
<p>数据压缩归档：<code>zlib,gzip,bz2,lzma,zipfile,tarfile</code>；</p>
</li>
<li>
<p>任务调度：<code>asyncio, multiprocessing, threading, concurrent, signal, subprocess, queue, select, atexit</code>：</p>
<blockquote>
<p><code>concurrent.futures</code></p>
</blockquote>
</li>
<li>
<p>程序管理：<code>importlib, inspect, typing, argparse, getopt, traceback</code>；</p>
</li>
<li>
<p>调试：<code>timeit, trace</code>；</p>
<p><a href="https://pypistats.org/top">PyPI Download Stats (pypistats.org)</a></p>
</li>
</ul>
<h3 id="第三方库"><a class="header" href="#第三方库">第三方库</a></h3>
<ul>
<li>
<p>语法格式：<code>autopep8</code>, <code>pylint</code>；</p>
</li>
<li>
<p>系统管理：<code>filelock, psutil</code></p>
</li>
<li>
<p>数值计算：<code>numpy</code>、<code>scipy</code>；</p>
</li>
<li>
<p>数据可视化：<code>matplotlib, seaborn, bokeh, plotly, pyecharts</code>；</p>
<blockquote>
<p><a href="https://blog.csdn.net/weixin_39777626/article/details/78598346">Python可视化库_As的博客-CSDN博客_python可视化</a>。</p>
</blockquote>
</li>
<li>
<p>文档生成：<a href="https://jeltef.github.io/PyLaTeX/current/index.html"><code>pylatex</code></a>, <a href="https://pypi.org/project/pdfkit/"><code>pdfkit</code></a>；</p>
</li>
<li>
<p>Web开发：<code>django, flask, tornado, requests, beatifulsoup, scrapy</code>；<code>urllib3</code>, <code>requests</code></p>
<blockquote>
<p><a href="https://docs.python-requests.org/en/master/">Requests</a>由<a href="https://urllib3.readthedocs.io/en/latest/">urllib3</a>提供支持。</p>
</blockquote>
</li>
<li>
<p>图形界面开发：<code>wxPython, PyQT, TKinter</code>；</p>
</li>
<li>
<p>命令行工具：<code>click</code>、<a href="https://github.com/Textualize/rich"><code>rich</code></a>`。</p>
</li>
<li>
<p><a href="Python/../%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5.html#%E6%90%AD%E5%BB%BA%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83">机器学习</a>。</p>
</li>
</ul>
<h5 id="数据处理"><a class="header" href="#数据处理">数据处理</a></h5>
<p><code>pandas</code>、<code>pandasql</code>、<code>pyarrow</code>、<code>dask</code>；</p>
<p>使用<code>conda</code>安装时<code>pyarrow</code>，默认的仓库安装版本较旧（<code>0.15</code>），导致兼容问题，因此使用<code>conda-forge</code>通道。</p>
<pre><code class="language-python">conda install -c conda-forge pyarrow
</code></pre>
<pre><code class="language-python">conda install dask
pip install &quot;dask[complete]&quot;    # Install everything
</code></pre>
<p>Pandas：</p>
<pre><code class="language-python">pd.show_versions()   # 查看系统环境、pandas版本及其依赖包的版本
</code></pre>
<pre><code class="language-python">pd.io.parquet.get_engine('auto')   # 获取parquet读写引擎
</code></pre>
<blockquote>
<p>引入<code>pandas</code>包后立即调用该方法，解决与<code>matlab.engine</code>的环境冲突。</p>
</blockquote>
<h3 id="visual-studio"><a class="header" href="#visual-studio">Visual Studio</a></h3>
<p>安装Python工作负载；</p>
<p>安装Python/Conda虚拟环境；</p>
<p>通过Python环境窗口，安装或卸载包或启动交互式Python命令环境；</p>
<img src="Python/Python开发环境.assets/image-20210522085526208.png" alt="image-20210522085526208" style="zoom:50%;" />
<h3 id="visual-studio-codepython-extension-pack"><a class="header" href="#visual-studio-codepython-extension-pack">Visual Studio Code（Python Extension Pack）</a></h3>
<p>Conda环境未正确加载会导致某些包（例如<code>numpy</code>）无法被导入。解决方案：</p>
<ol>
<li>
<p><em>为保证终端中Conda环境自动加载（终端启动时加载），执行</em></p>
<pre><code class="language-powershell">conda init cmd.exe|powershell   # conda config --set auto_activate_base false
</code></pre>
<p>初始化文件在<code>%USER%/Documents/WindowsPowerShell/profile.ps1</code>。</p>
</li>
<li>
<p><em>在VS Code中配置Conda路径，从而使终端启动时自动激活Conda虚拟环境（<code>cmd</code>）</em>。</p>
<pre><code class="language-json">&quot;python.condaPath&quot;: &quot;C:\\tools\\miniconda3\\Scripts\\conda.exe&quot;
</code></pre>
</li>
</ol>
<blockquote>
<p>To ensure the environment is set up well from a shell perspective, one option is to use an Anaconda prompt with the activated environment to launch VS Code ==using the <code>code .</code> command==. At that point you just need to select the interpreter using the Command Palette or by clicking on the status bar.</p>
<p>Conda environments can't be automatically activated in the VS Code Integrated Terminal if the default shell is <em>set to PowerShell</em>. </p>
<p><a href="https://github.com/microsoft/vscode-python/issues/11638">PowerShell does not support automatic activation of conda virtual environment · Issue #11638 · microsoft/vscode-python (github.com)</a></p>
</blockquote>
<p>忽略单行警告，在行末添加声明。如果要忽略同一文件，则将声明置于单独行。</p>
<pre><code class="language-python">import config.logging_settings  # type: ignore   =&gt; pylance
import config.logging_settings  # pylint: disable=unused-import
</code></pre>
<blockquote>
<p><code>pylint</code>可以放在<code>type</code>标记后。</p>
</blockquote>
<p>全局忽略警告：</p>
<pre><code class="language-json">&quot;python.linting.pylintArgs&quot;: [
    &quot;--disable=unused-import&quot;,
    &quot;--disable=too-few-public-methods&quot;
]  // =&gt; pylint
&quot;python.analysis.diagnosticSeverityOverrides&quot;: {
    &quot;reportUnusedImport&quot;: &quot;information&quot;,
    &quot;reportMissingImports&quot;: &quot;none&quot;
}  // ==&gt; pylance
</code></pre>
<blockquote>
<p>Pylance和pylint可同时启用，因此需要设置两项配置。</p>
</blockquote>
<p>Better Comments插件：有5中类型的注释高亮，分别用符号<code>* ? ! //todo</code>来区分。</p>
<h5 id="自动补全和语法分析配置"><a class="header" href="#自动补全和语法分析配置">自动补全和语法分析配置</a></h5>
<pre><code class="language-json">{
   &quot;python.autoComplete.extraPaths&quot;: [
      &quot;/home/gary/dataproc/dataproc/lib&quot;
   ],
   &quot;python.analysis.extraPaths&quot;: [
      &quot;/home/gary/dataproc/dataproc/lib&quot;
   ]
}
</code></pre>
<h4 id="单元测试"><a class="header" href="#单元测试">单元测试</a></h4>
<p>可将项目目录下的一个文件夹设置为单元测试目录（如<code>test</code>）；单元测试脚本需要位于该目录下，以<code>test_*.py</code>模式保存的文件将被自动发现为测试脚本<sup class="footnote-reference"><a href="#vsctest">1</a></sup>。单元测试环境会自动将测试目录和当前项目目录加入<code>PYTHONPATH</code>。</p>
<blockquote>
<p><strong>Tip</strong>: Sometimes tests placed in subfolders aren't discovered because such test files cannot be imported. To make them importable, create an empty file named <code>__init__.py</code> in that folder. （为每一级测试目录创建<code>__init__.py</code>测试路径可被识别为包）</p>
<p>由于测试目录位于搜索路径的最前，因此应该避免测试目录中包含与系统模块或用户模块同名的文件或文件夹（导致其屏蔽系统/用户模块的导入）。</p>
</blockquote>
<h5 id="单元测试项自动发现"><a class="header" href="#单元测试项自动发现">单元测试项自动发现</a></h5>
<p>如果单元测试脚本中包含错误（无法捕获异常），则在发现阶段会将其分类的错误测试项一栏（完整错误日志可在Python输出窗口中查看）；解决错误后会自动更新到对应的测试目录树下。</p>
<h4 id="在vs-code中使用jupyter-notebook"><a class="header" href="#在vs-code中使用jupyter-notebook">在VS Code中使用Jupyter Notebook</a></h4>
<p>需要安装<code>ipykernel</code>以启动内核。</p>
<h3 id="jupyter"><a class="header" href="#jupyter">Jupyter</a></h3>
<h5 id="安装"><a class="header" href="#安装">安装</a></h5>
<pre><code class="language-shell">conda create -n jupyterlab -c conda-forge {jupyterlab|jupyterhub}
conda install -c conda-forge ipywidgets jupyterhub-idle-culler
</code></pre>
<h4 id="jupyterlab"><a class="header" href="#jupyterlab">JupyterLab</a></h4>
<h5 id="路径信息"><a class="header" href="#路径信息">路径信息</a></h5>
<p><code>jupyter --path</code>配置文件、数据等的默认路径（以下给出首选路径）。</p>
<pre><code class="language-shell">config:
    $HOME/.jupyter 
data:
    $HOME/.local/share/jupyter
runtime:
    $HOME/.local/share/jupyter/runtime
</code></pre>
<p>生成配置文件：配置文件中包含默认值（可进行修改）</p>
<pre><code class="language-shell">jupyter lab --generate-config  # -&gt; $HOME/.jupyter/jupyter_lab_config.py
</code></pre>
<p>网络配置</p>
<pre><code class="language-python">c.ServerApp.base_url='/analyze/jupyter'
c.ServerApp.ip = 'localhost' # --ip=0.0.0.0
c.ServerApp.port = 0         # --port=8888
</code></pre>
<blockquote>
<p>如果使用代理出现403错误，尝试设置<code>c.ServerApp.disable_check_xsrf=True</code>禁用<em>cross-site-request-forgery</em>检查。</p>
</blockquote>
<p><a href="Python/../%E5%BA%94%E7%94%A8%E8%BD%AF%E4%BB%B6/%E7%BD%91%E7%BB%9C%E6%9C%8D%E5%8A%A1%E8%BD%AF%E4%BB%B6.html#Nginx">NGINX</a>反向代理JupyterLab服务，参考<a href="Python/Python%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83.html#JupyterHub%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE">JupyterHub反向代理配置</a>。</p>
<p>运行环境配置</p>
<pre><code class="language-python">c.ServerApp.root_dir='~/jupyter'
c.ServerApp.allow_root = False   # --allow-root: Allow the server to be run from root.
c.ServerApp.autoreload = True    # --autoreload
c.ServerApp.open_browser = False # --no-browser
</code></pre>
<p>安全配置</p>
<pre><code class="language-python">c.ServerApp.allow_origin = '*'
c.ServerApp.certfile = ''
c.ServerApp.keyfile = ''
c.ServerApp.cookie_secret = b''
c.ServerApp.cookie_secret_file = ''
c.ServerApp.password = ''   # from jupyter_server.auth import passwd; passwd()
</code></pre>
<h5 id="启动jupyterlab服务"><a class="header" href="#启动jupyterlab服务">启动JupyterLab服务</a></h5>
<p>以系统服务启动：</p>
<pre><code class="language-ini">[Service]
Type=simple
Environment=&quot;WORKDIR=/home/ml/jupyterlab&quot;
Environment=&quot;LOGDIR=/var/log/jupyterlab&quot;
ExecStartPre=/usr/bin/mkdir -p /tmp/jupyter $WORKDIR
ExecStart=/usr/local/miniconda3/envs/jupyter/bin/jupyter lab $OPTIONS \
          &gt; ${LOGIDR}/server.log 2&gt; ${LOGIDR}/server.error.log
TimeoutSec=10
ExecStop=/bin/kill -s TERM $MAINPID
User=ml
</code></pre>
<h4 id="jupyterhub"><a class="header" href="#jupyterhub">JupyterHub</a></h4>
<h5 id="系统架构"><a class="header" href="#系统架构">系统架构</a></h5>
<img src="Python/Python开发环境.assets/jhub-fluxogram.jpeg" alt="JupyterHub subsystems" style="zoom: 50%;" />
<p>Jupyter系统组件包括：</p>
<ul>
<li><strong>HTTP Proxy</strong>：代理用户请求，对外的唯一的Web接口；</li>
<li><strong>Hub</strong>：</li>
<li><strong>Spawners</strong>：管理用户服务；</li>
<li><strong>Authenticator</strong>：用户鉴权组件。</li>
</ul>
<p>各个服务通过HTTP进行通信，因此可以分离部署。</p>
<blockquote>
<p><em>Connections to user servers go through the proxy, and not the hub itself. If the proxy stays running when the hub restarts (for maintenance, re-configuration, etc.), then user connections are not interrupted. For simplicity, by default the hub starts the proxy automatically, so if the hub restarts, the proxy restarts, and user connections are interrupted. It is easy to run the proxy separately, for information see the separate proxy page.</em></p>
</blockquote>
<pre><code class="language-shell">jupyterhub token|upgrade-db -h
</code></pre>
<h5 id="配置jupyterhub"><a class="header" href="#配置jupyterhub">配置JupyterHub</a></h5>
<p>推荐以下安装配置：</p>
<ul>
<li><code>/srv/jupyterhub</code> for all security and runtime files</li>
<li><code>/etc/jupyterhub</code> for all configuration files</li>
<li><code>/var/log</code> for log files</li>
</ul>
<p>生成并修改配置文件（默认输出到当前目录，使用<code>-f</code>选项指定输出目录）。</p>
<pre><code class="language-shell">jupyterhub --generate-config -f /etc/jupyterhub/jupyterhub_config.py  
jupyterhub -h,--help-all   # 列出所有命令行配置项
configurable-http-proxy -h # 代理配置项
</code></pre>
<p>除了上述命令列出的配置项外，所有配置项均可通过命令行选项进行配置以覆盖配置文件中的对应配置项。</p>
<pre><code class="language-shell">--Class.trait='value'  # c.Class.trait in [jupyterhub_config.py]
</code></pre>
<p>验证配置：</p>
<pre><code class="language-shell">jupyterhub --show-config -f config_file  # 列出当前生效的配置(仅非默认值项)
</code></pre>
<h5 id="数据存储配置"><a class="header" href="#数据存储配置">数据存储配置</a></h5>
<pre><code class="language-python">c.JupyterHub.data_files_path = '/usr/local/share/jupyterhub'
c.JupyterHub.db_url = 'sqlite:////var/lib/jupyterhub/jupyterhub.sqlite'
</code></pre>
<blockquote>
<p>在读取配置文件时：<code>sqlite:///</code>视为相对路径，绝对路径需要使用<code>sqlite:////</code>。</p>
</blockquote>
<h5 id="jupyterhub网络配置"><a class="header" href="#jupyterhub网络配置">JupyterHub网络配置</a></h5>
<p><code>bind_url</code>配置JupyterHub代理服务（用户的Web访问地址，代替弃用的<code>ip</code>、<code>port</code>和<code>base_url</code>）。省略IP则监听所有地址接收的请求，默认URL根路径为<code>/</code>。</p>
<pre><code class="language-python">c.JupyterHub.bind_url='http://:8000/'  # --url
</code></pre>
<p><code>api_url</code>配置REST API接口的访问地址（Hub服务通过该接口与代理服务通信）。</p>
<pre><code class="language-python">c.ConfigurableHTTPProxy.api_url = 'http://localhost:8001' 
</code></pre>
<p><code>hub_bind_url</code>配置Hub服务的访问地址（代理与Spawners通过该地址与Hub通信，代替<code>hub_ip</code>和<code>hub_port</code>）。<code>hub_connect_url</code>用于分离部署时指定Hub服务的地址（代替<code>hub_connect_ip</code>/<code>hub_connect_port</code>）。</p>
<pre><code class="language-python">c.JupyterHub.hub_bind_url = 'http://localhost:8081'
c.JupyterHub.hub_connect_url = 'http://hub_ip:8081'
</code></pre>
<p><a href="https://jupyterhub.readthedocs.io/en/stable/reference/config-proxy.html#nginx">外部nginx反向代理</a>：</p>
<pre><code class="language-nginx">map $http_upgrade $connection_upgrade {
    default upgrade;
    ''      close;
}
server {
  location /jupyterhub {
    proxy_pass http://127.0.0.1:8000;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header Host $host;  #  $http_host for http connection
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    # websocket headers
    proxy_http_version 1.1;
    proxy_set_header Upgrade $http_upgrade;
    proxy_set_header Connection $connection_upgrade;
    proxy_set_header X-Scheme $scheme;

    proxy_buffering off;
  }
}
</code></pre>
<p>Spawner网络配置：</p>
<pre><code class="language-python">c.Spawner.ip = '127.0.0.1'
c.Spawner.port = 0
</code></pre>
<p>使用SSL：</p>
<pre><code class="language-shell">--ssl-key my_ssl.key   # c.JupyterHub.ssl_key = '/path/to/my.key'
--ssl-cert my_ssl.cert # c.JupyterHub.ssl_cert = '/path/to/my.cert'
</code></pre>
<blockquote>
<p>使用<code>jupyterhub --generate-certs</code>生成自签名证书和私钥。</p>
</blockquote>
<h5 id="用户访问控制"><a class="header" href="#用户访问控制">用户访问控制</a></h5>
<p>配置JupyterHub用户</p>
<pre><code class="language-python">c.Authenticator.allowed_users = {'mal', 'zoe', 'inara', 'kaylee'} # 初始化用户集合
c.Authenticator.admin_users = {'mal', 'zoe'}
</code></pre>
<blockquote>
<p><em>if <code>allowed_users</code> is not set, then all authenticated users will be allowed into your hub.</em></p>
</blockquote>
<p>可选：使用系统用户进行鉴权：<em>creating that user via the system <code>adduser</code> command line tool.</em></p>
<pre><code class="language-python">c.LocalAuthenticator.create_system_users = True
# PAMAuthenticator -&gt; LocalAuthenticator -&gt; Authenticator
</code></pre>
<blockquote>
<p><em>This approach is not recommended when running JupyterHub in situations where JupyterHub users map directly onto the system’s UNIX users.</em></p>
</blockquote>
<p>自动创建用户可能会失败（CentOS7），可提前创建系统用户并进行初始化。</p>
<pre><code class="language-shell">allowed_users=(mal zoe inara)
for u in &quot;${users[@]}&quot;; do
    useradd -m -g ml $u;     # 添加用户并添加到预定义的组
    if [ $? -eq 0 ]; then    # 为新用户设置默认密码（用于JupyterHub初始登录验证，登陆后修改密码）
        passwd $u --stdin &lt;&lt;&lt; '1234abcd'
    fi
    cat /etc/passwd | grep --color=always $u  # 显示用户基本信息
done
</code></pre>
<p>Hub和Proxy（<code>ConfigurableHTTPProxy </code>）之间通过一个<code>secret token</code>来验证请求。此令牌可通过<code>openssl</code>生成，保存在配置文件或环境变量中。如果未设置，则Hub会自动随机生成一个，那么重启Hub的同时需要重启Proxy。</p>
<pre><code class="language-shell">c.ConfigurableHTTPProxy.api_token = 'abc123...def' 
export CONFIGPROXY_AUTH_TOKEN=$(openssl rand -hex 32)
</code></pre>
<p><code>cookie secret</code>用于对浏览器中用于鉴权的Cookies信息进行加密，可通过<code>openssl</code>生成。</p>
<pre><code class="language-shell">openssl rand -hex 32 &gt; /srv/jupyterhub/jupyterhub_cookie_secret 
chmod 600 /srv/jupyterhub/jupyterhub_cookie_secret
export JPY_COOKIE_SECRET=$(openssl rand -hex 32)
</code></pre>
<p>有三种指定方式：配置为环境变量，在配置文件中指定该信息所在的文件或在配置文件中指定该信息。</p>
<pre><code class="language-python">c.JupyterHub.cookie_secret_file = '/srv/jupyterhub/jupyterhub_cookie_secret'
c.JupyterHub.cookie_secret = bytes.fromhex('64 CHAR HEX STRING')
</code></pre>
<blockquote>
<p>如果未配置上述任何方法，则<code>jupyterhub_cookie_secret</code>默认创建在运行JupyterHub的用户的主目录下。该文件应该仅有该用户的读写权限，否则服务不会启动。</p>
<p>使用环境变量配置的随机生成密码会在重启服务时重新生成，导致所有登录会话失效。</p>
</blockquote>
<p><strong>基于角色的访问控制</strong>：<a href="https://jupyterhub.readthedocs.io/en/stable/rbac/scopes.html"><strong>Scopes</strong></a> are specific permissions used to evaluate API requests. <a href="https://jupyterhub.readthedocs.io/en/stable/rbac/roles.html"><strong>Roles</strong></a> are collections of scopes that specify the level of what a client is allowed to do. </p>
<pre><code class="language-python">c.JupyterHub.load_roles = [
 {
   'name': 'server-rights',
   'description': 'Allows parties to start and stop user servers',
   'scopes': ['servers'],
   'users': ['alice', 'bob'],
   'services': ['idle-culler'],
   'groups': ['admin-group'],
 }
]
</code></pre>
<p><a href="https://jupyterhub.readthedocs.io/en/stable/rbac/use-cases.html">Use Cases — Scopes in JupyterHub</a></p>
<h5 id="配置用户后台服务"><a class="header" href="#配置用户后台服务">配置用户后台服务</a></h5>
<pre><code class="language-shell">c.Spawner.cmd = ['jupyterhub-singleuser']  # 后台启动命令
# c.Spawner.cmd=[&quot;jupyter-labhub&quot;]
c.Spawner.notebook_dir = '~/notebooks'     # 工作目录路径(默认为~)
</code></pre>
<blockquote>
<p><em>Since the single-user server extends the notebook server application, it still loads configuration from the jupyter_notebook_config.py config file. Each user may have one of these files in $HOME/.jupyter/. Jupyter also supports loading system-wide config files from /etc/jupyter/, which is the place to put configuration that you want to affect all of your users.</em></p>
</blockquote>
<p>修改用户的工作目录为Jupyter服务独占目录，防止与用户的其他服务的文件冲突。如果为用户配置了非默认工作目录，则需要在用户服务初始化前进行检查确认该目录存在。JupyterHub配置文件中提供了初始化过程的接口。</p>
<pre><code class="language-shell">def my_hook(spawner):
    import os,pwd,shutil
    username = spawner.user.name
    path = f'/home/{username}/notebooks'
    if not os.path.exists(path):
        os.makedirs(path, mode=0o755, exist_ok=True)
        passwd = pwd.getpwnam(username)
        os.chown(path, passwd.pw_uid, passwd.pw_gid)
        src = '/usr/local/share/jupyterhub/.bashrc'
        if os.path.exists(src):
            dest = f'/home/{username}/.bashrc'
            shutil.copy(src, dest)
            os.chown(dest, passwd.pw_uid, passwd.pw_gid)
c.Spawner.pre_spawn_hook = my_hook
</code></pre>
<blockquote>
<p>除了工作目录外，这里也附带配置了用户的Shell初始化文件（<code>.bashrc</code>中包含Python执行环境初始化，可将已有用户的Shell配置文件作为模板文件）。</p>
</blockquote>
<p>资源分配控制</p>
<pre><code class="language-python">c.JupyterHub.active_server_limit = 0
c.JupyterHub.active_user_window = 1800
c.JupyterHub.activity_resolution = 30
c.Spawner.cpu_guarantee = None
c.Spawner.cpu_limit = None
c.Spawner.mem_guarantee = None
c.Spawner.mem_limit = None
</code></pre>
<h5 id="启动jupyterhub"><a class="header" href="#启动jupyterhub">启动JupyterHub</a></h5>
<p>以系统服务运行JupyterHub：</p>
<pre><code class="language-ini">[Service]
Type=simple
Environment=&quot;PATH=/usr/local/miniconda3/envs/jupyterhub/bin:...&quot;
ExecStart=/usr/local/miniconda3/envs/jupyterhub/bin/jupyterhub -f \
          /etc/jupyterhub/jupyterhub_config.py
TimeoutSec=10
ExecStop=/bin/kill -s TERM $MAINPID
StandardOutput=journal
StandardError=journal
SyslogIdentifier=JupyterHub
User=root
</code></pre>
<p>使用管理员权限运行JupyterHub可允许多用户登录。</p>
<blockquote>
<p><a href="https://github.com/jupyterhub/jupyterhub/wiki/Using-sudo-to-run-JupyterHub-without-root-privileges">Using sudo to run JupyterHub without root privileges · jupyterhub/jupyterhub Wiki (github.com)</a></p>
</blockquote>
<h4 id="jupyter-docker-stack"><a class="header" href="#jupyter-docker-stack">Jupyter Docker Stack</a></h4>
<p>https://jupyter-docker-stacks.readthedocs.io/en/latest/</p>
<p>Docker image for Core Stacks：https://jupyter-docker-stacks.readthedocs.io/en/latest/using/selecting.html#core-stacks</p>
<blockquote>
<p>https://hub.docker.com/u/jupyter</p>
</blockquote>
<p><a href="https://jupyterhub.readthedocs.io/en/stable/quickstart-docker.html">Using Docker — JupyterHub 2.2.2 documentation</a></p>
<p><a href="https://zero-to-jupyterhub.readthedocs.io/en/latest/">Zero to JupyterHub with Kubernetes — Zero to JupyterHub with Kubernetes documentation (zero-to-jupyterhub.readthedocs.io)</a></p>
<p>JupyterLab Documentation：https://jupyterlab.readthedocs.io/en/latest/</p>
<h4 id="问题"><a class="header" href="#问题">问题</a></h4>
<ol>
<li>
<p>终端启动配置问题，无法像登录终端一样初始化：<a href="https://stackoverflow.com/questions/60073276/how-to-login-to-bash-with-current-user-and-the-users-bashrc-file-in-jupyterl">jupyter - How to login to bash with current user, and the user's .bashrc file, in jupyterlab? - Stack Overflow</a></p>
<pre><code class="language-python">c.ServerApp.terminado_settings = {'shell_command': ['/bin/bash']}
</code></pre>
</li>
</ol>
<h3 id="pycharm"><a class="header" href="#pycharm"><a href="https://www.runoob.com/w3cnote/pycharm-windows-install.html">PyCharm</a></a></h3>
<p>支持Windows、Linux和mac。</p>
<h2 id="辅助工具"><a class="header" href="#辅助工具">辅助工具</a></h2>
<p><strong>pyreadline</strong>：命令行自动补全。在Windows平台中，如果命令记录中包含中文，那么<code>pyreadline</code>在读取历史记录时采用平台相关的编码（<code>gbk</code>）会出错。可以将其源码中默认的编码方式改为<code>utf-8</code>。</p>
<pre><code class="language-python"># xxx\envs\data\lib\site-packages\pyreadline\lineeditor\history.py
for line in open(filename, 'r', encoding='utf-8'):
</code></pre>
<h2 id="参考文献-2"><a class="header" href="#参考文献-2">参考文献</a></h2>
<div class="footnote-definition" id="jupyterhub"><sup class="footnote-definition-label">2</sup></div>
<div class="footnote-definition" id="vsctest"><sup class="footnote-definition-label">1</sup>
<p><a href="https://code.visualstudio.com/docs/python/testing">Testing Python in Visual Studio Code</a>.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="数据类型和数据结构"><a class="header" href="#数据类型和数据结构">数据类型和数据结构</a></h1>
<p><code>string</code>、<code>tuple</code>、<code>bytes</code>和 <code>number </code>是<strong>不可更改的对象</strong>（修改对象的方法返回新的对象），而 <code>list</code>、<code>dict</code>等则是<strong>可以修改的对象</strong>（可修改当前对象内容）。</p>
<p><strong>特殊类型</strong></p>
<pre><code class="language-python">None						# null
NotImplemented
</code></pre>
<h2 id="数值numbers"><a class="header" href="#数值numbers">数值（Numbers）</a></h2>
<h3 id="数值类型"><a class="header" href="#数值类型">数值类型</a></h3>
<h4 id="整数int"><a class="header" href="#整数int">整数（<code>int</code>）：</a></h4>
<p>Python3不区分32bit/64bit整数，可以表现任意位数的整数。</p>
<p>Python预定义了一个小整数池<code>[-5, 256]</code>，避免整数频繁申请和销毁内存空间。</p>
<pre><code class="language-python">x.bit_length()   # 整数的位宽
</code></pre>
<h5 id="字面值"><a class="header" href="#字面值">字面值</a></h5>
<ul>
<li>二进制前缀：<code>0b</code>；</li>
<li>八进制前缀：<code>0o</code>；</li>
<li>十六进制前缀：<code>0x</code>；</li>
</ul>
<pre><code class="language-python">x = int('0xA2', base=16)
x = 281_028_344  # 数字分隔符
</code></pre>
<p>整数的字符串表示：<code>hex(x)</code>，<code>oct(x)</code>。将字符转换为整数<code>ord(ch)</code></p>
<h4 id="浮点型float"><a class="header" href="#浮点型float">浮点型（<code>float</code>）：</a></h4>
<p>有小数点或科学记数法表示</p>
<pre><code class="language-python">y = int(x,[base])   # x 为数值或字符串
y = float(x)        # x 为数值或字符串
complex(real, imag)
</code></pre>
<p><code>nan</code>和<code>inf</code>是特殊的浮点数：</p>
<pre><code class="language-python">x = float('nan')
y = float('inf')   # -inf: -y 或 float('-inf')
</code></pre>
<blockquote>
<p><code>numpy</code>中对应的值为<code>np.nan</code>和<code>np.inf</code>。</p>
</blockquote>
<h4 id="逻辑bool"><a class="header" href="#逻辑bool">逻辑（<code>bool</code>）</a></h4>
<p>值为<code>True</code>或<code>False</code>。整数和浮点数可转换为<code>bool</code>类型（非零值为<code>True</code>）；</p>
<h4 id="复数complex"><a class="header" href="#复数complex">复数（<code>complex</code>）</a></h4>
<p>实部和虚部都是浮点型。</p>
<pre><code class="language-python">a + bj
complex(a,b)
</code></pre>
<h3 id="判断是否为数值类型"><a class="header" href="#判断是否为数值类型">判断是否为数值类型</a></h3>
<pre><code class="language-python">from numbers import Number
isinstance(n, Number)
</code></pre>
<h3 id="枚举类型"><a class="header" href="#枚举类型">枚举类型</a></h3>
<pre><code class="language-python">from enum import Enum, IntEnum, unqiue, auto
Month = Enum('Month', ('Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec')) # auto-value
</code></pre>
<p><code>Enum</code>类型成员不属于整数，<code>IntEnum</code>的成员可与整数进行比较（标准<code>Enum</code>枚举与整数比较返回<code>False</code>）。</p>
<blockquote>
<p>虽然<code>Enum</code>由 <code>class</code>语法创建，但<code>Enum</code>并不是常规的Python 类。</p>
</blockquote>
<p>如果需要更精确地控制枚举类型的值（可以是整数以外的值），可以使用<code>IntEnum</code>等派生类，或者从<code>Enum</code>派生出自定义类：</p>
<pre><code class="language-python">class Request(IntEnum):
   POST = 1
   GET = 2
   pass
class Perm(IntFlag):
   R = 4
   W = 2
   X = 1
@unique              # 保证枚举值唯一
class Color(Enum):
   RED = 1          # Color.RED.name = 'RED'
   GREEN = 2        # Color.GREEN.value = 2
   BLUE = 3
   YELLOW = auto()
isinstance(Color.GREEN, Color)    # True
</code></pre>
<blockquote>
<p>使用自定义类行可以获得类型提示，而使用<code>Enum</code>类则没有类型提示。</p>
</blockquote>
<p><code>IntFlag</code>类用于表示位类型的标识枚举，同时也继承整数类型。</p>
<h5 id="访问枚举成员"><a class="header" href="#访问枚举成员">访问枚举成员</a></h5>
<pre><code class="language-python">m = Month.Jan       # 显式成员引用
m = Month(1)        # 按枚举成员的值(not index)引用: Month.Jan.value
m = Month['Jan']    # 按枚举成员的名称引用: Month.Jan.name
</code></pre>
<p>通过枚举成员的名称，可以==将字符串表示转换为枚举类型==。</p>
<h5 id="获取枚举成员的属性"><a class="header" href="#获取枚举成员的属性">获取枚举成员的属性</a></h5>
<p>枚举类型的变量有一个字符串名称<code>name</code>以及值<code>value</code>（整数）。</p>
<pre><code class="language-python">for m in Month:     # 按定义顺序，而非数值大小
   print(m.name, m.value)
</code></pre>
<h2 id="时间"><a class="header" href="#时间">时间</a></h2>
<h3 id="时间类型"><a class="header" href="#时间类型">时间类型</a></h3>
<p>时间可以表示为字符串、时间戳、<code>datetime</code>（<code>date</code>，<code>time</code>）以及<code>time_tuple</code>（<code>time_struct</code>）。</p>
<h5 id="时间戳"><a class="header" href="#时间戳">时间戳</a></h5>
<p>Python使用浮点数表示时间戳，单位为秒，精度为微秒（$10^{-6}\mathrm{s}$）。</p>
<pre><code class="language-python">import time as tm
ts = tm.time()  # return timestamp (seconds)
ts_ms = np.int64(ts*1000) # 毫秒表示的时间戳
</code></pre>
<h5 id="时间元组结构"><a class="header" href="#时间元组结构">时间元组（结构）</a></h5>
<p><code>localtime()</code>将时间戳转换为本地时间并返回时间元组<code>struct_time</code>；<code>mktime()</code>做逆向变换，<code>tup_time</code>为表示时间的九元组或<code>time_struct</code>。</p>
<pre><code class="language-python">import time   
struct_time = time.localtime(ts)
ts = time.mktime(time_tuple|struct_time)
</code></pre>
<h5 id="时间类型对象"><a class="header" href="#时间类型对象">时间类型对象</a></h5>
<p>时间对象封装了时间戳/时间字段。<a href="https://docs.python.org/3/library/datetime.html">Python</a>在<code>datetime</code>模块中提供多个类构造和<a href="Python/Python%E6%95%B0%E5%80%BC%E8%AE%A1%E7%AE%97.html#%E6%97%B6%E9%97%B4%E6%97%A5%E6%9C%9F">修改</a>时间：</p>
<ul>
<li><code>datetime</code>：完整的日期时间信息，精度为微秒（<code>microseconds</code>）；</li>
<li><code>date</code>：仅包含日期部分；</li>
<li><code>time</code>：包含时间信息，精度为微秒；</li>
</ul>
<pre><code class="language-python">import datetime as dt
t = dt.datetime(year, month, day, hour, ..., tzinfo) # datetime object
t = dt.datetime.combine(date, time)  
d = dt.date(year, month, day)  # date object
t = dt.time(hour, minute, second, microsecond, tzinfo)# time object
t = {datetime|date|time}.replace(...) # repalce fields with new value
</code></pre>
<blockquote>
<p>构造函数的参数对应了对象中的成员变量。</p>
</blockquote>
<p>获取当前日期/时间：</p>
<pre><code class="language-python">day = dt.date.today()         # [date]
now = dt.datetime.today()     # [datetime]=&gt;dt.fromtimestamp(time.time())
now = dt.datetime.now(tz=None)# [datetime]
now.date()
now.time()
</code></pre>
<p>Pandas的<code>Timestamp</code>类的方法类似于标准库<code>datetime</code>类，其底层数据类型为<code>np.datetime64</code>。</p>
<pre><code class="language-python">import pandas as pd
pd_ts = pd.Timestamp(
   ts, unit,  # unit = 'h'|'m'|'s'|'ms'|... ==&gt; pd.to_datetime()
   year,month,day,hour,minute,second,microsecond,nanosecond, # =&gt;dt.datetime
   tz         # e.g. Asia/Shanghai
)
</code></pre>
<blockquote>
<p><code>nanosecond</code>：其他时间类型精度达不到；</p>
<p>获取<code>Timestamp</code>对象的时间单位<code>unit</code>：<code>np.datetime_data(t.to_datetime64())=&gt;(unit,step)</code>；</p>
<p><a href="https://numpy.org/doc/stable/reference/arrays.datetime.html">Datetimes and Timedeltas — NumPy v1.21 Manual</a></p>
</blockquote>
<h5 id="时间类型转换"><a class="header" href="#时间类型转换">时间类型转换</a></h5>
<p>将时间日期对象转换为时间戳。</p>
<pre><code class="language-python">secs = dt.timestamp()     # return timestamp as float
secs = pd_ts.timestamp()  # return seconds
</code></pre>
<p>没有时区信息的时间日期对象转换为时间戳时视为<code>UTC+00</code>时间。</p>
<blockquote>
<p>如果调用者将<code>UTC+NN:00</code>的时间构造为时间对象，但未设置相应<a href="Python/Python%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.html#%E6%97%B6%E5%8C%BA%E8%AE%BE%E7%BD%AE%E5%92%8C%E8%BD%AC%E6%8D%A2">时区信息</a>，则转换为时间戳会导致时间超前<code>NN</code>小时，即<code>00:00(UTC+NN:00) != 00:00 UTC+00:00 &lt;=&gt; NN:00 UTC+NN:00</code>。</p>
</blockquote>
<p>将时间戳转换为为时间/日期对象</p>
<pre><code class="language-python">dt = datetime.fromtimestamp()
day = date.fromtimestamp()
</code></pre>
<p>将日期转换为时间结构：</p>
<pre><code class="language-python">dt.datetime.timetuple()     # date.timetuple()
</code></pre>
<p>也可以从<a href="Python/Python%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.html#%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%97%B6%E9%97%B4">字符串表示构造</a>时间日期对象。</p>
<h4 id="时区设置和转换"><a class="header" href="#时区设置和转换">时区设置和转换</a></h4>
<p><code>datetime</code>类构造的时间对象默认不包含时区信息（<code>tzinfo=None</code>，默认时区为计算机本地时区）。要设置时区，首先构造时区信息：</p>
<pre><code class="language-python">from datetime import timezone,timedelta
tz_local = timezone(timedelta(hours=8), name='Asia/Shanghai')
</code></pre>
<blockquote>
<p><code>timezone.utc</code>是内置的时区（UTC+00:00）。</p>
</blockquote>
<p>切换时区信息：切换时区不影响时间对象底层的数据，只修改时区信息。</p>
<pre><code class="language-python">dt_local = t.replace(tzinfo=tz_local)  # &lt;== t.astimezone(tz_local)
</code></pre>
<p>获取时间对象中的时区信息：</p>
<pre><code class="language-python">delta = dt_local.utcoffset()   # return offset to utc time.
tz_name = dt_local.tzname()   # get timezone name
</code></pre>
<h5 id="pandastimestamp类的时区"><a class="header" href="#pandastimestamp类的时区"><code>pandas.Timestamp</code>类的时区</a></h5>
<p>应尽可能显式设置构造方法中的时区参数，防止数据互操作时解析错误。如果<code>ts</code>中也同时包含时区信息，会将其转换至<code>tz</code>指定的时区（内部时间戳不变）。</p>
<p>如果<code>Timestamp</code>对象初始化时不包含信息或未设置时区参数：</p>
<ul>
<li>从时间戳构造默认时区为<code>UTC+00:00</code>（与<code>datetime.fromtimestamp()</code>不同），应该将其转换至本地时区使用；</li>
<li>从(不包含时区信息的)时间对象或字符串构造默认时区为计算机本地时区，以==与字面值保持一致==（<code>UTC+08:00</code>）。</li>
</ul>
<pre><code class="language-python">pd_ts.tz_localize('UTC+08:00')    # 导致时间戳减小8小时
pd_ts.tz_localize('UTC')\         # 设置时区信息 UTC+00:00，时间戳不变
     .tz_convert('Asia/Shanghai') # 然后，转换为目标时区（时区名可使用UTC或区域名）
</code></pre>
<p><code>tz_localize()</code>在时间字面值基础上添加了时区偏移，因此会==修改底层的时间数据（时间戳）==。<code>tz_convert()</code>则同时修改时间字面值和时区字面值，因此底层时间数据不变。</p>
<blockquote>
<p>未设置时区信息的时间是不能转换时区的（<em>Cannot convert tz-naive Timestamp</em>），因此必须调用<code>tz_localize</code>（类似于<code>dt.replace(tzinfo=tz_local) </code>）；已有时区信息的对象则不能再调用<code>tz_localize</code>。</p>
</blockquote>
<h4 id="时间段"><a class="header" href="#时间段">时间段</a></h4>
<p>表示由开始和结束时间确定的时间区间。</p>
<h5 id="time-interval"><a class="header" href="#time-interval">Time Interval</a></h5>
<pre><code class="language-python">ti = pd.TimeInderval(pd.Timestamp('20210901'), pd.Timestamp('20210903'))
</code></pre>
<h5 id="time-period"><a class="header" href="#time-period">Time Period</a></h5>
<p><code>pandas.Period</code>表示给定周期的某个时间段，例如1月、1周、1天等；由于具有固定周期，因此可以<a href="Python/Python%E6%95%B0%E5%80%BC%E8%AE%A1%E7%AE%97.html#%E6%97%B6%E9%97%B4%E5%91%A8%E6%9C%9F">与整数进行数值运算</a>实现区间平移。</p>
<pre><code class="language-python">p = pd.Period(value, freq='M')
p = pd.Period(year=1971, month=1, day=1,..., freq='D')
p = p.asfreq(freq, how='end') # 改变周期，how决定原周期的起点或终点作为新周期的起点
</code></pre>
<blockquote>
<p>至少指定<code>year</code>（否则返回<code>NaT</code>）， 参数<code>day</code>对于频率<code>M</code>无效。</p>
</blockquote>
<p>传递给构造方法的参数可通过对象的属性访问，例如<code>p.day</code>。其他属性和方法包括：</p>
<pre><code class="language-python">p.start_time    # p.strftime(), p.to_timestamp()
p.end_time
</code></pre>
<h3 id="格式化时间"><a class="header" href="#格式化时间">格式化时间</a></h3>
<h5 id="时间对象格式化"><a class="header" href="#时间对象格式化">时间对象格式化</a></h5>
<p>上述类型的<a href="Python/Python%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.html#%E6%97%B6%E9%97%B4%E7%B1%BB%E5%9E%8B%E5%AF%B9%E8%B1%A1">时间对象</a>提供<code>strftime</code>， <code>strptime</code>用于转换自定义格式的时间字符串，格式声明参考<a href="Python/../Linux/Linux%E9%85%8D%E7%BD%AE%E5%92%8C%E7%AE%A1%E7%90%86.html#%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4">Linux规范</a>（不支持<code> %q, %N</code>）。<code>isoformat()</code>用于输出标准格式。</p>
<pre><code class="language-python">t = dt.datetime.strptime(time_str, '%Y%m%d')
t_str = t.strftime('%Y%m%d')
dt.isoformat(sep='T', timespec='milliseconds')
datetime.fromisoformat(fmt_str)
</code></pre>
<blockquote>
<p>ISO格式：包括时区信息。</p>
</blockquote>
<p><code>date</code>类型未提供转换为<code>datetime</code>类型的方法。通过字符串方法可以方便地实现<code>date</code>类型到<code>datetime</code>类型的变换，或是使用<code>datetime.combine()</code>方法将<code>date</code>和<code>time</code>类型组合构造成<code>datetime</code>类型。</p>
<p><code>pd.Period</code>也支持<code>strftime</code>方法，将<code>start_time</code>转换为字符串。</p>
<h5 id="时间元组结构-1"><a class="header" href="#时间元组结构-1">时间元组（结构）</a></h5>
<p><code>time</code>模块提供的格式化函数在字符串和时间元组之间相互转换。</p>
<pre><code class="language-python">import time
str_time = time.asctime(st_time) # 格式化输出时间。
str_time = time.strftime(format, st_time)
st_time = time.strptime(str_time, format)
</code></pre>
<h5 id="pandas-period"><a class="header" href="#pandas-period">Pandas Period</a></h5>
<p>除Python默认的格式声明外，<a href="https://pandas.pydata.org/docs/reference/api/pandas.Period.strftime.html?highlight=strftime#pandas.Period.strftime">还支持<code> %f, %F, %q</code></a>。</p>
<h2 id="对象集合"><a class="header" href="#对象集合">对象集合</a></h2>
<p>集合类型包括序列类型（列表、元组、字符串）、映射类型（字典）、集合类型等。</p>
<h5 id="统计函数"><a class="header" href="#统计函数">统计函数</a></h5>
<p>可应用于所有内置容器类型（包括字典）。</p>
<pre><code class="language-python">x = max(a)			# built-in max/min in Python, min
l = len(a)			# length of container
</code></pre>
<h3 id="序列类型"><a class="header" href="#序列类型">序列类型</a></h3>
<h4 id="字符串string"><a class="header" href="#字符串string">字符串（String）</a></h4>
<pre><code class="language-python">s = 'ilovepython'
</code></pre>
<p>Python可以使用引号(<code>'</code>)、双引号(<code>&quot;</code>)、三引号(<code>'''</code>或 <code>&quot;&quot;&quot;</code>)来表示字符串，引号的开始与结束必须的相同类型的。其中三引号可以由多行组成，可以直接包含换行、制表等特殊字符（而无需使用转义字符）；常用于<a href="Python/Python%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80.html#%E6%B3%A8%E9%87%8A%E5%92%8C%E6%96%87%E6%A1%A3">文档字符串</a>，在文件的特定地点，被当做注释。</p>
<blockquote>
<p>Python使用了<strong>字符串驻留</strong>技术来提高字符串效率，即同样的字符串对象仅仅会保存一份（长度不超过20），这也决定了字符串必须是不可变对象。</p>
</blockquote>
<h5 id="转义序列"><a class="header" href="#转义序列">转义序列</a></h5>
<div class="table-wrapper"><table><thead><tr><th>转义序列</th><th>实际字符</th><th>转义序列</th><th>实际字符</th></tr></thead><tbody>
<tr><td><code>\\</code></td><td><code>\</code></td><td></td><td></td></tr>
<tr><td><code>\&quot;</code></td><td>&quot;</td><td><code>\' </code></td><td>'</td></tr>
<tr><td><code>\n</code></td><td>换行</td><td><code>\t</code></td><td>横向制表符</td></tr>
</tbody></table>
</div>
<blockquote>
<p>无效的转义序列（例如<code>'\.'</code>）不会被处理和丢弃，保持原始输入。</p>
</blockquote>
<p>八进制编码：<code>\0xx</code>，例如<code>\000=&gt;NULL</code>；</p>
<p>十六进制编码：<code>\xFF</code>，对应<code>latin-1</code>编码字符；</p>
<p>Unicode编码：<code>\uFFFF</code>，<code>\UFFFFEEEE</code>（Python3中文本被解析为字符串后都是UTF-8编码）；</p>
<p>Unicode 字符串：<code>u'Hello 世界!'</code>可直接在字符串字面值输入非ASCII字符。</p>
<blockquote>
<p>字符编码：<code>chr(i)</code>返回Unicode编码（整数<code>0&lt;=i&lt;=0x10ffff</code>）对应的字符；<code>ord(x)</code>返回字符的Unicode编码。</p>
</blockquote>
<p>原始字符串：不解释转义序列：<code>r'Hello\nWorld!'</code>（或<code>R</code>前缀）。使用<code>repr(str)</code>可恢复字符串的<a href="Python/Python%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80.html#%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98">原始文本表示</a>（将特殊字符转换为转义序列）。</p>
<p>变量替换：<code>s = f'{arg1}, {arg2}'</code></p>
<p>可以采用<a href="Python/Python%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.html#%E5%AF%B9%E8%B1%A1%E8%BF%90%E7%AE%97%E7%AC%A6">对象运算符</a>对字符串进行拼接、重复和截取等操作。</p>
<h5 id="查找统计"><a class="header" href="#查找统计">查找统计</a></h5>
<p><code>idx=str.find(sub_str, beg=0, end=len(str))</code>：<code>rfind</code>、<code>index</code>、<code>rindex</code>，以及<a href="Python/Python%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.html#%E5%BA%8F%E5%88%97%E7%B1%BB%E5%9E%8B%E5%85%AC%E5%85%B1%E6%96%B9%E6%B3%95">序列类型公共方法</a>（<code>index</code>）；<code>in</code>和<code>not in</code>运算符可用于判断字符串是否包含子串。</p>
<pre><code class="language-python">import operator # operator模块是用c实现的，所以执行速度比python代码快。
tf = operator.contains(&quot;hello, python&quot;, &quot;llo&quot;)
</code></pre>
<p><code>tf=str.startWith(suffix, beg=0,end=len(str))</code>：<code>endWith</code>：<code>suffix</code>可以是单个字符串或多个字符串构成的元组（只要其中一个满足即返回<code>True</code>）。</p>
<blockquote>
<p>正则表达式匹配查找使用<code>re</code>模块。</p>
</blockquote>
<p><code>n=str.count(sub_str, beg=0,end=len(str))</code>：查找字串：返回字串出现的次数。</p>
<p>使用<a href="Python/Python%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.html#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F">正则表达式</a>。</p>
<p><code>is*()</code>方法：</p>
<h5 id="变换"><a class="header" href="#变换">变换</a></h5>
<p><code>sep.join(list_str)</code>：将字符串拼接起来，并适用字符串<code>sep</code>作为分隔符。</p>
<p><code>new_str = str.replace(old, new, max_count=-1)</code>：替换子串。</p>
<p><code>new_str=center(width, fillchar)</code>：类似地<code>ljust</code>、<code>rjust</code>、<code>zfill(width)</code>。</p>
<p><code>new_str=str.expandtabs(tabsize=8)</code>：将<code>tab</code>符号替换为空格。</p>
<p><code>new_str=str.strip(chars='')</code>：移除字符串两端<code>chars</code>中指定的任意字符，默认为空白字符。<code>lstrip</code>、<code>rstrip</code>。</p>
<p><code>list_strs=split(sep=None)</code>：默认分隔符为==所有连续==空字符，包括空格、换行、制表符等。<code>sep</code>指定的==字符串被视为一个分隔符==，而非将其中单个字符视为分隔符（若需要提供多个分隔符，使用<code>re.split</code>）。两个连续<code>sep</code>字符串之间会形成一个空的字串。</p>
<p><code>list_strs=str.splitlines(keepends=False)</code></p>
<p><code>new_str=str.title()</code>：每个单词首字母大写，<code>capitalize()</code>、<code>swapcase()</code>、<code>lower()</code>、<code>upper()</code>。</p>
<h5 id="字符串格式化"><a class="header" href="#字符串格式化">字符串格式化</a></h5>
<p>C-style格式化: 仅在字符串后缀<code>%</code>参数时，字符串中的<code>%</code>序列才会执行变量替换，否则只是普通字符。</p>
<pre><code class="language-shell">&quot;... %s ... %04d ...&quot;%(args...)
</code></pre>
<p>Python-style格式化：其中，<code>idx</code>代表参数位置，从<code>0</code>开始，没有指定则使用默认参数顺序；位置及关键字参数可以任意的结合。<code>format</code>代表格式化参数；<code>args</code>为需要被代入字符串的参数； </p>
<pre><code class="language-python">&quot;... {} ... {:format} ...&quot;.format(args...)
&quot;... {idx} ... {idx.member} ... {idx:format} ...&quot;.format(args...)
&quot;... {idx.member} ... {idx[0]} ...&quot;.format(args...)
&quot;... {var_name} ...&quot;.format(var_name=value)
</code></pre>
<p>格式化声明：</p>
<pre><code class="language-shell">[[fill]align][sign][#][0][width][,][.precision][type]
fill        =  &lt;any character&gt;
align       =  {&lt; | ^ | &gt;}[=]
sign        =  +| - | &quot;&quot;   # +表示始终显示符号，-和&quot;&quot;表示仅显示负号 
width       =  integer
precision   =  integer
type        =  b|c|d|e|E|f|F|g|G|n|o|s|x|X|%
</code></pre>
<blockquote>
<p>对齐方式：“<code>=</code>”不能在字符串中使用，在符号位后添加填充（反之在符号位前）；如果需要指定填充，则必须指定对齐方式；位宽前如果存在0，则0作为默认的填充字符。</p>
<p><code>#</code>：为二进制、八进制和十六进制添加前缀<code>0b,0o,0x</code>；</p>
<p><code>,</code>：千位分隔符；</p>
<p><code>e/E</code>：科学计数法，<code>precision</code>表示小数位数；</p>
<p><code>f/F</code>：定点计数法，固定小数位数（<code>precision</code>默认6位），位宽<code>width</code>不限制整数部分范围；</p>
<p><code>g/G</code>：使用位宽<code>width</code>（包括符号位）、固定有效数字位数<code>precision</code>表示。首先按有效数字位数丢弃末尾小数，当在小数部分无法显示足够位数有效数字时，切换为科学计数法（<code>.precision</code>表示有效数字位数）。</p>
<p>https://docs.python.org/3/library/string.html#format-specification-mini-language。</p>
</blockquote>
<h5 id="正则表达式"><a class="header" href="#正则表达式">正则表达式</a></h5>
<p>正则表达式匹配可用于字符串和<a href="Python/Python%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.html#%E5%AD%97%E8%8A%82%E5%BA%8F%E5%88%97%E7%B1%BB%E5%9E%8B">字节序列</a>。</p>
<p><code>re.match</code>：尝试从字符串的<strong>起始位置</strong>匹配一个模式（等效于<code>^pattern</code>），否则返回<code>None</code>。</p>
<blockquote>
<p><code>re.fullmatch</code>：将模式与整个字符串匹配，相当于使用<code>^pattern$</code>。</p>
</blockquote>
<p><code>re.search</code>：扫描整个字符串并返回<strong>第一个</strong>成功的匹配。</p>
<pre><code class="language-python">import re
m=re.match(pattern, string, flags=0)   # startswith(pattern)
m=re.search(pattern, string, flags=0)  # include(pattern)
m.span()     # 匹配位置(m.start(),m.end())  m.pos和m.endpos是原字符串的开始和结束位置
m.group()    # 匹配内容=&gt;m.group(0)
m.groups()   # 捕获组：(m.groups()[i]=&gt;m.group(i+1),...)
</code></pre>
<p><code>m.groups() </code>数量与表达式中声明的捕获组<code>&quot;(pattern)&quot;</code>对应。<em>未成功匹配的捕获组，其捕获内容返回<code>Null</code>。</em></p>
<blockquote>
<pre><code class="language-python">text=r'试图打印下列文档：D:\Users\gary\Documents\Python数据类型.md'
pattern=r'(文档：)(.*)(\.\w*)|(文档：)(.*)'
m = re.search(pattern, text)
</code></pre>
</blockquote>
<p><code>re.findall()</code>：查找并返回所有匹配结果。如果模式中不包含捕获，则每个结果括整个匹配内容；反之，返回子串构成的元组。<code>re.finditer()</code>返回一个子串匹配对象<code>Match</code>的迭代器。</p>
<pre><code class="language-python">all_matches = re.findall(pattern, string[, pos[, endpos]]) # -&gt; List[str]|List[Tuple[str]]
for m in re.finditer(pattern, text):
  print(m.group(0))
</code></pre>
<p><code>re.sub</code>：从最左至右替换字符串中的匹配项（最大匹配次数<code>count</code>）。</p>
<pre><code class="language-python">newstr   = re.sub(pattern, replace, count=0, flags=0)
newstr,n = re.subn(pattern, replace, count=0, flags=0)
</code></pre>
<blockquote>
<p><code>replace</code>可以是一个函数，可基于匹配内容生成替换内容</p>
<pre><code class="language-python">def repl(matched: re.Match):
    return '\\' + matched.group(0)  # group(0)未整个匹配内容，group(1)为第一个捕获组
</code></pre>
</blockquote>
<p>字符串分割：</p>
<pre><code class="language-python">list_strs = re.split('.|,|:|;| ', string)
</code></pre>
<p><code>re.compile</code>编译正则表达式并检查语法，生成一个正则表达式<code>re.Pattern</code>对象，提供<code>match</code>、<code>search</code>等方法（与静态方法相同）。</p>
<pre><code class="language-python">pat=re.compile(pattern[,flag])
</code></pre>
<p>https://www.runoob.com/python3/python3-reg-expressions.html.</p>
<h5 id="json"><a class="header" href="#json">JSON</a></h5>
<p>编码和解码：</p>
<pre><code class="language-python">json.dumps(obj)     # 将Python类型转换为JSON字符串
json.loads(string)  # 将JSON字符串转换为Python对象
</code></pre>
<blockquote>
<p>提供<code>dump</code>，<code>load</code>直接与文件进行<a href="Python/Python%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA.html#JSON">输入输出</a>。</p>
</blockquote>
<h5 id="url编码"><a class="header" href="#url编码">URL编码</a></h5>
<p>将非ASCII按给定的编码方案进行编码，并将编码结果以十六进制字符表示。</p>
<pre><code class="language-python">from urllib.parse import quote,unquote,quote_plus,unquote_plus
text = &quot;丽江@2020//&quot;                    
url_code_str = quote(text,'utf-8')   # =&gt; '%E4%B8%BD%E6%B1%9F%402020%2F%2F'
text_orgin = unquote(url_code_str,'utf-8')
urllib.request.pathname2url(path)   # url2pathname
</code></pre>
<p><code>quote_plus,unquote_plus</code>额外将<code>' '</code>（空格）替换为<code>+</code>。</p>
<h4 id="字节序列类型"><a class="header" href="#字节序列类型">字节序列类型</a></h4>
<p>==字节序列类型<code>bytes</code>和字符串类型有相同的操作方法==；<code>bytearray</code>可以修改对象内容。</p>
<blockquote>
<p>[<code>memoryview</code>](https://docs.python.org/zh-cn/3.7/library/stdtypes.html?highlight=list append#memoryview) 对象允许 Python 代码访问一个对象的内部数据，只要该对象支持 <a href="https://docs.python.org/zh-cn/3.7/c-api/buffer.html#bufferobjects">缓冲区协议</a> 而无需进行拷贝。</p>
</blockquote>
<h5 id="字符串编码和解码"><a class="header" href="#字符串编码和解码">字符串编码和解码</a></h5>
<p>字符串底层对应了某种编码方案（例如<code>gbk</code>, <code>utf-8</code>），因此可以使用对应的编码方案实现字符串与字节序列间的相互转换。</p>
<img src="https://miro.medium.com/max/2973/1*RQnsjdUrGkRdxaFYBwz_SA.png" alt="Image for post" style="zoom: 25%;" />
<pre><code class="language-python">s_encoded = s.encode(encoding='utf-8', errors='strict')
b_decoded = b.decode(encoding='utf-8', errors='strict')
</code></pre>
<p><strong>乱码</strong>：显示界面与字符串采用的编解码方式不一致。当输出文本到显示界面，实际是将对应的编码序列发送过去，而显示界面需要解码然后进行显示。当显示界面不能成功解码时，可能随机选择某系符号代替错误码字（或者丢弃码字），从而产生乱码。</p>
<p>产生乱码的常见情形：</p>
<ul>
<li>单字节编码方案(如<code>latin-1</code>)与<code>utf-8</code>不匹配；</li>
<li>本地化编码方案（如<code>gbk</code>）与<code>utf-8</code>不匹配。</li>
</ul>
<p>在严格模式<code>errors=strict</code>下编码生成的字符串对象，只要采用对应的编码方案即可逆变换得到字节序列，并尝试使用其他编码方案以获得正确解码文本。</p>
<blockquote>
<p><em>In Python 3, reading files in <code>r</code> mode means decoding the data into Unicode and getting a <code>str</code> object. Reading files in <code>rb</code> mode means reading the data as is, with no implicit decoding, and saving it as <code>bytes</code>.</em></p>
<p>https://docs.python.org/3/library/codecs.html#standard-encodings</p>
<div class="table-wrapper"><table><thead><tr><th>Codec</th><th>Meaning</th></tr></thead><tbody>
<tr><td><code>raw_unicode_escape</code></td><td><strong>编码</strong>：将字符串按<code>latin_1</code>方案（单字节）编码。如果字符串中包含其他非<code>latin_1</code>范围的码字，则使用转义表示<code>&quot;\\uXXXX&quot;</code>和<code>&quot;\\UXXXXXXXX&quot;</code>Unicode码点；<br/></td></tr>
<tr><td><code>unicode_escape</code></td><td>Decode from Latin-1 ==source code==.<br />解码会处理所有以<code>\</code>字符开始的序列，并吸收无效序列。</td></tr>
</tbody></table>
</div></blockquote>
<h5 id="推断未知编码类型"><a class="header" href="#推断未知编码类型">推断未知编码类型</a></h5>
<p><code>chardet</code>可根据编码序列特征推断文本最可能的编码类型。</p>
<pre><code class="language-python">import chardet
chardet.detect(text_bytes)
# {'encoding': 'utf-8', 'confidence': 0.99, 'language': ''}
</code></pre>
<h6 id="十六进字符串转换"><a class="header" href="#十六进字符串转换">十六进字符串转换</a></h6>
<pre><code class="language-python">bytes_array = bytes.fromhex('FEF0ABC12')
hex_str = bytes_array.hex()   # str.upper() to uppercase
</code></pre>
<h6 id="二进制数据的字符编解码"><a class="header" href="#二进制数据的字符编解码">二进制数据的字符编解码</a></h6>
<blockquote>
<p><strong><a href="https://en.wikipedia.org/wiki/Base64">Base64</a></strong> 将6bit数据映射为8bit，对应于将3字节数据编码为4个码字（合法码字共64个包含<code>A~Za~z0~9</code>以及符号<code>+/</code>，此外<code>=</code>用于填充不在合法码字范围内）<sup class="footnote-reference"><a href="#b64">1</a></sup>。</p>
</blockquote>
<pre><code class="language-python">import base64
x = 'this is a string'
x_bytes = x.encode('utf-8')
x_b64:bytes = base64.b64encode(x_bytes:bytes)
x_bytes = base64.b64decode(x_b64) # 输入为bytes或ASCII str
x = str(x_bytes, 'utf-8')    # x_bytes.decode(encoding='utf-8')
</code></pre>
<blockquote>
<p>命令行调用：</p>
<pre><code class="language-shell">echo &quot;hell world&quot; | python -m base64
echo &quot;aGVsbG8sIHdvcmxkCg==&quot; | python3 -m base64 -d
</code></pre>
</blockquote>
<h5 id="struct"><a class="header" href="#struct">struct</a></h5>
<p><a href="https://www.liaoxuefeng.com/wiki/1016959663602400/1017685387246080">struct - 廖雪峰的官方网站 (liaoxuefeng.com)</a></p>
<h4 id="元组tuple"><a class="header" href="#元组tuple">元组（Tuple）</a></h4>
<pre><code class="language-python">tup = ( 'runoob', 786 , 2.23, 'john', 70.2 )
</code></pre>
<blockquote>
<p>定义元组所用的括号可省略。</p>
</blockquote>
<p>元组的元素不能二次赋值（<code>tup[i]=value</code>），相当于只读列表。多个元组可以进行拼接（<code>+</code>）生成新的元组。</p>
<p>如果元素是可变对象，可以对对象内容修改。</p>
<blockquote>
<p><code>(x,)</code>表示只有一个元素的元组，使用<code>,</code>区分元组与普通括号运算符。</p>
</blockquote>
<p>展开元组：将元组元素返回到变量中。</p>
<pre><code class="language-python">x,y,z = (1,2,3)
x,y,*rest = (1,2,...)  # 使用rest接收其他元素
x,y,*_ = (1,2,...)     # 使用*_代替其他任意多的元素
</code></pre>
<blockquote>
<p><code>_</code>用于替代返回值中不需要接收的数据。</p>
</blockquote>
<h5 id="zip"><a class="header" href="#zip">zip</a></h5>
<p>使用<code>zip</code>将多个序列中的相应元素合并到一个元组中：</p>
<pre><code class="language-python">l1 = ['bar', 'bar', 'baz', 'baz', 'foo']
l2 = ['one', 'two', 'one', 'two', 'one']
tuples = list(zip(l1, l2))
# [('bar', 'one'), ('bar', 'two'), ..., ('foo', 'one')]
</code></pre>
<blockquote>
<p><code>zip</code>生成一个元组的迭代器，需要进行类型转换。</p>
</blockquote>
<h4 id="列表list"><a class="header" href="#列表list">列表（List）</a></h4>
<p>列表可以动态添加和删除元素。</p>
<pre><code class="language-python">li = [ 'runoob', 786 , 2.23, 'john', 70.2 ]
li = [ func(x) for x in iterable if cond(x) ] # cond(x) is optional
li = [ func1(x) if cond1(x) else func2(x) for x in iterable ]
</code></pre>
<blockquote>
<p>使用<code>[]</code>构造列表<a href="https://www.datacamp.com/community/tutorials/python-list-comprehension">性能更好</a>。</p>
</blockquote>
<p><code>range</code>类型表示不可变的数字序列，通常用于在 <code>for</code>循环中循环指定的次数。</p>
<pre><code class="language-python">class range(start, stop[, step])
</code></pre>
<blockquote>
<p>包含<code>start</code>，不包含<code>stop</code>。</p>
</blockquote>
<h5 id="修改列表"><a class="header" href="#修改列表">修改列表</a></h5>
<pre><code class="language-python">l.append(e) # 追加元素。
l.insert(index,e) # 在当前index位置前插入元素
l.remove(e) # 删除第一个值为e的元素（必须在列表中，否则产生ValueError）。
v = l.pop(i=-1)  # =&gt; del l[i]
</code></pre>
<h5 id="合并序列"><a class="header" href="#合并序列">合并序列</a></h5>
<pre><code class="language-python">l.extend(l1)  # 拼接另一个序列
</code></pre>
<blockquote>
<p>“<code>+</code>”运算符将返回新的对象，且只能支持列表合并；<code>extend()</code>支持当前对象与任意<code>iterable</code>对象合并（等价于<code>+=</code>）。</p>
</blockquote>
<p><a href="Python/Python%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.html#%E5%90%88%E5%B9%B6%E5%A4%9A%E4%B8%AA%E5%BA%8F%E5%88%97">合并多个序列</a>的方法。</p>
<h5 id="列表排序"><a class="header" href="#列表排序">列表排序</a></h5>
<p><code>list.sort(key=None, reverse=False)</code>为列表类型特有的（升序）排序函数，对原列表进行稳定排序操作（<em>in-place</em> and <em>stable</em>）。<code>key</code>为比较参考值，<a href="Python/Python%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.html#%E5%BA%8F%E5%88%97%E7%B1%BB%E5%9E%8B%E5%85%AC%E5%85%B1%E6%96%B9%E6%B3%95">基于基于排序元素的计算函数</a>。</p>
<blockquote>
<p>Python的排序规则不是通过显式指定比较函数，而是指定排序所使用的参考值。使用以下方法可实现自定义比较函数进行排序。</p>
<pre><code class="language-python">import functools
def cmp_func(a,b):
   if a.value &gt; b.value:
      return 1
   elif a.value &lt; b.value:
      return -1
   else:
      return 0
li.sort(key=functools.cmp_to_key(cmp_func))
</code></pre>
</blockquote>
<p>为了支持多个字段的排序，可对序列进行多次排序，即按优先级最低到最高的字段分别进行排序（<code>list.sort</code>是稳定排序算法，对较高优先级字段的排序时如果值相同不会改变顺序，因此也就不会影响低优先级字段的排序结果）：</p>
<pre><code class="language-python">from operator import attrgetter
def multisort(xs, specs):
    for key, reverse in reversed(specs):
        xs.sort(key=attrgetter(key), reverse=reverse)
    return xs
multisort(list(objects), (('field1', True), ('Field2', False)))
</code></pre>
<h5 id="get-unique-values-from-a-list"><a class="header" href="#get-unique-values-from-a-list">Get unique values from a list</a></h5>
<p>https://www.geeksforgeeks.org/python-get-unique-values-list/</p>
<ol>
<li>Traversal of list <code>if x not in unique_list</code>；</li>
<li>Using <code>set</code>：<code>unique_list = list(set(list1))</code>；</li>
<li>Using <code>numpy.unique()</code>；</li>
<li>Using <code>Series.unique()</code>。</li>
</ol>
<h4 id="序列类型公共方法"><a class="header" href="#序列类型公共方法">序列类型公共方法</a></h4>
<h5 id="序列类型的索引"><a class="header" href="#序列类型的索引">序列类型的索引</a></h5>
<p>访问元素：</p>
<pre><code class="language-python">s[idx]
</code></pre>
<blockquote>
<p>不能使用列表或元组访问多个元素。</p>
</blockquote>
<p><strong>切片</strong>：从左到右索引默认0开始（<em><strong>zero-based</strong></em>）的，最大范围是字符串长度少1；从右到左索引默认-1开始的，最大范围是数组开头。（包含开始不包含结束位置的值）</p>
<pre><code class="language-python">a[start:end+1]	# 读取从第start到第end的元素
a[start:end+1:step]# i缺省为0 j缺省为L s缺省为1
a[-j:-i]# 读取从倒数第(j-1)到倒数第i的元素: a[-i:-j:1]
a[-i:-j:-s] # 步长为负，逆序读取
a[:]	# all 
a[:-1]  # 从位置0到位置-1之前的数 a[-L:-1:-1]
a[::-1] # 反转操作：-n 读取倒数第n个元素之前的内容
</code></pre>
<blockquote>
<p>超出范围的下标自动被忽略。</p>
</blockquote>
<blockquote>
<p>序列类型不能通过整数序列或<code>bool</code>序列选取元素（<code>numpy.ndarray</code>支持）。</p>
</blockquote>
<h5 id="对象操作"><a class="header" href="#对象操作">对象操作</a></h5>
<p>使用对象运算符<code>*</code>复制序列，使用<code>+</code>进行序列拼接。</p>
<pre><code class="language-python">li = [None]*5  # 构造长度为的序列
s = 'xyz'*5    # 通过复制扩展字符串
</code></pre>
<h5 id="查找find"><a class="header" href="#查找find">查找（find）</a></h5>
<pre><code class="language-python">idx = list.index(value)  # retrun the first occurence
</code></pre>
<blockquote>
<p><code>==</code>运算符不能用于序列与元素的比较，返回<code>bool</code>掩码；<code>==</code>直接比较两个对象。</p>
<p>如果元素不存在，返回异常<code>ValueError</code>。</p>
</blockquote>
<p>查找多个元素：</p>
<pre><code class="language-python">L = [1,2,3,2,1,4,5]
R = [1,3]
indices = [i for i in range(len(L)) if L[i] in R]
</code></pre>
<h5 id="排序"><a class="header" href="#排序">排序</a></h5>
<p>排序结果作为新的对象返回（适用于元组等不能修改的对象）。</p>
<pre><code class="language-python">sorted(iterable, key=None, reverse=False)
key = lambda x: x[0]
key = lambda x: x.prop
from operator import attrgetter
key = attrgetter('prop')  # 使用对象的&quot;prop&quot;属性进行排序
</code></pre>
<p><code>key</code>是一个（升序）排序元素的函数，使用迭代器的元素计算排序的比较参考值。<code>sorted</code>不支持自定义比较函数（Python3）。</p>
<h5 id="过滤"><a class="header" href="#过滤">过滤</a></h5>
<pre><code class="language-python">iterable = filter(func, iterable)  # 过滤序列中func(item)为False的元素
iterable = [item if func(item)==True for item in iterable]
</code></pre>
<blockquote>
<p>如果<code>func=None</code>，则过滤<code>item=False</code>的元素。</p>
</blockquote>
<h5 id="迭代"><a class="header" href="#迭代">迭代</a></h5>
<pre><code class="language-python">import itertools
</code></pre>
<p>构造可迭代对象 。</p>
<h5 id="合并多个序列"><a class="header" href="#合并多个序列">合并多个序列</a></h5>
<ol>
<li>
<p>：按序依次拼接。</p>
<pre><code class="language-python"># Method1: def concat function with for-loop and concat operator (+)
def concat(nest_list):
  li = []
  for l in nest_list:
    li.extend(l)			# 合并两个列表
  return li
l_nest = [[1,2,3], ['a', 'b'], [4]]
ll = concat(l_nest)
# Method3: Substitute concat() with reduce()
from functools import reduce
ll = reduce(list.__add__, l_nest)	# =&gt; lambda x,y: x+y	
# Method2: List constructor, append by elements
ll = [y for l in l_nest for y in l] 
# Method 6 yield from [Python编程基础.md#迭代器] 
def merge(*lists):
   for l in lists:
      yield from l     # return one element one time from l
list(merge(list01, list02, list03))
# Method4:
import itertools			# use itertools
flat = itertools.chain.from_iterable(l_nest)
iterable = itertools.chain(list01, list02, list03) # 可转换为序列类型
</code></pre>
</li>
<li>
<p>合并且排序</p>
<pre><code class="language-python"># Method 5
from heapq import merge
li = list(merge(li1,li2,li3,...))   # 堆排序算法合并序列，保持序列有序
</code></pre>
</li>
</ol>
<h3 id="映射类型"><a class="header" href="#映射类型">映射类型</a></h3>
<h4 id="字典dictionary"><a class="header" href="#字典dictionary">字典（Dictionary）</a></h4>
<p>字典当中的元素是通过键来存取的，而不是通过偏移存取。</p>
<h5 id="定义字典"><a class="header" href="#定义字典">定义字典</a></h5>
<p>从元素构造字典，或基于已有字典进行构造（合并）。</p>
<pre><code class="language-python">d = {'name': 'john','code':6734, 'dept': 'sales'}
# ==&gt; d = {**d, **d2}
d = dict(key1=val1, key2=val2, ...) # =&gt; d = dict(**d1, **d2) 
d = dict([(key1, val1), (key2,val2), ...]) # &lt;- zip(keys, values)
# ==&gt; d = {k:v for k,v in kv_tuples}
# ==&gt; d = dict(itertools.chain(d.items(), d2.items()))
d = dict.fromkeys(keys, value) # 初始化所有keys的值为同一个value
d.update(d2:dict)  # inplace
</code></pre>
<blockquote>
<p>Python 3.9支持使用<code>|</code>和<code>|=</code>运算符进行字典合并。</p>
</blockquote>
<p>复制字典对象：</p>
<pre><code class="language-python">d2 = d.copy()   # 浅拷贝
from copy import deepcopy
d2 = deepcopy(d) # 深拷贝
</code></pre>
<p>增删字典元素：</p>
<pre><code class="language-python">d['key'] = value
value=d.setdefault(key, default)
d.update([(k1,v1), ...], k1=v1,...)
del(d['key'])	# 删除字典元素  =&gt; del d['key']
value=d.pop(key, default)  # 移除元素，如果key不存在则返回default；
                           # 如果未提供default则产生KeyError
key_val=d.popitem()  #移除末尾元素
dict.clear()  #清空字典元素。
</code></pre>
<p>遍历字典元素：</p>
<pre><code class="language-python">for key in dict:		           # =&gt; for key in dict.keys()
    print(key, dict[keys])
for key,value in dict.items(): # iter on (key,value) 
    print(key, value)
</code></pre>
<p>键是不可变数据类型，包括数值、字符串、元组、<code>datetime</code>等； 值可以是任意类型。</p>
<pre><code class="language-python">keys = d.keys()      # return Type &lt;dict_keys&gt;
vals = d.values()    # return type &lt;dict_values&gt;
</code></pre>
<p><code>keys()</code>和<code>values()</code>无法通过下标访问，但可通过迭代访问。</p>
<h5 id="查询字典"><a class="header" href="#查询字典">查询字典</a></h5>
<p>字典的<code>key</code>是唯一标识，相当于集合类型。可查询<code>key</code>是否存在字典中。</p>
<pre><code class="language-python">tf = key in dc  # =&gt; key in dc.keys()
</code></pre>
<h5 id="字典排序"><a class="header" href="#字典排序">字典排序</a></h5>
<p>Python 3.7+的字典保持其元素加入的顺序。可通过重新构造对象实现对字典的排序或使用<a href="Python/Python%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.html#%E6%9C%89%E5%BA%8F%E5%AE%B9%E5%99%A8">有序容器</a>。</p>
<pre><code class="language-python">dict(sorted(x.items(), key=lambda item: item[0]))   # sorted by key
dict(sorted(x.items(), key=lambda item: item[1]))   # sorted by value
</code></pre>
<h4 id="namespace"><a class="header" href="#namespace">NameSpace</a></h4>
<blockquote>
<p><em><a href="https://www.reddit.com/r/Python/comments/3373dm/silly_question_whats_the_difference_between_dict/">A namespace is essentially a collection of names bound to values</a>. They are sometimes <strong>implemented</strong> by a dict &quot;under the hood&quot;, but not always, and the implementation detail is really irrelevant, and they're not the same thing.</em></p>
</blockquote>
<pre><code class="language-python">from types import SimpleNamespace  
from argparse import Namespace
ns = SimpleNamespace(**kwargs)
ns.varname  # 访问命名空间中的变量
ns.__dict__ # 将命名空间的成员转换为字典
</code></pre>
<blockquote>
<p>命名空间中的变量类似于字典的值或类的成员变量（具有类作用域）。</p>
</blockquote>
<h3 id="集合"><a class="header" href="#集合">集合</a></h3>
<p><code>set</code>对象是由具有唯一性的 <a href="https://docs.python.org/zh-cn/3.7/glossary.html#term-hashable">hashable</a> 对象所组成的无序多项集。 常见的用途包括<strong>成员检测、从序列中去除重复项以及数学中的集合类计算</strong>，例如交集、并集、差集与对称差集等等。 </p>
<pre><code class="language-python">s = {'xyz', 123, True}  # 空集合为set()，{}创建的是空字典
s = set('abcdefg')      # 将字符串的字符转换为集合元素。
</code></pre>
<blockquote>
<p>集合类型是无序的，其元素顺序与构造时提供的顺序不一定一致。</p>
<p>使用<code>in</code>/<code>not in</code>判断集合元素是否存在。</p>
<p>第三方包<code>orderedset</code>和<code>ordered-set</code>实现了保持元素顺序的集合<code>OrderedSet</code>：</p>
<pre><code class="language-python">from orderedset import OrderedSet   # or from ordered_set
</code></pre>
</blockquote>
<h4 id="修改集合"><a class="header" href="#修改集合">修改集合</a></h4>
<pre><code class="language-python">s.add(x)      
s.update(x)   # 参数可以是列表，元组，字典等
s.remove(x)   # 不存在会发生错误
s.discard(x)
s.pop()       # 设置随机删除集合中的一个元素
s.clear()
</code></pre>
<p><code>frozenset</code>为对应的不可变类型。</p>
<h4 id="集合运算"><a class="header" href="#集合运算">集合运算</a></h4>
<pre><code class="language-python">s = s1.intersection(s2) # 交集：s = s1&amp;s2
s = s1.union(s2)        # 并集：s = s1|s2
s = s1.difference(s2)   # 差集：s = s1-s2, 在s1中但不在s2中的元素
s = s1^s2        # 等效：s1.union(s2)-s1.intersection(s2)
s.isdisjoint()   # 集合是否有没有交集
s.issubset(A)    # 判断s是否为A的子集
s.issubset(A)    # 判断s是否为A的子集
</code></pre>
<blockquote>
<p>集合不支持<code>+</code>运算符。</p>
</blockquote>
<p><a href="https://docs.python.org/zh-cn/3.7/library/index.html">Python 标准库</a></p>
<h3 id="容器类型转换"><a class="header" href="#容器类型转换">容器类型转换</a></h3>
<p>元组：<code>tuple(s)</code>；列表：<code>list(s)</code>；集合：<code>set(s), frozenset(s)</code>。</p>
<h3 id="有序容器"><a class="header" href="#有序容器">有序容器</a></h3>
<p><code>sortedcontainers</code>包含<code>SortedList</code>、<code>SortedSet</code>、<code>SortedDict</code>等维持元素大小顺序的容器(默认升序)。</p>
<pre><code class="language-python">sd = SortedDict(func_key, *kv_tuples, **dict_kwargs)  # func_key将key映射为比较值
sd.__reversed__() &lt;==&gt; reversed(sd)
</code></pre>
<p><code>sortedcollections</code>（基于<code>sortedcontainers</code>实现）除包含上述类型外，还包含保持元素加入顺序的类型：<code>OrderedSet</code>、<code>OrderedDict</code>。</p>
<h2 id="矩阵"><a class="header" href="#矩阵">矩阵</a></h2>
<p>存储<a href="Python/Python%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.html#%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">同类型元素</a>的类型，区别于<code>list</code>、<code>tuple</code>等序列类型。</p>
<ul>
<li>Python标准库提供<code>array</code>类用于构造<a href="https://docs.python.org/zh-cn/3.7/library/array.html?highlight=append#array.array.append">一维数值数组</a>。</li>
<li>NumPy提供<code>ndarray</code>(<code>array</code>)类用于构建数值数组、<code>matrix</code>用于表示矩阵。</li>
<li>SciPy提供多种类型的<a href="Python/Python%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.html#%E7%A8%80%E7%96%8F%E7%9F%A9%E9%98%B5">稀疏矩阵</a>。</li>
</ul>
<h3 id="多维矩阵"><a class="header" href="#多维矩阵">多维矩阵</a></h3>
<p><code>ndarray</code>（<code>array</code>）类型可表示多维同构（<em>homogeneous</em>）矩阵。</p>
<h4 id="属性"><a class="header" href="#属性">属性</a></h4>
<div class="table-wrapper"><table><thead><tr><th>名称</th><th>用途</th></tr></thead><tbody>
<tr><td><code>ndim</code></td><td>数组的维数，例如向量为1，矩阵为2矩阵。</td></tr>
<tr><td><code>shape</code></td><td>数组的形状。使用矩阵表示向量：列向量$N\times 1$，行向量默认为$1\times N$，与仅有一个维度的向量类型不同。</td></tr>
<tr><td><code>size</code></td><td>数组的元素总数。</td></tr>
<tr><td><code>dtype</code></td><td><a href="https://numpy.org/devdocs/user/basics.types.html">数据类型</a>，矩阵元素不仅可以使数值类型，也可以是字符串等类型，但<a href="Python/Python%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.html#%E4%BB%8E%E5%B7%B2%E6%9C%89%E6%95%B0%E6%8D%AE%E5%AF%B9%E8%B1%A1%E6%9E%84%E9%80%A0">所有元素类型相同</a>。</td></tr>
<tr><td><code>itemsize</code></td><td>单个元素的内存占用量。</td></tr>
<tr><td><code>data</code></td><td>数据的==内存地址==。</td></tr>
<tr><td><code>base</code></td><td>If the array is a view into another array, that array is its <code>base</code></td></tr>
</tbody></table>
</div>
<blockquote>
<p><code>len(array)</code>返回数组第一维的长度。</p>
</blockquote>
<h5 id="数组维度判断"><a class="header" href="#数组维度判断">数组维度判断</a></h5>
<p>可以<code>ndarray</code>以外的类型进行判断：对象维度为0，序列维度为1。</p>
<pre><code class="language-python">n = np.ndim(x)
shape = np.shape(x)
</code></pre>
<p>标量：（内置）数值对象、字符串、字节序列等（<code>np.ndim(x)==0</code>）；</p>
<pre><code class="language-python">tf = np.isscalar(x)
</code></pre>
<blockquote>
<p>只有一个元素的序列类型、数组类型等返回<code>False</code>。非数值对象返回<code>False</code>。</p>
<p><code>np.isscalar(None)==False</code>。</p>
</blockquote>
<h4 id="元素数据类型"><a class="header" href="#元素数据类型">元素数据类型</a></h4>
<blockquote>
<p><em>Python defines only one type of a particular data class (there is only one integer type, one floating-point type, etc.).</em> </p>
<p><em>NumPy defines 24 new <a href="https://numpy.org/doc/stable/reference/arrays.scalars.html">fundamental scalar types</a>, mostly based on the types available in the C language that CPython is written in.</em></p>
<img src="Python/Python数据类型.assets/dtype-hierarchy.png" alt="dtype-hierarchy" style="zoom:85%;" />
</blockquote>
<p>内置数据类型定义包括：平台相关类型（<code>np.int</code>，<code>np.float</code>，...，<code>np.ubyte,...</code>，弃用）以及定长类型（<code>np.int8</code>, <code>np.int16</code> , <code>np.int32</code>, <code>np.int64</code>, <code>np.float32</code>, <code>np.float64</code>, ..., <code>np.bool</code>，无符号类型：<code>np.uint8,...</code>）。</p>
<blockquote>
</blockquote>
<h5 id="数据类型元信息"><a class="header" href="#数据类型元信息">数据类型元信息</a></h5>
<p>在创建矩阵时，<code>dtype</code>参数可以为矩阵统一或的每列指定一个名称和类型。<code>dtype</code>声明了数据的类型（整数<code>i/u</code>、浮点数<code>f</code>、对象<code>O</code>等）、占用字节数、字节序（little-endian或big-endian）、<a href="https://numpy.org/doc/stable/reference/arrays.dtypes.html">结构以及子数组大小类型等信息</a>。上述信息封装在<code>np.dtype</code>对象中（类似于Python内置的<code>type</code>类）。</p>
<blockquote>
<p>Several kinds of strings can be converted. Recognized strings can be prepended with <code>'&gt;'</code> (<a href="https://numpy.org/doc/stable/glossary.html#term-big-endian">big-endian</a>), <code>'&lt;'</code> (<a href="https://numpy.org/doc/stable/glossary.html#term-little-endian">little-endian</a>), or <code>'='</code> (hardware-native, the default), to specify the byte order.</p>
</blockquote>
<pre><code class="language-python">dtype.aligment  # 占用字节数
t.kind          # 数据类型（整数/浮点数/...）
t.name          # 类型名（int64）
t.str           # 数据类型规则声明('&lt;i8') -&gt; t.descr
dtype.byteorder # 字节序
</code></pre>
<h5 id="数据类型判断"><a class="header" href="#数据类型判断">数据类型判断</a></h5>
<p>可以将数据类型对象与字符串表示进行比较（Pandas数据表的底层类型为<code>ndarray</code>，也遵循该规则）。</p>
<pre><code class="language-python">isinstance(x[0], np.int32)
x.dtype   # dtype('int32')
x.dtype == 'int32'   # return True
x.dtype == np.int32  # return True  &gt;&gt; type(x) == np.int32
x.dtype == int       # return True
x.dtype == '&lt;i4'
</code></pre>
<blockquote>
</blockquote>
<h4 id="创建数组"><a class="header" href="#创建数组">创建数组</a></h4>
<pre><code class="language-python">numpy.full(shape, fill_value, dtype=None, order='C')
</code></pre>
<p>创建指定形状<code>shape</code>的数组，并指定初始值<code>fill_value</code>和元素类型<code>dtype</code>（例如<code>bool</code>）。<code>shape</code>指定数组的维度，可以是<strong>整数标量</strong>、<strong>列表</strong>或<strong>元组</strong>（<code>[m,n,p,...]</code>）。</p>
<ul>
<li>标量：为<code>0</code>表示空数组；为<code>1</code>相当于标量组成的数组，其他值则为向量；</li>
<li>长度为<code>2</code>的列表或元组：生成矩阵；</li>
<li>大于2的列表或元组：生成高阶数组。</li>
</ul>
<p><code>order</code>指定数据存储方式： <em><strong>row-major (C-style) or column-major (Fortran-style)</strong></em>。</p>
<pre><code class="language-python">np.ones(shape, dtype=None, order='C')
np.zeros(...)
</code></pre>
<p>当采用<em><strong>C-style</strong></em>时，最后的维度（<code>[m,n,p]</code>中的<code>p</code>）索引的元素在内存中是连续存储的；反之，采用<em><strong>Fortran-style</strong></em>时，最前的维度索引的元素是连续存储的。==元素在内存中的存储方式对于新创建的数组以及按索引访问数组而言没有影响，但影响数组变形（<code>reshape</code>）后元素的排列方式以及切片赋值的效率。==</p>
<pre><code>np.empty(shape, dtype=Float, order='C')
</code></pre>
<p>创建数组，不执行初始化。</p>
<h5 id="等差序列"><a class="header" href="#等差序列">等差序列</a></h5>
<pre><code class="language-python">np.arange(start=0, stop, step=1, dtype=None)
np.linspace(start, stop, num=50, endpoint=True, ...)
</code></pre>
<p><code>arange</code>创建序列<strong>不包含</strong><code>stop</code>，使用<code>step</code>指定步长；<code>linspace</code>包含<code>stop</code>，使用<code>num</code>指定序列元素个数。</p>
<h5 id="等比序列"><a class="header" href="#等比序列">等比序列</a></h5>
<pre><code class="language-python">np.logspace(start, stop, num=50, endpoint=True, base=10.0)
</code></pre>
<p>该等比序列可以表示为指数形式：$\mathrm{base}^\mathrm{idx}$，其中指数$\mathrm{idx}$对应于等差序列<code>np.linspace(start, stop, num)</code>中的元素。如果要生成<code>(s,t)</code>之间的等比序列，则先取其对数的等差序列：</p>
<pre><code class="language-python">nums = np.logspace(np.log10(s), np.log10(t), int(n))
# 等价于
# exps = np.linspace(np.log10(s), np.log10(s), n)
# nums = np.power(10, exps)
</code></pre>
<pre><code class="language-python">np.meshgrid(x,y,...,sparse=False,...)
</code></pre>
<h6 id="对角矩阵"><a class="header" href="#对角矩阵">对角矩阵</a></h6>
<p><code>identity</code>，<code>eye</code>，<code>diag|diagonal</code>，<code>diag_flat</code>、</p>
<h6 id="三角矩阵"><a class="header" href="#三角矩阵">三角矩阵</a></h6>
<p><code>tri</code>，<code>tril</code>，<code>triu</code>。</p>
<h5 id="从已有数据对象构造"><a class="header" href="#从已有数据对象构造">从已有数据对象构造</a></h5>
<pre><code class="language-python">np.array(array_like, dtype=None, ndmin=0,...)
</code></pre>
<p>从已有矩阵或序列对象创建矩阵，==矩阵元素类型默认根据序列对象的兼容类型推导，并对元素进行强制类型转换==。嵌套序列对象可初始化为多维矩阵。</p>
<pre><code class="language-python">np.array([(1,2,3), (4,5,6)], dtype='i4')
</code></pre>
<p>当数据中包含混合类型（如字符串与整数），Numpy将自动将数值转换为统一的兼容类型（将整数转换为字符串）。如果要保持原类型，应该声明<code>dtype=object</code>。</p>
<blockquote>
<p>另有其他采用固定选项对<code>array</code>方法的封装方法：</p>
<ul>
<li><code>asarray</code>：避免兼容类型复制（<code>copy=False</code>）；</li>
<li><code>asanyarray</code>：避免兼容类型及其子类的复制（<code>copy=False,subok=True</code>）；</li>
<li><code>copy</code>：总是复制；</li>
<li>...</li>
</ul>
</blockquote>
<h5 id="从数据源创建"><a class="header" href="#从数据源创建">从数据源创建</a></h5>
<h6 id="读取缓存数据"><a class="header" href="#读取缓存数据">读取缓存数据</a></h6>
<pre><code class="language-python">numpy.frombuffer(buffer, dtype=float, count=-1, offset=0)
</code></pre>
<p>从字节数组读取数据并创建一维数组。<code>count</code>为读取的字节数，<code>offset</code>为跳过起始字节数。</p>
<h6 id="读取文件数据"><a class="header" href="#读取文件数据">读取文件数据</a></h6>
<p>使用<code>loadtxt</code>、<code>genfromtxt</code>。</p>
<h5 id="其他特殊数组"><a class="header" href="#其他特殊数组">其他特殊数组</a></h5>
<p>随机数：<code>np.random.randn(m, n,...)</code></p>
<h4 id="数组对象操作"><a class="header" href="#数组对象操作">数组对象操作</a></h4>
<h5 id="复制对象"><a class="header" href="#复制对象">复制对象</a></h5>
<ol>
<li>
<p>不复制，直接引用</p>
<pre><code class="language-python">a = b
a = b[:,idx]
</code></pre>
<p>通过<a href="Python/Python%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.html#%E7%B4%A2%E5%BC%95%E5%92%8C%E5%88%87%E7%89%87">切片</a>方式获得的数组子集仍然直接引用原数组。</p>
</li>
<li>
<p>浅拷贝/视图</p>
<p>对象之间共享底层存储数据的内存，两个对象可对底层数据有不同的表达。</p>
<pre><code class="language-python">y = x.view(dtype=np.int16, type=np.matrix)  # reinterpret
b = a.reshape(shape)
</code></pre>
<p>多数数组操作函数，不必要情况下都不会复制数组内容，而是使用浅拷贝。</p>
</li>
<li>
<p>深拷贝</p>
<pre><code class="language-python">a = b.copy()    # list.copy()是浅拷贝
</code></pre>
</li>
</ol>
<h5 id="初始化"><a class="header" href="#初始化">初始化</a></h5>
<pre><code class="language-python">a.fill(value)
</code></pre>
<h5 id="数组变形"><a class="header" href="#数组变形">数组变形</a></h5>
<pre><code class="language-python">a.reshape((m,n,...), order='C')  # =&gt; np.reshape(a,...)
</code></pre>
<p>参数为<code>-1</code>表示该维度的长度由其他维度和数组元素数量决定（只能有一个维度设置为<code>-1</code>）。<code>a.reshape(-1)</code>将数组变换为向量，等效方法包括：</p>
<pre><code class="language-python">a.ravel(order='C')    # =&gt; np.ravel(a,...)
a.flatten(order='C')
</code></pre>
<blockquote>
<p><code>a.squeeze()</code>：降维，移除数组中长度为1的维度。</p>
</blockquote>
<pre><code class="language-python">a.resize((m,n,...))
</code></pre>
<p>根据新的形状重新分配存储空间，如果数组空间减小则舍弃靠后的元素，反之将新增元素置为0。根据底层存储方式（<code>C</code>或<code>F</code>）决定元素在内存中的位置。</p>
<pre><code class="language-python">np.repeat(a, n_repeat, axis)
</code></pre>
<p>在给定方向<code>axis</code>，对矩阵<code>a</code>进行重复。</p>
<p>转置：</p>
<pre><code class="language-python">a.transpose
</code></pre>
<h5 id="拼接"><a class="header" href="#拼接">拼接</a></h5>
<p>将多个数组进行垂直/水平拼接。</p>
<pre><code class="language-python">np.concatenate((a1,a2,...),axis=0)
np.vstack(list_array)	# vertical concatenate
np.hstack(list_array) # horizontal concatenate (沿行方向拼接，对于1D数组直接拼接)
np.stack(list_array, axis=0) # 在新的维度上拼接数据（维度+1）
</code></pre>
<p><code>list_array</code>是多个数组组成的序列（<strong>列表或元组</strong>），这里的数组可以是标量、Python序列以及<code>ndarray</code>。</p>
<p>拼接方向上各数组长度应该相同。一维数组（向量）与向量/标量只能进行水平拼接。</p>
<h5 id="分割"><a class="header" href="#分割">分割</a></h5>
<pre><code>np.hsplit
</code></pre>
<h4 id="访问数组"><a class="header" href="#访问数组">访问数组</a></h4>
<h5 id="索引"><a class="header" href="#索引">索引</a></h5>
<p>访问数组时的下标个数应与声明时的维数（<code>ndim</code>）一致。</p>
<pre><code class="language-python">a[i] # vector
a[i,j], a[i][j] # matrix
a[(i,j)]		# matrix
</code></pre>
<blockquote>
<p>元组作为下标将被展开至每个维度，因此长度需要与矩阵维数相同。</p>
</blockquote>
<h5 id="切片"><a class="header" href="#切片">切片</a></h5>
<p>对高维数组（例如<code>3d</code>）切片时，得到的子数组元素按最低维度连续排列（<em><strong>C-style</strong></em>，反之如果是<em><strong>Fortran-style</strong></em>，则按最高维度连续排列）。</p>
<pre><code class="language-python">a[I]	# sub-array, equals to a[i,;] for 2d array or a[i,:,:] for 3d array
A[I,:]  
A[:,J] 
A[I,J] # I/J is a sequece or ndarray-vector
</code></pre>
<blockquote>
<p>下标可以是单个元素，也可以是列表，或<code>ndarray</code>向量。</p>
</blockquote>
<h5 id="迭代-1"><a class="header" href="#迭代-1">迭代</a></h5>
<pre><code class="language-python">for row in array:  # iterate by rows
  print(row)
for col in array.T: # iterate by columns
    print(col)
for a in array1d:  # iterate by elements
    print(a)
</code></pre>
<h5 id="更新"><a class="header" href="#更新">更新</a></h5>
<pre><code class="language-python">a[m:n]=x  # 修改数组内容
a[:]=a+1  # a=a+1 将使a指向新的对象
</code></pre>
<h3 id="结构数组"><a class="header" href="#结构数组">结构数组</a></h3>
<p><a href="https://numpy.org/doc/stable/user/basics.rec.html">结构数组</a>是特殊的<code>ndarray</code>，其每个元素是由不同简单类型构成的元组，元素类型具有统一的复合类型声明。</p>
<pre><code class="language-python">x = np.array([('Rex', 9, 81.0), ('Fido', 3, 27.0)],
             dtype=[('name', 'U10'), ('age', 'i4'), ('weight', 'f4')])
</code></pre>
<blockquote>
<p>其中，<code>dtype</code>声明了每个元素的各个字段名称及其类型。</p>
</blockquote>
<p>与普通数组一样，可以声明高维数组，但此时元组作为整体不再展开为<code>ndarray</code>的元素。</p>
<p>可以使用声明的字段名称访问各元素：</p>
<pre><code class="language-python">x['age'] = 10    # set all elements' age to 10
</code></pre>
<p>结构数组可以支持<code>pandas.DataFrame</code>的构造。</p>
<h3 id="稀疏矩阵"><a class="header" href="#稀疏矩阵">稀疏矩阵</a></h3>
<p><code>scipy.sparse</code>提供稀疏矩阵。</p>
<pre><code class="language-python">As = lil_matrix(D)	# construct from 2D ndarray
As = lil_matrix(As) # construct from a sparse matrix
As = lil_matrix((M,N), dtype=None) # construct empty matrix with size and type
</code></pre>
<p>稀疏矩阵类型：</p>
<div class="table-wrapper"><table><thead><tr><th>类型</th><th>说明</th></tr></thead><tbody>
<tr><td><code>lil_matrix</code></td><td>Row-based linked list sparse matrix。<br/>用于==高效地逐步构建稀疏矩阵==，但数值运算效率低，在数值运算前转换为其他类型。</td></tr>
<tr><td><code>dok_matrix</code></td><td>Dictionary Of Keys based sparse matrix.<br/>用于==高效地逐步构建稀疏矩阵==，但数值运算效率低，在数值运算前转换为其他类型。<br/>支持$O(1)$复杂度访问元素，可以高效转换为<code>coo_matrix</code>。<br />支持矩阵元素运算。</td></tr>
<tr><td><code>coo_matrix</code></td><td><code>ijv</code>三元组表示稀疏矩阵，==不支持算术运算==，用于稀疏矩阵类型间的快速转换。</td></tr>
<tr><td><code>csr_matrix</code></td><td>同类型矩阵高效地数值运算；高效地行切片。</td></tr>
<tr><td><code>csc_matrix</code></td><td>同类型矩阵高效地数值运算；高效地列切片。</td></tr>
</tbody></table>
</div>
<h5 id="compressed-sparse-row-matrix"><a class="header" href="#compressed-sparse-row-matrix">Compressed Sparse Row matrix</a></h5>
<p>表示方法（其中一种构造方法）：</p>
<pre><code class="language-python">csr_matrix((data, indices, indptr), [shape=(M, N)])
</code></pre>
<p><code>data/indices</code>是一个1D向量，分别按序储存所有行非零元素的值及其列索引；同时，<code>indptr[i:i+1]</code>则表示第<code>i</code>行非零元素的值与索引在<code>data/indices</code>中的位置。由于元素可按行快速索引，因此方便进行高效切片以及按行运算（运算结果需重新构造三个存储结构）。</p>
<p>其他构造方法：</p>
<pre><code class="language-python">csr_matrix((data, (row_ind, col_ind)), [shape=(M, N)]) # 基于ijk三元组构造
csr_matrix((M, N), [dtype]) # empty matrix
csr_matrix(D) # from dense/sparse matrix
</code></pre>
<h5 id="compressed-sparse-column-matrix"><a class="header" href="#compressed-sparse-column-matrix">Compressed Sparse Column matrix</a></h5>
<p>类似于<code>csr_matrix</code>。</p>
<p><a href="Python/Python%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA.html#%E4%BF%9D%E5%AD%98%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%84">保存和加载</a></p>
<h3 id="数组类型转换"><a class="header" href="#数组类型转换">数组类型转换</a></h3>
<h4 id="ndarray转换为其他类型"><a class="header" href="#ndarray转换为其他类型"><code>ndarray</code>转换为其他类型</a></h4>
<pre><code class="language-python">ndarray.astype(dtype, ...)
</code></pre>
<blockquote>
<p>复制数组并作元素类型转换。</p>
</blockquote>
<pre><code class="language-python">list(a)
a.tolist()
</code></pre>
<p>将矩阵转换为嵌套的列表。</p>
<h4 id="稀疏矩阵转换"><a class="header" href="#稀疏矩阵转换">稀疏矩阵转换</a></h4>
<p>稀疏矩阵可以在各类型间相互转换，根据面向的运算类型，选择合适的稀疏矩阵类型。</p>
<p>稀疏矩阵可以转换为常规矩阵。</p>
<pre><code class="language-python">A = As.todense()   # A=As.toarray(oder=None,out=None)
</code></pre>
<h2 id="表格"><a class="header" href="#表格">表格</a></h2>
<h3 id="构造对象"><a class="header" href="#构造对象">构造对象</a></h3>
<h4 id="dataframe"><a class="header" href="#dataframe">DataFrame</a></h4>
<pre><code class="language-python">df = pd.DataFrame(data=array, dtype=single_type,
                  index=index_label, columns=label_list)
df = pd.DataFrame.from_records(data, columns)
</code></pre>
<h5 id="dataframe封装的数据类型"><a class="header" href="#dataframe封装的数据类型">DataFrame封装的数据类型</a></h5>
<p><code>data</code>可以是<code>list</code>、<code>tuple</code>、<code>Series</code>及其复合类型（如<code>list_of_list</code>、<code>list_of_tuple</code>、<code>tuple_of_list</code>等）以及<code>ndarray</code>（支持结构数组）。</p>
<ul>
<li>当数据表示向量时，构造的表格为<code>Nx1</code>类型的。</li>
<li>当复合类型为字典时，等效于<code>pd.DataFrame.from_dict(*, orient='columns')</code>；</li>
<li>当字典元素的值为标量时，应为构造函数指定<code>index=[0]</code>；</li>
</ul>
<p><code>pd.DataFrame</code>的<code>dtype</code>参数只能为整个表格指定一种数据类型，可在创建后调用<code>astype</code>分别设置各列的数据类型。<code>pd.DataFrame.from_records(...)</code>可以指定每列的类型。</p>
<p><code>DataFrame</code>内部的数据存储类型为<code>numpy</code>数组，其基本数值类型为<code>numpy</code>内置类型以及<code>str</code>类型。</p>
<h5 id="以字典或列表初始化"><a class="header" href="#以字典或列表初始化">以字典或列表初始化</a></h5>
<pre><code class="language-python">df = pd.DataFrame({'col1':values1, 'col2':values2, ...}) 
df = pd.DataFrame.from_dict(
  {'col1': values1, 'col2': values2, ...}, 
  orient='columns'
)
</code></pre>
<p>字典的键作为表格的行/列索引名，值可以是<strong>序列类型</strong>（<code>list</code>、<code>tuple</code>、<code>Series</code>等），作为表格对应列的数据。<code>from_dict(...)</code>将字典的值（序列类型）转换为表格的行（<code>orient='columns'</code>，默认）或列（<code>orient='index'</code>）。</p>
<blockquote>
<p>当字典的值为标量，可使用<code>from_dict(d, orient='index')</code>得到单列的表格（不支持<code>orient='columns'</code>）。</p>
</blockquote>
<blockquote>
<p>如果字典的值为<code>Series</code>，则无法指定<code>orient=index</code>，可在按列构造后转置。</p>
</blockquote>
<pre><code class="language-python">df = pd.DataFrame.from_records(
  [
    {'col1': v1, 'col2': v2}, 
    {'col1': v1, 'col2': v2}
  ]
)
</code></pre>
<blockquote>
<p>每个记录的字段类型可以不同，缺少的字段值未<code>NaN</code>。</p>
</blockquote>
<p>Pandas也提供将<code>DataFrame</code>转换为字典或序列的方法<code>to_dict(orient='records')</code>（根据<code>orient</code>参数的值决定转换后的对象类型为字典或对象，以及具体的数据结构）。</p>
<h5 id="创建空对象"><a class="header" href="#创建空对象">创建空对象</a></h5>
<p>构造函数不传入数据，但设置行列索引（将行或列索引设置为空）。</p>
<pre><code class="language-python">index=pd.MultiIndex.from_tuples([],names=['Name', 'IP'])
df = pd.DataFrame(columns=['A', 'B', 'C'], index=index)
</code></pre>
<p>或将列设置为索引（数据为空，因此索引也为空，但设置了索引名）。</p>
<pre><code class="language-python">df = pd.DataFrame(columns=['A', 'B', 'C']).set_index(['A', 'C'], drop=False)
</code></pre>
<p>可向空对象按索引<a href="Python/Python%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.html#%E8%BF%BD%E5%8A%A0%E8%A1%8C">添加新的行</a>。</p>
<h5 id="读取数据源"><a class="header" href="#读取数据源">读取数据源</a></h5>
<p>表格通常通过从<a href="Python/Python%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA.html#%E4%BD%BF%E7%94%A8Pandas">数据源导入数据</a>的方式初始化，例如<code>read_csv</code>、<code>read_parquet</code>等。</p>
<blockquote>
<p><code>read_parquet</code>需要<code>pyarrow</code>或<code>fastparquet</code>支持。</p>
</blockquote>
<h4 id="series"><a class="header" href="#series">Series</a></h4>
<pre><code class="language-python">ss = pd.Series(data=None, index=None, dtype=None, name=None, copy=False)
ss = pd.Series(values, index=arrays)
</code></pre>
<p>一维序列。<code>copy</code>表示是否复制输入数据。</p>
<blockquote>
<p>迭代<code>Series</code>对象返回每个元素。<code>Series</code>没有列索引，因此不需要传入字典进行初始化。</p>
<pre><code class="language-python">ss = pd.Series([1, 3, 5, np.nan, 6, 8])
</code></pre>
</blockquote>
<blockquote>
<p><code>pd.Series</code>不能进行自动hash，因此无法与同样长度的元组进行比较，需要将其转换为元组再比较。</p>
</blockquote>
<h3 id="数据属性"><a class="header" href="#数据属性">数据属性</a></h3>
<p><code>shape</code>：行列数。</p>
<p><code>size</code>：元素总数。</p>
<p><code>empty</code>：==数据表是否为空==。</p>
<blockquote>
<p><code>values</code>：推荐使用 <code>.array()</code> or <code>.to_numpy()</code></p>
</blockquote>
<pre><code class="language-python">df.info(memory_usage='deep', show_counts=True)
df.memory_usage(index=True, deep=False)  # sys.getsizeof(df)
</code></pre>
<h5 id="series属性"><a class="header" href="#series属性"><code>Series</code>属性</a></h5>
<pre><code class="language-python">ss.shape         # 行数
ss.is_monotonic  # =&gt; is_monotonic_increasing
ss.is_unique
ss.hasnans
</code></pre>
<h4 id="列数据类型"><a class="header" href="#列数据类型">列数据类型</a></h4>
<p><code>df.dtypes</code>：每列的数据类型。</p>
<pre><code class="language-python">y = df.astype(dtype, copy=True)		# 转换整个数据表
# 转换指定列的类型
y = df.astype({col1:dtype1,col2:dtype2,...}, copy=True, errors='raise') 
</code></pre>
<blockquote>
<p><code>copy</code>和其他方法的<code>inplace</code>意义不同，此处总是返回新的表格。</p>
<p>如果列名和类型分别为序列，首先将其<a href="Python/Python%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.html#%E5%AE%9A%E4%B9%89%E5%AD%97%E5%85%B8">转换为字典</a>。</p>
</blockquote>
<p>将数据类型转换为支持<code>pd.NA</code>的最可能类型。</p>
<pre><code class="language-python">df.convert_dtypes(
   infer_objects=True,   # 将object类型转换为最合适类型
   convert_string=True,  # 将object类型转换为StringDtype
   convert_integer=True, # 尽可能转为为pandas整数类型
   convert_boolean=True, # 尽可能转为为BooleanDtype
   convert_floating=True # 尽可能转为为pandas浮点数类型（优先转换为整数）
)
df.infer_objects()  # 推断最合适的列数据类型
</code></pre>
<h5 id="时间日期序列类型"><a class="header" href="#时间日期序列类型">时间日期序列类型</a></h5>
<p><code>pd.Timestamp</code>使用NumPy <code>datetime64</code> and <code>timedelta64</code> dtypes。<a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html">Time series / date functionality — pandas 1.3.0 documentation (pydata.org)</a></p>
<blockquote>
<p>当对时间类型的列复制为非时间类型数据，如时间文本或时间戳数值，==其结果会自动转换为时间类型==。时间类型字段也可以和时间文本或时间戳数值自动比较。</p>
</blockquote>
<h3 id="概览数据"><a class="header" href="#概览数据">概览数据</a></h3>
<p>可以直接打印（<code>print</code>），Pandas根据窗口控件对部分内容进行省略（可以<a href="Python/Python%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA.html#%E8%A1%A8%E6%A0%BC%E8%BE%93%E5%87%BA">控制终端显示内容</a>）。</p>
<pre><code class="language-python">df.head(n=5)		# return the first n rows
df.tail()
print(df.to_string(index=True, header=True))  # remove dtype/header/index info
</code></pre>
<blockquote>
<p>终端会自动回显方法返回的值，在脚本中必须使用<code>print</code>。</p>
</blockquote>
<h3 id="索引-1"><a class="header" href="#索引-1">索引</a></h3>
<h4 id="index"><a class="header" href="#index">Index</a></h4>
<p>表示（行/列）索引的数据类型。</p>
<pre><code class="language-python">index = pd.Index(['e', 'd', 'a', 'b'])
index = pd.Index(list(range(5)), name='rows')
columns = pd.Index(['A', 'B', 'C'], name='cols')
</code></pre>
<p><code>Index</code>可以被视为特殊类型的<code>Series</code>，因此<code>Series</code>多数属性、方法也适用于<code>Index</code>。</p>
<pre><code class="language-python">df.index						# 获取DataFrame的索引
index.name          # 索引的名称
index.has_duplicates
index.is_all_dates
</code></pre>
<pre><code class="language-python">loc = index.get_loc(key)
</code></pre>
<blockquote>
<p>Return <em>int if unique index, slice if monotonic index, else mask</em>. </p>
</blockquote>
<p><code>nan</code>不影响<em>unique index</em>的统计（包含多个<code>nan</code>的索引调用<code>get_loc()</code>时仍返回的是标量）。</p>
<p><a href="https://zhuanlan.zhihu.com/p/86042616">Index索引的用途总结</a>：</p>
<ul>
<li>更方便的数据查询（<code>df.loc[index]</code>）；</li>
<li>使用index可以获得性能提升：对于唯一的index使用hash表查找，对于有序index使用二分法查找；</li>
<li>自动的数据对齐功能（进行序列或表格运算时，非公共的index对应的数据计算结果为<code>Nan</code>）；</li>
<li>更多更强大的数据结构支持，包括<code>Categoricallndex</code>、<code>Multilndex</code>、<code>Datetimeindex</code>等；</li>
</ul>
<h4 id="索引类型"><a class="header" href="#索引类型">索引类型</a></h4>
<h5 id="数值索引"><a class="header" href="#数值索引">数值索引</a></h5>
<h5 id="类别索引"><a class="header" href="#类别索引">类别索引</a></h5>
<h5 id="时间索引"><a class="header" href="#时间索引">时间索引</a></h5>
<p><code>DatetimeIndex</code>以时间点为数据点。可从时间数据、<a href="Python/Python%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.html#%E5%8C%BA%E9%97%B4%E7%B4%A2%E5%BC%95">周期索引转换</a>构造、或者按规则构造。从时间数据（<a href="Python/Python%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.html#%E6%97%B6%E9%97%B4%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2">文本表示或时间戳表示</a>）构造索引：</p>
<pre><code class="language-shell">dt_index = pd.to_datetime(
	ts_data, 
	utc=False,                       # True=&gt;为时间添加时区信息(UTC+00:00)
	unit='s',                        # unit='s'|'ms'|'ns'转换数值类型
	format=None,                     # strftime格式转换字符类型
	exact=True,
	dayfirst=False, yearfirst=False, # 推测格式
	infer_datetime_format=False,     # True-&gt;format优先级比自动推测更高
) # 返回值与输入对应： 
# -&gt; list-like: DatetimeIndex
# -&gt; Series: Series of datetime64 dtype
# -&gt; scalar: Timestamp (pd.Timestamp)
dt_index = pd.DatetimeIndex(datetime_data)    
</code></pre>
<p><code>ts_data</code>为<code>datetime</code>类型的数据或表示时间的字符串构成的序列类型。如果原数据未包含时区信息，则<a href="Python/Python%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.html#pandas.Timestamp%E7%B1%BB%E7%9A%84%E6%97%B6%E5%8C%BA">采用默认时区，但无法转换为其他时区</a>(需要调用<code>tz_localize</code>)。<code>DatetimeIndex</code>和<code>PeriodIndex</code>可直接调用<code>tz_localize</code>和<code>tz_convert</code>，但元素类型为<code>Timestamp</code>或<code>Period</code>的序列无法直接调用（需要使用<code>apply</code>方法对每个元素分别<a href="Python/Python%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.html#pandas.Timestamp%E7%B1%BB%E7%9A%84%E6%97%B6%E5%8C%BA">转换时区</a>）。</p>
<p>构造<strong>周期性</strong>时间索引：</p>
<pre><code class="language-python">datetime_index = pd.date_range(
  start=None, end=None, periods=None, freq=None, 
  tz=None, normalize, name, closed)
</code></pre>
<p><code>start, end</code>：起始和结束时间（<code>str|datetime</code>）；
<code>periods</code>：生成的点数；
<code>freq</code>：时间间隔，如<code>5H</code>。==以上四个参数仅需指定三个==（剩余一个可推测）。</p>
<blockquote>
<p>单位标识如下：</p>
<div class="table-wrapper"><table><thead><tr><th>年</th><th>季</th><th>月</th><th>周</th><th>日</th><th>时</th><th>分</th><th>秒</th><th>毫秒</th></tr></thead><tbody>
<tr><td><code>Y</code></td><td><code>Q</code></td><td><code>M</code></td><td><code>W</code></td><td><code>D</code></td><td><code>H</code></td><td><code>T</code></td><td><code>S</code></td><td><code>L</code></td></tr>
</tbody></table>
</div>
<p>前缀<code>B</code>：仅计算工作时间，默认单位为天（<code>+MQY</code>）；<code>CB</code>：自定义工作时间；
后缀<code>S</code>：以周期开始作为记录点（无后缀代表以结束为记录点，<code>+MQY</code>）；
前缀<code>S</code>(semi)：以半周期为记录点（只用于<code>M</code>，可与其他前后缀组合使用）。</p>
</blockquote>
<p><code>tz</code>：<a href="Python/Python%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.html#%E6%97%B6%E5%8C%BA%E8%BD%AC%E6%8D%A2">时区</a>，缺少时区设置则采用计算机本地时区。
<code>normalize=True|False</code>：将起点和终点对齐当天午夜零点。
<code>name</code>：索引的列名。
<code>closed=None|'left'|'right'</code>：索引区间的开闭，默认为全闭。</p>
<h5 id="区间索引"><a class="header" href="#区间索引">区间索引</a></h5>
<pre><code class="language-python">pd.IntervalIndex.from_arrays(left, right, closed='left|right|both|neither')
pd.IntervalIndex.from_breaks([0, 1, 2, 3], ...)
pd.IntervalIndex.from_tuples([(0, 1), (1, 2)], ...)
</code></pre>
<blockquote>
<p><code>pandas.Interval(left, right, colsed='right')</code>表示区间，<code>left</code>和<code>right</code>表示可比较大小的数值类型、<code>pd.Timestamp</code>以及<code>pd.Timedelta</code>（不支持<code>dt.datetime</code>和<code>dt.timedelta</code>）。</p>
</blockquote>
<p><strong>时间区间索引</strong>：<code>PeriodIndex</code>以==固定周期==的<a href="Python/Python%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.html#%E6%97%B6%E9%97%B4%E6%AE%B5">时间段</a>索引数据。<code>pandas.IntervalIndex</code>也可使用<code>datetime</code>作为元素表示时间区间。</p>
<pre><code class="language-python">pi_index = pd.period_range(start, end, periods, freq, name) # ==&gt; date_range
pi_index = pd.PeriodIndex(period_list, freq=&quot;M&quot;)
</code></pre>
<h6 id="部分索引"><a class="header" href="#部分索引">部分索引</a></h6>
<p>对于<code>DatetimeIndex</code>和<code>PeriodIndex</code>，可传入<code>datetime</code>或<code>str</code>表示时间日期的高位部分以索引相应时间的数据。</p>
<pre><code class="language-python">ss.loc['2020-01']
ss.loc[dt.datetime(2011, 12, 25):]
ss[&quot;10/31/2011&quot;:&quot;12/31/2011&quot;]
</code></pre>
<p>时间索引和区间索引的相互转换：</p>
<pre><code class="language-python">dt_index.to_period()     # &lt;==&gt; pi_index.to_timestamp()
</code></pre>
<h4 id="multiindex"><a class="header" href="#multiindex">MultiIndex</a></h4>
<p>通常使用辅助函数创建<code>MultiIndex</code>。</p>
<pre><code class="language-python">from pandas import MultiIndex
MultiIndex.from_arrays(list_of_arrays) # 每个数组为一级索引
MultiIndex.from_tuples(list_of_tuples) # 每个元组为一行索引
MultiIndex.from_product([('a','b'),(1,2),...]) # cross product
MultiIndex.from_frame(...)  # from DataFrame
</code></pre>
<p><code>from_product</code>适用于多个索引具有层级关系的情况（先给出的索引为高层级，在生成的索引中是连续相同的）。</p>
<p>以上方法的其他参数：</p>
<ul>
<li><code>names=['first', 'second']</code>多级索引的名称；使用<code>index.names</code>查看索引名称；多级索引的<code>index.name</code>为<code>None</code>。</li>
<li><code>sortorder=i|None</code>：指定用于排序的索引级别。</li>
</ul>
<p>创建<code>DataFrame</code>时，可通过<code>index</code>参数提供原始数据直接创建<code>MultiIndex</code>，或通过<code>set_index</code>来创建。</p>
<h4 id="表格索引操作方法"><a class="header" href="#表格索引操作方法">表格索引操作方法</a></h4>
<p><code>df.columns</code>：类型为<code>Index</code>，获取或设置列索引名称，<code>Series</code>不存在列索引。</p>
<p><code>df.index</code>：获取或设置行索引名。</p>
<pre><code class="language-python">df.columns = ['A', 'B', 'C', ...]  # 整体修改
df.rename(columns={&quot;A&quot;: &quot;a&quot;, &quot;B&quot;: &quot;c&quot;}, 
          errors='raise'|'ignore', inplace=False) # 替换修改
df.rename(index={0: &quot;x&quot;, 1: &quot;y&quot;, 2: &quot;z&quot;})  
ss.rename(index='name') # ss.name='Name', 使用标量或hashable序列（元组）修改名称  
ss.rename(index = dict_map_func)  # 修改序列索引
</code></pre>
<p>设置行列索引的名称（<code>index.name</code>或<code>index.names</code>）：</p>
<pre><code class="language-python">df.rename_axis(index='index_axis_name', columns='col_axis_name')
</code></pre>
<blockquote>
<p>当存在多个行列标签时，以字典给出新旧名称的映射。</p>
<p>当打印表格时，行列索引名如果不为空将显示在左上角单元格。</p>
</blockquote>
<h5 id="设置索引"><a class="header" href="#设置索引">设置索引</a></h5>
<p>使用指定的一列/或多列数据设置为索引。</p>
<pre><code class="language-python">df.index = data
df.set_index(keys, drop=True, inplace=False)		# 添加新的索引项
</code></pre>
<p><code>keys</code>：如果为列名，则使用对应列移至索引列，索引列名称为对应列名；如果为与表格长度相同的列（包括<code>Series</code>、<code>Index</code>、<code>np.ndarray</code>、<code>Iterator</code>），则设置默认的索引列（无索引列名）；也可以是以上两者组合的列表（设置多重索引）。</p>
<p><code>drop</code>：默认移除作为索引的列，反之移保留为索引的列；</p>
<h5 id="重置索引"><a class="header" href="#重置索引">重置索引</a></h5>
<p>设置为数字索引。</p>
<pre><code class="language-python">df.reset_index(drop=False, inplace=False)				
</code></pre>
<p><code>drop</code>：默认将原有索引设置为新的列（<strong>首列</strong>），反之移除原有索引；</p>
<p><code>inplace</code>：默认返回新的对象，反之对源对象进行修改。</p>
<h5 id="修改多级索引"><a class="header" href="#修改多级索引">修改多级索引</a></h5>
<p>移除数据表指定级的索引：</p>
<pre><code class="language-python">df=df.droplevel(level:Union[int,str,list], axis=0)
</code></pre>
<blockquote>
<p><code>MultiIndex.droplevel</code>功能相同，返回修改后的索引。</p>
</blockquote>
<p>The <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.MultiIndex.swaplevel.html#pandas.MultiIndex.swaplevel"><code>swaplevel()</code></a> method can switch the order of two levels。</p>
<h3 id="访问数据"><a class="header" href="#访问数据">访问数据</a></h3>
<p><strong>下标运算符<code>[]</code>和成员运算符<code>.</code></strong>：接受标签或切片对象作为参数。</p>
<blockquote>
<p>使用<code>.</code>时，标签/列名需要是合法的Python标识符。</p>
</blockquote>
<pre><code class="language-python">ss = df[colname]			# return Series corresponding to colname
ss = df.&lt;column_name&gt; # column_name必须是合法标识符。
</code></pre>
<blockquote>
<p>可以使用列表传递多个列的名称<code>df_sub = df[names]</code>，返回表格的子集。</p>
</blockquote>
<p><code>Series</code>的参数为行索引，而非列名（<code>Series</code>无列名）。</p>
<pre><code class="language-python">x = ss[index_labels]	# return sca lar/Series value via index labels
x = ss.&lt;index_name&gt;
</code></pre>
<h4 id="访问数据切片"><a class="header" href="#访问数据切片">访问数据切片</a></h4>
<pre><code class="language-python">s1 = ss[i:j:s]    # s not included
d1 = df[i:j:s]		# slicing rows
</code></pre>
<blockquote>
<p>仅支持<code>:</code>操作符构造的参数（与Python规则一致），不支持列表作为参数（会被视为列标签）</p>
</blockquote>
<h5 id="loc属性"><a class="header" href="#loc属性"><code>loc</code>属性</a></h5>
<p>参数为标签，或<code>boolean</code>向量。</p>
<blockquote>
<p>提供的参数与数据表标签类型不一致会导致报错。</p>
</blockquote>
<pre><code class="language-python">s.loc[index_labels]				      # Series
df.loc[row_labels,column_names] # DataFrame
</code></pre>
<p>标签表示方法包括：</p>
<ul>
<li>
<p>单个标签：例如<code>5</code>、<code>a</code>等；</p>
</li>
<li>
<p>序列：<code>['a', 'b', 'c']</code>；</p>
</li>
<li>
<p>切片对象：<code>'a':'f'</code>、<code>'d':</code>等，与下标不同，==<code>end</code>包含在内==；</p>
</li>
<li>
<p><code>boolean</code>向量</p>
<p>可以使用<code>query(expr)</code>代替<code>boolean</code>表达式（不能使用<code>1</code>和<code>0</code>分别代表<code>True</code>和<code>False</code>，前者会直接被当作索引处理）。</p>
</li>
</ul>
<blockquote>
<p><code>loc</code>属性和<code>[]</code>运算符可以增大数据表，方便增添数据。</p>
<p><code>df.loc[row_labels,:]</code>等价于<code>df.loc[row_labels]</code>。</p>
<p>返回值为单个元素时，如果参数为标量对象则返回标量，如果参数包含列表类型（即使仅有一个元素），则返回值为<code>Series</code>。</p>
<p>返回值为向量时，如果参数为标量，则返回值构成<code>Series</code>，反之（即使仅有一列）构成<code>DataFrame</code>。</p>
</blockquote>
<p>以切片索引访问表格时总是返回表格类型，而当行列索引为标量时，返回值类型会转换为<code>Series</code>；以当给定的切片索引范围不在表格内时，对应索引会被忽略；给定单个索引不在表格内则会报错。</p>
<pre><code class="language-python">x = df.loc[i:j]  # x always be DataFrame
x = df.loc[i]    # x becomes Series if i is scalar
</code></pre>
<h5 id="iloc属性"><a class="header" href="#iloc属性"><code>iloc</code>属性</a></h5>
<p>参数基于整数位置（下标，和Python，Numpy的语法一致），或<code>boolean</code>向量。</p>
<blockquote>
<p>参数表示方式对返回值的类型影响与<code>.loc</code>一致。</p>
</blockquote>
<pre><code class="language-python">s0 = s.iloc[indices]
df.iloc[row_indices, col_indices]
</code></pre>
<p>下标表达方式包括：</p>
<ul>
<li>
<p>标量整数；</p>
</li>
<li>
<p>整数列表；</p>
</li>
<li>
<p>切片对象；</p>
</li>
<li>
<p><code>boolean</code>向量：<strong>查询数据表返回的表达式（例如<code>df['A']&gt;0</code>）为<code>Series</code>，不能直接用于<code>iloc</code>的下标参数</strong>，代替方法可以先将返回值转换为矩阵：</p>
<pre><code class="language-python">df['A'].to_numpy()&gt;0      # or
((df['A'])&gt;0).to_numpy()
</code></pre>
</li>
</ul>
<blockquote>
<p><code>ix</code> is deprecated.</p>
</blockquote>
<h4 id="访问单个元素"><a class="header" href="#访问单个元素">访问单个元素</a></h4>
<p>通过简化下标的判断和处理，访问速度比通过切片接口<code>loc</code>和<code>iloc</code>更快，仅限访问一行一列的单个元素。</p>
<pre><code class="language-python">df.at[label, column_name] # s.at[label]  # label based
df.iat[row_idx, col_idx]  # s.iat[index] # integer based
</code></pre>
<h4 id="多级访问"><a class="header" href="#多级访问">多级访问</a></h4>
<p>当传入单个索引时，可仅指定条目的部分索引（编号最小的索引）。</p>
<pre><code class="language-python">df.loc[l1_key, cols]     # access data with only level-1 index labels
df.loc[(l1_key, l2_key)] # access data with both 2-level index labels
df.loc[(l1_key, l2_key), cols]  # with column labels
df.loc[index, :]         # 使用索引对象访问数据
# .loc does not accept access directly via level-2 index labels
df.xs(idx, level=idx_name)  # direct &quot;read&quot; any index level
</code></pre>
<blockquote>
<p><em>indexing past lexsort depth may impact performance</em>：当<a href="Python/Python%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.html#%E7%B4%A2%E5%BC%95%E6%8E%92%E5%BA%8F">索引未排序</a>时可能产生以上警告。</p>
</blockquote>
<p>当传入单个索引时，取回内容会<strong>自动去掉传入层级的索引</strong>，因此可以使用链式访问方式：</p>
<pre><code class="language-python">df.loc[l1_key][cols]
df.loc[l1_key].loc[l2_key]  # chaining access
</code></pre>
<p>如果要同时访问多个条目，则必须提供每个层级完整的索引。可将索引封装为元组序列，或者将每一级索引单独提供：</p>
<pre><code class="language-python">df.loc[[(id1,id2,...),(id1,id2,...),...],cols] # list of tuple index
df.loc[l1_idx, l2_idx, :, ...][cols] # separate index
</code></pre>
<p>当单独提供每一级索引时，不能同时包含列名，因此需要链式访问方式提供列名。</p>
<p>https://pandas.pydata.org/pandas-docs/stable/user_guide/advanced.html</p>
<p>获取部分索引：</p>
<pre><code class="language-python">idx = df.index.get_level_values(level_name)  # get index of specified level
idx = df.index.droplevel(level_name)  # drop index of specified level
</code></pre>
<p>获取某一级索引对应的下标：</p>
<pre><code class="language-python">df.index.get_loc_level(idx)  # return (tf_values, loc)
</code></pre>
<h4 id="赋值"><a class="header" href="#赋值">赋值</a></h4>
<p>可以将<code>Series</code>对象赋值给<code>DataFrame</code>的行或列，无需保证两者的索引一致。</p>
<ul>
<li>仅<code>Series</code>对象和<code>DataFrame</code>对象的公共索引元素被赋值；</li>
<li>未包含在<code>DataFrame</code>的索引所对应的元素被忽略；</li>
<li><code>DataFrame</code>中存在而<code>Series</code>对象中不存在的索引赋值为<code>NaN</code>。</li>
</ul>
<p>当赋值使表格<a href="Python/Python%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.html#%E6%96%B0%E5%A2%9E%E8%A1%8C%E5%88%97">新增行列</a>时，可以使用字典对表格进行赋值（不能使用字典对已有行赋值，会将字典的键名而非值传递给表格），字典的字段必须与表格行/列匹配。</p>
<h4 id="索引赋值"><a class="header" href="#索引赋值">索引赋值</a></h4>
<p>直接将表格对象赋值给另一个变量是浅拷贝（引用类型默认行为）。</p>
<h5 id="settingwithcopywarning"><a class="header" href="#settingwithcopywarning">SettingWithCopyWarning</a></h5>
<blockquote>
<p><em>pandas/core/indexing.py/_LocationIndexer/__setitem__</em>
<em>pandas/core/indexing.py/_iLocIndexer/__setitem_with_single_block</em>
<em>pandas/core/generic.py/NDFrame/_check_is_chain_assignment</em>
<em>pandas/core/generic.py/NDFrame/_check_set_item_copy</em></p>
</blockquote>
<p>对<code>DataFrame</code>进行索引时返回视图或新对象的情况比较复杂。<code>pandas</code>使用内部变量记录下表格（<code>_is_view</code>和<code>_is_copy</code>）生成的方式，从而在对新对象赋值时给出相应的警告<code>SettingWithCopyWarning</code>，从而避免用户对数据进行误操作。</p>
<h6 id="显式链式索引赋值-chained-assignment"><a class="header" href="#显式链式索引赋值-chained-assignment">显式链式索引赋值 (Chained assignment)</a></h6>
<p>链式索引赋值的首个索引运算符可能会返回新对象，导致后续的索引赋值运算不会作用在原对象上，这可能与用户的意图不符，因此<code>Pandas</code>会给出警告。</p>
<pre><code class="language-python">df[row_indices][cols]=value
df.loc[row_indices[,col_indices]][cols]=value
</code></pre>
<p>避免这种警告的方式就是将链式索引更改为<code>.loc</code>索引，从而实现一次索引赋值运算：</p>
<pre><code class="language-python">df.loc[row_slice, cols] = value
</code></pre>
<h6 id="隐式链式索引赋值"><a class="header" href="#隐式链式索引赋值">隐式链式索引赋值</a></h6>
<p>被索引的对象可能是先前代码（或方法传入参数）中通过索引得到的子表格，子表格的构造方式（视图/实例）对于当前代码而言未知（即使用户自己生成的子表格，也难以判断其构造方式）。因此后续的索引赋值也难以判断其是更改的新对象或原始对象，因此<code>Pandas</code>会根据内部变量状态给出警告。</p>
<blockquote>
<p>传入函数的表格对象通常不要对其进行修改，如果有修改应该利用返回值返回，以提示该对象做了修改。</p>
</blockquote>
<pre><code class="language-python">df1 = df[row_indices]   # df2 = df.loc[row_indices]
df1.loc[idx] = value
</code></pre>
<p>消除警告的方式是用户主动断开隐式的索引链，即在先前代码生成子表格（或传入参数）时进行拷贝。==即如果预计到要对某个子表格做更改，则使用<code>copy()</code>方法复制得到子表格，反之则使用索引得到的对象。==</p>
<pre><code class="language-python">df1 = df[row_indices].copy()   # df2 = df.loc[row_indices]
df1.loc[idx] = value
</code></pre>
<blockquote>
<p>索引总是浅拷贝，因为索引为不可变对象，更新索引时总是创建新的对象，所以浅拷贝是安全的。</p>
</blockquote>
<h4 id="迭代-2"><a class="header" href="#迭代-2">迭代</a></h4>
<p>按列/行以此访问表格。</p>
<pre><code class="language-python">for col_name in df:			# iterate column names
  print(df[col_name])
for label, series_column in df.iteriterms():  # df.iterms(), df.iterrows()
  print(label)
  print(series_column)
</code></pre>
<h4 id="查询筛选"><a class="header" href="#查询筛选">查询筛选</a></h4>
<h5 id="查找"><a class="header" href="#查找">查找</a></h5>
<p><code>isin()</code>查询<code>Series</code>或<code>DataFrame</code>每个元素是否在指定集合中。</p>
<pre><code class="language-python">df_tf = df.isin(values:[iterable,Series,DataFrame,dict])
</code></pre>
<blockquote>
<p><code>in</code>运算符返回前置运算数是否在后置运算数（集合）中。</p>
<p><code>==</code>要求运算对象的维度兼容，而<code>isin</code>不限制参数类型。</p>
</blockquote>
<p>查找<code>Series</code>或<code>DataFrame</code>是否包含某个索引：</p>
<pre><code class="language-python">tf = idx in ss  # =&gt; idx in ss.index
tf = idx in df  # =&gt; idx in df.columns
</code></pre>
<p>查找满足条件的行列：</p>
<pre><code class="language-python">tf_mask = df[col_name]==value # return Series
idx = df.index[tf_mask]		# return index as Index
idx = np.where(tf_mask)[0]    # as ndarray-vector
idx = np.argwhere(tf_mask.to_numpy()).reshape(2)
ss.argmin()   # ss.argmax() 仅适用于数值, see also np.argmin(a)
</code></pre>
<p>获取满足条件的子表格：</p>
<pre><code class="language-python">s = df.loc[tf_mask,'colname'] # return filtered value: 
s = df.loc[idx, 'colname']
</code></pre>
<p>基于标签查找对应元素。</p>
<pre><code class="language-python">a = df.lookup(row_labels, col_labels) # -&gt; array([df.loc[row_label,col_label]])
</code></pre>
<h5 id="表达式查找"><a class="header" href="#表达式查找">表达式查找</a></h5>
<p><code>df.query(expr)</code>根据表达式的值筛选表格。表达式语法格式：</p>
<ul>
<li>普通标识符表示数据中的列名，特殊列名使用<code>`First Name`</code>表示；</li>
<li>全局空间中的变量名使用<code>@var</code>引用；</li>
<li>字面值与Python语法一致；</li>
</ul>
<pre><code class="language-shell">s = df.query('col_name==&quot;gary&quot; &amp; value == 10')
</code></pre>
<h5 id="boolean-reduction"><a class="header" href="#boolean-reduction">Boolean Reduction</a></h5>
<pre><code class="language-python">df.all(axis=[0,1,None])  # see also df.any()
df.isna().all(axis=0)  # 判断列是否全为Nan
</code></pre>
<h5 id=""><a class="header" href="#"></a></h5>
<h3 id="编辑"><a class="header" href="#编辑">编辑</a></h3>
<h4 id="替换"><a class="header" href="#替换">替换</a></h4>
<pre><code class="language-python">df.where(df_mask, new_value=nan)# replace with new_value where df_mask is true 
</code></pre>
<blockquote>
<p>不像<code>np.where()</code>返回下标。</p>
</blockquote>
<pre><code class="language-python">df.replace(to_replace=None, value=None, regex=False, inplace=False, limit=None)
</code></pre>
<p><code>to_replace</code>：数值类型、字符串、正则表达式（<code>regex=True</code>）以及</p>
<ul>
<li>列表类型：与<code>value</code>类型长度==兼容==；</li>
<li>字典类型：<code>to_replace.key()</code>==限定查找的列==，<code>.value()</code>为查找的值，<code>value</code>参数对应替换内容（字典类型提供其他参数表达方式，但与分参数传递重复）。</li>
</ul>
<p><code>value</code>：除了普通值外，接受正则表达式中的替换命令。</p>
<h4 id="新增行列"><a class="header" href="#新增行列">新增行列</a></h4>
<p><strong>新增行列开销较大，不适合大型数据表格。</strong></p>
<h5 id="新增列"><a class="header" href="#新增列">新增列</a></h5>
<pre><code class="language-python">df = df.assign(colname=values,...)  # 添加一个或多个新列（colname）
df[new_cols] = values               # scalar|vector|array =&gt; df.loc[:, newcols]
</code></pre>
<h5 id="插入列"><a class="header" href="#插入列">插入列</a></h5>
<pre><code class="language-python">df.insert(col_loc, colname:str, value:Union[int,ndarray,Series])
</code></pre>
<p><code>loc</code>为插入列的位置，<code>colname</code>为插入列的名称，<code>value</code>为插入列的值。==插入操作更新当前对象==。</p>
<p>==插入操作一次只能插入一列==，如果要插入多列可逐次插入或使用拼接方式。</p>
<pre><code class="language-python">for col in reversed(new_frame.columns): 
   df.insert(insert_loc, col, new_frame[col])
df = pd.concat([df.iloc[:,:insert_loc], new_frame, df.iloc[:,insert_loc]], axis=1)
</code></pre>
<h5 id="追加行"><a class="header" href="#追加行">追加行</a></h5>
<pre><code class="language-python">df.loc[index]=values          # values可为标量或规格相同的向量
df.loc[index, cols] = values  # 未指定的列值为NaN
</code></pre>
<p>当指定的<code>index</code>不存在于表格时，新增一行；==只能一次新增一行==，尝试提供多个不存在的索引会提示<code>KeyError: 'Non of [label] are in the index'</code>。</p>
<blockquote>
<p>当索引为连续整数，令<code>index=df.shape[0]</code>可使==增加的行索引保持连续==；使用<code>index=-1</code>将添加<code>-1</code>作为索引（而不是在表格末尾自动增加索引编号）。</p>
</blockquote>
<p>如果是<code>MultiIndex</code>，则不能省略列索引参数（可使用<code>:</code>代替列名），否则无法正确识别索引。<strong>注意</strong>：<code>df.loc[index,:]=values</code>默认会自动将数值类型转换为<code>float64</code>，当新增数据后需要使用<code>astype</code>将数据类型转换为预期类型。</p>
<p><code>df.loc</code>在原数据表上修改，<code>df.append()</code>返回新的数据表。</p>
<pre><code class="language-python">df = df.append(other_df_ss_dict, ignore_index=False)  #追加表格、行或字典表示的行
</code></pre>
<p>当<code>ignore_index=True</code>时（重置索引为<code>RangeIndex</code>），可以追加一个<code>Series</code>或<code>dict</code>作为新的行，或追加一个序列的上述对象以追加多行记录。</p>
<h5 id="扩展表格"><a class="header" href="#扩展表格">扩展表格</a></h5>
<pre><code class="language-python">df.at[row_idx,col_idx] = value # scalar
</code></pre>
<blockquote>
<p>可同时扩展多列，但类似于<code>loc</code>，一次只能增加一行（即只提供单个行索引）。</p>
<p><code>iloc</code>、<code>iat</code>无法新增数据（<code>out-of-bounds</code>）。</p>
</blockquote>
<h5 id="explode"><a class="header" href="#explode">Explode</a></h5>
<p>指定列的元素如果为序列类型，将其展开为多行，同一行其他列的值复制原有值。</p>
<pre><code class="language-python">df.explode(column:str, ignore_index=False)  # simliar for Series
#            A  B           A  B
# 0  [1, 2, 3]  a  =&gt;  0    1  a   # 将序列元素转换为多行
#                      0    2  a
#                      0    3  a
# 1        foo  b  =&gt;  1  foo  b   # 标量元素不变
# 2         []  c  =&gt;  2  NaN  c   # 空序列变换为np.nan
</code></pre>
<h4 id="移除行列"><a class="header" href="#移除行列">移除行列</a></h4>
<h5 id="按索引移除行列"><a class="header" href="#按索引移除行列">按索引移除行列</a></h5>
<pre><code class="language-python">pd.drop(labels=None, axis=0, index=None, columns=None,inplace=False)
</code></pre>
<p><code>labels</code>和<code>axis</code>组合使用，以确定<code>labels</code>代表的是行/列索引；或者可以同时指定<code>index</code>和<code>columns</code>以删除指定行列。</p>
<blockquote>
<p><code>labels</code>、<code>index</code>、<code>columns</code>是标量或列表类似结构（不能是元组）。</p>
</blockquote>
<h5 id="按索引保留行列"><a class="header" href="#按索引保留行列">按索引保留行列</a></h5>
<p>按照给定的索引标签顺序重排表格内容。未给出的索引对应的表格行列将被丢弃，新增的索引对应的行列将填充指定的值<code>fill_value</code>。</p>
<pre><code class="language-python">df_new = df.reindex(labels, axis={'index'|'columns'}, fill_value=nan, ...)  # axis选择行/列索引
df_new = df.reindex(index=idx_labels, columns=colnames, copy=True, ...)  # 直接以关键字给出行列索引
</code></pre>
<blockquote>
<p><code>copy=True</code>将返回新的表格对象。</p>
</blockquote>
<h5 id="移除重复行列"><a class="header" href="#移除重复行列">移除重复行列</a></h5>
<p>重复行：</p>
<pre><code class="language-python">tf = df.duplicated(subset=cols, keep='first')
df.drop_duplicates(...,inplace=False,ignore_index=False)
tf = ss.duplicated(keep)
</code></pre>
<p><code>keep='first'|'last'|False</code>：<code>first</code>将第一行以外的重复项标记为True。</p>
<p>移除重复列：将底层数据转职并检查其中的重复行。</p>
<pre><code class="language-python">df.loc[:,~df.T.duplicated(keep='first')]
</code></pre>
<h4 id="表格排序"><a class="header" href="#表格排序">表格排序</a></h4>
<h5 id="索引排序"><a class="header" href="#索引排序">索引排序</a></h5>
<p>按照索引标签对表格的行/列排序：</p>
<pre><code class="language-python">df.sort_index(axis=0, ascending=True, inplace=False)
</code></pre>
<p><code>axis</code>指定按行/列排序，<code>ascending</code>指定升序/降序。</p>
<h5 id="数值排序"><a class="header" href="#数值排序">数值排序</a></h5>
<p>按照行/列的值对表格排序：</p>
<pre><code class="language-python">df.sort_values(by, axis=0, ascending=True, inplace=False)
ss.sort_values(...)  # 无需指定排序的列，使用数据列排序
</code></pre>
<p><code>DataFrame</code>的排序参考为表格的一个或多个列，由<code>by</code>指定。</p>
<p>判断数据是否有序：</p>
<pre><code class="language-python">pd.Index(data).is_monotonic   // or Series
</code></pre>
<h3 id="表格对象操作"><a class="header" href="#表格对象操作">表格对象操作</a></h3>
<p>表格操作只能返回新的对象。</p>
<pre><code class="language-python">df_t = df.T		# 返回表格的转置
</code></pre>
<h4 id="拼接-1"><a class="header" href="#拼接-1">拼接</a></h4>
<p>拼接数据表或序列。</p>
<pre><code class="language-python">df_new = pd.concat([df1, df2, s1, ...], axis=0, join='outer', ignore_index=False,...)
</code></pre>
<p><code>axis</code>：<code>0</code>表示沿行索引方向拼接，<code>1</code>表示按列索引方向拼接；==当指定<code>axis=1</code>时，<code>DataFrame</code>与<code>Series</code>可按列拼接==。</p>
<p><code>join</code>：<code>'inner'</code>表示取非拼接方向索引的<strong>交集</strong>，<code>‘outer</code>表示取索引的<strong>并集</strong>（缺失数据填充为<code>NaN</code>）（==只支持两种方式==，其他合并方式使用<code>merge</code>或<code>join</code>）；</p>
<p><code>ignore_index</code>：如果为<code>True</code>则忽略在==拼接方向==上原有的索引，以<code>0,1,2,...</code>代替；</p>
<p><code>keys</code>：追加最外层的索引（每个组成表格对应相同的索引元素）。当沿列索引方向拼接时，<code>keys</code>将替换相应数据表的列标签。</p>
<blockquote>
<p>性能问题：创建新的数据表对象设计大量数据复制，因此在进行拼接多个数据表时，首先将数据表组成列表。</p>
<pre><code class="language-python">frames = [ process_your_file(f) for f in files ]
result = pd.concat(frames)
</code></pre>
</blockquote>
<p><code>DataFrame.append</code>方法仅用于<strong>在行索引方向</strong>进行拼接。</p>
<pre><code class="language-python">df = df1.append(df2, ignore_index=True)
</code></pre>
<blockquote>
<p><code>DataFrame.append</code>仍<strong>返回拼接后的新对象</strong>，而不像Python列表的<code>append</code>方法对原对象进行修改。</p>
</blockquote>
<p><a href="https://stackoverflow.com/questions/35084071/concat-dataframe-reindexing-only-valid-with-uniquely-valued-index-objects">python - Concat DataFrame Reindexing only valid with uniquely valued Index objects - Stack Overflow</a></p>
<p>问题：存在列名相同的列。</p>
<h4 id="数据库方式合并"><a class="header" href="#数据库方式合并">数据库方式合并</a></h4>
<h5 id="merge"><a class="header" href="#merge">merge</a></h5>
<p>根据指定列或索引进行表格合并。</p>
<pre><code class="language-python">result = pd.merge(left_df, right_df, how='inner', on=None, sort=True, 
                  suffixes=('_x', '_y'))
result_df = pd.DataFram.merge(self, right, ...)
</code></pre>
<p><code>on</code>：拼接参考列或索引名，需要在两个表中均存在；可以使用多个标签的组合（<code>on=['key1','key2']</code>）作为参考。如果未指定参考标签，则两个表的公共列将被作为合并参考关键字。</p>
<blockquote>
<p><code>left_on=None, right_on=None</code>：可以分别指定两个表格的参考列或索引名；
<code>left_index: bool, right_index: bool</code>：使用索引作为参考列。</p>
</blockquote>
<p><code>how</code>：合并方法</p>
<ul>
<li><code>'left'</code>：使用左侧表的参考列作为合并索引。<strong>如果合并索引的值与右侧对应参考列的一行或多行相等，则进行一对多合并；如果右侧表的参考列不存在对应的值，则合并后右表其他列填充<code>NaN</code>；右表未被匹配的行被丢弃。</strong></li>
<li><code>'right'</code>：使用右侧表的参考列作为合并索引；</li>
<li><code>'outer'</code>：使用两侧表的参考列的并集作为合并索引，若索引未在某个表格中匹配到行，则合并结果中该表格对应的列填充<code>Nan</code>；</li>
<li><code>'inner'</code>：使用两侧表的参考列的交集作为合并索引。左右表格中未被索引匹配的行被丢弃。</li>
<li><code>'cross'</code>： ==<strong>cartesian product</strong>==。</li>
</ul>
<p><code>sort</code>：按参考标签值进行字典序排序；</p>
<p><code>suffixes</code>：同名的非参考列都会添加到合并结果中。<code>suffixes</code>为同名列添加后缀，其中一个可以为<code>None</code>，即使用原列名。如果未指定后缀而存在相同列，则自动添加<code>_x,_y</code>作为后缀。</p>
<h5 id="join"><a class="header" href="#join">join</a></h5>
<p>将表格的列或索引与==另一个表格的索引==（<em>column-on-index</em>）作为合并的参考。</p>
<pre><code class="language-python">df_new = df.join(other, on=None, how='left', ...)
</code></pre>
<blockquote>
<p><code>join</code>不能指定另一个表格的参考列，只能使用索引作为另一个表格的参考列。可已将另一个表格的列首先设置为索引。</p>
</blockquote>
<h3 id="表格数据类型转换"><a class="header" href="#表格数据类型转换">表格数据类型转换</a></h3>
<h5 id="序列数据转换"><a class="header" href="#序列数据转换">序列数据转换</a></h5>
<p>Pandas提供方法将标量、列表、元组一维数组或<code>Series</code>的数据类型转换，返回<code>ndarray</code>或<code>Series</code>（输入为<code>Series</code>时）</p>
<pre><code class="language-python">pd.to_numeric(data)
index.to_series()
</code></pre>
<h5 id="转换为矩阵"><a class="header" href="#转换为矩阵">转换为矩阵</a></h5>
<p><code>DataFrame</code>对象如果保存的是同一类型数据，则<code>to_numpy()</code>将返回对象的底层数据对象，可<strong>通过底层数据对象修改</strong><code>DataFrame</code>对象。对于异构的数据类型，则返回矩阵的数据类型将适当调整（例如包括整数和<code>string</code>类型则返回类型为<code>object</code>，如果包含浮点数和整数，则返回类型为浮点型），<strong>返回的数据不是<code>DataFrame</code>的底层数据对象</strong>。</p>
<pre><code class="language-python">a = df.to_numpy(copy=False) # -&gt; np.ndarray
a = df.values               # ss.values, idx.values, recommend using to_numpy()
</code></pre>
<blockquote>
<p>将数据对象转换为矩阵。<code>copy=False</code>只在必要的时候复制数据。</p>
</blockquote>
<h5 id="index-1"><a class="header" href="#index-1">Index</a></h5>
<p><code>index</code>类型可转换为<code>set</code>。</p>
<h2 id="graph"><a class="header" href="#graph">Graph</a></h2>
<h3 id="networkx"><a class="header" href="#networkx">networkx</a></h3>
<h4 id="创建图"><a class="header" href="#创建图">创建图</a></h4>
<h5 id="从空图开始"><a class="header" href="#从空图开始">从空图开始</a></h5>
<pre><code class="language-python">import networkx as nx
G = nx.Graph(**prop_kwargs)    # nx.DiGraph有向图
</code></pre>
<blockquote>
<p><code>prop_kwargs</code>为图对象添加属性。</p>
</blockquote>
<p>添加节点：nodes can be any <a href="https://docs.python.org/3/glossary.html#term-hashable">hashable</a> object。</p>
<pre><code class="language-python">G.add_node(node_obj, prop=value)
G.add_nodes_from([v2, v3], prop=value)
G.add_nodes_from([(node_obj, node_attrs_dict),...])
</code></pre>
<blockquote>
<p>当字符串作为<code>add_nodes_from</code>的参数时，每个字符将被视为一个节点。</p>
</blockquote>
<p>可在添加节点的同时，设置节点的属性（<code>dict</code>）。</p>
<p>添加边：添加边的同时也会自动添加节点。</p>
<pre><code class="language-python">G.add_edge(v1, v2, object=x, weight=1)
G.add_edges_from([(v1, v2), (v1, v3),...])
G.add_edges_from([(v1, v2, edge_attr_dict),...])
G = nx.Graph(edgelist)
</code></pre>
<blockquote>
<p><code>weight</code>必须是数值类型，提供给需要权重的算法。</p>
</blockquote>
<p>移除元素：</p>
<pre><code class="language-python">G.remove_node(v2)
G.remove_nodes_from([v2, v3])
G.remove_edge(1, 3)   # remove_edge_from()
</code></pre>
<h5 id="从数据表构造图"><a class="header" href="#从数据表构造图">从数据表构造图</a></h5>
<p>如果数据中包含节点和边的属性，可通过以下方式构造。</p>
<pre><code class="language-python">df_nodes=pd.DataFrame.from_records(data_nodes) # 节点编号和属性数据
df_edges=pd.DataFrame.form_records(data_edges) # 连接编号和属性数据
for idx,n in df_nodes.set_index('id',drop=True).iterrows():
  G.add_node(idx, **n.to_dict())
for idx,e in df_edges.set_index(['head','tail'],drop=True).iterrows():
  G.add_node(*idx, **e.to_dict())
</code></pre>
<p>如果节点无属性信息，可以通过以下方法从连接表直接构造和导出。</p>
<pre><code class="language-python">df = nx.to_pandas_edgelist(G, source='source', target='target') # source,target,weight,...
G = nx.from_pandas_edgelist(df)
</code></pre>
<h5 id="从邻接矩阵构造图"><a class="header" href="#从邻接矩阵构造图">从邻接矩阵构造图</a></h5>
<p>对于只有权重的图，可以使用以下方法通过邻接矩阵构造和导出。</p>
<pre><code class="language-shell">df = nx.to_pandas_adjacency(G, weight='weight', nonedge=0.0)    # 邻接矩阵
G = nx.from_pandas_adjacency(df)
array = nx.to_numpy_array(G, weight='weight', nonedge=0)        # 邻接矩阵
G = nx.from_numpy_array(array)
array = nx.to_scipy_sparse_matrix(G, weight='weight', format='csr')
G = nx.from_scipy_sparse_matrix(A, edge_attribute='weight')
</code></pre>
<h5 id="基于已有图构造"><a class="header" href="#基于已有图构造">基于已有图构造</a></h5>
<pre><code class="language-python">G.add_nodes_from(H)  # 从另一个图中添加节点
G.add_edges_from(H.edges)
G = nx.Graph(H)
</code></pre>
<h5 id="文本数据导入导出"><a class="header" href="#文本数据导入导出">文本数据导入导出</a></h5>
<pre><code class="language-python">from networkx import json_graph
data = json_graph.node_link_data(G)  # return nodes and links as dict
G = json_graph.node_link_graph(data)
data = json_graph.adjacency_data(G)  # return nodes and adjacent neighbors
G = json_graph.adjcency_graph(data)
</code></pre>
<p>除了直接按上述方法从JSON数据构造图外，还可将导出的<code>JSON</code>数据转换为<code>DataFrame</code>，从而得到规范完整的节点和链路信息，可进一步编辑并<a href="Python/Python%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.html#%E4%BB%8E%E6%95%B0%E6%8D%AE%E8%A1%A8%E6%9E%84%E9%80%A0%E5%9B%BE">构造图对象</a>。</p>
<h4 id="图的信息"><a class="header" href="#图的信息">图的信息</a></h4>
<h5 id="节点信息"><a class="header" href="#节点信息">节点信息</a></h5>
<p>节点属性集合是一个字典，可动态修改。</p>
<pre><code class="language-python">G.nodes              # -&gt; NodeView:Iterable
for n in G.nodes:    # n 是节点的索引，即初始化时传入的节点编号
  print(G.nodes[n])
</code></pre>
<h5 id="边信息"><a class="header" href="#边信息">边信息</a></h5>
<pre><code class="language-python">G.edges                  # EdgeView:Iterable, 
for e in G.edges:        # e为边的索引，即首尾节点编号二元组
  print(e, G.edges[e])   # =&gt; G.edges[v1,v2] =&gt; G[v1][v2] 边
G.edges([subset_nodes])  # -&gt; EdgeDataView：获取包含给定节点的边集合
</code></pre>
<p>遍历元素属性：</p>
<pre><code class="language-python">for (u, v, wt) in FG.edges.data('weight'):
    if wt &lt; 0.5:
        print(f&quot;({u}, {v}, {wt:.3})&quot;)
</code></pre>
<h5 id="邻居信息"><a class="header" href="#邻居信息">邻居信息</a></h5>
<pre><code class="language-python">G.adj           # -&gt; AdjacencyView: {node:{adj_node:link_attrs,...},...}
G.adj[v]        # &lt;=&gt; G[v] -&gt; AtlasView: {node:link_attrs,...}
G.adjacency()   # -&gt; dict_itemiterator: [(node:{adj_node:link_attrs,...}),...]
G.neighbors(v)  # -&gt;Iterator 邻接表：节点v的邻居列表
G.degree()
G.degree[v]     # &lt;=&gt; G.degree(v) or G.degree()[v]
G.degree([subset_nodes]) 
</code></pre>
<p>遍历图的信息：</p>
<pre><code class="language-python">for n, nbrs in G.adj.items():
   for nbr, eattr in nbrs.items():
       wt = eattr['weight']
       if wt &lt; 0.5: print(f&quot;({n}, {nbr}, {wt:.3})&quot;)
</code></pre>
<h5 id="设置图属性"><a class="header" href="#设置图属性">设置图属性</a></h5>
<p>除了构造图时设置属性，也可采用类似字典的方式为图或元素设置属性。</p>
<pre><code class="language-python">G.graph['day'] = &quot;Monday&quot;
</code></pre>
<h5 id="设置元素属性"><a class="header" href="#设置元素属性">设置元素属性</a></h5>
<p>设置节点属性：</p>
<pre><code class="language-python">nx.set_node_attributes(G, values, name=AttributeName)  # 设置节点属性
nx.set_edge_attributes(...)                            # 设置边属性
</code></pre>
<p>如果<code>values</code>为字典（<code>{node:value,...}</code>），则仅设置其中指定的节点为对应的值；否则<code>values</code>应该为标量并设置全部节点。也可直接通过访问节点或边设置某一个具体节点或边的属性。</p>
<pre><code class="language-python">G.nodes[1]['room'] = 714
G.nodes[1]['pos'] = (1,2)
G[1][3]['color'] = &quot;blue&quot;
</code></pre>
<p>节点位置<code>pos</code>属性通常在图可视化中使用，除了已知位置（如地理位置），可<a href="https://networkx.org/documentation/stable/reference/drawing.html#module-networkx.drawing.layout">利用布局引擎生成节点位置</a>（如<a href="Python/Python%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA.html#%E4%BD%BF%E7%94%A8Graphviz%E7%BB%98%E5%88%B6%E7%BD%91%E7%BB%9C%E5%9B%BE"><em>Graphviz</em></a>）。</p>
<h4 id="有向图"><a class="header" href="#有向图">有向图</a></h4>
<h2 id="dask分布式数据结构"><a class="header" href="#dask分布式数据结构">Dask分布式数据结构</a></h2>
<p>提供基于Numpy数组和Pandas <code>DataFrame</code>对象等的分布式数据结构，支持本地化分布式并行计算。</p>
<h3 id="分布式数据"><a class="header" href="#分布式数据">分布式数据</a></h3>
<h4 id="dask-dataframe"><a class="header" href="#dask-dataframe">Dask DataFrame</a></h4>
<p><img src="Python/Python数据类型.assets/dask-dataframe.svg" alt="Dask DataFrames coordinate many Pandas DataFrames" style="float:right; zoom:20%;" />https://docs.dask.org/en/latest/dataframe.html</p>
<p>https://docs.dask.org/en/latest/dataframe-api.html</p>
<pre><code class="language-python">import dask.dataframe as dd
df = dd.read_parquet(&quot;/path/sub*/file*.parquet&quot;) # read_csv()
df = dd.from_pandas(
   df_or_ss, 
   npartitions=None, 
   chunksize=None,  # number of rows per partition
   sort=True,       # 首先对数据按索引排序，以获得divisions
   name=None        # 为分布式数据命名（默认名为Hash值）
)
</code></pre>
<blockquote>
<p><code>dask</code>的读取函数可以使用通配符匹配文件夹和文件。如果数据是从HDFS导出的分片数据，则传入父文件夹将以子文件夹名重建分片参考列。</p>
</blockquote>
<pre><code class="language-python">df.to_parquet(path,
              write_index=True, # 写入索引
              partition_on=None, # 对每个分区按指定列拆分为多个文件
              write_metadata_file=True # 导出元数据(_metadata)到文件
             ) 
</code></pre>
<p>将每个分区单独写入一个文件。</p>
<h4 id="dask-array"><a class="header" href="#dask-array">Dask Array</a></h4>
<h3 id="数据表操作"><a class="header" href="#数据表操作">数据表操作</a></h3>
<p>多数可执行操作为Pandas API的子集，但行为有所不同。</p>
<ul>
<li><code>df.reset_index</code>：与Pandas不同，索引在每个分区中单独设置，因此非单调。</li>
<li><code>df.set_index</code>：该操作会首先对要设置的索引列进行排序（开销较大；如果指定列已经有序可通过<code>sorted</code>参数告知方法避免重新排序）；</li>
<li>不支持为行赋值（<code>df.loc[i,col]=a</code>出错）；<code>iloc</code>仅支持取整列：<code>df.iloc[:,col_idx]</code></li>
<li><code>head(n=5, npartitions=1, compute=True)</code>：</li>
<li><code>groupby</code>仅支持对分组后的数据进行汇聚统计，不支持获取分组子表格，不支持以列索引级别分组（<code>level=</code>）。</li>
<li><code>to_datetime</code>：仅支持表格类型的数据转换（需要包含index），如Pandas/Dask的<code>DataFrame</code>和<code>Series</code>等。</li>
<li><code>df.any(axis=None).compute()</code>：如果<code>df</code>是列为1的表，返回的是长度为1的<code>Series</code>，而非标量（<code>pd.DataFrame</code>: <code>axis=None</code>计算所有元素返回标量）；代替方法转换为<code>pandas.DataFrame</code>或转换为<code>Series</code>。</li>
<li><code>dask.dataframe</code>不支持排序操作（分布式运行耗时）。</li>
</ul>
<p>判断是否<a href="Python/Python%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.html#%E7%BC%BA%E5%A4%B1%E6%95%B0%E6%8D%AE">缺失数据</a>：Dask仅提供<code>notnull()</code>和<code>isnull()</code>方法，未实现<code>isna()</code>和<code>notna()</code>。</p>
<h5 id="数据源"><a class="header" href="#数据源">数据源</a></h5>
<ul>
<li>不支持限定读取行数（例如<code>read_csv</code>不支持<code>n_rows</code>参数）；</li>
<li><code>read_csv</code>不支持设置数据中的列为索引列（设置索引开销较大且会改变数据顺序，可显式调用<code>set_index</code>）；</li>
<li></li>
</ul>
<h4 id="赋值-1"><a class="header" href="#赋值-1">赋值</a></h4>
<p>不支持<code>df.loc[:,cols]=values</code>赋值，使用<code>df.loc[idx]=values</code>为行赋值。支持行索引和真值访问数据表的一行或多行。</p>
<pre><code class="language-python">df1 = df.loc[df[col]&lt;10]  # truth value必须为dask类型
</code></pre>
<h4 id="数据分区"><a class="header" href="#数据分区">数据分区</a></h4>
<p><code>df = df.partitions[start:end:step]</code></p>
<p><code>n = df.npartitions</code></p>
<p><code>df.get_partition(n)</code></p>
<h4 id="汇总"><a class="header" href="#汇总">汇总</a></h4>
<pre><code class="language-python">df = result.compute()
</code></pre>
<h3 id="最佳实践"><a class="header" href="#最佳实践">最佳实践</a></h3>
<h5 id="使用pandas"><a class="header" href="#使用pandas">使用Pandas</a></h5>
<p>在内存能够容纳数据的情况下，优先使用Pandas，避免并行计算开销。</p>
<h5 id="筛选汇聚数据后使用pandas"><a class="header" href="#筛选汇聚数据后使用pandas">筛选汇聚数据后使用Pandas</a></h5>
<p>利用条件筛选行列，利用分组统计（<code>groupby</code>）进行汇聚后，可大幅减少数据量。</p>
<h5 id="使用索引"><a class="header" href="#使用索引">使用索引</a></h5>
<p>可以为<code>DataFrame</code>设置一列索引（<code>set_index</code>），针对索引列的某些操作将会很快，例如通过排序过的索引查找内容，执行<code>groupby.apply</code>等操作。可通过<code>df.known_divisions</code>判断数据是否是经过排序的。</p>
<pre><code class="language-python">df2 = df.set_index(d.timestamp, 
                   drop=True, 
                   sorted=False, 
                   npartitions='auto')
</code></pre>
<blockquote>
<p>为<code>dask.DataFrame</code>设置索引开销较大(Data Shuffling)，因此应避免频繁使用（使用<code>persist</code>），或者将设置索引后的数据表存储到磁盘上供后续使用。</p>
<p>如果指定列本身为有序的，则设置索引可以快速完成。</p>
</blockquote>
<h5 id="避免数据交换data-shuffling"><a class="header" href="#避免数据交换data-shuffling">避免数据交换（Data Shuffling）</a></h5>
<p>排序、分区(<code>repartition</code>)、去重(<code>drop_duplicates</code>)、设置索引(<code>set_index</code>)等操作需要各分区间进行数据交换。</p>
<blockquote>
<p><em>shuffling operations</em> that rearrange data become much more communication intensive. </p>
</blockquote>
<p>将结算结果缓存（<code>persist</code>）在内存中，从而避免重复读取和交换数据等操作。
在单机集群上，由于所有工作节点共存，因此为避免数据缓存占用过多内存，应该首先对数据进行筛选。</p>
<pre><code class="language-python">ddf = dd.read_parquet(filepath) # Load data from files
ddf = ddf.loc[ddf[colA]==value, cols] # Filter data to a subset
ddf = ddf.set_index('date_time') # set an intelligent index (shuffle)
df = client.persist(df)  # persist data in memory
</code></pre>
<p>在单机上，如果数据量过大导致无法将内容缓存在内存中，则可以将中间运算结果存储到外部存储。由于Dask采取并行懒加载方式处理数据，后续再重新从外部存储读取并处理数据仍比较快。</p>
<h5 id="repartition-to-reduce-overhead"><a class="header" href="#repartition-to-reduce-overhead">Repartition to Reduce Overhead</a></h5>
<p>分区大小影响数据交换和Pandas向量化计算的效率。每个分区大小控制在<code>100MB</code>左右，而少于100个分区则有利于数据交换。应该控制分区数量（<code>df.repartition</code>），使得分区适应内存（小于<code>1G</code>），并减少调度节点的处理开销。</p>
<pre><code class="language-python">df = df.repartition(divisions=None, npartitions=None, partition_size='5MB')
</code></pre>
<blockquote>
<p>当数据有索引时，<code>df.divisions</code>为分区的索引边界。</p>
<p><code>partition_size</code>为内存占用量，大约为磁盘占用量的2倍。</p>
</blockquote>
<p><code>repartition</code>会根据指定参数合并或拆分已有分区。在未指定<code>divisions</code>的情况下，<a href="https://stackoverflow.com/a/56014192/6571140">并不能保证各分区大小均匀</a>。</p>
<h5 id="使用parquet格式存储数据"><a class="header" href="#使用parquet格式存储数据">使用Parquet格式存储数据</a></h5>
<p>https://docs.dask.org/en/latest/dataframe-best-practices.html</p>
<p>https://docs.dask.org/en/latest/dataframe-joins.html</p>
<h3 id="daskdataframe类型转换"><a class="header" href="#daskdataframe类型转换"><code>dask.DataFrame</code>类型转换</a></h3>
<pre><code class="language-python">df.to_dask_array()
dd.to_datetime()
</code></pre>
<h2 id="vaex"><a class="header" href="#vaex">Vaex</a></h2>
<div class="table-wrapper"><table><thead><tr><th></th><th>Vaex</th><th>Dask</th><th>Pandas</th></tr></thead><tbody>
<tr><td><strong>Performance</strong></td><td>$&gt;{10}^9$ RPS</td><td></td><td></td></tr>
<tr><td><strong>Lazy Compute</strong></td><td>√</td><td></td><td></td></tr>
<tr><td><strong>Memory</strong></td><td>memory mapping</td><td></td><td></td></tr>
<tr><td></td><td></td><td></td><td></td></tr>
</tbody></table>
</div>
<p><code>vaex-core</code>: DataFrame and core algorithms, takes <code>numpy</code> arrays as input columns.</p>
<p><code>vaex-hdf5</code>: Provides memory mapped numpy arrays to a DataFrame.</p>
<p><code>vaex-arrow</code>: <a href="https://arrow.apache.org/">Arrow</a> support for cross language data sharing.</p>
<p><code>vaex-viz</code>: Visualization based on matplotlib.</p>
<p><code>vaex-ml</code>: <a href="https://vaex.io/docs/ml.ipynb">Machine learning</a></p>
<p><code>vaex-jupyter</code>: interactive visualization and selection in the Jupyter notebook and Jupyter lab.</p>
<blockquote>
<p>Vaex依赖Dask。</p>
</blockquote>
<p>Instead of making copies, Vaex internally keeps track which rows are selected.</p>
<pre><code>df.select(df.x &lt; 0)
df.evaluate(df.x, selection=True)
</code></pre>
<p>you can also create filtered datasets. This is similar to using Pandas, except that Vaex does not copy the data.</p>
<pre><code>df_negative = df[df.x &lt; 0]
df_negative[['x', 'y', 'z', 'r']]
</code></pre>
<h5 id="group-and-compute"><a class="header" href="#group-and-compute">group-and-compute</a></h5>
<pre><code>counts_x = df.count(binby=df.x, limits=[-10, 10], shape=64)
</code></pre>
<p>二维分组：</p>
<pre><code>xycounts = df.count(binby=[df.x, df.y], limits=[[-10, 10], [-10, 20]], shape=(64, 128))
</code></pre>
<h5 id="import-data"><a class="header" href="#import-data">import data</a></h5>
<pre><code class="language-python">df = vaex.from_arrays(col_x=x, col_y=y)
vaex.from_pandas(df, name='pandas', copy_index=False, index_name='index')
# Read a CSV file as a DataFrame, and optionally convert to an hdf5 file.
vaex.from_csv(file, chunk_size=None, 
              convert:Union[bool, str]=False,
              **pd_kwargs)
vaex.from_ascii(path, seperator=None, names=True, skip_lines=0)
vaex.open(path,...)
</code></pre>
<pre><code class="language-python">to_pandas_df(column_names=None, selection=None, strings=True, virtual=True, index_name=None, parallel=True, chunk_size=None, array_type=None)
to_records(index=None, selection=None, column_names=None, strings=True, virtual=True, parallel=True, chunk_size=None, array_type='python')

export(path, progress=None, chunk_size=1048576, parallel=True, fs_options=None, fs=None)
export_hdf5(path, byteorder='=', progress=None, chunk_size=1048576, parallel=True, column_count=1, writer_threads=0, group='/table', mode='w')
export_arrow(to, progress=None, chunk_size=1048576, parallel=True, reduce_large=True, fs_options=None, fs=None, as_stream=True) # support parquet
export_parquet(path, progress=None, chunk_size=1048576, parallel=True, fs_options=None, fs=None, **kwargs)
export_partitioned(path, by, directory_format='{key}={value}', progress=None, chunk_size=1048576, parallel=True, fs_options={}, fs=None)
export_csv(path, progress=None, chunk_size=1048576, parallel=True, **kwargs)[source]
</code></pre>
<p><a href="http://web.mit.edu/fwtools_v3.1.0/www/H5.intro.html#Intro-WhatIs">Introduction to HDF5 (mit.edu)</a></p>
<h5 id="可视化"><a class="header" href="#可视化">可视化</a></h5>
<pre><code>df.plot1d(df.x, limits='99.7%');
</code></pre>
<h2 id="参考文献-3"><a class="header" href="#参考文献-3">参考文献</a></h2>
<div class="footnote-definition" id="b64"><sup class="footnote-definition-label">1</sup>
<p><a href="https://www.rfc-editor.org/rfc/rfc4648.html">RFC 4648: The Base16, Base32, and Base64 Data Encodings (rfc-editor.org)</a></p>
</div>
<div class="footnote-definition" id="dataclass"><sup class="footnote-definition-label">2</sup>
<p><a href="https://towardsdatascience.com/9-reasons-why-you-should-start-using-python-dataclasses-98271adadc66">9 Reasons Why You Should Start Using Python Dataclasses | by Ahmed Besbes | Towards Data Science</a></p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="输入输出"><a class="header" href="#输入输出">输入输出</a></h1>
<h2 id="文件读写"><a class="header" href="#文件读写">文件读写</a></h2>
<p>创建文件对象：</p>
<pre><code class="language-python">fp = open(file_name, mode='r|b', encoding=None, buffering)  # === io.open
# os.open底层IO接口
</code></pre>
<p><code>access_mode</code>：<a href="Python/../Linux/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%8E%A5%E5%8F%A3.html#open">访问模式</a>。文件打开模式决定读写内容是文本（默认）或<a href="Python/./Python%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.html#%E5%AD%97%E8%8A%82%E5%BA%8F%E5%88%97%E7%B1%BB%E5%9E%8B%EF%BC%88bytes%EF%BC%89">字节序列</a>。</p>
<blockquote>
<p><code>a</code>：追加模式，如果文件不存在将自动创建。</p>
</blockquote>
<p><code>close</code>：可使用<code>with</code>语句实现自动管理文件资源。</p>
<h5 id="文件对象"><a class="header" href="#文件对象">文件对象</a></h5>
<div class="table-wrapper"><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody>
<tr><td><code>file.closed</code></td><td>如果文件已被关闭返回<code>true</code>，否则返回<code>false</code>。</td></tr>
<tr><td><code>file.mode</code></td><td>返回被打开文件的访问模式。</td></tr>
<tr><td><code>file.name</code></td><td>返回文件的名称。</td></tr>
<tr><td><code>file.softspace</code></td><td>如果用<code>print</code>输出后必须跟一个空格符，则返回<code>false</code>。</td></tr>
</tbody></table>
</div>
<h5 id="文件读写-1"><a class="header" href="#文件读写-1"><a href="Python/../Linux/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%8E%A5%E5%8F%A3.html#%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99">文件读写</a></a></h5>
<blockquote>
<p><code>read</code>  <code>readlines</code>  <code>write</code>  <code>writelines</code>  <code>seek</code>  <code>tell</code>；</p>
</blockquote>
<p><code>fp.readline()</code>返回结果包含换行符“<code>\n</code>”；</p>
<p><code>fileinput</code>基于行读取文件：</p>
<pre><code class="language-python">import fileinput
with fileinput.input(files=('data.txt',)) as file:
  for line in file: print(line)
</code></pre>
<p>内置库<code>filecache</code>，你可以用它来指定读取具体某一行，或者某几行，不指定就读取全部行。</p>
<pre><code class="language-python">import linecache
content = linecache.getline(filename, lineno)  # 行号从1开始，0返回空行
content = linecache.getlines(filename)
</code></pre>
<h3 id="输入输出对象"><a class="header" href="#输入输出对象">输入输出对象</a></h3>
<p>提供类似文件读写的接口读写内存缓存空间的数据，包括基于文本<code>io.StringIO</code>和基于字节<code>io.BytesIO</code>的输入输出对象。</p>
<pre><code class="language-python">str_buffer = io.StringIO(initial_value='')
bytes_buffer = io.BytesIO(initial_bytes=b'')
</code></pre>
<h3 id="文件类型支持"><a class="header" href="#文件类型支持">文件类型支持</a></h3>
<h5 id="gzip"><a class="header" href="#gzip">gzip</a></h5>
<p><code>gzip</code>模块提供 <a href="https://docs.python.org/zh-cn/3/library/gzip.html#gzip.GzipFile"><code>GzipFile</code></a> 类和 <a href="https://docs.python.org/zh-cn/3/library/gzip.html#gzip.open"><code>open()</code></a>、<a href="https://docs.python.org/zh-cn/3/library/gzip.html#gzip.compress"><code>compress()</code></a>、<a href="https://docs.python.org/zh-cn/3/library/gzip.html#gzip.decompress"><code>decompress()</code></a> 几个便利的函数。</p>
<p><a href="https://docs.python.org/zh-cn/3/library/gzip.html#gzip.GzipFile"><code>GzipFile</code></a> 类可以读写<strong>gzip</strong>格式的文件，还能自动压缩和解压缩数据，这让操作压缩文件如同操作普通的文件对象一样方便。</p>
<pre><code class="language-python">gzip.open(filename, mode='rb', ...)
</code></pre>
<blockquote>
<p>对于二进制模式，这个函数等价于 <a href="https://docs.python.org/zh-cn/3/library/gzip.html#gzip.GzipFile"><code>GzipFile</code></a> 构造器：<code>GzipFile(filename, mode, compresslevel)</code>。</p>
</blockquote>
<pre><code class="language-python">gzip.compress(data, compresslevel=9)
</code></pre>
<pre><code class="language-python">gzip.decompress(data)
</code></pre>
<h5 id="xml"><a class="header" href="#xml">XML</a></h5>
<pre><code class="language-python">import xml.etree.ElementTree as xml
root = xml.Element(&quot;users&quot;)
</code></pre>
<h2 id="标准输入输出"><a class="header" href="#标准输入输出">标准输入输出</a></h2>
<p>读取一行输入字符串。</p>
<pre><code class="language-python">line = input(&quot;Press [enter] to continue.&quot;)
</code></pre>
<p>输入密码：</p>
<pre><code class="language-python">import getpass
p=getpass.getpass(prompt='Password: ')
</code></pre>
<p>使用<code>print</code>打印对象的<a href="Python/Python%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80.html#%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98">文本表示</a> <code>str(x)</code>（<code>__str__()</code>）。如果要格式化输出，通过<code>str.format</code>将输出<a href="Python/./Python%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A0%BC%E5%BC%8F%E5%8C%96">格式化为字符串</a>，再通过<code>print</code>输出字符串。</p>
<pre><code class="language-python">print(value, ..., sep=' ', end ='\n', file=sys.stdout) # 支持多个参数连续输出
print(&quot;... %{0:s} ... %{1:d} ...&quot;.format('Zara',21))
</code></pre>
<blockquote>
<p>Python 2.x：<code>print &quot;... %s ... %d ...&quot; % ('Zara', 21)</code>。</p>
</blockquote>
<h3 id="警告信息"><a class="header" href="#警告信息">警告信息</a></h3>
<h4 id="生成警告信息"><a class="header" href="#生成警告信息">生成警告信息</a></h4>
<pre><code class="language-python">import warnings
warnings.warn(message,category=UserWarning,stacklevel=1,source=None)
</code></pre>
<blockquote>
<p><code>stacklevel</code>用于指定显示触发告警语句的层级，<code>1</code>表示<code>warn</code>语句所在行，2表示<code>warn</code>语句的上一级调用。</p>
<p><code>source</code>：*if supplied, is the destroyed object which emitted a <code>ResourceWarning</code>.*通常没用。</p>
</blockquote>
<p><code>warn</code>告警信息给出的行号总是在调用<code>warn</code>的位置，因此不能准确反映代码中触发告警的位置。使用<code>warn_explicit()</code>可以指定<a href="Python/Python%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80.html#%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E4%BF%A1%E6%81%AF">代码行号</a>。</p>
<pre><code class="language-python">warnings.warn_explicit(message, category, filename, lineno, module=None, registry=None, module_globals=None, source=None)
</code></pre>
<h5 id="警告类型"><a class="header" href="#警告类型"><a href="https://docs.python.org/3/library/warnings.html#warning-categories">警告类型</a></a></h5>
<p><a href="https://docs.python.org/3/library/exceptions.html#Warning"><code>Warning</code></a>：所有警告类型的基类，继承自<a href="Python/Python%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><code>Exception</code></a>。<code>UserWarning</code>是<code>warn()</code>产生警告的默认类型。<code>DeprecationWarning</code>和<code>FutureWarning</code>分别用于告知开发者和最终用户相关特性将被弃用。</p>
<p><code>SyntaxWarning/RuntimeWarning/ImportWarning/UnicodeWarning/BytesWarning/ResourceWarning...</code>。</p>
<h4 id="警告信息筛选"><a class="header" href="#警告信息筛选">警告信息筛选</a></h4>
<p>每条告警信息按尝试依次匹配筛选规则，当匹配到规则，则按该规则的处理方式处理告警<sup class="footnote-reference"><a href="#warnings">1</a></sup>。告警筛选规则包括：</p>
<ul>
<li><code>action</code>：警告的处理方式；
<ul>
<li><code>&quot;always&quot;</code>：总是打印警告；</li>
<li><code>&quot;default&quot;</code>：打印首次出现的匹配警告（不同的<code>module</code>+<code>lineno</code>）；<code>&quot;module&quot;</code>打印模块内首次出现的匹配警告（不同的<code>module</code>）；<code>&quot;once&quot;</code>：仅打印一次匹配的警告；</li>
<li><code>&quot;error&quot;</code>：将警告转换为异常；</li>
<li><code>&quot;ignore&quot;</code>：从不打印警告；</li>
</ul>
</li>
<li><code>message</code>：匹配警告信息的正则表达式（大小写不敏感）；</li>
<li><code>category</code>：匹配警告类型的类名（<code>Warning</code>的子类）；</li>
<li><code>module</code>：匹配触发警告信息的模块名的正则表达式（大小写不敏感）；</li>
<li><code>lineno</code>：匹配触发警告的行号（默认<code>0</code>匹配任意行）。</li>
</ul>
<p>如果一条警告信息未匹配到筛选规则，则按默认处理方式处理。</p>
<h5 id="设置警告规则列表"><a class="header" href="#设置警告规则列表">设置警告规则列表</a></h5>
<p>使用环境变量<code>PYTHONWARNINGS</code>（使用<code>,</code>分隔规则）、Python解释器<code>-W</code>选项（多次提供设置多个规则）设置，首次导入<code>warnings</code>模块时加载这些设置。一条规则的声明语法为</p>
<pre><code class="language-python">action:message:category:module:line
</code></pre>
<p>如果某个参数未提供，则<code>:</code>之间为空；如果字段数不足则对应参数值为空。Python内置了部分告警过滤规则，通过上述方法可覆盖这些预置规则。</p>
<pre><code class="language-python">warnings.filterwarnings(action,message='',category=Warning,module='',lineno=0,append=False)
warnings.simplefilter(action,category=Warning,lineno=0,append=False) # 不匹配message和module
</code></pre>
<p><code>append=False</code>：默认将规则置于最前端。</p>
<h5 id="临时设置警告规则"><a class="header" href="#临时设置警告规则">临时设置警告规则</a></h5>
<pre><code class="language-python">with warnings.catch_warnings():
    warnings.simplefilter(&quot;ignore&quot;)
    states_contains_warning()
</code></pre>
<h3 id="日志"><a class="header" href="#日志">日志</a></h3>
<h4 id="产生日志"><a class="header" href="#产生日志">产生日志</a></h4>
<p>产生日志的方法：<code>debug(), info(), warning(), error(), critical()</code>，对应了相应的日志等级<code>DEBUG, INFO, WARNING, ERROR, CRITICAL</code>，默认等级为<code>WARNING</code>。</p>
<h5 id="全局日志生成器"><a class="header" href="#全局日志生成器">全局日志生成器</a></h5>
<pre><code class="language-python">import logging
logging.warning('Watch out!')  # print to console
root_logger = logging.getLogger()
</code></pre>
<h5 id="logger"><a class="header" href="#logger">Logger</a></h5>
<p>日志生成器（Logger）包含一名称用于区分日志来源，推荐基于模块级别构造日志生成器（使用<code>.</code>命名区分层级）。</p>
<pre><code class="language-python">logger = logging.getLogger(name=__name__)  # default is root
logger.setLevel(level)   # effective level
logger.warning(msg)      # error/exception/warning/info/debug/trace
</code></pre>
<p>属性：<code>level</code>（日志级别）、<code>name</code>（日志器名称）。日志生成器会默认将消息传递给全局生成器（意味着会在生成两次日志并发送到相应目标），如果这一行为并非期望的方式，令<code>logger.propagate=False</code>禁止传递消息。</p>
<h4 id="处理日志"><a class="header" href="#处理日志">处理日志</a></h4>
<p>日志处理方法包括：打印至控制台（<code>StreamHandler</code>，默认输出流为标准错误输出<code>sys.stderr</code>），存储到磁盘文件<code>FileHandler</code>。</p>
<h5 id="配置全局日志处理方法"><a class="header" href="#配置全局日志处理方法">配置全局日志处理方法</a></h5>
<pre><code class="language-python">logging.basicConfig(filename='example.log', encoding='utf-8', level=...)
</code></pre>
<blockquote>
<p><code>basicConfig()</code>需要在产生日志的方法前调用。</p>
</blockquote>
<h5 id="自定义配置日志处理方法"><a class="header" href="#自定义配置日志处理方法">自定义配置日志处理方法</a></h5>
<p><code>Handlers</code>类型将日志发送到指定的目标。可以为一个日志生成器添加<a href="https://stackoverflow.com/questions/17745914/python-logging-module-is-printing-lines-multiple-times/37340718">多个日志处理器</a>，从而将日志送至不同目标（默认添加了全局的日志处理方法，即输出到<code>stderr</code>）。<a href="https://docs.python.org/3/howto/logging.html#useful-handlers">常用处方法类型</a>：<code>FileHandler</code>、<code>RotatingFileHandler</code>、<code>TimedRotatingFileHandler</code>、<code>SocketHandler</code>、<code>DatagramHandler</code>、<code>SysLogHandler</code>、<code>NTEventLogHandler</code>、<code>QueueHandler</code></p>
<pre><code class="language-python">handler = logging.FileHandler(filename,mode='a',encoding=...) # mode可为追加(a)或清空(w)
from logging import handlers   # 更多的处理方法在handlers模块中
handlers.TimedRotatingFileHandler(filename, when='h', interval=1,...)
# TimedRotatingFileHandler按时间区间轮换
# RotatingFileHandler按文件大小轮换，适用于多个进程向文件写数据。
</code></pre>
<blockquote>
<p><code>when</code>：时间单位包括<code>S</code>秒；<code>M</code>分；<code>H</code>时；<code>D</code>天；<code>W0-W6</code>周（大小写不敏感）。</p>
</blockquote>
<p><code>logger.hasHandlers()</code>可查看日志生成器是否配置了处理方法；使用<code>logger.handlers</code>查看其直接处理方法。如果日志生成器的属性<code>propagate=True</code>，则该日志生成器还会将日志传递上级日志生成器（<code>logger.parent</code>，默认为<code>root</code>）。</p>
<pre><code class="language-shell">handler.setLevel(level)    # handler需要处理的最低日志级别
logger.addHandler(handler) # logger.removeHandler() =&gt; logger.handlers
logger.addFilter(filter)   # and Logger.removeFilter()  =&gt; logger.filters
# addFilter() and removeFilter()
</code></pre>
<h4 id="日志格式"><a class="header" href="#日志格式">日志格式</a></h4>
<pre><code class="language-python">logging.basicConfig(format='[%(asctime)s] - %(levelname)s: %(message)s',
                    datefmt='%Y-%m-%d %H:%M:%S')
</code></pre>
<blockquote>
<p><code>%(name)s</code>：日志发生器名称；
<code>%(asctime)s</code>：输出日期时间（格式参考<code>time.strftime()</code>）；
<code>%(message)s</code>：日志消息；
<code>%(levelname)s</code>，<code>%(lineno)d</code>，<code>%(funcName)s</code>，<code>%(process)d</code>……</p>
</blockquote>
<h5 id="formatter"><a class="header" href="#formatter">Formatter</a></h5>
<pre><code class="language-python">handler.setFormatter(
	logging.Formatter(fmt=None, datefmt=None, style='%|{|$')
)  # 设置格式化方法
</code></pre>
<h4 id="配置日志"><a class="header" href="#配置日志">配置日志</a></h4>
<ol>
<li><a href="https://docs.python.org/3/howto/logging.html#configuring-logging">分别创建</a>并配置日志处理流程的各个对象；</li>
<li>读取日志配置文件<code>fileConfig('log.conf')</code>;</li>
<li>读取包含配置信息的字典<code>dictConfig()</code>，可从<code>JSON</code>或<code>YAML</code>文件读取配置信息。</li>
</ol>
<p><a href="https://docs.python.org/3/howto/logging.html">Logging HOWTO — Python 3.9.5 documentation</a></p>
<p><a href="https://docs.python.org/3/howto/logging-cookbook.html#logging-cookbook">Logging Cookbook — Python 3.9.5 documentation</a></p>
<p><a href="https://www.datadoghq.com/blog/python-logging-best-practices/">How to Collect, Customize, and Centralize Python Logs | Datadog (datadoghq.com)</a></p>
<p><a href="https://docs.python.org/3/library/logging.html">logging — Logging facility for Python — Python 3.9.5 documentation</a></p>
<h3 id="对象输出"><a class="header" href="#对象输出">对象输出</a></h3>
<h4 id="格式化对象输出"><a class="header" href="#格式化对象输出">格式化对象输出</a></h4>
<p>Python内置<code>pprint</code>模块，支持将对象的数据成员序列化为JSON对象并格式化输出（提供缩进），默认输出到标准输出（<code>stream=None</code>）。</p>
<pre><code class="language-python">from pprint import pprint
pprint(object, stream=None, indent=1, width=80, depth=None, *, compact=False)
</code></pre>
<p>使用<code>rich</code>模块能够利用现代终端特性，提供输出内容的风格设置（斜体、加粗、颜色、高亮等）。</p>
<pre><code class="language-shell">from rich import print  # as rprint
print(&quot;[italic red] Hello[/italic red] World!&quot;, locals())  # 替换系统print函数
from rich import pretty
pretty.install()  # 自动格式化Python命令行回显的对象。
from rich import inspect
inspect(obj, methods=Ture)  # 格式化输出对象成员信息
</code></pre>
<blockquote>
<p>在notebook中首先执行<code>%load_ext rich</code>，在Jupyter Notebook中通过<code>display</code>方法使用<code>rich</code>。</p>
</blockquote>
<h4 id="数组输出"><a class="header" href="#数组输出">数组输出</a></h4>
<p>设置打印选项：</p>
<pre><code class="language-python">np.set_printoptions(
  precision=8,  # number of digits after &quot;.&quot;
  linewidth=75, 
  nanstr=None, infstr=None, 
  suppress=False, formatter=None, sign=None, floatmode=None)
</code></pre>
<h4 id="表格输出"><a class="header" href="#表格输出">表格输出</a></h4>
<p>Pandas设置打印宽度等参数：</p>
<pre><code class="language-python">pd.set_option('display.width', 80)        # 每行显示字符数
pd.set_option('display.max_columns', 40)  # 最多显示的数据列数
pd.set_option('display.max_rows', 60)     # 也适用于Jupyter Notebook
</code></pre>
<blockquote>
<p><em><code>width</code>和<code>max_columns</code>需要同时设置才有效。</em></p>
</blockquote>
<p>设置数值显示精度：</p>
<pre><code class="language-python">with pd.option_context('display.precision', 2):
  print(df)
</code></pre>
<h3 id="进度条"><a class="header" href="#进度条">进度条</a></h3>
<h4 id="clickprogressbar"><a class="header" href="#clickprogressbar">click.progressbar</a></h4>
<p><a href="https://click.palletsprojects.com/en/7.x/utils/#showing-progress-bars">Showing Progress Bars</a></p>
<h4 id="tqdm"><a class="header" href="#tqdm">tqdm</a></h4>
<p>安装：</p>
<pre><code class="language-shell">conda install -c conda-forge tqdm # pip install tqdm
</code></pre>
<p>用法：</p>
<pre><code class="language-python">from tqdm import tqdm, trange
for char in tqdm(iterable):
    sleep(0.25)    
for i in trange(100): sleep(0.01)
with tqdm(total=10, desc='TaskName',unit='it') as pbar:   # =&gt; pbar.close()
   for i in range(10):
      tqdm.write(&quot;task in progress ...&quot;)
      sleep(1)			
      _ = pbar.update(n=1)  # True if a `display()` was triggered.
</code></pre>
<blockquote>
<p><code>desc</code>值当进度条左侧显示的信息；<code>unit</code>指定在进度条右侧显示的速率单位。</p>
<pre><code class="language-python">tqbar.set_description(desc=None, refresh=True)
</code></pre>
</blockquote>
<h5 id="防止进度条重绘"><a class="header" href="#防止进度条重绘">防止进度条重绘</a></h5>
<p>直接在进度条循环中添加输出语句（<code>print</code>）会导致进度条重复绘制（内容会粘连到之前绘制的进度条后面），可使用<code>tqdm.write</code>来输出信息（清除之前的进度条并输出信息，然后在下一行重绘进度条）。如果迭代过程中调用第三方库输出内容，可以首先将标准输出和错误输出重定向到<code>tqdm</code>。</p>
<pre><code class="language-python">import sys, contextlib, tqdm, time
from tqdm.contrib import DummyTqdmFile
@contextlib.contextmanager
def std_out_err_redirect_tqdm():
    orig_out_err = sys.stdout, sys.stderr
    try:
        sys.stdout, sys.stderr = map(DummyTqdmFile, orig_out_err)
        yield orig_out_err[0]
    except Exception as exc:
        raise exc
    finally:
        sys.stdout, sys.stderr = orig_out_err
      
with std_out_err_redirect_tqdm() as orig_stdout:
  pbar = tqdm(total=100, file=orig_stdout, dynamic_ncols=True)
  for i in range(100):
    time.sleep(1) # internal messages
    print(f'progress to {i}')
    print(f'progress to {i*10}')
    _ = pbar.update(n=1)
  pbar.close()
</code></pre>
<p>图形界面</p>
<pre><code class="language-python">import tqdm.gui
tqdm.gui.tqdm(total=100, desc='Progress')
</code></pre>
<h5 id="用于applymap操作"><a class="header" href="#用于applymap操作">用于Apply|Map操作</a></h5>
<pre><code class="language-python">tqdm.pandas(desc)
df.progress_apply(...)     # similar to apply()
df.progress_applymap(...)  # similar to applymap()
</code></pre>
<h4 id="alive-progress"><a class="header" href="#alive-progress">alive-progress</a></h4>
<p>安装：<code>pip install alive-progress</code>。</p>
<pre><code class="language-python">from alive_progress import alive_bar
with alive_bar(total=100, title='Task') as bar:
    for i in range(100):      # iterate as usual
      sleep(1)
      bar()                 # call after consuming one item
</code></pre>
<blockquote>
<p><code>title</code>：显示在进度条左侧。</p>
</blockquote>
<h2 id="数据交换"><a class="header" href="#数据交换">数据交换</a></h2>
<h3 id="对象序列化"><a class="header" href="#对象序列化">对象序列化</a></h3>
<h4 id="json对象序列化"><a class="header" href="#json对象序列化">JSON对象序列化</a></h4>
<p>将Python对象转为为JSON描述的字符串形式，并写入文件；或从文件读取JSON字符串并转换为Python对象。</p>
<pre><code class="language-python">json.dump(obj, fp,..., ensure_ascii=True，indent=None，
          default=default_func, cls=custom_encoder)
obj = json.load(fp,...)
</code></pre>
<blockquote>
<p><code>ensure_ascii=True</code>则将非ASCII字符传唤为Unicode转义序列，如<code>\u9ed8\u8ba4</code>；反之则使用UTF-8编码文本，文件也应该使用<code>UTF-8</code>编码打开。</p>
<p><code>indent</code>：如果为None，则不会换行；反之，按给定数量缩进各层级内容；</p>
<p><code>dumps</code>和<code>loads</code>在对象和字符串之间转换。</p>
</blockquote>
<p>默认编码类<code>JSONEncoder</code>支持转换的Python类型包括：</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Python</th><th style="text-align: left">JSON</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>dict</code></td><td style="text-align: left"><code>object</code></td></tr>
<tr><td style="text-align: left"><code>list</code>/ <code>tuple</code></td><td style="text-align: left"><code>array</code></td></tr>
<tr><td style="text-align: left"><code>str</code></td><td style="text-align: left"><code>string</code></td></tr>
<tr><td style="text-align: left"><code>numeric</code>（<code>int,float</code>）</td><td style="text-align: left"><code>number</code></td></tr>
<tr><td style="text-align: left"><code>True</code></td><td style="text-align: left"><code>true</code></td></tr>
<tr><td style="text-align: left"><code>False</code></td><td style="text-align: left"><code>false</code></td></tr>
<tr><td style="text-align: left"><code>None</code></td><td style="text-align: left"><code>null</code></td></tr>
</tbody></table>
</div>
<p>对于<code>JSONEncoder</code>不支持的类型，可通过自定义<code>default</code>方法或继承<code>JSONEncoder</code>并重写<code>default</code>方法。例如，将任意迭代类型转换为<code>list</code>，或者将<code>np.int64</code>转换为<code>int</code>。</p>
<pre><code class="language-python">def default(o):
  try:
    iterable = iter(o)
    return list(iterable)  
  except TypeError as e:
      raise e
def MyEncoder(JSONEncoder):
  def default(self, o):
    pass
</code></pre>
<h5 id="不完整的json对象解析"><a class="header" href="#不完整的json对象解析">不完整的JSON对象解析</a></h5>
<h4 id="yaml"><a class="header" href="#yaml">YAML</a></h4>
<h5 id="安装-1"><a class="header" href="#安装-1">安装</a></h5>
<pre><code class="language-shell">pip install pyyaml
python setup.py --with-libyaml install  # install with lib
</code></pre>
<h5 id="使用"><a class="header" href="#使用">使用</a></h5>
<pre><code class="language-python">import yaml
try:  # use LibYAML based parser and emitter
    from yaml import CLoader as Loader, CDumper as Dumper
except ImportError:
    from yaml import Loader, Dumper
	
data = yaml.load(stream, Loader=Loader)
output = yaml.dump(data, Dumper=Dumper)
</code></pre>
<h4 id="marshmallow"><a class="header" href="#marshmallow">marshmallow</a></h4>
<blockquote>
<p><a href="https://marshmallow.readthedocs.io/en/stable/#marshmallow-simplified-object-serialization">marshmallow: simplified object serialization</a>, <em>converting complex datatypes to and from native Python datatypes.</em></p>
</blockquote>
<p><code>marshmallow</code>使用<code>Schema</code>约束对象的序列化和反序列化时的==数据类型==（相比<code>json</code>无类型验证）。Schema定义的字段对应于对象的成员变量/属性或是字典的元素。</p>
<pre><code class="language-python">from marshmallow import Schema, fields
class ArtistSchema(Schema): # 使用静态成员来定义Schema
    name = fields.Str()
class AlbumSchema(Schema): 
    title = fields.Str()
    release_date = fields.Date()
    artist = fields.Nested(ArtistSchema())  # 嵌套定义
album = dict(   # 要序列化的对象可以是字典或是对象（特别地，数据类对象）
  artist=dict(name=&quot;David Bowie&quot;), 
  title=&quot;Hunky Dory&quot;, 
  release_date=date(1971, 12, 17)
)
schema = AlbumSchema()
result = schema.dump(album)  # -&gt; Python字典
result = schema.dumps(album)  # -&gt; JSON文本
</code></pre>
<p><a href="https://marshmallow.readthedocs.io/en/stable/quickstart.html">Quickstart — marshmallow 3.11.1 documentation</a></p>
<h4 id="pickle"><a class="header" href="#pickle">pickle</a></h4>
<blockquote>
<p><em>The <code>pickle</code> module implements binary protocols for serializing and de-serializing a Python object structure.</em></p>
<p><em>The <code>pickle</code> module <strong>is not secure</strong>. Only unpickle data you trust.</em></p>
</blockquote>
<pre><code class="language-python">pickle.dump(obj, file, ...)   # write an object to file stream
obj_bytes = pickle.dumps(...) # return bytes array instead of writing to file
</code></pre>
<p><code>file</code>：打开的文件对象。</p>
<pre><code class="language-python">a = pickle.load(file, ...)
a = pickle.loads(bytes_buffer, ...)
</code></pre>
<blockquote>
<p><code>pickle</code>编码的数据与代码相关，不同Python版本间可能存在兼容性问题。</p>
<p><code>pickle</code>编码速度较慢。</p>
</blockquote>
<h5 id="cloudpicke"><a class="header" href="#cloudpicke">cloudpicke</a></h5>
<p><code>cloudpickle</code>支持序列化<code>pickle</code>模块不支持的Python数据结构，尤其是支持==函数对象==，因此可以将代码保存并传递到本地或远程的其他进程。<code>cloudpickle</code>提供与<code>pickle</code>相同的接口。</p>
<h5 id="marshal"><a class="header" href="#marshal">marshal</a></h5>
<p><code>marshal</code>不能用于序列化用户自定义类型对象。</p>
<blockquote>
<p><em>The <code>marshal</code> module exists mainly to support reading and writing the “pseudo-compiled” code for Python modules of <code>.pyc</code> files. Therefore, the Python maintainers reserve the right to modify the marshal format in ==backward incompatible== ways should the need arise. If you’re serializing and de-serializing Python objects, use the <code>pickle</code> module instead – <strong>the performance is comparable, version independence is guaranteed, and pickle supports a substantially wider range of objects than marshal</strong>.</em></p>
</blockquote>
<p><a href="https://stackoverflow.com/a/10050570/6571140">How to pickle a python function with its dependencies?</a></p>
<h5 id="shelve"><a class="header" href="#shelve">shelve</a></h5>
<blockquote>
<p><em>A “shelf” is a persistent, dictionary-like object, where the <strong>values</strong> in a shelf can be essentially arbitrary Python objects that the <code>pickle</code> module can handle. including most <strong>class instances, recursive data types, and objects containing lots of shared sub-objects</strong>. The <strong>keys</strong> are ordinary strings.</em></p>
<p><a href="https://docs.python.org/3/library/shelve.html#module-shelve">shelve — Python object persistence — Python 3.10.7 documentation</a></p>
</blockquote>
<h3 id="导入导出数据"><a class="header" href="#导入导出数据">导入导出数据</a></h3>
<h4 id="使用numpyscipy"><a class="header" href="#使用numpyscipy">使用NumPy/SciPy</a></h4>
<p>保存数组数据为二进制文件(默认以<code>.npy</code>作为扩展名)。</p>
<pre><code class="language-python">np.save(file_name, array, allow_pickle=True, fix_imports=True)
array = np.load(file_name)	# 加载数组或pickle对象。
</code></pre>
<blockquote>
<p>序列类型也可以进行保存，Numpy会自动将其转换为<code>ndarray</code>。</p>
</blockquote>
<h5 id="保存多个数组"><a class="header" href="#保存多个数组">保存多个数组</a></h5>
<pre><code class="language-python">np.savez(file, arrays, kw_arrays)  # save as '.npz' format
</code></pre>
<p>使用关键字参数可以关键字作为数组名一并保存；反之，数组将按<code>'arr_0', 'arr_1'</code>的方式依次命名。</p>
<blockquote>
<p><code>npz</code>文件格式是一个由数组对象对应的<code>npy</code>文件组成的档案文件。使用<code>savez_compressed</code>将档案文件进行压缩。</p>
</blockquote>
<p>同样使用<code>np.load</code>读取<code>npz</code>文件并返回一个<code>NpzFile</code>对象，可访问其中包括的数组对象。</p>
<pre><code class="language-python">arrays = np.load(file)
var_names = arrays.files  # 获取包含的数组名
arr = arrays[var_name]    # 读取数组
</code></pre>
<h5 id="保存数组为文本文件"><a class="header" href="#保存数组为文本文件">保存数组为文本文件</a></h5>
<p>==仅适用于<code>1D</code>或<code>2D</code>数组==。</p>
<pre><code class="language-python">np.savetxt(fname, array, fmt='%.18e', delimiter=' ', newline='\n', header='', ...)
array = np.loadtxt(fname, dtype=&lt;class 'float'&gt;, delimiter=None,...)
array = np.genfromtxt(fname, dtype=&lt;class 'float'&gt;, delimiter=None,...)
</code></pre>
<blockquote>
<p><code>fmt</code>中可以添加固定字符，例如添加<code>\n</code>以强制换行。</p>
<p><code>newline</code>为插入到两行之间的分隔符（默认<code>\n</code>）；</p>
<p><code>genfromtxt</code>增加了处理缺失数据的选项。</p>
</blockquote>
<h5 id="保存稀疏数组"><a class="header" href="#保存稀疏数组">保存稀疏数组</a></h5>
<pre><code class="language-python">from scipy import sparse
sparse.save_npz(file_path, matrix)
matrix = sparse.load_npz(file_path)
</code></pre>
<h4 id="使用pandas-1"><a class="header" href="#使用pandas-1">使用Pandas</a></h4>
<p>Pandas提供读取多种格式的数据的方法：包括<code>CSV</code>、<code>EXCEL</code>、<code>JSON</code>、数据库等。<code>pd.read_csv/read_json()</code>和<code>pd.DataFrame.to_csv/to_json()</code>可读取文件或<a href="Python/Python%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA.html#%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%AF%B9%E8%B1%A1">IO文本缓存对象</a>。</p>
<pre><code class="language-python"># 适用于转换命令行输出的表格型数据
df=pd.read_csv(io.StringIO(output))
</code></pre>
<h5 id="csv"><a class="header" href="#csv">CSV</a></h5>
<pre><code class="language-python">data = pd.read_csv(
    &quot;D:/DataSets/NSL-KDD/KDDTrain+.txt&quot;, header='infer', index_col=None, escapechar=&quot;\\&quot;)
</code></pre>
<blockquote>
<p><code>header</code>:默认将第一行作为表头<code>header=0</code>，没有头部的<code>CSV</code>文件应该设置<code>header=None</code>（将生成默认数组编号表头）；
<code>names</code>：代替从文件中读取的表头；
<code>index_col</code>：设置作为行索引的列名，设置多个列名以生成<code>MultiIndex</code>；
<code>usecols</code>：指定要读取的列；
<code>dtype</code>：指定数据类型，使用字典单独指定某列类型；
<code>skipinitialspace</code>：==跳过分隔符后的空白字符==。
<code>quotechar</code>：引号字符用于包含字符串，对字符串中的分隔符转移；<code>doublequote</code>将两个连续引号字符视为一个引号元素。
<code>escapechar</code>：转义字符，可以消除任何字符可能具有的特殊含义（<code>\n</code>、<code>\t</code>等代表特殊控制序列，直接转换为字母），主要用于消除引号的特殊意义。<strong>不仅限于使用引号字符的字符串，任何字段中包含转移字符都有效</strong>。
分隔符<code>sep|delimiter</code>：<code>sep=','</code>（默认）；<code>\s+</code>空白，==用于处理以空格或<code>\t</code>分隔的数据==；长于1个字符将被视为正则表达式（强制使用Python解析引擎）；<code>delim_whitespace=True</code>用于指定空白作为分隔符。
<code>lineterminator</code>：只有选择<code>'C'</code>解析引擎才可用。
<code>encoding=utf-8</code>：文件的编码方案，其他包括：<code>gb18030</code>。
<code>skiprows=N|[i,j,...]|func</code>：跳过文件中的行，先于读取表头（即跳过的行包含表头）。如果参数为列表，则跳过指定行，如果为整数则跳过相应行数。如果为函数，则函数根据输入行号计算是否跳过对应行，如：</p>
<ul>
<li><code>lambda i: i&gt;0 and i&lt;=100</code>（跳过除第一行之后的100行）。</li>
<li><code>lambda j: i%2==0</code>（跳过奇数行）。</li>
</ul>
<p><code>error_bad_lines</code>：
<code>warn_bad_lines</code>：
<code>comment</code>：注释行开始符号。</p>
</blockquote>
<p>日期解析选项：</p>
<ul>
<li><code>parse_dates:bool|List[str]|List[int]|dict{'name': List}</code>：指定是否解析日期以及解析日期的列名/编号；使用字典表示使用多列的值拼接后进行解析，并将解析后的值以字典键名作为列名输出。</li>
<li><code>infer_datetime_format=False</code>：自动推测日期格式。</li>
<li><code>keep_date_col=False</code>：如果是使用原数据的多列拼接解析，是否保留原数据。</li>
<li><code>date_parser=dateutil.parser.parser</code>：解析日期的函数。</li>
<li><code>day_first=False</code>：日期格式为<code>DD/MM</code>。</li>
</ul>
<p>读取<code>excel</code>文件需要<code>openpyxl</code>库支持。</p>
<p>输出：</p>
<pre><code class="language-python">df.to_csv(&quot;path/to/file.csv&quot;, header=True, index=True, columns=None, float_format='%.2f', sep=',', na_rep='', )
</code></pre>
<blockquote>
<p>使用<code>columns</code>参数指定导出的列。</p>
<p><code>quotechar</code>（默认为<code>&quot;</code>）、<code>doublequote=True</code>、<code>escapechar=None</code></p>
</blockquote>
<h5 id="json-1"><a class="header" href="#json-1">JSON</a></h5>
<pre><code class="language-shell">pd.read_json(path_or_none, orient='records', dtype=True, 
	convert_dates=True, keep_default_dates=True, date_unit=None, 
	encoding='utf-8', encoding_errors='strict', 
	compression='infer', # 'infer', 'gzip', 'bz2', 'zip', 'xz', None for no compression
	lines=False, chunksize=None, nrows=None, # refer to pd.read_csv()
	storage_options=None   # e.g. http://user:passwd@host/path/file.json
)
</code></pre>
<p><code>orient</code>：导出数据格式。</p>
<ul>
<li>
<p><code>'split'</code>：<code>=&gt;{'index':[...],'columns':[...],'data':[...]}</code>，分别存储索引、列名和数据（矩阵）；</p>
</li>
<li>
<p><code>'values'</code>：仅存储数据矩阵（<code>split</code>的数据矩阵）；</p>
</li>
<li>
<p><code>'index'</code> ：<code>=&gt;{'index':{'column':value,...},...}</code>，按==行索引==存储记录，每条记录都包含列名；</p>
<ul>
<li>
<p><code>'columns'</code>：<code>=&gt;{'column':{'index':value,...},...}</code>，按==列存储==，每列都包含索引名；</p>
</li>
<li>
<p><code>'records'</code>：<code>=&gt;[{'col1':val1,...},...,{'col2':val2,...}]</code>，使用列表存储记录，不存储索引；</p>
</li>
<li>
<p><code>'table'</code>：<code>{'schema': schema, 'data': data}</code>。<code>data</code>结构和<code>records</code>输出结构相同（包含<code>index</code>）；</p>
<pre><code class="language-json">{
   &quot;fields&quot;: [{&quot;name&quot;: name, &quot;type&quot;: type},...],
   &quot;primaryKey&quot;: [&quot;index&quot;]
}
</code></pre>
</li>
</ul>
</li>
</ul>
<p><code>dtype</code>：默认自动推导数据类型，如果为字典则使用指定类型；</p>
<p><code>convert_dates</code>：默认将类似日期的列转换为日期类型数据（<code>datetime64[ns]</code>）；如果为列表，则只对指定列进行转换；</p>
<p><code>keep_default_dates</code>：默认尝试转换以<code>'_at','_time'</code>结尾，以<code>'timestamp'</code>开头，或为<code>'modified, date'</code>的字段；</p>
<p><code>date_unit</code>：默认尝试检测日期的单位；如果自动检测不正确，则可以指定单位为<code>'s','ms','us','ns'</code>；此处指定的时间单位仅影响读取数据，==不影响转换后日期类型的单位==。</p>
<p><code>chunksize</code>：分块大小，返回一个迭代对象，每次获取指定数量的记录；</p>
<p><code>nrows</code>：仅返回指定数量的记录（默认返回全部）。</p>
<pre><code class="language-python">df.to_json(path_or_none, orient='records', 
           date_format='epoch', date_unit='ms', double_precision=10, 
           force_ascii=True,  # 不强制保存为ASCII（可使用UTF-8打开文件）
           lines=False,  # for orient='records'：输出去掉外层[]，每行一条记录
           index=True,   # for orient='split'| 'table'
           indent=4, 
           default_handler=str,
           compression='infer', # infer from filename
           storage_options,
          )
</code></pre>
<blockquote>
<p><code>date_format</code>：<code>'epoch'</code>表示<code>date_unit</code>单位的时间戳（除<code>orient='table'</code>外的默认值），<code>iso</code>表示ISO8601文本格式（<code>2017-09-30T09:00:00</code>，<code>orient='table'</code>的默认值）。</p>
<p><code>date_unit</code>：转换后的数值单位（<code>'s','ms','us','ns'</code>）。</p>
<p><code>default_handler</code>：对于无法转换的数据结构的默认转换方法。</p>
<p>与<code>to_json()</code>类似的方法是<a href="Python/Python%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.html#%E4%BB%A5%E5%AD%97%E5%85%B8%E6%88%96%E5%88%97%E8%A1%A8%E5%88%9D%E5%A7%8B%E5%8C%96"><code>to_dict()</code></a>，后者仅将数据表转换为Python字典，因此不需要考虑数据序列化的问题，因此没有序列化相关参数。</p>
</blockquote>
<h5 id="parquet"><a class="header" href="#parquet">Parquet</a></h5>
<pre><code class="language-python">df.to_parqeut(filepath=None, index=None, partition_cols=None)
</code></pre>
<blockquote>
<p><code>index=False</code>：不保存索引信息。如果为<code>True</code>则索引被保存为数据列，如果为<code>None</code>，则索引被保存为元数据。==如果未指定分区，则路径为文件；反之，路径为目录名==；如果未指定路径则返回一个<code>bytes</code>对象。</p>
<p>Pandas使用<code>pyarrow</code>库作为读写Parquet文件的接口，使用以下方法可以读取文件的元信息：</p>
<pre><code class="language-python">import pyarrow.parquet as pq
pq.read_metadata(file)    # 汇总信息
schema = pq.read_schema(file)      # 表格字段类型定义
types = [str(t) for t in schema.types] 
df = pd.DataFrame({'Field': schema.names, 'Type': types})
</code></pre>
</blockquote>
<p><em>读取分片数据时可能遇到类型不匹配问题（null schema）。</em></p>
<h5 id="数据库"><a class="header" href="#数据库">数据库</a></h5>
<p>Pandas使用<code>SQLAlchemy</code>读取数据库。</p>
<pre><code class="language-python">sql_engine = sqlalchemy.create_engine(db_url, **kwargs)
df = pd.read_sql(table_or_query, sql_engine, **kwargs)
</code></pre>
<p>如果参数为表名则调用<code>read_sql_table</code>，反之调用<code>read_sql_query</code>。</p>
<p><code>index_col</code>：用作索引的列（<code>str</code>或<code>list</code>）；
<code>coerce_float</code>：尝试将非数值（如<code>decimal.Decimal</code>）转换为浮点数类型；
<code>parse_dates</code>：针对源数据为字符串或时间戳，转为日期时间的列名（<code>list</code>）或：</p>
<ul>
<li><code>{column_name: format_string}</code>）：列名及其对应的变换格式；</li>
<li><code>{column_name: arg_dict}</code>：列名及传递给<code>pandas.to_datetime</code>的选项参数（用于数据库不支持<code>Datetime</code>的情况）</li>
</ul>
<p><code>columns</code>：从表中读取的列（仅用于读取表格）；
<code>chunksize</code>：如果指定该参数，则返回一个迭代器<code>Iterator[DataFrame]</code>包含指定的行数；</p>
<p>写入数据库（如果表格不存在将自动创建）：</p>
<pre><code class="language-python">df.to_sql(
   table_name,
   con=sql_engine,          # created by SQLalchemy
   if_exists='fail',        # 如果表格存在, &quot;replace&quot; or &quot;append&quot;
   dtype=dict_or_scalar,    # 指定某些列的类型，使用SQLAlchemy定义的类型
   index=True,              # 是否将索引保存为数据库表的列
   index_label=str_or_list, # 指定保存的索引列名称
   chunksize=None           # 每次写入的行数（默认一次全部写入）
)
</code></pre>
<p>覆盖表格内容：使用<code>if_exists='replace'</code>将删除并重新创建数据库表。为了==确保数据库表的定义不变==（<code>to_sql</code>生成的表定义可能与人工配置的定义不同），可在写入前先执行<code>TRUNCATE TABLE</code>命令，再使用<code>if_exists='append'</code>进行==追加写入==。</p>
<p><code>df.to_sql()</code>不支持更新已有数据库表中的记录（因为涉及查找匹配记录的具体逻辑）。</p>
<h3 id="读写配置文件"><a class="header" href="#读写配置文件">读写配置文件</a></h3>
<p><code>configparser</code>：<a href="https://betterprogramming.pub/tips-and-tricks-for-handling-configuration-files-in-python-a9d7429aa50b">Tips and Tricks for Handling Configuration Files in Python | by Ng Wai Foong | Better Programming</a></p>
<p><a href="https://stackoverflow.com/questions/3085029/pros-and-cons-for-different-configuration-formats">python - Pros and cons for different configuration formats? - Stack Overflow</a></p>
<p><a href="https://www.barenakedcoder.com/blog/2020/03/config-files-ini-xml-json-yaml-toml/">Config Files: INI, XML, JSON, YAML, TOML | BareNakedCoder.com</a></p>
<h2 id="声音"><a class="header" href="#声音">声音</a></h2>
<p>产生蜂鸣音：</p>
<pre><code class="language-python">import winsound
frequency = 2500  # Set Frequency To 2500 Hertz
duration = 1000  # Set Duration To 1000 ms == 1 second
winsound.Beep(frequency, duration)
os.system(&quot;beep -f 555 -l 460&quot;)  # on linux
</code></pre>
<h2 id="图形"><a class="header" href="#图形">图形</a></h2>
<h3 id="matplotlib"><a class="header" href="#matplotlib">Matplotlib</a></h3>
<p><code>matplotlib</code>中，frontend就是我们写的python代码，而backend就是负责显示我们代码所写图形的底层代码。backend分为两类：</p>
<ul>
<li><code>interface backend</code>（<code>interactive backend</code>）：跟显示到屏幕相关的UI库（需要额外安装）；</li>
<li><code>hardcopy backend</code>（<code>non-interactive backend</code>）：写入到文件相关的库。</li>
</ul>
<pre><code class="language-python">import matplotlib
matplotlib.rcsetup.interactive_bk     # 获取 interactive backend
# GTK4Agg, Qt5Agg, TkAgg, WXAgg, GTX4Cario, Qt5Cario, TkCario, WXCario ......
matplotlib.rcsetup.non_interactive_bk # 获取 non-interactive backend
# agg, cario, pdf, pgf, ps, svg, template
matplotlib.rcsetup.all_backends       # 获取所有 backend
plt.get_backend()          # 获取正在使用的后端
plt.switch_backend('name') # 切换后端
matplotlib.use('Qt5Agg')   # 切换后端, use before import pyplot
</code></pre>
<blockquote>
<p>不同的后端提供的图形接口可能不同。</p>
</blockquote>
<h4 id="绘图窗口figure"><a class="header" href="#绘图窗口figure">绘图窗口（figure）</a></h4>
<pre><code class="language-python">import matplotlib.pyplot as plt
fig = plt.figure(num=None, figsize=None, dpi=None, facecolor=None, edgecolor=None, frameon=True, clear=False)
</code></pre>
<p><code>figsize</code>：图形尺寸（英寸）<code>[width, height]</code>。</p>
<p><code>clear</code>：激活图形时是否清除已有内容。</p>
<p><code>num</code>：可以为整数（<code>fig.number</code>）或字符串（作为图形标签以及窗口标题）。如果没有指定，则自动编号。如果为整数，则窗口编号默认为<code>Figure &lt;num&gt;</code>。==如果指定编号切片对应图形窗口存在，则激活该窗口，反之创建对应该编号的窗口。==可以在相关绘图函数中指定编号以操作对应的图形窗口。</p>
<p>图形窗口创建后默认为隐藏状态，需要调用<code>fig.show()</code>（非阻塞）/<code>show()</code>来显示窗口。</p>
<p>利用各种绘图函数也可以自动创建图形窗口。</p>
<h5 id="绘制子图"><a class="header" href="#绘制子图">绘制子图</a></h5>
<p>在当前图形窗口中创建子图。如果当前没有图形窗口则创建一个。</p>
<pre><code class="language-python">ax = plt.subplot(nrows, ncols, index, ...,**kwargs)
ax = plt.subplot(pos, ..., **kwargs)
</code></pre>
<p><code>nrows</code>，<code> ncols</code>指定网格大小，<code>index</code>为按行索引的子图序号。<code>index</code>也可以设置为二元组<code>(first,last)</code>表示子图跨列。==当指定的网格大小超出当前图形窗口的网格范围，会清除此前已经创建的子图网格并重新创建；反之，则切换当前子图。==如果只是添加子图，则使用<code>add_subplot()</code>方法。</p>
<p><code>pos</code>使用三位数字代替<code>nrows, ncols, index</code>（少于9幅子图）；</p>
<p><code>sharex, sharey</code>：所有子图共享坐标轴设置（limits, ticks, scale）；</p>
<p><code>label</code>：子图坐标系的标签；当指定指定坐标子图时默认返回已有子图（如果没有则新创建一个），==如果提供不同标签，则会返回新的子图==。</p>
<p><code>**kwargs</code>：<a href="https://matplotlib.org/3.1.1/api/_as_gen/matplotlib.pyplot.subplot.html"><code>subplot()</code></a>方法还接受坐标轴的属性对应的关键字参数。</p>
<blockquote>
<p>封装了<code>Figure.add_subplot(nrows, ncols, index, ...,**kwargs)</code>。</p>
</blockquote>
<p>创建一个包含子图网格的窗口：==当所有子图的属性一致时，以及设置窗口属性==，使用该函数更加方便。</p>
<pre><code class="language-python">fig,ax = plt.subplots(nrows=1, ncols=1, 
                      **subplot_kw, **gridspec_kw, **fig_kw)
</code></pre>
<p>当只生成一幅子图时，返回的坐标对象<code>ax</code>；当生成<code>1xN</code>或<code>Nx1</code>幅子图时，返回1维坐标对象向量；其他返回<code>MxN</code>坐标对象矩阵。</p>
<blockquote>
<p>当不提供行列数（即<code>nrows=1, ncols=1</code>），<code>subplots</code>等效于先创建图形窗口，再调用<code>fig.add_subplot()</code>。</p>
<p><code>subplots()</code>不接受<code>pos</code>参数。</p>
</blockquote>
<h5 id="获取当前窗口"><a class="header" href="#获取当前窗口">获取当前窗口</a></h5>
<p>获取当前窗口，如果不存在图形窗口，则创建一个。</p>
<pre><code class="language-python">fig = plt.gcf() 
</code></pre>
<h5 id="部件"><a class="header" href="#部件">部件</a></h5>
<h4 id="显示绘图"><a class="header" href="#显示绘图">显示绘图</a></h4>
<pre><code class="language-python">plt.show(block=True)  # show current figure  
</code></pre>
<blockquote>
<p><code>block=True</code>：在交互式终端中，显示绘图后阻塞程序，直到绘图窗口关闭。<code>fig.show()</code>不能阻塞程序，当程序退出时，图形窗口将关闭（在图形显示后执行<code>sleep</code>会使图形窗口无响应）。</p>
</blockquote>
<p>在非交互模式（<code>ion()</code>/<code>ioff()</code>）下，修改图形数据后重绘当前图形窗口。</p>
<pre><code class="language-python">plt.draw()  # ==&gt; fig.canvas.draw_idle()
plt.clf()   # Clear the current figure
</code></pre>
<h5 id="清除图形内容"><a class="header" href="#清除图形内容">清除图形内容</a></h5>
<pre><code class="language-python">fig.clear()   # fig.clf() 清除图形内容
ax.cla()  # 清除坐标轴内容
</code></pre>
<p>关闭图形窗口</p>
<pre><code class="language-python">plt.close()
</code></pre>
<h4 id="坐标系"><a class="header" href="#坐标系">坐标系</a></h4>
<p>除了绘图返回坐标系以外，也可以首先手动创建坐标系。</p>
<pre><code class="language-python">from matplotlib.pyplot import axes, gca
ax = plt.axes(**kwargs)	# creat an axes and make it current axes.
plt.axes(ax)			      # add an axes and make it the current axes.
</code></pre>
<p>获取当前坐标系，如果不存在，则创建一个新的坐标系。</p>
<pre><code class="language-python">ax = plt.gca(**kwargs)		# 参数用于必要情况下创建坐标系
</code></pre>
<pre><code class="language-python">ax.get_figure()  # 获取坐标系所属图片
ax.axis('off')   # hide the axes: ax.set_axis_off()
</code></pre>
<pre><code class="language-python">ax.set(**kwargs)
ax.set_title(label, fontdict=None, loc={'center|left|right'},y)   
ax.set_xlabel()  # set_ylabel
ax.set_xlim()    # set_ylim
</code></pre>
<blockquote>
<p><code>kwargs</code>中的属性都对应了相应的<code>set_property()</code>方法。<code>plt.property(...)</code>快捷方法等效于调用或<code>ax.set_property(...)</code></p>
<p>使用$\LaTeX$为标签添加数学公式：</p>
<pre><code class="language-python">bbplt.rcParams.update({
 &quot;text.usetex&quot;: True,
 &quot;font.family&quot;: &quot;sans-serif&quot;,        # serif
 &quot;font.sans-serif&quot;: [&quot;Helvetica&quot;]})  # &quot;Times New Roman&quot;
</code></pre>
<p>在标签文本中添加行内公式（inline），$\LaTeX$命令需要使用转义字符<code>$\\beta=0.1$</code>。</p>
</blockquote>
<h5 id="设置坐标刻度"><a class="header" href="#设置坐标刻度">设置坐标刻度</a></h5>
<p>默认以图形数据的<code>x,y</code>值作为刻度数值和刻度的标签。当数据点数较多时，可人工设置刻度值和标签，从而减少坐标轴上标记的数量（刻度数值和刻度标签是一一对应的，刻度标签需要在设置刻度后设置（调用<code>ax.set_xticks,ax.set_xticklabels</code>或者<code>plt.xticks</code>等效调用），否则可能会导致标签与刻度错位）。</p>
<pre><code class="language-python">ax.set_xticks(x, minors=False)           # =&gt; set_yticks, 
ax.set_xticklabels(labels, minors=False, rotation=50) # set_yticklabels
plt.xticks(ticks=None,labels=None,**kwargs)      # 同时设置刻度值和刻度标签(Text properties)
</code></pre>
<blockquote>
<p><code>kwargs</code>为<a href="https://matplotlib.org/stable/api/text_api.html#matplotlib.text.Text">标签文本的属性</a>，包括<code>rotation</code>（逆时针旋转角度）。<code>plt.xticks</code>在未提供刻度和标签参数，但提供属性参数时，更新当前坐标轴刻度的属性。</p>
</blockquote>
<p>坐标轴对象提供了刻度常用属性的设置：</p>
<pre><code class="language-python">ax.tick_params(axis='both|x|y', which='major|minor', labelrotation=...) # 设置刻度及标签属性
ax.ticklabel_format(axis='both|x|y', style='sci', scilimits=(0,3)) # 设置标签格式（科学计数法）
</code></pre>
<blockquote>
<p><a href="https://matplotlib.org/stable/api/_as_gen/matplotlib.axes.Axes.tick_params.html?highlight=tick_params#matplotlib.axes.Axes.tick_params"><code>tick_params</code></a>常用属性包括：</p>
<ul>
<li><code>color, labelsize, labelcolor,labelrotation</code>，</li>
<li><code>bottom,top,left,right</code>（是显示某个方向的刻度），</li>
<li><code>labelbottom,labeltop,labelleft,labelright</code>（是否显示某个方向的标签）。</li>
</ul>
</blockquote>
<h5 id="设置网格"><a class="header" href="#设置网格">设置网格</a></h5>
<pre><code class="language-python">plt.grid(color='#95a5a6', linestyle='--', linewidth=2, axis='y', alpha=0.7)
</code></pre>
<h5 id="设置图例"><a class="header" href="#设置图例">设置图例</a></h5>
<pre><code class="language-python">ax.legend(fontsize='small', loc='upper left', ncol=2) # 自动设置(plt.legend)
ax.legend(lines, labels, ...) # 指定对应图例
</code></pre>
<p>自动设置：1) 在调用相应绘图函数时指定标签（<code>label='line_label'</code>）；2）通过已绘制的图形部件设置标签（<code>set_label('line_label')</code>）；</p>
<blockquote>
<p>以下划线开头的标签，将不会自动显示在图例中。</p>
</blockquote>
<h4 id="图形部件"><a class="header" href="#图形部件">图形部件</a></h4>
<h5 id="折线图"><a class="header" href="#折线图">折线图</a></h5>
<pre><code class="language-python">lines = plt.plot([x], y, [fmt], [x2], y2, [fmt2], ..., **kwargs)
lines = ax.plot(...)
</code></pre>
<p>使用<code>fmt</code>定义折线格式的颜色、标记和线形，例如<code>--ro</code>；或使用曲线（<code>Line2D</code>）属性作为<code>kwargs</code>（应用于此次绘制的所有曲线），其中：</p>
<ul>
<li>
<p><code>color='green'</code>（或<code>c</code>）：</p>
</li>
<li>
<p><code>marker='o'</code>：标记类型，常用类型包括：<code>+</code>(加号)、<code>o</code>(实心圆)、<code>*</code>(星号)、<code>.</code>（点）、<code>|_</code>(短划线)、<code>1|2|3|4</code>（三分符号）、 <code>x</code>(斜十字)、<code>^|v|&lt;|&gt;</code>(三角形)、<code>s</code>(正方形)、<code>D|d</code>(菱形)、<code>p</code>(五边形)、<code>h|H</code>(六边形)</p>
<blockquote>
<p><code>,</code>(仅为一个像素点)、<code>8</code>(八边形)、<code>P</code>(加粗十字)、<code>X</code>(加粗斜十字)。</p>
</blockquote>
</li>
<li>
<p><code>markersize=12</code>：标记尺寸；</p>
</li>
<li>
<p><code>markevery=(start,N)</code>：当绘图点数较多时，通过该选项减少标记的点数。每<code>N</code>个点标记，从<code>start</code>开始标记（<code>Line2D.set_markevery()</code>）。</p>
</li>
<li>
<p><code>fillstyle</code>：标记填充方式，<code>'full'</code>使用<code>markerfacecolor</code>填充、<code>none</code>不填充；</p>
</li>
<li>
<p><code>linestyle='-'</code>（或<code>ls</code>）：线形<code>'-','--','-.',':','',...</code>；</p>
</li>
<li>
<p><code>linewidth=2</code>（或<code>lw</code>）：</p>
</li>
<li>
<p><code>label='Line1'</code>：折线关联的标签，用于显示图例（<code>ax.legend</code>）。</p>
</li>
</ul>
<h6 id="对数尺度绘图"><a class="header" href="#对数尺度绘图">对数尺度绘图</a></h6>
<p>手动绘图：将坐标值进行对数转换（<code>np.log10</code>）；坐标轴刻度值设置为相应的对数转换后的值，坐标轴刻度标签设置为原始数值的表示。</p>
<pre><code class="language-python">ax = np.plot(np.log10(x), y)
ax.set(
  xticks = np.log10(sub_x), # 选取部分值作为坐标轴刻度
  xticklabels = ['format'.(x) for x in sub_x]
)
</code></pre>
<p>使用库函数绘制对数尺度折线图：自动设置刻度和标签格式（默认为指数表示）。</p>
<pre><code class="language-python">plt.semilogx(x,y,...) # plt.semilogy(...), ax.semilogx(...), ...
plt.loglog(x,y,...) # 横纵坐标均使用对数尺度绘图。
</code></pre>
<blockquote>
<p>如果需要手动设置刻度标签，为了使刻度均匀分布，刻度值应该是等比数列，标签与刻度值保持一致。</p>
</blockquote>
<pre><code class="language-python">plt.axvline(x)  # 垂直线, 水平线 plt.axhline(x)
</code></pre>
<h5 id="柱状图"><a class="header" href="#柱状图">柱状图</a></h5>
<pre><code class="language-python">from matplotlib.axes import Axes
bars = ax.bar(x, height, align='center', tick_label=...,
              width=0.8, label=...)
</code></pre>
<p><code>x</code>：柱状图的横坐标；如果<code>x</code>为数值则表示实际位置；如果<code>x</code>为字符串，则位置按序号确定。<code>x</code>的值为默认横坐标标签，使用<code>tick_label</code>自定义横坐标标签。<code>width</code>表示柱形占<code>x</code>两个点之间的间距的比例，<code>align='center'|'edge'</code>为柱形相对<code>x</code>点的对齐方式（默认为中心对齐，<code>edge</code>为靠左边缘对齐）。</p>
<p><code>xerr,yerr</code>：横纵坐标的值与误差。误差的设置方式：</p>
<ul>
<li>标量：每个柱形的<code>+/-</code>误差相同；</li>
<li>向量：每个柱形对应<code>+/-</code>误差，<code>+/-</code>误差相同；</li>
<li>矩阵（<code>2,N</code>）：每个柱形具有独立的<code>+/-</code>误差。</li>
<li><code>None</code>：没有误差线。</li>
</ul>
<blockquote>
<p>使用<code>barh</code>绘制水平柱形图。此时<code>x</code>为纵轴，<code>y</code>为横轴，但``xerr,yerr`的含义不变。</p>
</blockquote>
<p><code>label</code>：为一个系列数据的标签，用于显示图例（<code>legend</code>）。</p>
<p>颜色选项：<code>color</code>、<code>edgecolor</code>；</p>
<p>线条选项：<code>linewidth</code>、``</p>
<h6 id="堆栈式柱状图"><a class="header" href="#堆栈式柱状图">堆栈式柱状图</a></h6>
<p>每个条形分为多段，每一段代表一个系列的数据。</p>
<p>通过指定<code>bottom</code>参数来指定各个系列的相对位置。</p>
<pre><code>ax.bar(x,y1,...)
ax.bar(x,y2,...,bottom=y1)
</code></pre>
<h6 id="分组柱状图"><a class="header" href="#分组柱状图">分组柱状图</a></h6>
<p><img src="Python/Python输入输出.assets/sphx_glr_barchart_001.png" style="float: right; zoom: 150%;" />多个系列数据的每个点并列展示。绘图时需要设置每个系列的<code>x</code>值偏移量，使各系列同一点的柱形并排显示（<code>pandas</code>封装了<a href="Python/Python%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA.html#Pandas">分组柱状图的快捷绘图方式</a>）。</p>
<h5 id="频数直方图"><a class="header" href="#频数直方图">频数直方图</a></h5>
<pre><code class="language-python">plt.hist(x, bins, range, density)
</code></pre>
<p>如果<code>x</code>是多个序列组成列表，则分别统计并绘制多个直方图。</p>
<p><code>bins</code>：如果为整数，则指定分组个数，按均匀间隔分组；如果为序列，则指定分组的边界（$N+1$）；如果为字符串，则应该为：<code>'auto', 'fd', 'doane','scott', 'stone', 'rice', 'sturges', or 'sqrt'</code>（<code>np.histogram_bin_edges</code>）。</p>
<p><code>density=True</code>：显示频率而非频数。</p>
<h5 id="饼图"><a class="header" href="#饼图">饼图</a></h5>
<pre><code class="language-python">ax.pie(sizes, explode=None, 
       labels=None, labeldistance,           # 标签及其离中心距离
       autopct='%1.1f%%', pctdistance=None,  # 百分比及其离中心距离
       shadow=False, startangle=0)
</code></pre>
<p><code>explode</code>控制饼图组成部分与中心分离的程度；</p>
<p><code>autopct</code>：在饼图中显示百分比，并设置百分数格式；</p>
<p><code>shadow</code>：饼图的立体阴影；</p>
<p><code>startangle</code>：起始部分的角度（默认为0，即右侧水平位置）；</p>
<h5 id="boxplot"><a class="header" href="#boxplot">boxplot</a></h5>
<img style="float: right; zoom: 80%;" src="Python/Python输入输出.assets/ploxplot.png">
<h5 id="hexbin"><a class="header" href="#hexbin">hexbin</a></h5>
<p><img style="float: right; zoom: 40%;" src="Python/Python输入输出.assets/hexbin.png">统计二维数据的分布信息。</p>
<h5 id="形状"><a class="header" href="#形状">形状</a></h5>
<pre><code class="language-python">from matplotlib.patches import Ellipse, Polygon
</code></pre>
<h5 id="文本"><a class="header" href="#文本">文本</a></h5>
<p><a href="https://matplotlib.org/stable/api/text_api.html#matplotlib.text.Text">文本对象</a>在图中的标题、坐标轴标题、图例、刻度标签等使用，需要设置其属性。标签文本的常用属性包括：</p>
<ul>
<li><code>text</code>：</li>
<li><code>color</code>：</li>
<li><code>fontfamily={FONTNAME,'serif','sans-serif','monospace'}</code>：</li>
<li><code>math_fontfamily</code>：</li>
<li><code>fontsize|size</code>：</li>
<li><code>fontstyle|style={'normal'|'italic'|'oblique'}</code>：</li>
<li><code>fontweight|weight={VALUE|'normal'|'regular'|'light'|'bold'...}</code>：</li>
<li><code>horizontalalignment|ha={'center'|'right'|'left'}</code>：</li>
<li><code>verticalalignment|va={'center'|'top'|'bottom'|'baseline'|'center_baseline'}</code>；</li>
<li><code>parse_math:bool</code>：</li>
<li><code>usetex:bool</code>：<code>None</code>使用<code>rcParams[&quot;text.usetex&quot;]</code>；</li>
<li><code>rotation={FLOAT|'vertical'|'horizontal'}</code>：</li>
<li><code>url:str</code></li>
<li></li>
</ul>
<h5 id="标注"><a class="header" href="#标注">标注</a></h5>
<pre><code class="language-python">plt.annotate('msg', point)
</code></pre>
<h4 id="默认绘图属性"><a class="header" href="#默认绘图属性">默认绘图属性</a></h4>
<p>默认绘图属性通过<code>matplotlibrc</code>配置文件、样式表（<em>style sheets</em>）和运行时配置参数<code>rcParams</code>（<em>runtime configuration</em>）确定，优先级按载入顺序依次由低到高。所有运行时配置参数储存在字典结构<a href="https://matplotlib.org/stable/api/matplotlib_configuration_api.html#matplotlib.rcParams"><code>matplotlib.rcParams</code></a>中（可通过<code>matplotlib</code>或<code>pyplot</code>来访问）。</p>
<pre><code class="language-python">plt.rcParams.update({'group.prop': value})   # 单独设置各项属性
plt.rc(group, **kwargs)   # by group: plt.rc('font', size=20)
</code></pre>
<p><code>plt.rc</code>按属性分组（<code>font</code>，<code>lines</code>，<code>axes</code>，<code>figure</code>等）设置当前的绘图属性。</p>
<blockquote>
<p>通过<code>plt.rcParams()</code>获取所有绘图属性的当前值，默认值可通过<code>plt.rcParamsDefault</code>获取；<code>matplotlib.rcdefaults</code>。</p>
</blockquote>
<p>临时修改默认属性：</p>
<pre><code class="language-python">with mpl.rc_context(prop_value_pairs):  # 使用上下文管理器
    plt.plot(data)      
@mpl.rc_context(prop_value_pairs)  # 使用装饰器
def plotting_function():
    plt.plot(data)
</code></pre>
<h5 id="使用样式表设置默认绘图属性"><a class="header" href="#使用样式表设置默认绘图属性">使用样式表设置默认绘图属性</a></h5>
<pre><code class="language-python">print(plt.style.available)
plt.style.use('ggplot')  # 使用内置或自定义样式表。
plt.style.use(['dark_background', 'presentation'])
with plt.style.context('dark_background'): # 临时修改绘图属性
    plt.plot(np.sin(np.linspace(0, 2 * np.pi)), 'r-o')
plt.show()
</code></pre>
<p>自定义样式表格式与<code>matplotlibrc</code>格式相同，忽略与实际样式无关的<code>rcParams</code>参数。多个样式表（定义不同方面的样式）可进行叠加。</p>
<pre><code class="language-ini">axes.titlesize : 24
axes.labelsize : 20
lines.linewidth : 3
lines.markersize : 10
xtick.labelsize : 16
ytick.labelsize : 16
</code></pre>
<h5 id="标题"><a class="header" href="#标题">标题</a></h5>
<pre><code class="language-python">fig.canvas.set_window_title('title') # Window Title
# fig.canvas.setWindowTitle('title') 无效
</code></pre>
<h5 id="尺寸"><a class="header" href="#尺寸">尺寸</a></h5>
<pre><code class="language-python">fig.set_size_inches(w, h=None, forward=True)
fig.set_figwidth(val, forward=True) # set_figheigth()
</code></pre>
<blockquote>
<p><code>forward=True</code>自动更新画布。长度单位转换：$1\mathrm{cm}\approx0.39\mathrm{in}$。</p>
</blockquote>
<p>窗口状态：最大/最小化</p>
<pre><code class="language-python">fig_manager = plt.get_current_fig_manager()
# TkAgg backend
fig_manager.window.state('zoomed') 
# Qt5Agg: showMinimized, showNormal, showFullScreen
fig_manager.window.showMaximized()
# wxAgg
fig_manager.frame.Maximize(True)
</code></pre>
<h5 id="-1"><a class="header" href="#-1"></a></h5>
<h4 id="颜色"><a class="header" href="#颜色">颜色</a></h4>
<h5 id="colormap"><a class="header" href="#colormap">colormap</a></h5>
<img src="Python/Python输入输出.assets/sphx_glr_colormaps_001.png" alt="colormaps" style="zoom:80%;" />
<p>Matplotlib具有一系列<a href="https://matplotlib.org/tutorials/colors/colormaps.html">内置colormap</a>。</p>
<pre><code class="language-python">cmap = plt.get_cmap(name)  # =&gt; matplotlib.cm.get_cmap(name)
</code></pre>
<blockquote>
<p><em>A perceptually uniform colormap: equal steps in data are perceived as equal steps in the color space. Human brain perceives changes in the lightness much better than changes in hue（颜色）.</em></p>
<p>gist_earth, ocean, and terrain all seem to be created for plotting topography (green/brown) and water depths (blue) together. </p>
</blockquote>
<p>获取颜色系列：</p>
<pre><code class="language-python">colors = pl.cm.jet(np.linspace(a,b,n))  # a,b in [0,1]
</code></pre>
<blockquote>
<p><code>matplotlib.cm</code>内置颜色表（colormaps）和处理程序。</p>
</blockquote>
<h4 id="pandas"><a class="header" href="#pandas">Pandas</a></h4>
<p>使用表格数据绘图。类型包括：<code>line</code>、<code>bar</code>、<code>barh</code>(水平柱状图)、<code>hist</code>、<code>box</code>(<a href="Python/Python%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA.html#boxplot">boxplot</a>)、<code>kde|density</code>  (<em>Kernel Density Estimation</em>)、<code>area</code>、<code>pie</code>、<code>scatter</code>、<code>hexbin</code>。<code>plot()</code>方法统一封装了上述类型的绘图方法。</p>
<pre><code class="language-python">ax = df.plot(x=xname, y=y_names, 
             kind='line',
             .., 
             ax=None,
             subplots=False, # separate subplots for each y-column,
             layout=(rows, columns), # subplot layout
             figsize,           # 单独使用Pandas创建窗口使用
             title,             # title (list) for (sub)plot
             grid=False,        # 显示网格
             legend=False,      # place legend
             style:[list,dict], # matplotlib linestyle for column
             logx=False,        # log-scale x axis, =&gt; logy, loglog
             xticks,            # =&gt; yticks, xlim, ylim, xlabel, ylabel,
             use_index,         # index as x-ticks
             fontsize, 
             colormap,
             rot,               # *rot=0水平显示横坐标
             sort_columns=False,
             **kwargs # 传递给绘图方法
            )
ax = df.plot.bar(...,stacked=False,color[list,dict],**kwargs) # =&gt; barh
ax = df.plot.hexbin(x='x', y='y', gridsize=20)
ax = df.plot.hist(by=cols, bins=10, **kwargs)
ax = df.plot.scatter(...,c=colors)
</code></pre>
<ul>
<li><code>x|y</code>：指定<code>DataFrame</code>中用于绘图<code>x</code>轴和<code>y</code>轴数据的列名；同时，<code>x</code>用作坐标轴名称，<code>y</code>用做默认图例名；某些类型的图形可能不需要指定横坐标值（如<code>hist</code>和<code>pie</code>）；<code>x</code>轴的值可以是非数值类型，<code>x</code>的值作为刻度均匀分布于坐标轴上，==其位置与数值大小无关==。当未指定<code>x</code>时，适用数据的<code>index</code>作为<code>x</code>值；未指定<code>y</code>时，适用所有数据列绘图。</li>
</ul>
<p>默认后端：<code>plotting.backend=matplotlib</code>。可以与<code>matplotlib</code>的方法混合使用，例如绘制子图（需要==指定已有的坐标系对象<code>ax</code>==，否则创建新的图形窗口）。</p>
<h3 id="seaborn"><a class="header" href="#seaborn">Seaborn</a></h3>
<p>https://stackoverflow.com/questions/62115464/sns-pairplot-shows-density-curve-instead-of-histogram</p>
<pre><code class="language-python">sns.pairplot(df, vars, hue='class', diag_kind='hist', kind='scatter')
</code></pre>
<p><code>diag_kind='auto'|'hist'|'kde'|None</code>，If ‘auto’, choose based on whether or not <code>hue</code> is used.</p>
<p><code>kind='scatter'|'kde'|'hist’|'reg'</code></p>
<blockquote>
<p>绘图数据太多会导致内存开销过大，执行缓慢；可随机抽样数据的一个子集绘图。</p>
</blockquote>
<h3 id="plotly"><a class="header" href="#plotly">Plotly</a></h3>
<p>创建图形窗口：</p>
<pre><code class="language-python">fig = go.Figure(data,layout=None) # data is a single trace or a tuple of traces.
fig.update_layout(**kwargs)
fig.show()
</code></pre>
<p><code>layout</code>是布局对象或创建对象所需的参数字典。创建图形的显示布局对象：</p>
<pre><code class="language-python">layout=go.Layout(
   title='Network graph made with Python',
   titlefont_size=16,  # layout.title.font
   showlegend=False,
   hovermode='closest',
   margin={'b':20,'l':5,'r':5,'t':40},  # 图形外部填充的空白
   annotations=[{
      'text':&quot;a&quot;, 'showarrow':False, 'xref':&quot;paper&quot;, 'yref':&quot;paper&quot;,
      x=0.005, y=-0.002 }],
   xaxis=dict(showgrid=False, zeroline=False, showticklabels=False),
   yaxis=dict(showgrid=False, zeroline=False, showticklabels=False)
)
</code></pre>
<p>布局参数：</p>
<ul>
<li><code>width,height</code>：图形的绝对尺寸；</li>
<li><code>margin</code>：图形的边缘空白填充，需要保留填充空间才能显示标题等图形外的内容。</li>
</ul>
<h3 id="图片"><a class="header" href="#图片">图片</a></h3>
<pre><code class="language-python">im_ax = plt.imshow(X, cmap=None, norm=None, aspect=None, origin)
</code></pre>
<p><code>X</code>：图像数据矩阵，支持的格式包括：</p>
<ul>
<li>$(M,N)$：使用colormap（<code>cmap</code>）可视化数据。</li>
<li>$(M,N,3)$：RGB值</li>
<li>$(M,N,4)$：RGBA值。</li>
</ul>
<p><code>aspect</code>：图像纵横比，可设置为<code>equal</code>、<code>auto</code>或任意浮点数值。</p>
<p><code>origin</code>：指定图像<code>[0,0]</code>像素点位于左上角（<code>upper</code>）或左下角（<code>lower</code>）。</p>
<p>读取图像：</p>
<pre><code class="language-python">plt.imread(fname, format=None)
</code></pre>
<blockquote>
<p><code>fname</code>表示文件名、URL或可读文件对象；<code>format</code>如果未给出则从文件扩展名推测，如果无法推测，则默认为<code>PNG</code>格式。</p>
</blockquote>
<p>显示矩阵数据：原点为左上角，图形的比例与矩阵维度比例一致。</p>
<pre><code class="language-python">plt.matshow(A, fignum=None, **kwargs)
</code></pre>
<p>如果<code>fignum=None</code>则创建一个新图形窗口；如果<code>fignum=0</code>则在当前坐标系绘图。</p>
<h3 id="保存图像"><a class="header" href="#保存图像">保存图像</a></h3>
<pre><code class="language-python">plt.savefig(fname, format=None, 
            bbox_inches='tight', transparent = False)
</code></pre>
<p><code>fname</code>：文件路径、文件对象等。如果未设置<code>format</code>则从文件名中推测保存格式。该方法不会尝试将格式类型追加为扩展名。<code>format</code>包括<code>'png'</code>、<code>'pdf'</code>、<code>'svg'</code>、……</p>
<p>保存图片：</p>
<pre><code class="language-python">plt.imsave(fname, X, format=None, ...)
</code></pre>
<h2 id="绘制网络图"><a class="header" href="#绘制网络图">绘制网络图</a></h2>
<h3 id="使用networkx绘图"><a class="header" href="#使用networkx绘图">使用NetworkX绘图</a></h3>
<p>NetworkX提供基于Matplotlib的基本的图可视化方法（其主要是用于图分析），推荐使用专门的图可视化工具如Graphviz。</p>
<pre><code class="language-python">nx.draw(G)
</code></pre>
<h3 id="使用graphviz绘制网络图"><a class="header" href="#使用graphviz绘制网络图">使用Graphviz绘制网络图</a></h3>
<pre><code class="language-python">from graphviz import Digraph,Graph
G = Digraph(name=None,
            comment='The Round Table', 
            filename='hello.gv',
            directory=None,
            format='svg',    # jpg|png|pdf|svg...
            engine='neato',  # 布局
            encoding='utf-8',
            graph_attr={'rankdir': 'LR'},
            node_attr={'shape': 'plaintext'},
            edge_attr={}
           )
</code></pre>
<blockquote>
<p><code>G.source</code>生成图形源代码。</p>
</blockquote>
<p><code>engine</code>参数设置布局引擎，在绘图时自动计算节点位置以及边的形状。</p>
<h4 id="图数据源"><a class="header" href="#图数据源">图数据源</a></h4>
<p>添加节点和边的方法。添加边会自动添加不存在的节点。</p>
<pre><code class="language-python">G.node('A', label='King Arthur', **attr_dict)  # add node
G.edge(tail_name, head_name, label=label_str, **attr_dict)
G.edges(['AB', ('A','L')])  # add edges
</code></pre>
<p>节点和边添加后，不能修改指定节点或边的属性，只能<a href="Python/Python%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA.html#%E5%9B%BE%E5%85%83%E7%B4%A0%E7%9A%84%E9%BB%98%E8%AE%A4%E5%B1%9E%E6%80%A7">修改某类型对象的默认属性</a>。如动态更新图数据，可维护一个外部数据结构，如：NetworkX的图对象或Pandas表格存储的节点和边数据，且提供更加灵活的方法来访问边和节点并修改其属性。最后，在进行绘图前，可首先将图数据表示为上述数据结构，再转换为Graphviz对象。</p>
<p>NetworkX图（<code>G.nodes,G.edges</code>）转换为Graphviz图：</p>
<pre><code class="language-python">for n in G.nodes:  # G is NetworkX Graph
  g.node(str(n), **G.nodes[n])   # 如果节点索引非字符串，需要首先将其转换为字符串
for e in G.edges:  
  g.edge(str(e[0]), str(e[1]), **G.edges[e])
</code></pre>
<p>Pandas表格图数据（节点和边数据）转换为Graphviz图。节点数据包含节点索引列和节点属性，边数据包含边首尾节点编号和边的属性。</p>
<pre><code class="language-shell">for idx, n in df_nodes.set_index('id',drop=True).iterrows():
  g.node(str(idx),  **n.to_dict())
for idx, e in df_edges.set_index(['head','tail'],drop=True).iterrows():
  g.edge(str(idx[0]),str(idx[1]),**e.to_dict())
</code></pre>
<p>导入外部数据时注意：仅通过接口（如<code>nx.set_node_attributes</code>）设置取值有区别的属性，节点或边的公共属性可通Graphviz提供的<code>attr</code>等方统一设置，因此数据转换时没必要传递给每一个节点或边。</p>
<p>此外，可利用<code>NetworkX</code>提供的<code>pydot</code>接口将NetworkX图对象直接转换为Graphviz的源码，并用于构造Graphviz图对象。</p>
<pre><code class="language-python">dot: pydot.Dot = nx.nx_pydot.to_pydot(G) 
g = gv.Graph(name=&quot;Reconstruct from source&quot;, strict=True, 
             body=dot.to_string().split('\n')[1:-2],...)
</code></pre>
<blockquote>
<p><code>body</code>：源码中的正文部分的行构成的==序列==，不包括<code>&quot;[strict] graph &lt;NAME&gt; {&quot;</code> 和 <code>&quot;}&quot;</code>，因此需要根据源码格式去除开始和结尾行。</p>
</blockquote>
<h4 id="图的属性"><a class="header" href="#图的属性">图的属性</a></h4>
<h5 id="图形元素的默认属性"><a class="header" href="#图形元素的默认属性">图形元素的默认属性</a></h5>
<p>修改组件的<strong>默认</strong>属性，后续添加元素如果未声明相应属性则使用默认属性。属性的值均使用字符串表示。</p>
<pre><code class="language-python">g.attr(kw=None, attrs=value, **kwargs)
</code></pre>
<p><code>kw</code>表示要设置属性的对象类别，包括<code>None,'graph','node','edge'</code>，<code>None</code>表示通用属性。<code>attrs</code>表示属性声明文本，例如：<code>&quot;fixedsize=shape shape=circle width=0.5&quot;</code>。<code>kwargs</code>为单独的属性项。也可通过图对象提供的成员（字典类型，<code>g.graph_attr,edge_attr,node_attr</code>）修改对应类别的默认属性。</p>
<pre><code class="language-shell">g.graph_attr['rankdir'] = 'LR' # graph类
</code></pre>
<h5 id="全局属性"><a class="header" href="#全局属性">全局属性</a></h5>
<p>对于图、节点和边通用的属性。</p>
<div class="table-wrapper"><table><thead><tr><th>属性</th><th>说明</th><th>参数值（字符串）</th></tr></thead><tbody>
<tr><td><code>color</code></td><td>填充或边框<a href="https://graphviz.org/doc/info/colors.html#svg">颜色</a></td><td>`aqua</td></tr>
<tr><td><code>style</code></td><td>图形填充和边框样式</td><td>`filled</td></tr>
<tr><td></td><td></td><td></td></tr>
</tbody></table>
</div>
<h5 id="图形属性"><a class="header" href="#图形属性">图形属性</a></h5>
<div class="table-wrapper"><table><thead><tr><th>属性</th><th>说明</th><th>参数值（字符串）</th></tr></thead><tbody>
<tr><td><code>engine</code></td><td>图形布局</td><td>`dot</td></tr>
<tr><td><code>rankdir</code></td><td>图形的流向</td><td>`LR</td></tr>
<tr><td><code>size</code></td><td>图形尺寸</td><td></td></tr>
<tr><td></td><td></td><td></td></tr>
</tbody></table>
</div>
<h5 id="节点属性"><a class="header" href="#节点属性">节点属性</a></h5>
<div class="table-wrapper"><table><thead><tr><th>属性</th><th>说明</th><th>参数值说明</th></tr></thead><tbody>
<tr><td><code>label</code></td><td>节点标签</td><td>支持HTML标记<code>&lt;tag&gt;&lt;/tag&gt;</code>。</td></tr>
<tr><td><code>shape</code></td><td><a href="https://graphviz.org/doc/info/shapes.html">节点形状</a></td><td><code>box/rect/rectangle/square/</code>：矩形/正方形<br/><code>invtriangle/triangle</code>：三角形<br/><code>diamond/parallelogram</code>：菱形/平行四边形<br /><code>circle/doublecircle/ellipse/oval</code>：圆/椭圆<br /><code>plaintext/plain/none</code>：纯文本<br /><code>tab/folder/note</code>：标签页/文件夹/笔记图标</td></tr>
<tr><td><code>fixedsize</code></td><td></td><td><code>false</code>：由包含内容和边距决定最小长宽，且不小于<code>width,height</code>；<br/><code>true</code>：仅由<code>width,height</code>决定，不会自适应内容；<br/><code>shape</code>：类似于<code>true</code>，但根据内容调整节点距离避免重叠。</td></tr>
<tr><td><code>width</code></td><td>节点宽度</td><td>宽度或最小宽度</td></tr>
<tr><td><code>height</code></td><td>节点高度</td><td>高度或最小高度</td></tr>
</tbody></table>
</div>
<h5 id="连接属性"><a class="header" href="#连接属性">连接属性</a></h5>
<div class="table-wrapper"><table><thead><tr><th>属性</th><th>说明</th><th>参数值</th></tr></thead><tbody>
<tr><td><code>weight</code></td><td></td><td></td></tr>
<tr><td><code>label</code></td><td>连线标签</td><td></td></tr>
<tr><td><code>len</code></td><td>边长度(<code>dot</code>引擎下无效)</td><td><code>1.00</code></td></tr>
<tr><td><code>arrowhead</code></td><td>箭头形状（<code>Digraph</code>）</td><td>`normal</td></tr>
<tr><td><code>arrowsize</code></td><td>箭头大小（<code>Digraph</code>）</td><td><code>2</code></td></tr>
<tr><td><code>fontsize</code></td><td>边标签字号</td><td><code>10</code></td></tr>
</tbody></table>
</div>
<p><a href="https://www.graphviz.org/doc/info/attrs.html">Attributes | Graphviz</a></p>
<h4 id="布局"><a class="header" href="#布局">布局</a></h4>
<p><code>u = w.unflatten(stagger=3)</code></p>
<h4 id="渲染和保存"><a class="header" href="#渲染和保存">渲染和保存</a></h4>
<p>将图对象转换为源码并生成图像文件。</p>
<pre><code class="language-python">G.render('test-output/round-table.gv', view=True, cleanup=False)
gv.render(...,)   # gv.render(filepath,...)
gv.Source.render(...)  #直接从DOT源码渲染对象
</code></pre>
<blockquote>
<p><em>To render the generated DOT source code, you also need to install [Graphviz](https://www.graphviz.org/
).</em></p>
</blockquote>
<p>从字符串读取DOT源码：</p>
<pre><code class="language-python">G.save()  # 保存图形的DOT源码
dot_src = gv.Source(dot_str, ...)
gv.Source.from_file(...)
dot_src.save(...)
</code></pre>
<p><a href="https://graphviz.readthedocs.io/en/stable/manual.html#piped-output">Piped output</a></p>
<h4 id="相关模块"><a class="header" href="#相关模块">相关模块</a></h4>
<blockquote>
<p><em>pydot</em></p>
<p><em>PyGraphviz requires [Graphviz](https://www.graphviz.org/
).</em></p>
</blockquote>
<pre><code class="language-python">dot = nx.nx_agraph.to_agraph(G)  # pygraphviz.AGraph()
</code></pre>
<h3 id="使用plotly绘制网络图"><a class="header" href="#使用plotly绘制网络图">使用Plotly绘制网络图</a></h3>
<p>如果图的节点没有位置信息，需要使用布局引擎来计算节点位置以及边的形状。<code>networkx</code>提供多个<a href="https://networkx.org/documentation/stable/reference/drawing.html#module-networkx.drawing.layout">布局方法</a>以及基于Graphviz的布局方法生成位置数据。</p>
<pre><code class="language-python">pos=nx.bipartite_layout(G, nodes, align='vertical',...,aspect_ratio=4/3)
pos=nx.circular_layout(G, scale=1, center=None, dim=2)
pos=nx.nx_agraph.graphviz_layout(G, prog='neato', root=None, args='') # =&gt; pygraphviz_layout
pos=nx.nx_pydot.graphviz_layout(G, prog='neato', root=None) # =&gt; pydot_layout(...)
</code></pre>
<blockquote>
<p><code>root</code>是某些布局算法需要确定的根节点，<code>args</code>为传递给布局程序的额外参数。</p>
</blockquote>
<p><code>pos</code>是关于节点名的字典，元素值为<code>(x,y)</code>。因此，可直接将生成的节位置添加到图的节点属性中：</p>
<pre><code class="language-python">nx.set_node_attributes(G, pos, name='pos')
</code></pre>
<p>生成Plotly绘图数据，即节点和边的绘图数据：</p>
<pre><code class="language-shell">def get_edge_trace(graph, linewidth=3):
    edge_x, edge_y = [],[]
    for edge in graph.edges():
        x0, y0 = graph.nodes[edge[0]]['pos']
        x1, y1 = graph.nodes[edge[1]]['pos']
        edge_x.extend((x0, x1, None))
        edge_y.extend((y0, y1, None))
    edge_trace = go.Scatter(
        x=edge_x, y=edge_y,
        line=dict(width=linewidth, color='#888'),
        hoverinfo='none',
        mode='lines')
    return edge_trace
    
def get_node_trace(graph, nodesize=20):
    node_x,node_y = [],[]
    for node in graph.nodes():
        x, y = graph.nodes[node]['pos']
        node_x.append(x)
        node_y.append(y)

		marker_specs = {
        'size':nodesize,
        'line_width':2,
        'reversescale':True,
        'showscale':True,
        'colorscale':'Jet', # Greys,Rainbow,Jet,...
        'color':[],
        'colorbar':{title='ColorMeaning',titleside='right',xanchor='left',thickness=15}
     }

    node_trace = go.Scatter(x=node_x, y=node_y, 
                            mode='markers', hoverinfo='text', marker=marker_specs)

    num_neighbor = np.zeros(len(graph.nodes))
    node_text = []
    for i, adj in enumerate(graph.adjacency()):
        num_neighbor[i] = len(adj[1])
        node_text.append(f'Number of connections: {num_neighbor[i]}')
    node_trace.marker.color = list(num_neighbor)
    node_trace.text = node_text
    return node_trace 
</code></pre>
<p>使用Plotly绘制生成的绘图数据（生成的绘图对象可调用<a href="Python/Python%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA.html#Plotly">show()</a>方法显示）。</p>
<pre><code class="language-python">layout = go.Layout(...)
fig = go.Figure(data=[edge_trace, node_trace], layout=layout)
</code></pre>
<h2 id="绘制表格"><a class="header" href="#绘制表格">绘制表格</a></h2>
<h3 id="使用plotly绘制表格"><a class="header" href="#使用plotly绘制表格">使用Plotly绘制表格</a></h3>
<pre><code class="language-python">plotly_table = go.Table(
  columnwidth = [60]*len(df.columns),   # 宽度比例，绝对宽度由图形宽度决定.
  header=dict(
    values=list(df.columns),
    line_color='darkslategray',
    fill_color='paleturquoise',
    align='center',
    font=dict(color='blue', size=16),
    height=30
  ),
  cells=dict(
    values=[df[col] for col in df.columns], # values given by columns
    #fill_color='lavender',      # cell fill color
    line_color='darkslategray',  # default is None, scalar or list
    fill=dict(color=['lavender', 'white']),  # missing column use the last specified color
    align='center',
    format= ['d'] + [ '.3f']*(len(df.columns)-1),  
    font_size=16,
    height=30
  )
)
fig = go.Figure(data=plotly_table)  
</code></pre>
<h3 id="使用html渲染pandas表格输出"><a class="header" href="#使用html渲染pandas表格输出">使用HTML渲染Pandas表格输出</a></h3>
<p><code>pd.DataFrame.style</code>是<code>Style</code>类型对象，使用生成表格数据的显示格式（CSS）。</p>
<p>https://mp.weixin.qq.com/s/uaYAQj69BCx5EqcxL4uqoA</p>
<h4 id="颜色-1"><a class="header" href="#颜色-1">颜色</a></h4>
<pre><code class="language-python">def color_negative_red(val):
  color = 'red' if val &lt; 0 else 'black'
  return f'color: {color}'
s = df.style.applymap(color_negative_red)
def highlight_max(s):
    is_max = s == s.max()
    return ['background-color: yellow' if v else '' for v in is_max]
s = df.style.apply(highlight_max, axis=0, subset=['B', 'C'])
</code></pre>
<blockquote>
<p>需要在支持HTML的输出环境中（例如Notebook或Streamlit）才能显示指定的效果。</p>
</blockquote>
<p><code>Style</code>类型支持链式调用，因此可以将多种格式叠加到一个表格。</p>
<h4 id="数值格式"><a class="header" href="#数值格式">数值格式</a></h4>
<pre><code class="language-python">df.style.format(&quot;{:.2%}&quot;, na_rep=&quot;-&quot;)
df.style.format(&quot;B&quot;: &quot;{:.2%}&quot;)   # 设置指定列的格式
df.style.format({&quot;B&quot;: lambda x: &quot;±{:.2f}&quot;.format(abs(x))}) # 格式化函数
</code></pre>
<pre><code class="language-python">df.style.set_precision(2)
</code></pre>
<blockquote>
<p>字符串的对齐声明符在HTML输出中无效，使用CSS<code>text-align</code>属性声明。</p>
</blockquote>
<h4 id="内置风格"><a class="header" href="#内置风格">内置风格</a></h4>
<pre><code class="language-python">df.style.highlight_null(null_color='red')
import seaborn as sns
cm = sns.light_palette(&quot;green&quot;, as_cmap=True)
s = df.style.background_gradient(cmap=cm)
df.style.hide_index()
df.style.hide_columns(['C','D'])
</code></pre>
<h4 id="全局风格"><a class="header" href="#全局风格">全局风格</a></h4>
<p>使用全局风格声明表格的默认字体、字号、对齐等风格。</p>
<pre><code class="language-python">list_style = [
  dict(selector=&quot;th&quot;, props=[(&quot;font-size&quot;, &quot;4pt&quot;)]),   # header
  dict(selector=&quot;td&quot;, props=[('padding', &quot;0em 0em&quot;)]), # cell
  dict(selector=&quot;tr:hover&quot;,
       props=[(&quot;background-color&quot;, &quot;%s&quot; % hover_color)]# row
]
df.style.set_table_styles(list_style)
</code></pre>
<p><code>props</code>由一个或多个属性的键值对组成。</p>
<p>设置一个数据切片的的属性：</p>
<pre><code class="language-python">df.style.set_properties(subset=None, **kwargs)
</code></pre>
<blockquote>
<p><code>subset</code>表示表格的子集，例如列名的列表；<code>kwargs</code>为CSS属性。</p>
</blockquote>
<p>在列数据背景上绘制柱状图：</p>
<pre><code class="language-python">df.style.bar(subset=['A', 'B'], color='#d65f5f')
</code></pre>
<p>标题：</p>
<pre><code class="language-python">df.style.set_caption('Colormaps, with a caption.')
</code></pre>
<h4 id="共享格式"><a class="header" href="#共享格式">共享格式</a></h4>
<pre><code class="language-python">style2.use(style1.export())
</code></pre>
<h3 id="dtale"><a class="header" href="#dtale"><a href="https://pypi.org/project/dtale/">DTale</a></a></h3>
<h2 id="流程图"><a class="header" href="#流程图">流程图</a></h2>
<h3 id="diagrams"><a class="header" href="#diagrams">diagrams</a></h3>
<pre><code class="language-shell">conda create -n diagram -c conda-forge diagrams # pip install diagrams
</code></pre>
<p><a href="https://diagrams.mingrammer.com/docs/guides/diagram">Diagrams · Diagrams (mingrammer.com)</a></p>
<h2 id="图形用户界面"><a class="header" href="#图形用户界面">图形用户界面</a></h2>
<h3 id="jupyter-notebook"><a class="header" href="#jupyter-notebook">Jupyter Notebook</a></h3>
<h4 id="常用控件"><a class="header" href="#常用控件">常用控件</a></h4>
<p>可用控件：</p>
<pre><code class="language-python">import ipywidgets as widgets
l = pd.Series([x for x in dir(widgets) if not x.startswith('_')])
df_widgets = l.loc[l.apply(lambda x: x[0].isupper())]
display(pd.DataFrame(df_widgets.to_numpy()[:60].reshape(10,6))) # 超过60个内置控件
</code></pre>
<p>[Widget List — Jupyter Widgets 8.0.0rc0 documentation (ipywidgets.readthedocs.io)](https://ipywidgets.readthedocs.io/en/latest/examples/Widget List.html)</p>
<h5 id="输入控件"><a class="header" href="#输入控件">输入控件</a></h5>
<pre><code class="language-python">widgets.IntSlider(min=0, max=10, step=1, description='Slider:', value=3)
</code></pre>
<h5 id="输出控件"><a class="header" href="#输出控件">输出控件</a></h5>
<pre><code class="language-python">from IPython.display import display
slider = widgets.IntSlider()
text = widgets.IntText()
display(slider, text, ...)
slider.value
</code></pre>
<p><code>IPython.display</code>可根据对象类型采用合适的展示方式，而不仅是<code>print</code>对象。</p>
<pre><code class="language-python">from IPython.display import display
display(obj_value)
</code></pre>
<p>Matplotlib绘图对象会自动显示（无论命令执行位置，显示在单元输出的结尾位置），不需要使用<code>display</code>。</p>
<h5 id="ui属性"><a class="header" href="#ui属性">UI属性</a></h5>
<pre><code class="language-python">description='Int Slider:'  # 空间标签
</code></pre>
<h4 id="布局和数据交互"><a class="header" href="#布局和数据交互">布局和数据交互</a></h4>
<p>连接控件：上一控件的输出更新下一控件的输入。</p>
<pre><code class="language-python">widgets.jslink((slider, 'value'), (text, 'value'))
</code></pre>
<h4 id="ui事件"><a class="header" href="#ui事件">UI事件</a></h4>
<pre><code class="language-python">btn = widgets.Button(description='Medium')
display(btn)
def btn_eventhandler(obj):
    print('Hello from the {} button!'.format(obj.description))
btn.on_click(btn_eventhandler)
</code></pre>
<p>刷新输出：使用<code>Output</code>控件捕获cell输出。</p>
<pre><code class="language-python">output_year = widgets.Output()
def dropdown_year_eventhandler(change):
  output_year.clear_output()
  with output_year:
    display(output_info)
dropdown_year.observe(dropdown_year_eventhandler, names='value')
display(output_year)
</code></pre>
<h3 id="streamlit"><a class="header" href="#streamlit">Streamlit</a></h3>
<p>安装：</p>
<pre><code class="language-shell">pip install streamlit    # conda install streamlit -c conda-forge
</code></pre>
<p>启动：</p>
<pre><code class="language-shell">streamlit run app.py
</code></pre>
<p>编辑程序：运行中的程序可感知代码发生变换，并重新执行。</p>
<pre><code class="language-python">import streamlit as st
</code></pre>
<p>版本信息：</p>
<pre><code class="language-python">st.__version__
</code></pre>
<h4 id="ui组件"><a class="header" href="#ui组件">UI组件</a></h4>
<p><code>key</code>：默认以UI的标签区分UI对象，如果标签相同，则需要提供额外的<code>key</code>参数区分UI对象。</p>
<h5 id="标签"><a class="header" href="#标签">标签</a></h5>
<p>标题：</p>
<pre><code class="language-python">st.title('Title')
st.header('Header1')
st.subheader('Header2')
</code></pre>
<h5 id="选择"><a class="header" href="#选择">选择</a></h5>
<p>按钮/开关：</p>
<pre><code class="language-python">tf_press = st.button(&quot;Button&quot;)
tf_check = st.checkbox(&quot;Check&quot;, value=False)
</code></pre>
<p>单选组：</p>
<pre><code class="language-python">genre = st.radio(
     &quot;What's your favorite movie genre&quot;,
     ('Comedy', 'Drama', 'Documentary'),
     index=1
)
</code></pre>
<p>单选下拉列表：</p>
<pre><code class="language-python">option = st.selectbox(
    'How would you like to be contacted?',
    ('Email', 'Home phone', 'Mobile phone'),
    index = 2
)
</code></pre>
<p>数值选择器：</p>
<pre><code class="language-python">age = st.slider(
  'How old are you?', 
  value=25,
  min_value=0, max_value=130)
</code></pre>
<p>类型选择器：</p>
<pre><code class="language-python">color = st.select_slider(
    'Select a color of the rainbow',
    options=[
      'red', 'orange', 'yellow', 'green', 'blue', 'indigo', 'violet']
)
</code></pre>
<p>颜色选择：</p>
<pre><code class="language-python">color = st.color_picker('Pick A Color', '#00f900')
</code></pre>
<p>多选：</p>
<pre><code class="language-python">options = st.multiselect(
    'What are your favorite colors',
    ['Green', 'Yellow', 'Red', 'Blue'],
    ['Yellow', 'Red']
)
</code></pre>
<h5 id="输入"><a class="header" href="#输入">输入</a></h5>
<p>单行文本输入：</p>
<pre><code class="language-python">title = st.text_input('Movie title', value = 'Life of Brian', type='default')
</code></pre>
<p><code>type=password</code>：设置为密码输入框。</p>
<p>文本区（多行文本输入）：</p>
<pre><code class="language-python">txt = st.text_area('Text to analyze', 
'''It was the best of times, it was the worst of times, it was
the age of wisdom, it was the age of foolishness, it was
the epoch of belief, it was the epoch of incredulity, it
was the season of Light, it was the season of Darkness, it
was the spring of hope, it was the winter of despair, (...)''',
    height=200
)
</code></pre>
<p>数值输入：</p>
<pre><code class="language-python">number = st.number_input('Insert a number',
                         value=50,
                         min_value=0, max_value=100,step=1, 
                         format='%.2f')
</code></pre>
<p>日期输入：</p>
<pre><code class="language-python">d = st.date_input(
    &quot;When's your birthday&quot;,
    datetime.date(2019, 7, 6)
)
</code></pre>
<p>时间输入：</p>
<pre><code class="language-python">t = st.time_input('Set an alarm for', datetime.time(8, 45))
</code></pre>
<h5 id="文件上传"><a class="header" href="#文件上传">文件上传</a></h5>
<pre><code class="language-python">uploaded_file = st.file_uploader(&quot;Choose a CSV file&quot;, type=&quot;csv&quot;)
</code></pre>
<h5 id="文本输出"><a class="header" href="#文本输出">文本输出</a></h5>
<p><code>st.write</code>根据对象类型选择相应的输出格式。</p>
<pre><code class="language-python">st.write(object)
</code></pre>
<p>全局作用域中的多行注释内容将被视为Markdown格式内容添加到输出结果中（等效于<code>st.write</code>），因此可以利用该性质添加段落输出。</p>
<p>文字格式输出：</p>
<pre><code class="language-python">st.text(text)     # 等宽字体
st.caption(text)  # 小号字体
</code></pre>
<p>数字指标输出：</p>
<pre><code class="language-python">st.metric(label=&quot;Streamlit version&quot;, value=0.87, delta=0.01)
</code></pre>
<h5 id="表格输出-1"><a class="header" href="#表格输出-1">表格输出</a></h5>
<pre><code class="language-python">st.dataframe(data:Union[pd.DataFrame,pd.Styler,np.ndarray,Iterable,dict])
</code></pre>
<p>支持<code>df.style</code>的高亮语法，不支持宽度和对齐等设置。高度固定，自动生成水平/垂直滑动块；</p>
<blockquote>
<p>Streamlit不能输出超过50MB的表格，此时可以仅截取部分内容输出。</p>
<p>Streamlit目前不能显示<code>category</code>类型的数据。</p>
</blockquote>
<p><code>table = st.table(df)</code>：支持自动调整列宽，在页面上显示全部内容。当页面宽度足够时，设置宽度有效。</p>
<h5 id="信息块"><a class="header" href="#信息块">信息块</a></h5>
<pre><code class="language-python">st.success('This is a success message!')
st.info('This is a purely informational message')
st.warning('This is a warning')
st.error('This is an error')
e = RuntimeError('This is an exception of type RuntimeError')
st.exception(e)  # display an exception
</code></pre>
<h5 id="动画"><a class="header" href="#动画">动画</a></h5>
<p>进度条：</p>
<pre><code class="language-python"># placeholder = st.empty()  # 进度条占位符
my_bar = st.progress(0)  # placeholder.progress(0)
for percent_complete in range(10):
    time.sleep(0.1)
    my_bar.progress(percent_complete * 10)
# placeholder.empty()  # 移除进度条
</code></pre>
<p>可将进度条置于<a href="Python/Python%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA.html#%E7%AE%80%E5%8D%95%E5%AE%B9%E5%99%A8"><code>st.empty()</code></a>中，可以在进度完成后手动移除进度条。</p>
<p>进度指示器：</p>
<pre><code class="language-python">with st.spinner('Wait for it...'):
    time.sleep(5)
</code></pre>
<h5 id="下载"><a class="header" href="#下载">下载</a></h5>
<pre><code class="language-python">st.download_button
</code></pre>
<h4 id="布局-1"><a class="header" href="#布局-1">布局</a></h4>
<pre><code class="language-python">st.set_page_config(page_title='动态服务管理', page_icon=None,
                   layout='wide', initial_sidebar_state='auto')
</code></pre>
<blockquote>
<p>在其他命令使用前运行。</p>
</blockquote>
<h5 id="容器"><a class="header" href="#容器">容器</a></h5>
<p>在一个容器中添加多个UI组件。</p>
<pre><code class="language-python">with st.container():
  st.write(&quot;This is inside the container&quot;)
  st.bar_chart(np.random.randn(50, 3))
group = st.container()
group.write(&quot;This is inside another container&quot;)
</code></pre>
<p>与主页中直接组件的效果添加相同，和<code>empty()</code>不同不能更新已添加的组件。可以将<code>empty()</code>置于容器内部。</p>
<h5 id="简单容器"><a class="header" href="#简单容器">简单容器</a></h5>
<p>空占位符<code>st.empty()</code>：可在后续代码中向其中添加==一个==UI组件。空占位符引用该组件对象，因此可以多次调用该组件以更新其内容。</p>
<blockquote>
<p>普通方式调用组件函数未返回组件对象的引用，因此无法对其更新，重复调用组件函数将创建多个UI组件。</p>
</blockquote>
<pre><code class="language-python">placeholder = st.empty()
for i in range (1,100):
  placeholder.text(f'Progress is: {i}')   # update text
</code></pre>
<p>删除占位容器中的UI组件：</p>
<pre><code class="language-python">placeholder.empty()
</code></pre>
<p>可使用<code>placeholder</code>多次创建UI组件并替换现有内容。==通常不使用包含<code>key</code>参数的UI组件==（通常是输出组件，例如<code>st.progress, st.write, st.text</code>等），如果再次通过<code>placeholder</code>替换该类型组件，需要提供不同的<code>key</code>。</p>
<p>在<code>with</code>语句块中调用组件函数不会重复创建UI，<code>with</code>语句块结束后其中创建的组件不会消失。</p>
<pre><code class="language-python">with st.empty():
   for seconds in range(60):
      st.write(f&quot;⏳ {seconds} seconds have passed&quot;)
      time.sleep(1)
   st.write(&quot;✔️ 1 minute over!&quot;)
</code></pre>
<p>可在<code>st.empty()</code>中设置一个<code>container</code>，从而构造可刷新的仪表板。</p>
<pre><code class="language-python">placeholder = st.empty()
with placeholder.container():
    # place components here!
</code></pre>
<h5 id="折叠内容"><a class="header" href="#折叠内容">折叠内容</a></h5>
<pre><code class="language-python">with st.expander(title, expanded=True):
  add_components
</code></pre>
<h5 id="表单"><a class="header" href="#表单">表单</a></h5>
<pre><code class="language-python">with streamlit.form(key:str):
   # add_components
   slider_val = st.slider(&quot;Form slider&quot;)
   submitted = st.form_submit_button(&quot;Submit&quot;)  # 提交按钮位于表单环境中
   pass
if submitted:
   handle_form_data
</code></pre>
<p><strong>UI响应</strong>：未使用表单时，更改UI组件状态将自动触发代码重新执行（更新组件后台状态）；使用表单后，更改表单内部组件的状态不会自动触发代码重新执行，内部组件的状态由表单UI组件缓存，直到点击提交按钮才会向后台发送状态变更并触发代码执行。</p>
<p><strong>状态缓存</strong>：代码执行时，总是使用上次点击“提交”按钮后的各组件的后台状态。</p>
<h5 id="水平线性布局"><a class="header" href="#水平线性布局">水平线性布局</a></h5>
<pre><code class="language-python">col1,co2,... = st.columns(n_or_portion)
with col1:
  add_components_to_col1
co2.add_components
</code></pre>
<p>当参数为整数<code>n</code>时表示创建<code>n</code>个等宽列；如果为列表<code>portion</code>，则根据列表元素值确定每列的宽度占比。</p>
<h5 id="水平多标签页"><a class="header" href="#水平多标签页">水平多标签页</a></h5>
<pre><code class="language-python">tab1, tab2, tab3 = st.tabs(['页面1', '页面2', '页面3'])
with tab1:
    pass
tab2.dataframe(df)
</code></pre>
<h5 id="侧边栏"><a class="header" href="#侧边栏">侧边栏</a></h5>
<p>在主页面上可使用的组件也可以添加到侧边栏（侧边栏可看组是一个特殊容器）。</p>
<pre><code class="language-python">add_selectbox = st.sidebar.selectbox(
    &quot;How would you like to be contacted?&quot;,
    (&quot;Email&quot;, &quot;Home phone&quot;, &quot;Mobile phone&quot;)
)
</code></pre>
<h5 id="多页面app"><a class="header" href="#多页面app">多页面App</a></h5>
<p>多页面App将单页面应用的代码按功能分解到多个文件中，代码组织结构如下。</p>
<pre><code class="language-shell">multipage-app
├── 01_⏱_demo_app.py
└── pages
    ├── 02_🍕_output_demo.py
    ├── 03_🥗_input_demo.py
    └── 04_🥩_plots_demo.py
streamlit run 01_⏱_demo_app.py
</code></pre>
<p>页面可根据文件名编号指定顺序展示。</p>
<h4 id="绘图"><a class="header" href="#绘图">绘图</a></h4>
<h5 id="内置绘图"><a class="header" href="#内置绘图">内置绘图</a></h5>
<pre><code class="language-python">chart = st.line_chart(data=None, width=0, height=0)
chart = st.area_chart(data=None, width=0, height=0)
chart = st.bar_chart(data=None, width=0, height=0)
</code></pre>
<blockquote>
<p><code>use_container_width=True</code>：与页面宽度一致。</p>
</blockquote>
<p>可以向图形对象添加数据，从而更新返回结果。</p>
<pre><code class="language-python">chart.add_rows(data2)
</code></pre>
<h5 id="显示图像"><a class="header" href="#显示图像">显示图像</a></h5>
<pre><code class="language-python">from PIL import Image
image = Image.open('sunrise.jpg')
st.image(image,caption='Sunrise',width=None,use_column_width='auto',output_format='png')
</code></pre>
<h5 id="matplotlib绘图"><a class="header" href="#matplotlib绘图"><a href="Python/Python%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA.html#Matplotlib">Matplotlib绘图</a></a></h5>
<pre><code class="language-python">fig,ax = plt.subplots(figsize=(width_inch,height_inch),...)
ax.bar(x1,y1)
st.pyplot(fig=fig, **kwargs_savefig)
</code></pre>
<p><code>matplotlib</code>的绘图后端：</p>
<pre><code class="language-python">matplotlib.rcsetup.all_backends   # supported backends
matplotlib.pyplot.get_backend()   # current use backend
</code></pre>
<p>==图形占用的宽度总是与页面宽度一致，图形的尺寸只影响显示的分辨率==。</p>
<ul>
<li>
<p>可以使用<code>st.columns</code>将页面划分为多个部分，而只在其中一列中放置图形。</p>
</li>
<li>
<p>将绘图转换为图片，使用<code>st.image</code>显示。</p>
<pre><code class="language-python">from io import BytesIO
buf = BytesIO()
fig.savefig(buf, format=&quot;png&quot;)
st.image(buf, caption=None, width=600, output_format='png')
</code></pre>
</li>
</ul>
<h5 id="graphviz绘图"><a class="header" href="#graphviz绘图">graphviz绘图</a></h5>
<pre><code class="language-python">import graphviz
graph = graphviz.Digraph()
st.graphviz_chart(graph)
</code></pre>
<h5 id="bokeh无法显示图像"><a class="header" href="#bokeh无法显示图像">bokeh（*无法显示图像）</a></h5>
<p><a href="https://docs.bokeh.org/en/latest/docs/user_guide/graph.html?highlight=network">Visualizing network graphs — Bokeh 2.3.1 Documentation</a></p>
<pre><code class="language-python">from bokeh.plotting import figure
p = figure(
    title='simple line example',
    x_axis_label='x',
    y_axis_label='y')
st.bokeh_chart(p, use_container_width=True)
</code></pre>
<h5 id="plotly-1"><a class="header" href="#plotly-1">Plotly</a></h5>
<p><a href="https://docs.streamlit.io/en/stable/api.html#streamlit.plotly_chart">API reference — Streamlit 0.81.1 documentation</a></p>
<p><a href="https://towardsdatascience.com/tutorial-network-visualization-basics-with-networkx-and-plotly-and-a-little-nlp-57c9bbb55bb9">Tutorial: Network Visualization Basics with Networkx and Plotly in Python | Towards Data Science</a></p>
<pre><code class="language-python">import plotly.figure_factory as ff
fig = ff.create_distplot(
        hist_data, group_labels, bin_size=[.1, .25, .5])
st.plotly_chart(fig, use_container_width=True)
</code></pre>
<h4 id="代码执行"><a class="header" href="#代码执行">代码执行</a></h4>
<h5 id="ui与程序执行流程"><a class="header" href="#ui与程序执行流程">UI与程序执行流程</a></h5>
<p>UI状态变更后，程序将从头重新执行。</p>
<p>当执行到UI创建代码后，UI创建代码会根据输入使用缓存UI或重绘UI，相应地返回的值为上一次UI状态变更时的数据，或本次重绘UI后的初始值。</p>
<h5 id="ui缓存"><a class="header" href="#ui缓存">UI缓存</a></h5>
<p>UI内置了缓存机制，以保存UI状态更改。UI初始化应该使用常量（每次运行用户程序不变的量），从而保证UI对象始终缓存。不需要尝试手动保存UI的最新状态，并随后再次使用最新状态初始化UI。</p>
<p>实际上，由于界面状态更新后，用户代码才开始执行，当执行到相应UI代码时，会使用上一次的缓存状态再次初始化UI并返回初始化值（即上一次的缓存状态），导致用户获取不到更新的界面状态。一般情况下，==如果界面初始化参数发生变化都将导致用户上一次的UI更改无效==。</p>
<blockquote>
<p>下图以<code>selectbox</code>为例，初始化<code>index=0</code>（初次执行代码后用户缓存该值<code>cache=0</code>），如果用户选择<code>index=2</code>将刷新页面并再次执行代码，UI对象的初始化输入不变（<code>cache=0--&gt;index</code>），因此返回给程序用户记录的选择(<code>2</code>)；当用户再次选择（<code>index=1</code>）并触发界面刷新和代码执行，UI对象的初始化输入从<code>index=0</code>变为<code>index=2</code>，会导致UI对象的重新初始化，并返回再次初始化的结果（<code>index=2</code>），<strong>与用户的目标选择不一致</strong>。这时用户获取的结果和界面显示一致，继续操作会导致上述行为会反复出现。如下图所示：</p>
</blockquote>
<pre><code class="language-mermaid">graph LR
A[index=0]--&gt;X1(get_ui)--&gt;B(sel=0)--&gt;|user select|D[index=2]--&gt;X2[get_ui]
B--&gt;C(cache=0)--&gt;|缓存一致|X2--&gt;E(sel=2)--&gt;|user select|D2[index=1]--&gt;F
E--&gt;C1(cache=2)--&gt;|缓存落后|F[update_ui]
A_[index=0]--&gt;X1_(get_ui)--&gt;B_(sel=0)--&gt;|user select|D_[index=2]--&gt;X2_[get_ui]--&gt;E_(sel=2)--&gt;|user select|D2_[index=1]--&gt;F_[get_ui]
</code></pre>
<p>实际上，用户可以缓存数据，但无需将其应用于更新UI。用户利用缓存数据与最新数据的对比以确定某个UI的状态变化从而执行相应操作。</p>
<h5 id="回调函数"><a class="header" href="#回调函数">回调函数</a></h5>
<p>状态变更后，代码从头开始执行。回调函数将先于其他代码首先被执行。回调函数仅知道UI状态变化，无法获取变更后的值。</p>
<h4 id="缓存"><a class="header" href="#缓存">缓存</a></h4>
<p>Streamlit可以缓存函数的返回对象，从而优化性能。</p>
<p>Streamlit在调用函数时记录函数名、函数参数、外部变量、函数体内容、调用的用户自定义函数内容，当再次调用函数时检测上述内容（基于Hash函数）是否被修改。如果未发生修改，则直接返回缓存对象；反之，重新执行函数并缓存新的对象。</p>
<pre><code class="language-python">streamlit.cache(
  func=None,                   # 调用的函数对象
  persist=False,               # 是否缓存到磁盘
  allow_output_mutation=False, # 允许返回对象在外部被修改，不计算返回对象的Hash
  hash_funcs={Type:hash_func}, # 自定指定类型对象的Hash函数
  max_entries=None,            # 最大缓存条目数
  ttl=None                     # 缓存有效期(秒)
) -&gt; object
@st.cache(**kwargs)
func(*args, **kwargs):
  pass
</code></pre>
<h5 id="hash函数"><a class="header" href="#hash函数">Hash函数</a></h5>
<ul>
<li>返回对象的基础类型成员，Streamlit可以使用内置Hash函数对其再进行Hash；</li>
<li><code>id()</code>函数：用于传入参数，计算全局唯一对象（指向外部资源）的内存地址，例如<a href="https://docs.streamlit.io/en/stable/caching.html#example-1-pass-a-database-connection-around">会话连接</a>；</li>
<li><a href="https://docs.streamlit.io/en/stable/caching.html#example-2-turn-off-hashing-for-a-specific-type"><code>lambda _: None</code></a>：已知对应类型对象不会在程序运行期间发生变化（避免对大型数据结构的计算开销）；</li>
<li><code>hash()</code>函数：使用Python内置的<a href="https://docs.streamlit.io/en/stable/caching.html#example-2-turn-off-hashing-for-a-specific-type">hash方法</a>代替Streamlit的hash方法，以解决某些类型无法计算hash值得问题；</li>
<li>自定义</li>
</ul>
<h5 id="变量显式缓存"><a class="header" href="#变量显式缓存">变量显式缓存</a></h5>
<p><strong>全局缓存</strong>：用户可以定义缓存函数创建缓存的数据容器（如字典），以显式缓存程序运行过程中产生的变量。</p>
<pre><code class="language-python">@st.cache(allow_output_mutation=True)
def namespace(name:str):
    return {}
ns = namespace('streamlit')
ns['x'] = 100
@st.experimental_memo 
@st.experimental_singleton
</code></pre>
<p><strong>会话状态缓存</strong></p>
<p><code>st.session_state</code>：与每个Web会话（<em>WebSocket</em>）相关的缓存变量，同一应用的不同页面其会话缓存变量相互独立。</p>
<h5 id="多线程执行"><a class="header" href="#多线程执行">多线程执行</a></h5>
<p>每开启一个Web页面，Streamlit应用会启动一个子线程执行该应用的用户代码并在Web页面进行展示。多个线程共享<a href="Python/Python%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA.html#%E5%85%A8%E5%B1%80%E7%BC%93%E5%AD%98">全局缓存空间</a>，具有独立的<a href="Python/Python%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA.html#%E4%BC%9A%E8%AF%9D%E7%8A%B6%E6%80%81%E7%BC%93%E5%AD%98">会话状态空间</a>。</p>
<h5 id="基于streamlit的服务"><a class="header" href="#基于streamlit的服务">基于Streamlit的服务</a></h5>
<p>利用Streamlit应用运行的规则，可以在用户代码中封装一个服务（持续执行不退出），当首次开启应用时启动该服务，并在全局缓存中记录服务的运行状态；后续再启动应用时，检测该服务的状态，并与该服务进行交互。</p>
<h4 id="问题-1"><a class="header" href="#问题-1">问题</a></h4>
<p><a href="Python/../Linux/Linux%E9%85%8D%E7%BD%AE%E5%92%8C%E7%AE%A1%E7%90%86.html#inotify%E6%96%87%E4%BB%B6%E7%9B%91%E6%8E%A7%E6%95%B0%E9%87%8F%E9%99%90%E5%88%B6"><em>inotify watch limit reached</em></a>，该问题会导致无法监控到后台文件更新，以及<code>streamlit</code>无法刷新Web页面（创建连接Streamlith后台服务的WebSocket失败）。</p>
<h2 id="机器学习可视化"><a class="header" href="#机器学习可视化">机器学习可视化</a></h2>
<h3 id="性能评估可视化"><a class="header" href="#性能评估可视化">性能评估可视化</a></h3>
<h5 id="混淆矩阵"><a class="header" href="#混淆矩阵">混淆矩阵</a></h5>
<p><em><strong>Confusion Matrix</strong></em></p>
<pre><code class="language-python">from sklearn.metrics import ConfusionMatrixDisplay as cm_disp
disp = cm_disp.from_predictions(y_test, y_pred)  
disp = cm_disp.from_estimator(clf, X_test, y_test) # 直接从分类器获取预测
plt.show()
# 自动生成混淆矩阵并创建图形对象
# cm = confusion_matrix(y_test, y_pred) # from sklearn.metrics import confusion_matrix
# disp = cm_disp(confusion_matrix=cm, display_labels=clf.classes_)
# disp.plot()
</code></pre>
<h2 id="问题-2"><a class="header" href="#问题-2">问题</a></h2>
<h3 id="中文乱码"><a class="header" href="#中文乱码">中文乱码</a></h3>
<p>原因：Linux系统缺少中文字体；</p>
<p>解决方法：</p>
<ul>
<li>
<p>下载中文字体（从Windows系统中复制），黑体（<code>simhei.ttf</code>）、华文宋体（<code>STSONG.TTF</code>）、楷体（<code>simkai.ttf</code>）......</p>
</li>
<li>
<p>将字体==安装==到<code>/usr/share/fonts</code>目录下，并链接到<code>matplotlib</code>的字体目录下。</p>
<pre><code class="language-sh">cd $CONDA_HOME/envs/$ENV/lib/python3.7/site-packages/matplotlib
ln -s /usr/share/fonts/simhei.ttf mpl-data/fonts/ttf/simhei.ttf
</code></pre>
</li>
<li>
<p>修改<code>matplotlib</code>配置文件：</p>
<pre><code class="language-sh">vim mpl-data/matplotlibrc
font.family:     sans-serif  # uncomment
font.sans-serif: simhei,...  # uncomment and add fonts at head
</code></pre>
</li>
<li>
<p>删除缓存文件：<code>rm ~/.cache/matplotlib/fontlist-v###.json</code></p>
</li>
<li>
<p>重启Python程序。</p>
<h5 id="中文字体测试代码"><a class="header" href="#中文字体测试代码">中文字体测试代码</a></h5>
<pre><code class="language-python">from matplotlib.font_manager import FontManager
import subprocess

fm = FontManager()
mat_fonts = set(f.name for f in fm.ttflist)
print( '*' * 10, 'Matplotlib可用字体', '*' * 10)
for f in mat_fonts:
    print(f)
output = subprocess.check_output(
  'fc-list :lang=zh -f &quot;%{family}\n&quot;', shell=True, encoding='utf-8')
print( '*' * 10, '系统可用的中文字体', '*' * 10)
zh_fonts = set(f.split(',', 1)[0] for f in output.split('\n'))
for f in zh_fonts:
    print(f)
</code></pre>
</li>
</ul>
<h2 id="参考文献-4"><a class="header" href="#参考文献-4">参考文献</a></h2>
<div class="footnote-definition" id="warnings"><sup class="footnote-definition-label">1</sup>
<p><a href="https://docs.python.org/3/library/warnings.html">warnings — Warning control — Python 3.10.4 documentation</a></p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="python编程应用"><a class="header" href="#python编程应用">Python编程应用</a></h1>
<p>Python应用框架和编程接口。</p>
<h2 id="命令行工具"><a class="header" href="#命令行工具">命令行工具</a></h2>
<h3 id="click-2"><a class="header" href="#click-2">click</a></h3>
<p>Command Line Interface Creation Kit (click)</p>
<ul>
<li>命令嵌套</li>
<li>自动生成帮助文档</li>
<li>支持运行时懒加载子命令</li>
<li>Unix/POSIX命令行约定</li>
</ul>
<p>https://click.palletsprojects.com/en/7.x/quickstart/</p>
<pre><code class="language-shell">pip install click 
</code></pre>
<h4 id="应用模板"><a class="header" href="#应用模板">应用模板</a></h4>
<pre><code class="language-python">import click
@click.group(help=&quot;group info.&quot;)   # 创建命令组，可以添加子命令
def cli():
   pass

@click.command(name='init', help='command info.', eplilog)
def initdb():
    click.echo('Initialized the database')
cli.add_command(initdb)  # 添加子命令

@cli.command(name='drop')   # 添加子命令
@click.option('-c','--count', default=1, help='number of greetings') # 添加选项
@click.argument('name')  # 添加位置参数
def dropdb(count, name):
    click.echo('Dropped the database')
      
if __name__ == '__main__':
    cli()  # 调用定义的任意命令或分组
</code></pre>
<h5 id="分组和子命令"><a class="header" href="#分组和子命令">分组和子命令</a></h5>
<p>使用<code>@click.command()</code>定义程序所需处理的命令行参数及其对应的处理函数；如果程序具有多个子命令，则需要使用<code>@click.group()</code>定义统一入口，以访问子命令。此外，通过<code>@Group.group()</code>可以嵌套定义子命令集合。</p>
<blockquote>
<p>主程序只能调用一个<code>click</code>对象（返回后程序结束），因此必须将子命令的处理方法组织到一个分组中。否则主程序只能调用其中一个子命令的处理方法。</p>
</blockquote>
<p>除了根分组外，子命令和子分组的名称默认为对应处理函数名，也可通过<code>name</code>参数指定。</p>
<h5 id="参数分类"><a class="header" href="#参数分类">参数分类</a></h5>
<ul>
<li>
<p><strong>位置参数</strong>：使用<code>@click.argument()</code>定义，第一个参数为参数名，并对应作为Python变量名。</p>
</li>
<li>
<p><strong>选项参数</strong>：使用<code>@click.option()</code>定义，参数列表<code>*args</code>用于定义多个长/短选项名（例如<code>&quot;-n&quot;,&quot;--name&quot;,&quot;name&quot;</code>）。</p>
<ul>
<li>
<p>其中如果包含没有短划线前缀的名称，则作为该选项的变量名传递给修饰的函数；反之，</p>
</li>
<li>
<p>第一个长选项用于推导选项变量名（移除前缀并将名称中出现的短划线转换为<code>_</code>以构成合法变量名）；</p>
</li>
<li>
<p>没有长选项时，使用第一个短选项作为变量名。</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p><a href="https://click.palletsprojects.com/en/7.x/quickstart/#switching-to-setuptools">setuptools integration</a></p>
</blockquote>
<p>通过装饰器声明的参数，必须在对应的处理函数的输入参数中声明。</p>
<h5 id="参数数据类型"><a class="header" href="#参数数据类型">参数数据类型</a></h5>
<p><code>str</code>（默认类型），<code>int</code>，<code>float</code>，<code>bool</code></p>
<p><code>click.DateTime</code></p>
<p>如果未指定类型，则根据默认值<code>default</code>推导（如果未提供<code>default</code>，则默认为<code>str</code>）。</p>
<h4 id="选项参数"><a class="header" href="#选项参数">选项参数</a></h4>
<pre><code class="language-python">@click.option('-c', '--count', default=1, help='number of greetings')
</code></pre>
<blockquote>
<p><code>help</code>：设置文档的帮助信息；<code>metavar</code>：帮助文档中用于表示选项的值。</p>
</blockquote>
<h5 id="强制选项"><a class="header" href="#强制选项">强制选项</a></h5>
<p>选项通常时可选的，如果需要强制某选项提供，则令<code>required=True</code>；</p>
<h5 id="标识选项"><a class="header" href="#标识选项">标识选项</a></h5>
<ul>
<li>
<p><strong>真值标识选项</strong>：<code>is_flag=True</code>：如果选项名称中包含<code>/</code>，则定义真值开关的两个选项（变量名为前者）。</p>
<pre><code class="language-python">@click.option('--shout/--no-shout', default=False)
</code></pre>
</li>
<li>
<p><strong>切换标识选项</strong>：<code>flag_value=value</code>，多个选项定义一个变量，其中一个设置为<code>True</code>。</p>
<pre><code class="language-python">@click.option('--upper', 'transformation', flag_value='upper', default=True)
@click.option('--lower', 'transformation', flag_value='lower')
</code></pre>
</li>
</ul>
<h5 id="多值选项"><a class="header" href="#多值选项">多值选项</a></h5>
<ul>
<li>一个选项如果要接受多个参数，使用<code>nargs=k</code>声明，该选项变量将保存为<code>tuple</code>；也可以通过直接定义多个参数的类型<code>type=(str,int)</code>表明选项接受的参数个数。</li>
<li>可重复使用的选项<code>multiple=True</code>：每次使用选项指定的值都被添加到序列对象；</li>
<li><strong>计数选项</strong>：<code>count=True</code>：选项的值为选项声明的次数。</li>
</ul>
<h5 id="取值受限的选项"><a class="header" href="#取值受限的选项">取值受限的选项</a></h5>
<p>根据选项配置，对输入值进行校验。</p>
<ul>
<li>
<p><strong>单选选项</strong>：</p>
<pre><code class="language-python">@click.option('--hash-type', 
              type=click.Choice(['MD5', 'SHA1'], 
              case_sensitive=False))
</code></pre>
</li>
<li>
<p><strong>数值范围选项</strong>：<code>IntRange</code>/<code>FloatRange</code>（默认为闭区间，可通过<code>min_open</code>/<code>max_open</code>设置开区间）。</p>
<pre><code class="language-python">@click.option('--count', type=click.IntRange(0, 20, clamp=True)) #*
@click.option('--digit', type=click.IntRange(0, 10))
</code></pre>
<blockquote>
<p><code>*</code>：<code>clamp=True</code>对于超出范围的输入参数，将其修改为设定的边界。</p>
</blockquote>
</li>
<li>
<p><strong>密码选项</strong>：</p>
<pre><code class="language-python">@click.password_option()  # equivalent password
@click.option('--password', prompt=True, hide_input=True, confirmation_prompt=True)
</code></pre>
</li>
</ul>
<h5 id="交互式选项与回调函数"><a class="header" href="#交互式选项与回调函数">交互式选项与回调函数</a></h5>
<p><code>prompt=Ture|message</code>：当命令行未提供该选项的值，弹出消息提示用户输入该选项的值。</p>
<p>根据用户输入决定程序的后续处理流程：</p>
<pre><code class="language-python">@click.confirmation_option(prompt='Are you want to continue?')
</code></pre>
<blockquote>
<p>等价实现方式：</p>
<pre><code class="language-python">def abort_if_flase(ctx, param, value):
   if not value:  # value of 'yes'
      ctx.abort()
@click.option('--yes','-y', is_flag=True, callback=abort_if_false, 
              expose_value=False,  # 不向处理流函数传递该参数
              prompt='Are you want to continue?')
</code></pre>
</blockquote>
<h5 id="选项默认值"><a class="header" href="#选项默认值">选项默认值</a></h5>
<p>通过<code>default</code>参数设置选项默认值。默认值可以是固定编码值，可以从配置文件或系统环境变量读取。</p>
<pre><code class="language-python">@option('username', 
        default=lambda: os.environ.get('USER',''), 
        show_default='current user', prompt=True)
</code></pre>
<p><code>default</code>如果为函数，则可同时与<code>prompt</code>结合使用；反之，如果设置了<code>default</code>则不会再弹出交互信息。使用<code>show_default</code>在文档中显示默认值信息。</p>
<p><code>auto_envvar_prefix='PREFIX'</code>：自动读取指定前缀环境变量<code>PREFIX_COMMAND_OPTION</code>（命令名中的<code>-</code>使用<code>_</code>替换）；</p>
<p>手动指定环境变量：</p>
<pre><code class="language-python">@click.option('username', envvar='USERNAME')
</code></pre>
<p><strong>从一个环境变量中读取多个值</strong>。在命令行利用<code>multiple=True</code>可重复使用一个选项以读入多个值；对于从环境变量读取，则尝试将环境变量分割为多个部分（默认使用空白分割，对于<code>File</code>和<code>Path</code>类型的选项值，则使用平台相关分隔符）。</p>
<p><code>default_map</code>：</p>
<h5 id="优先处理选项"><a class="header" href="#优先处理选项">优先处理选项</a></h5>
<pre><code class="language-python">@click.version_option()
</code></pre>
<blockquote>
<p>实现方式：使用<code>eager</code>选项以优先处理该参数。</p>
<pre><code class="language-python">def print_version(ctx, param, value):
   if not value or ctx.resilient_parsing: # value of 'version'
      return
   ctx.echo('version 1.0')
   ctx.exit()
@click.option('--version','-V', is_flag=True, callback=print_version, 
              expose_value=False, eager=True)
</code></pre>
</blockquote>
<p><a href="https://click.palletsprojects.com/en/7.x/options/#multiple-values-from-environment-values">Multiple Values from Environment Values</a></p>
<p><a href="https://click.palletsprojects.com/en/7.x/options/#callbacks-for-validation">Callbacks for Validation</a></p>
<h5 id="位置参数"><a class="header" href="#位置参数">位置参数</a></h5>
<p>参数接受的值的个数：</p>
<pre><code class="language-python">@click.argument('src', nargs=-1)  # 接受任意数量的值（只能由一个此类型）
@click.argument('dst', nargs=1)
</code></pre>
<blockquote>
<p><code>required=True</code>，可变数量参数至少包括一个参数（不能为空）。</p>
</blockquote>
<p><a href="https://click.palletsprojects.com/en/7.x/arguments/#file-arguments">File Arguments</a></p>
<p><code>click.File</code></p>
<p><a href="https://click.palletsprojects.com/en/7.x/arguments/#file-path-arguments">File Path Arguments</a></p>
<p><code>click.Path</code></p>
<h5 id="命令嵌套"><a class="header" href="#命令嵌套">命令嵌套</a></h5>
<p>https://click.palletsprojects.com/en/7.x/commands/</p>
<p>子命令的方法运行时父命令的方法也被执行。</p>
<p><a href="https://click.palletsprojects.com/en/7.x/commands/#group-invocation-without-command">Group Invocation Without Command</a></p>
<h5 id="生成文档"><a class="header" href="#生成文档">生成文档</a></h5>
<p>https://click.palletsprojects.com/en/7.x/documentation/</p>
<h5 id="自动补全"><a class="header" href="#自动补全">自动补全</a></h5>
<blockquote>
<p>Completion is only available if a script is installed and invoked through an entry point, not through the <code>python</code> command. See <a href="https://click.palletsprojects.com/en/7.x/setuptools/#setuptools-integration">Setuptools Integration</a>.</p>
</blockquote>
<h4 id="交互式程序中的应用"><a class="header" href="#交互式程序中的应用">交互式程序中的应用</a></h4>
<p>在Python脚本主模块中，调用<code>click</code>定义的任意命令或分组，即可实现相应命令的自动解析处理。</p>
<p>通过上述方式，执行命令后程序将自动退出。对于不自动退出的交互式程序，需要在程序中显式调用该命令行框架并将所需处理的命令行参数传入。</p>
<pre><code class="language-python">cli.main(['add', '--help'], standalone_mode=False)
</code></pre>
<p><code>standalone_mode=False</code>：在命令执行完成后继续执行程序，反之直接退出程序。</p>
<blockquote>
<p><em>问题：<code>click</code>捕获<code>SystemExit</code>，使得注册的退出处理函数不会被触发。</em></p>
</blockquote>
<p>next：https://click.palletsprojects.com/en/7.x/complex/。</p>
<h3 id="typer"><a class="header" href="#typer">Typer</a></h3>
<p><a href="https://typer.tiangolo.com/">Typer (tiangolo.com)</a></p>
<h2 id="http"><a class="header" href="#http">HTTP</a></h2>
<h3 id="http客户端"><a class="header" href="#http客户端">HTTP客户端</a></h3>
<h4 id="python-httpclient模块"><a class="header" href="#python-httpclient模块">Python <code>http.client</code>模块</a></h4>
<p><a href="https://docs.python.org/3.7/library/http.client.html#module-http.client"><code>http.client</code></a> is a low-level HTTP protocol client; implement the client side of the HTTP and HTTPS protocols. It is normally not used directly — the module <a href="https://docs.python.org/3.7/library/urllib.request.html#module-urllib.request"><code>urllib.request</code></a> uses it to handle URLs that use HTTP and HTTPS.</p>
<blockquote>
<p><a href="https://docs.python.org/3.7/library/http.html#module-http"><code>http</code></a> is a package that collects several modules for working with the HyperText Transfer Protocol:</p>
<ul>
<li><code>http.client</code>;</li>
<li><a href="https://docs.python.org/3.7/library/http.server.html#module-http.server"><code>http.server</code></a> contains basic HTTP server classes based on <a href="https://docs.python.org/3.7/library/socketserver.html#module-socketserver"><code>socketserver</code></a></li>
<li><a href="https://docs.python.org/3.7/library/http.cookies.html#module-http.cookies"><code>http.cookies</code></a> has utilities for implementing state management with cookies</li>
<li><a href="https://docs.python.org/3.7/library/http.cookiejar.html#module-http.cookiejar"><code>http.cookiejar</code></a> provides persistence of cookies</li>
</ul>
</blockquote>
<pre><code class="language-python">http.client.HTTPConnection(host, port=None, timeout=None)
HTTPConnection.request(method, url, body=None, headers={})
HTTPConnection.getresponse()
# HTTPSConnection
</code></pre>
<h4 id="python-urllibrequest模块"><a class="header" href="#python-urllibrequest模块">Python <code>urllib.request</code>模块</a></h4>
<blockquote>
<p><em>Extensible library  of high level API for opening URLs.</em></p>
</blockquote>
<pre><code class="language-python">r = urllib.request.urlopen(url_or_request, data=None, timeout=None)
urllib.request.Request(url, data=None, headers={}, method=None)
r.url
r.headers
r.response
r.read(length)  # read response body
</code></pre>
<blockquote>
<p><em>This function always returns an object which can work as a context manager and has the properties url, headers, and status.</em></p>
<p><em>The default method is 'GET' if data is None or 'POST' otherwise.</em></p>
</blockquote>
<h4 id="urllib3"><a class="header" href="#urllib3">urllib3</a></h4>
<p><a href="https://urllib3.readthedocs.io/en/latest/">Home - urllib3 2.0.0.dev0 documentation</a></p>
<h5 id="请求"><a class="header" href="#请求">请求</a></h5>
<pre><code class="language-python">response = urllib3.request(METHOD, url)
http = urllib3.PoolManager()
response = http.request(METHOD, url,headers=hdr_dict, fields=query_dict)
resp = http.request(
  &quot;POST&quot;, url,
  fields={&quot;hello&quot;: &quot;world&quot;}, # form data
  body=encoded_data  # JSON string or something else
)
</code></pre>
<h5 id="响应"><a class="header" href="#响应">响应</a></h5>
<pre><code class="language-python">response.status
response.headers
response.data
</code></pre>
<h4 id="requests"><a class="header" href="#requests">requests</a></h4>
<p><a href="https://docs.python-requests.org/en/master/">Requests: HTTP for Humans™ — Requests 2.25.1 documentation (python-requests.org)</a></p>
<blockquote>
<p><em>Requests allows you to send HTTP/1.1 requests extremely easily. There’s no need to manually add query strings to your URLs, or to form-encode your POST data. Keep-alive and HTTP connection pooling are 100% automatic, thanks to <a href="https://github.com/urllib3/urllib3">urllib3</a>.</em></p>
</blockquote>
<h5 id="请求-1"><a class="header" href="#请求-1">请求</a></h5>
<pre><code class="language-python">response = requests.get(
  url, 
  params=query_dict, 
  headers=hdr_dict, 
  cookies=cookie_dict_or_jar, # jar = requests.cookies.RequestsCookieJar(),
  allow_redirects=True,       # HEAD默认为False
  timeout=0.001
)
response = requests.post(
  url, 
  data = payload_str_or_dict, # data/files优先级高于json
  files = file_dict,
  json = payload_dict # Content-Type: application/json
)
files = {
  'file': (
    'report.xls', 
    open('report.xls', 'rb'), 
    'application/vnd.ms-excel', 
    {'Expires': '0'}
  )
}
</code></pre>
<blockquote>
<p>其他HTTP方法：<code>put, delete, head, options, ...</code></p>
</blockquote>
<h5 id="响应-1"><a class="header" href="#响应-1">响应</a></h5>
<pre><code class="language-python">response.status_code
response.raise_for_status()  # 抛出异常
response.headers  # HTTP headers (Header names are case-insensitive)
response.request.headers
response.cookies  # 
response.text     # 响应体
response.encoding # 响应体编码，设置编码以获得正确解码的text
response.content  # 原始响应体（binary，已解压缩），用于接收非文本数据
response.json     # 将JSON响应体解码为JSON对象
response.raw      # HTTP原始响应（未经处理的接收数据）
with open(filename, 'wb') as fd:
    for chunk in r.iter_content(chunk_size=128):
        fd.write(chunk)
</code></pre>
<h5 id="重定向"><a class="header" href="#重定向">重定向</a></h5>
<pre><code class="language-python">response.history
</code></pre>
<h5 id="异常"><a class="header" href="#异常">异常</a></h5>
<p><code>ConnectionError</code>：网络问题；</p>
<p><code>HttpError</code>：HTTP返回非成功响应码；</p>
<p><code>Timeout</code>：响应的超时；</p>
<p><code>TooManyRedirects</code>：重定向次数超过限制；</p>
<p><code>RequestException</code>：所有引发的异常的基类。</p>
<h5 id="会话对象"><a class="header" href="#会话对象">会话对象</a></h5>
<p>HTTP持久连接，重用TCP连接。</p>
<pre><code class="language-python">session = requests.Session()  # 通过session使用requests接口
</code></pre>
<h3 id="flask"><a class="header" href="#flask">Flask</a></h3>
<p>The “micro” in microframework means Flask aims to keep the core simple but extensible.</p>
<p>Flask has many configuration values, with sensible defaults, and a few conventions when getting started. By convention, templates and static files are stored in subdirectories within the application’s Python source tree, with the names <code>templates</code> and <code>static</code> respectively.</p>
<p>Flask itself just bridges to Werkzeug to implement a proper WSGI application and to Jinja2 to handle templating. It also binds to a few common standard library packages such as logging. Everything else is up for extensions.</p>
<p>Flask supports Python 3.6 and newer. <code>async</code> support in Flask requires Python 3.7+ for <code>contextvars.ContextVar</code>.</p>
<pre><code class="language-shell">conda create -n flask python=3.7 flask
</code></pre>
<p><a href="https://flask.palletsprojects.com/en/2.0.x/quickstart/">Quickstart — Flask Documentation (2.0.x) (palletsprojects.com)</a></p>
<h4 id="flask-app"><a class="header" href="#flask-app">Flask App</a></h4>
<h5 id="project-layout"><a class="header" href="#project-layout">Project Layout</a></h5>
<pre><code class="language-shell">flaskproject/
├── flaskproject/
│   ├── __init__.py
│   ├── db.py
│   ├── schema.sql
│   ├── auth.py
│   ├── blog.py
│   ├── templates/
│   │   ├── base.html
│   │   ├── auth/
│   │   │   ├── login.html
│   │   │   └── register.html
│   │   └── blog/
│   │       ├── create.html
│   │       ├── index.html
│   │       └── update.html
│   └── static/
│       └── style.css
├── tests/
│   ├── conftest.py
│   ├── data.sql
│   ├── test_factory.py
│   ├── test_db.py
│   ├── test_auth.py
│   └── test_blog.py
├── venv/
├── .gitignore
├── setup.py
└── MANIFEST.in
</code></pre>
<p><a href="https://flask.palletsprojects.com/en/latest/tutorial/layout/">Project Layout — Flask Documentation (2.1.x) (palletsprojects.com)</a></p>
<p><a href="https://flask.palletsprojects.com/en/latest/tutorial/factory/">Application Setup — Flask Documentation (2.1.x) (palletsprojects.com)</a></p>
<p><a href="https://flask.palletsprojects.com/en/latest/deploying/#self-hosted-options">Deployment Options — Flask Documentation (2.1.x) (palletsprojects.com)</a></p>
<p><a href="https://jinja.palletsprojects.com/en/3.0.x/templates/">Template Designer Documentation — Jinja Documentation (3.0.x) (palletsprojects.com)</a></p>
<h5 id="app-layout"><a class="header" href="#app-layout">App Layout</a></h5>
<pre><code class="language-python">from flask import Flask, request
app = Flask(__name__)
app.config['JSON_SORT_KEYS'] = False    # 响应JSON数据不对字段排序
@app.route(&quot;/url_path/&lt;name&gt;&quot;, methods=['GET', 'POST'])
def route_process(name=&quot;test&quot;):
  req = request.get_data(as_text=True)
  return &quot;success&quot;
if __name__ == '__main__':
    app.run(host='127.0.0.1', port=5000, debug=False,load_dotenv=True,**wsgi_options)
</code></pre>
<blockquote>
<p><code>load_dotenv=True</code>：加载<code>.env</code>或<code>.flaskenv</code>中定义的环境变量。</p>
</blockquote>
<h5 id="调试运行flask-app"><a class="header" href="#调试运行flask-app">调试运行Flask App</a></h5>
<p>如果Python代码中包含<code>__main__</code>代码块，且其中调用了<code>app.run()</code>方法，则可以直接运行该代码文件或模块启动Flask程序。反之，通过<code>flask run</code>命令自动调用指定Python模块<code>$FLASK_APP</code>（默认为<code>app</code>）中的<code>Flask</code>实例（通常是<code>app=Flask(__name__)</code>）的<code>run()</code>方法。</p>
<pre><code class="language-shell">export FLASK_APP=hello
export FLASK_ENV=development
flask run --host=0.0.0.0 --port=5000  --cert=PATH --key=FILE  # =&gt; python -m flask run
</code></pre>
<blockquote>
<p>这种方式不会执行Flask程序中的<code>__main__</code>代码块，因此不能将额外参数传递给要执行的程序。</p>
</blockquote>
<p><strong>调试模式</strong>：如果配置环境变量<code>FLASK_ENV=development</code>或运行时参数<code>debug=True</code>，将启用调式模式，在代码发生变化时服务器会<strong>自动加载</strong>且在发生异常时在终端显示交互式的调试器（使用<code>use_evalex=False</code>禁用调试器，使用<code>use_reloader=False</code>禁用自动加载），并在前端显示异常的追踪信息页面。未启用调试模式时，Flask会忽略任意处理过程产生的错误，仅返回通用的错误页面。==不推荐在启用自动加载的情况下通过代码调用<code>run()</code>方法（支持不好），而是使用<code>flask run</code>的方式==。大规模生产环境部署需要使用专门的WSGI服务器。</p>
<p><a href="https://code.visualstudio.com/docs/python/tutorial-flask">使用VS Code调试Flask App</a>。</p>
<h4 id="处理请求"><a class="header" href="#处理请求">处理请求</a></h4>
<h5 id="路由绑定"><a class="header" href="#路由绑定">路由绑定</a></h5>
<pre><code class="language-python">@app.route(&quot;PATH&quot;, methods=['POST','GET',...],)
</code></pre>
<p><strong>路径</strong>：客户端请求通过装饰器声明的路径规则进行分发，路径规则：</p>
<ul>
<li><code>/path</code>：路径以“<code>/</code>”结尾代表目录，请求省略<code>/</code>会被自动重定向到对应目录；反之，代表文件，如果请求包含“<code>/</code>”则无法找到相应资源（返回<code>404 Not Found</code>）。</li>
<li><code>/path/&lt;ARGUMENT&gt;</code>：<code>ARGUMENT</code>作为响应函数的参数。</li>
<li><code>/path/&lt;int:ARGUMENT&gt;</code>：限定参数数据类型。</li>
</ul>
<p>一个响应方法可添加多个路径声明。</p>
<p><code>url_for()</code>方法用于测试当前已声明的处理方法对应的URL。</p>
<pre><code class="language-python">with app.test_request_context():
    print(url_for('index'))
    print(url_for('login'))   # &quot;index&quot; and &quot;login&quot; 是已定义的处理方法 
</code></pre>
<h5 id="获取请求信息"><a class="header" href="#获取请求信息">获取请求信息</a></h5>
<pre><code class="language-python">from flask import request      # context local object
request.url                    # request.base_url, request.host_url, request.root_url
request.args                   # -&gt; dict: URL查询参数 -&gt; request.query_string
request.method
data = request.data            # binary data
request.get_data(as_text=True) # text data
request.get_json()             # json object -&gt; request.is_json
</code></pre>
<p>为了避免用户请求数据中包含的注入攻击脚本被执行，使用<code>escape</code>将请求数据转换为纯文本。</p>
<pre><code class="language-shell">from markupsafe import escape
@app.route(&quot;/&lt;name&gt;&quot;)
def hello(name):
    return f&quot;Hello, {escape(name)}!&quot;
</code></pre>
<h5 id="构造响应消息"><a class="header" href="#构造响应消息">构造响应消息</a></h5>
<p>处理方法必须提供返回值（不能返回<code>None</code>），响应消息可以是纯文本、JSON对象、HTML文本等类型。</p>
<h5 id="重定向和错误处理"><a class="header" href="#重定向和错误处理">重定向和错误处理</a></h5>
<pre><code class="language-python">from flask import abort, redirect, url_for
redirect(url_for('static', filename=subpath))
abort(404)
</code></pre>
<h5 id="会话"><a class="header" href="#会话">会话</a></h5>
<p>除了处理单次请求外，Flask为每个会话提供了会话上下文<code>session</code>。<a href="https://flask.palletsprojects.com/en/2.0.x/quickstart/#sessions">处理方法可在会话上下文中记录用户的登录状态</a>，从而连续处理用户的不同请求。</p>
<h5 id="日志-1"><a class="header" href="#日志-1">日志</a></h5>
<pre><code class="language-python">app.logger.warning('A warning occurred (%d apples)', 42)  # logging.Logger
</code></pre>
<h4 id="静态文件"><a class="header" href="#静态文件">静态文件</a></h4>
<p>静态文件位于Flask程序的工作目录下<code>static/</code>目录中。这些文件可以根据用户请求的URL（如<code>/static/style.css</code>）被自动响应。</p>
<h4 id="html模板"><a class="header" href="#html模板">HTML模板</a></h4>
<p>利用指定模板（Jinja2）和输入参数自动生成HTML响应。模板文件位于程序目录下的<code>templates/</code>目录下。</p>
<pre><code class="language-python">from flask import render_template
return render_template('hello.html', name=name)
</code></pre>
<h4 id="文件上传-1"><a class="header" href="#文件上传-1">文件上传</a></h4>
<h4 id="cookies"><a class="header" href="#cookies">Cookies</a></h4>
<h4 id="部署flask应用"><a class="header" href="#部署flask应用">部署Flask应用</a></h4>
<blockquote>
<p><em>While lightweight and easy to use, Flask’s built-in server is not suitable for production as it doesn’t scale well. You can deploy your Flask application to a WSGI server, where your <code>Flask</code> application object is the actual WSGI application.</em></p>
</blockquote>
<p>Flask实现了一个简易的HTTP WSGI服务器，方便开发者调试运行Flask程序而无须安装专门的WSGI服务器。但内置WSGI服务器功能简单，性能扩展能力差，因此可能无法胜任生产环境大规模服务请求。</p>
<p><a href="https://zhuanlan.zhihu.com/p/269456318">花了两个星期，我终于把 WSGI 给搞明白了 - 知乎用户的文章 - 知乎</a></p>
<p>WSGI服务器包括：Gunicorn、<a href="https://uwsgi-docs.readthedocs.io/en/latest/#">uWSGI</a>、</p>
<h5 id="run-flask-with-gunicorn"><a class="header" href="#run-flask-with-gunicorn">Run Flask with Gunicorn</a></h5>
<pre><code class="language-shell">gunicorn -w 4 -b 0.0.0.0:5000 your_project:app # serve your app with 4 workers on port 5000
</code></pre>
<p><code>app</code>是模块中可调用的Flask应用实例，或者提供创建实例的函数<code>myproject:create_app()</code>。</p>
<p>使用gevent（<code>-k gevent</code>）或<a href="https://eventlet.net/">eventlet</a>（<code>-k eventlet</code>）提供工作线程的异步支持。</p>
<blockquote>
<p><em><a href="http://www.gevent.org/">gevent</a> is a coroutine -based Python networking library that uses greenlet to provide a high-level synchronous API on top of the libev or libuv event loop.</em></p>
</blockquote>
<h5 id="nginx代理wsgi服务器"><a class="header" href="#nginx代理wsgi服务器">Nginx代理WSGI服务器</a></h5>
<pre><code class="language-nginx">server {
  location /flask {
    proxy_pass         http://127.0.0.1:8000/;
    proxy_redirect     off;
    proxy_set_header   Host                 $host;
    proxy_set_header   X-Real-IP            $remote_addr;
    proxy_set_header   X-Forwarded-For      $proxy_add_x_forwarded_for;
    proxy_set_header   X-Forwarded-Proto    $scheme;
  }
}
</code></pre>
<h3 id="fastapi"><a class="header" href="#fastapi">FastAPI</a></h3>
<p><a href="https://fastapi.tiangolo.com/">FastAPI (tiangolo.com)</a></p>
<pre><code class="language-shell">conda create --name fastapi python=3.7
pip install fastapi uvicorn[standard]
</code></pre>
<h2 id="数据库-1"><a class="header" href="#数据库-1">数据库</a></h2>
<p>SQLAlchemy由Core和ORM两套API组成，其中ORM基于Core构建。</p>
<ul>
<li>
<p>Core：数据库工具集的基础架构，包括管理数据库连接、处理查询和响应、构建SQL查询语句。</p>
</li>
<li>
<p>ORM：提供Python对象到数据库表的映射以及对象持久化机制。</p>
<blockquote>
<p>对象关系映射（<em><strong>Object Relational Mapping</strong></em>，ORM）模式使用描述对象和数据库之间映射的元数据，实现程序中的对象与数据库中的记录的同步与持久化存储。</p>
</blockquote>
</li>
</ul>
<pre><code class="language-python">import sqlalchemy as sqa
print(sqa.__version__)    # -&gt; 1.4.20
</code></pre>
<h3 id="数据库连接管理"><a class="header" href="#数据库连接管理">数据库连接管理</a></h3>
<pre><code class="language-python">db_url='dialect[+driver]://user:password@[host]/dbname[?key=value..],'
engine = sqa.create_engine(db_url, encoding='utf-8', echo=False, future=True)
</code></pre>
<ul>
<li>
<p><code>echo</code>：回显执行的SQL命令（如果为<code>&quot;debug&quot;</code>，还将输出返回结果）；也可通过<code>logging</code>模块调整输出信息的级别。</p>
</li>
<li>
<p><code>future=True</code>：完全使用2.0风格API。</p>
</li>
</ul>
<blockquote>
<p>数据库连接：需要首先安装相应数据的驱动包（DBAPI）。</p>
<ul>
<li>SQLite：<code>&quot;sqlite+pysqlite:///:memory:&quot;</code></li>
<li>PostgreSQL：<code>&quot;postgresql+psycopg2://user:passwd@/dbname?host=/var/run/postgresql&quot;</code></li>
<li>MySQL：<code>&quot;mysql+pymysql://root:gang2019wsl@/test?unix_socket=/var/run/mysqld/mysqld.sock&quot;</code></li>
</ul>
</blockquote>
<h5 id="连接"><a class="header" href="#连接">连接</a></h5>
<p><code>Engine</code>对象用于管理数据库连接<code>Connection</code>，从而实现对数据库的并发访问。当连接关闭时，连接的资源实际返回给<code>Engine</code>所管理的连接池，同时调用<code>.rollback()</code>释放未完成的事务以及锁从而使之能够被再次使用。</p>
<pre><code class="language-python">with engine.connect() as connection:
    result = connection.execute(sql_command)
</code></pre>
<h5 id="事务"><a class="header" href="#事务">事务</a></h5>
<p>事务用于保证数据操作过程的正确性和完整性，如果在事务执行过程中发生异常，则可以回退到初始状态，防止对数据库产生非预期操作。<code>Engine.begin()</code>或<code>Connection.begin()</code>会创建一个事务<code>Transaction</code>对象，使用上下文管理器来自动提交事务<code>.commit()</code>和处理异常回退<code>·.rollback()</code>（不使用上下文则需要手动提交和进行异常回退）。</p>
<pre><code class="language-python">with engine.begin() as conn:  # -&gt; Transaction
     result = conn.execute(sql_command)
# equals to =&gt;
#     with engine.connect() as connection:
#         with connection.begin():
#             result = connection.execute(sql_command) 
</code></pre>
<h3 id="数据库元数据"><a class="header" href="#数据库元数据">数据库元数据</a></h3>
<p>SQLAlchemy的<strong>查询和对象映射</strong>需要<strong>数据库元数据</strong>（<em>database metadata</em>）支持。元数据以Python对象的形式描述表格和其他Schema层次的对象（SQLAlchemy使用<em><strong>schema name</strong></em>来区分表格所属命令空间）。</p>
<blockquote>
<p>PostgreSQL的默认命名空间为<code>public</code>。</p>
</blockquote>
<h4 id="构造数据库元数据"><a class="header" href="#构造数据库元数据">构造数据库元数据</a></h4>
<p>元数据存储对象<code>MetaData</code>用于保存一个数据相关的元数据。</p>
<pre><code class="language-python">from sqlalchemy import MetaData
metadata_obj = MetaData(bind=engine, schema=&quot;default_schema&quot;)
</code></pre>
<blockquote>
<p><code>engine</code>可不提供，在实际执行操作时通过相关接口传入覆盖初始配置。当指定<code>schema</code>时，表格将显式通过<code>schema</code>来引用。如果需要通过元数据对数据执行实际操作，则==数据库中必须已经存在相应的命名空间==。</p>
</blockquote>
<p>向元数据存储中添加表格定义（描述数据类型及其他属性）：</p>
<pre><code class="language-python">from sqlalchemy.schema import Table,Column,ForeignKey,Sequence
from sqlalchemy import Integer, String
user = Table('user',metadata_obj,
    Column('id', Integer, primary_key=True),
    Column('name', String(16), nullable=False),
    schema='user' 
)
</code></pre>
<p>访问元数据存储的表格定义：</p>
<pre><code class="language-python">for n in metadata_obj.tables:  # &lt;-&gt; metadata_obj.sorted_tables
    table:Table = metadata_obj.tables[n]
    print(n)        # -&gt; print(table) -&gt; print(table.name)   
    table.metadata  # a runtime property of MetaData
    table.bind      # bound Engine/Connection
</code></pre>
<p>访问表格列信息：</p>
<pre><code class="language-python">col = user.columns.id  # -&gt; user.c.id -&gt; user['id']
col.name  # col.{type,nullable,primary_key,foreign_keys}
col.table # 反向引用列所属的表
for col in user.c:
    print(col)
for primary_key in employees.primary_key:
    print(primary_key)
for fkey in employees.foreign_keys:
    print(fkey)
</code></pre>
<h4 id="获取数据库元数据"><a class="header" href="#获取数据库元数据">获取数据库元数据</a></h4>
<p>使用SQLAlchemy提供的反射机制（<em>reflection</em>）从数据库自动加载元数据。</p>
<h5 id="使用metadata"><a class="header" href="#使用metadata">使用MetaData</a></h5>
<p><a href="https://docs.sqlalchemy.org/en/14/core/reflection.html#reflecting-all-tables-at-once"><code>MetaData</code></a>可自动返回连接数据库的所有数据表的元数据对象。</p>
<pre><code class="language-python">from sqlalchemy import MetaData
metadata_obj = MetaData()
metadata_obj.reflect(bind=engine,**kwargs)
metadata_obj.tables  # 所有表组成的字典
</code></pre>
<p>使用<code>Table</code>可返回指定数据表（及其外键引用的数据表）的元数据。</p>
<pre><code class="language-python">user = Table('user', metadata_obj, autoload_with=engine)
</code></pre>
<h5 id="使用inspector"><a class="header" href="#使用inspector">使用Inspector</a></h5>
<p><code>Inspector</code>提供更加底层的接口获取数据库表的元数据。</p>
<pre><code class="language-python">from sqlalchemy import inspect
from sqlalchemy.engine.reflection import Inspector
inspector:Inspector = inspect(engine)
for table in inspector.get_table_names():  # 获取表名
    for column in inspector.get_columns(table): # 获取列定义(字典)*
    	print(column['name'])
</code></pre>
<blockquote>
<p><code>*</code>：列定义包含<code>name</code>、<code>type</code>、<code>nullable</code>、<code>default</code>、<code>autoincrement</code>、<code>comment</code>等属性。</p>
</blockquote>
<p>检查表格是否存在：</p>
<pre><code class="language-python">tf = sqa.inspect(sql_engine).has_table(table_name)
</code></pre>
<h5 id="使用sql命令"><a class="header" href="#使用sql命令">使用SQL命令</a></h5>
<p>使用<a href="Python/../%E6%95%B0%E6%8D%AE%E5%BA%93/PostgreSQL.html#%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BF%A1%E6%81%AF">SQL语句从数据库的元数据表中获取</a>，具体命令与数据库类型相关。不支持PostgreSQL的<code>pgsql</code>命令行工具的快捷命令，如<code>\dt</code>。</p>
<h4 id="创建和删除数据表"><a class="header" href="#创建和删除数据表">创建和删除数据表</a></h4>
<p>使用元数据定义（批量）创建表。</p>
<pre><code class="language-python">metadata_obj.create_all(engine, checkfirst=True)
metadata_obj.drop_all(bind=engine)
table.create(bind=engine, checkfirst=True)
table.drop(bind=engine)
</code></pre>
<blockquote>
<p><code>checkfirst=True</code>：如果表格存在则不执行操作。</p>
</blockquote>
<h3 id="sql查询api"><a class="header" href="#sql查询api">SQL查询API</a></h3>
<h4 id="api用法"><a class="header" href="#api用法">API用法</a></h4>
<p>查询语句的构造方式分为两类：1) 构造SQL命令的文本对象；2) 通过API调用构造命令；</p>
<pre><code class="language-python">from sqlalchemy.sql import column, select, table  #*
sql_query = text(&quot;select x, y from some_table where y &gt; :y&quot;) # 文本模式
t = table(&quot;some_table&quot;, column('x'), column('y'))  
sql_query = select(column('x'), column('y'))\
           .select_from(t)\
           .where(t.c.y &gt; bindparam('y'))  # API构造模式
result = conn.execute(sql_query, {'y':'100'})
result.rowcount  # 查看查询/修改记录的行数
</code></pre>
<p>虽然SQL命令文本更加简洁，但是通过API调用可在程序更加灵活地参数化构造SQL查询命令（无需关注SQL语法细节）。</p>
<h5 id="查询对象构建"><a class="header" href="#查询对象构建">查询对象构建</a></h5>
<p>查询过程中的列和表都需要构造为语句对象而不能使用字符串文本直接表示，可用文本模式或API模式构建对象。</p>
<pre><code class="language-python">col_a, table_x = text('col_a'), text('table_x')    # 文本模式
col_a, table_x = column('col_a'), table('table_x', schema='public') # API模式
</code></pre>
<p>API模式支持对列或表做更多参数配置（如为表指定所属的schema）。<code>column</code>，<code>table</code>分别是<code>ColumnClause</code>和<code>TableClause</code>类型构造方法的封装。区别于元数据定义中使用的<code>Column</code>和<code>Table</code>类，后者不仅继承前者，还扩展了与数据类型、属性和数据库后端相关的接口。</p>
<blockquote>
<p>文本模式如果指定<code>schema_name.table_name</code>作为表名无法工作，因为该形式会被整体视为默认schema中的表名<code>public.&quot;schema_name.table_name&quot;</code>。</p>
</blockquote>
<h5 id="参数传递"><a class="header" href="#参数传递">参数传递</a></h5>
<p>在执行<code>execute()</code>方法时，SQL语句中的绑定参数通过<code>execute()</code>方法的<code>*multiparams, **params</code>参数传递。对于单次执行的命令，使用<code>execute()</code>方法的<code>**params</code>参数传递SQL语句中对应的绑定参数：</p>
<pre><code class="language-python">conn.execute(sql, key1=value1, key2=value2)
</code></pre>
<p>对于无返回值的SQL命令（如<code>INSERT</code>、<code>UPDATE</code>等，即未添加<code>RETURNING</code>表达式），可以批量执行SQL命令，则需要使用<code>*multiparams</code>参数（可以==合并为一个字典对象的序列传递==，方便<a href="Python/Python%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.html#%E4%BB%A5%E5%AD%97%E5%85%B8%E6%88%96%E5%88%97%E8%A1%A8%E5%88%9D%E5%A7%8B%E5%8C%96">从<code>pandas.DataFrame</code>传递数据</a>），批量接收绑定参数对应的参数数据。SQL命令将根据每个字典对象中的参数执行一次查询（底层数据库API也可能对批量查询提供优化）。</p>
<pre><code class="language-python">conn.execute(
    table.insert(), 
    {'key1': value1, 'key2': value2},
    {'key1': value3, 'key2': value4},
    # ...
) # [{'key1': v1, 'key2': v2}, {'key1': v3, 'key2': v4},...]
</code></pre>
<h5 id="输出sql命令"><a class="header" href="#输出sql命令">输出SQL命令</a></h5>
<p>可将通过API构造的SQL命令编译为文本形式并输出，从而方便验证是否正确调用相关API。</p>
<pre><code class="language-python">stmt: ClauseElement = select(t).where(t.c.id == 5)
print(stmt)
sql: Compiled = stmt.compile(literal_binds=True)
print(sql)
</code></pre>
<p><code>literal_binds=True</code>：将构造命令中的字面值嵌入表达式（反之在表达式中将以自动生成的绑定参数代替，执行时再使用字面值代替绑定参数）。</p>
<h5 id="表达式参数绑定"><a class="header" href="#表达式参数绑定">表达式参数绑定</a></h5>
<p>文本命令模式：使用<code>:arg_name</code>在SQL命令中嵌入运行时参数。</p>
<p>API构造模式：使用<code>bindparam()</code>设置运行时参数，其构造结果与文本造模式一致。对于参数为常量的表达式，SQLAlchemy也会将其转换为<strong>自动命名参数</strong>（基于列名和数字编号），并将常量作为参数的默认值在运行时传递给SQL语句。</p>
<h5 id="条件语句"><a class="header" href="#条件语句">条件语句</a></h5>
<p>逻辑连接：<code>and_(*exprs)</code>、<code>or_(*exprs)</code>和<code>not_(expr)</code>。支持使用相应的Python运算符<code>&amp;</code>、<code>|</code>和<code>~</code>，但注意使用<code>()</code>限定每个表达式的范围。</p>
<h5 id="比较运算符"><a class="header" href="#比较运算符">比较运算符</a></h5>
<pre><code class="language-python">column('x').is_(None)               # [is_/is_not] -&gt; x IS NULL
column('x').in_([1, 2, 3])          # [in_/not_in]
                                    # any_()/all_()
                                    # between
column('x').like('word')            # like/ilike/notlike/notilike*
column('x').startswith('word')      # startswith/endswith/contains
                                    # match
column('name').regexp_match('word') # dialect specific
</code></pre>
<blockquote>
<p><code>*</code>：需要添加通配符<code>%</code>以模糊匹配。</p>
</blockquote>
<h4 id="读取数据"><a class="header" href="#读取数据">读取数据</a></h4>
<p>通过<code>SELECT</code>命令或<code>select()</code>API调用读取数据。</p>
<pre><code class="language-python">from sqlalchemy import select
select(table).where(cond_expr)  
select(table.c.name, table.c.fullname)
select(name, fullname).select_from(table)
table.select().where(expr)  #*
</code></pre>
<blockquote>
<p><code>*</code>：此方式不再支持传入列名以选择数据表中的列；同时，仅返回已定义的表对象中的列（<code>SELECT</code>命令会自动包含所定义的列）。</p>
</blockquote>
<h5 id="选择数据源的所有列"><a class="header" href="#选择数据源的所有列">选择数据源的所有列</a></h5>
<pre><code class="language-python">sql = select(text('*')).select_from(table)
</code></pre>
<h5 id="排序和分组统计"><a class="header" href="#排序和分组统计">排序和分组统计</a></h5>
<pre><code class="language-python">from sqlalchemy import asc,desc,func
select(user).order_by(asc(user.c.name))  # -&gt; user.c.name.asc()
select(user.name, func.count(user.id).label(&quot;count&quot;))\
      .group_by(user.name)\
      .having(func.count(user.id) &gt; 10)  # HIVAING是对分组结果进行过滤
</code></pre>
<h5 id="sql函数"><a class="header" href="#sql函数">SQL函数</a></h5>
<p>提取字段：<code>extract(&quot;YEAR&quot;, t.c.date_created)</code>；</p>
<p>SQL统计函数：<code>func.FUNCNAME()</code>：将对应的函数调用<code>FUNCNAME()</code>转换为SQL函数表达式。</p>
<h5 id="连接-1"><a class="header" href="#连接-1">连接</a></h5>
<p>连接两个表并返回查询结果。默认根据两个表的外键字段进行连接；可通过<code>join_from</code>的第三个参数（<code>join</code>的第二个参数）指定连接条件，如<code>user.c.id == address.c.user_id</code>。</p>
<pre><code class="language-python">select(user.c.name, address.c.email_address)\ 
     .join_from(user, address, isouter=False, full=False) #*
select(user.c.name, address.c.email_address).join_from(address,**kwargs) #**
</code></pre>
<blockquote>
<p><code>*</code>：指定<code>OUTER</code>和<code>FULL</code>连接方式。</p>
<p><code>**</code>：<code>join()</code>方法只指定连接运算的右侧表（左侧根据查询推测）。</p>
</blockquote>
<h5 id="获取执行结果"><a class="header" href="#获取执行结果">获取执行结果</a></h5>
<pre><code class="language-python">result:CursorResult = connection.execute(sql_query)
for row in result: # -&gt; CursorResult: DBAPI cursor
  print(f&quot;x: {row.x}  y: {row.y}&quot;)
for row in result:  # 将行数据返回为对象: 可通过下标或属性访问数据
  x = row[0]
  y = row.y
for x, y in result: # 直接将序列对象展开为列元素
    # ...
for dict_row in result.mappings(): # 将行数据返回为字典
    x = dict_row['x']
    y = dict_row['y']
</code></pre>
<p>当返回的<code>CursorResult</code>被读取完后，DBAPI游标将被自动关闭（因此无法重复读取一个返回结果）。</p>
<p><a href="https://docs.sqlalchemy.org/en/14/tutorial/data_select.html">Selecting Rows with Core or ORM — SQLAlchemy 1.4 Documentation</a></p>
<h4 id="修改记录"><a class="header" href="#修改记录">修改记录</a></h4>
<h5 id="插入"><a class="header" href="#插入">插入</a></h5>
<pre><code class="language-python">from sqlalchemy import insert
stmt = insert(user_table)\ # -&gt; user_table.insert()
      .values(name='name', fullname='Full Name')\
result = conn.execute(sql_query, records_data)  # 数据包含name,fullname字段
</code></pre>
<p><code>Insert.values()</code>方法对绑定参数进行了简化，如果未显式调用<code>bindparam()</code>方法，则==SQL命令的参数名称与<code>values</code>方法的关键字参数名称相同==。</p>
<blockquote>
<p>需要注意：<code>values()</code>关键字参数中定义的列必须包含在操作的数据表的列定义中（适用于<code>insert()</code>和<code>update()</code>方法），否则出错*<code>CompileError: Unconsumed column names: xxx</code>*。</p>
</blockquote>
<h5 id="更新-1"><a class="header" href="#更新-1">更新</a></h5>
<p>根据匹配条件更新数据。如果未发生匹配则不会更改任何数据，如果未指定任何条件，则对所有数据都进行更新。</p>
<pre><code class="language-python">update(user_table)\  # -&gt; user_table.update()
      .where(user_table.c.name == 'patrick')\
      .values(fullname='Patrick the Star') # values类似于insert()
</code></pre>
<blockquote>
<p><code>where()</code>和<code>values()</code>方法中的列名不能重复，否则出错*<code>CompileError: Bind parameter 'xxx' conflicts with unique bind parameter of the same name.</code>*。已经出现在<code>where()</code>语句中的列是不需要执行更新操作的，因此无须再出现在<code>values()</code>中。</p>
</blockquote>
<h5 id="删除记录"><a class="header" href="#删除记录">删除记录</a></h5>
<pre><code class="language-python">delete(user_table)\  # -&gt; user_table.delete()
      .where(user_table.c.name == 'patrick')
</code></pre>
<h5 id="返回修改记录的信息"><a class="header" href="#返回修改记录的信息">返回修改记录的信息</a></h5>
<pre><code class="language-python">stmt.returning(user.c.id, user.c.name)
</code></pre>
<p>在上述修改数据记录的相关命令后，调用<code>returning</code>将返回修改数据的指定字段（==调用<code>returning</code>后，执行命令时将不支持批量传递数据==）。根据这些字段可判断对应的数据是否按预期完成操作（某些插入操作可能存在主键重复，或是更新和删除操作存在多个匹配项或未发现匹配项等）。</p>
<h3 id="orm-api"><a class="header" href="#orm-api">ORM API</a></h3>
<p><a href="https://docs.sqlalchemy.org/en/14/orm/quickstart.html">ORM Quick Start — SQLAlchemy 1.4 Documentation</a></p>
<h5 id="定义数据模型"><a class="header" href="#定义数据模型">定义数据模型</a></h5>
<p><a href="https://docs.sqlalchemy.org/en/14/orm/mapping_styles.html#orm-mapping-styles">ORM Mapped Class Overview — SQLAlchemy 1.4 Documentation</a></p>
<p>声明式定义：</p>
<pre><code class="language-python">from sqlalchemy import Column,ForeignKey,Integer,String
from sqlalchemy.orm import declarative_base,relationship
Base = declarative_base()  # 创建ORM对象存储
class User(Base):
    __tablename__ = &quot;user_account&quot;
    id = Column(Integer, primary_key=True)
    name = Column(String(30))
    fullname = Column(String)
    addresses = relationship(
        &quot;Address&quot;, back_populates=&quot;user&quot;, cascade=&quot;all, delete-orphan&quot;
    )
    def __repr__(self):
        return f&quot;User(id={self.id!r}, name={self.name!r}, fullname={self.fullname!r})&quot;

class Address(Base):
    __tablename__ = &quot;address&quot;
    id = Column(Integer, primary_key=True)
    email_address = Column(String, nullable=False)
    user_id = Column(Integer, ForeignKey(&quot;user_account.id&quot;), nullable=False)
    user = relationship(&quot;User&quot;, back_populates=&quot;addresses&quot;)
    def __repr__(self):
        return f&quot;Address(id={self.id!r}, email_address={self.email_address!r})&quot;
</code></pre>
<p>命令式定义：类的字段可动态设置。</p>
<pre><code class="language-python">from sqlalchemy import Table, Column, Integer, String, ForeignKey
from sqlalchemy.orm import registry

mapper_registry = registry()
user_table = Table(
    'user',
    mapper_registry.metadata,
    Column('id', Integer, primary_key=True),
    Column('name', String(50)),
    Column('fullname', String(50)),
    Column('nickname', String(12))
)
class User:
    pass
  
mapper_registry.map_imperatively(User, user_table)
</code></pre>
<p>数据模型可用于创建数据对象。</p>
<pre><code class="language-shell">squidward = User(name=&quot;squidward&quot;, fullname=&quot;Squidward Tentacles&quot;)
krabs = User(name=&quot;ehkrabs&quot;, fullname=&quot;Eugene H. Krabs&quot;)
</code></pre>
<h5 id="orm会话"><a class="header" href="#orm会话">ORM会话</a></h5>
<p>会话用于记录数据库与程序对象间的映射实例。通过上下文管理器实现数据的自动同步。</p>
<pre><code class="language-python">with Session(engine) as session, session.begin():
  session.execute(select(User))  # 获取数据
  session.add(squidward)         # 修改数据
  session.add(krabs)
# equals to =&gt;
#     with Session(engine) as session:
#         with session.begin():
#             session.add(some_object)
#             session.add(some_other_object)
</code></pre>
<p><a href="https://docs.sqlalchemy.org/en/14/orm/session_basics.html#what-does-the-session-do">Session Basics — SQLAlchemy 1.4 Documentation</a></p>
<h3 id="常见问题-2"><a class="header" href="#常见问题-2">常见问题</a></h3>
<h5 id="查询语句中存在特殊字符"><a class="header" href="#查询语句中存在特殊字符">查询语句中存在特殊字符</a></h5>
<ul>
<li>
<p><code>URL</code>字段中如果存在特殊字符，使用<code>urllib.parse.quote_plus</code>进行转义；或者使用<code>sqa.engine.url.URL.create()</code>创建URL对象。</p>
</li>
<li>
<p><code>%</code>序列在SQL查询语句中会由SQLAlchemy再次执行变量替换，为了防止替换，使用<code>%%</code>代替<code>%</code>或将查询语句置于<code>sqlalchemy.text()</code>避免变量替换。</p>
<blockquote>
<p>可能出现错误提示：<em><code>ValueError: unsupported format character (...) at index ...</code></em></p>
</blockquote>
</li>
</ul>
<h2 id="latex文档"><a class="header" href="#latex文档">$\LaTeX$文档</a></h2>
<h3 id="生成latex代码"><a class="header" href="#生成latex代码">生成$\LaTeX$代码</a></h3>
<h4 id="文档对象"><a class="header" href="#文档对象">文档对象</a></h4>
<h5 id="document"><a class="header" href="#document"><code>Document</code></a></h5>
<pre><code class="language-python">doc=Document(
   default_filepath='default_filepath',
   documentclass='article', 
   document_options=[&quot;12pt&quot;],   # 文档类的选项列表
   fontenc='T1', inputenc='utf8', 
   font_size=&quot;normalsize&quot;, 
   lmodern=True, textcomp=True, page_numbers=True, indent=None, 
   geometry_options={&quot;margin&quot;: &quot;2.5cm&quot;}, 
   data=None
)
doc.preamble.append(Command('title', 'Awesome Title'))
doc.preamble.append(Command('author', 'Gary Wang'))
doc.preamble.append(Command('date', NoEscape(r'\today')))
doc.append(NoEscape(r'\maketitle')) # from pylatex.utils import NoEscape
</code></pre>
<blockquote>
<p><code>NoEscape</code>将字符串直接添加到文档内容中，不会对其进行转义解释。</p>
</blockquote>
<p><code>generate_pdf</code> </p>
<h5 id="章节"><a class="header" href="#章节">章节</a></h5>
<p>使用<code>doc.append(item)</code>向章节中添加内容，添加内容不会自动包含切换换段落。</p>
<pre><code class="language-python">from pylatex import Section,Subsection,Subsubsection
with doc.create(Section('A section')):
    doc.append('Some regular text and some ') # 添加段落
    doc.append(italic('italic text. '))       # from pylatex.utils import italic
    with doc.create(Subsection('A subsection')):
        doc.append('Also some crazy characters: $&amp;#{}')
</code></pre>
<h5 id="文本内容"><a class="header" href="#文本内容">文本内容</a></h5>
<p>文本中的特殊字符会在生成的$\LaTeX$文档中被还原未转义序列（例如，<code>&quot;\&quot;-&gt;&quot;\textbackslash&quot;</code>）。如果不需要转换使用<code>NoEscape(text)</code>。</p>
<h5 id="图表"><a class="header" href="#图表">图表</a></h5>
<pre><code class="language-python">with doc.create(Table(position='!htbp')):
   with doc.create(Center()):
      with doc.create(Tabular('rccl')) as table:
         table.add_hline()
         table.add_row((1, 2, 3, 4))
         table.add_hline(1, 2)
         table.add_empty_row()
         table.add_row((4, 5, 6, 7))
         table.add_hline()
</code></pre>
<h5 id="数学环境"><a class="header" href="#数学环境">数学环境</a></h5>
<p>数学公式内容需要放在数学环境对象中。</p>
<pre><code class="language-python">doc.append(Math(data=[r'2\times\alpha=9'], escape=False))
</code></pre>
<p><code>Alignat</code>封装<code>align</code>环境，支持多行公式、编号等功能。</p>
<pre><code class="language-python">with doc.create(Alignat(aligns=2, escape=False)):
   doc.append(r'c^2&amp;=a^2+b^2\\')
   doc.append(r'x&amp;=\frac{a}{b}')
</code></pre>
<p>矩阵对象<code>Matrix</code>可以基于<code>numpy</code>==二维数组==构造，可作为公式环境中的内容：</p>
<pre><code class="language-python">a = np.array([[100, 10, 20]]).T
M = np.matrix([[2, 3, 4], [0, 0, 1], [0, 0, 2]])
with doc.create(Alignat(aligns=2, numbering=False)):
   doc.append(Matrix(M))
   doc.append(Matrix(a))
   doc.append('=')
   doc.append(Matrix(M*a))
</code></pre>
<h5 id="列表"><a class="header" href="#列表">列表</a></h5>
<pre><code class="language-python">with doc.create(Itemize()) as itemize:
   itemize.add_item(&quot;the first item&quot;)
   itemize.append(Command(&quot;ldots&quot;))
with doc.create(Enumerate(enumeration_symbol=r&quot;\arabic*)&quot;,
                          options={'start': 20})) as enum:
   enum.add_item(&quot;the first item&quot;)
</code></pre>
<h4 id="格式"><a class="header" href="#格式">格式</a></h4>
<h5 id="对齐"><a class="header" href="#对齐">对齐</a></h5>
<p><code>Center</code>对象定义居中对齐环境（<code>\begin{center}...\end{center}</code>）。</p>
<h4 id="命令对象"><a class="header" href="#命令对象">命令对象</a></h4>
<pre><code class="language-python">Command(command=None, arguments=None, options=None, packages=None)
# \usepackage{packages}
# \command[options]{arguments}
</code></pre>
<pre><code class="language-python">doc.append(Command(&quot;maketitle&quot;))
doc.append(NoEscape(r'\maketitle'))
</code></pre>
<h4 id="生成源码"><a class="header" href="#生成源码">生成源码</a></h4>
<pre><code class="language-python">doc.generate_tex(filepath=None)  # 将源码保存未tex文件
tex = doc.dumps()                # 将源码输出为字符串
</code></pre>
<h3 id="编译文档"><a class="header" href="#编译文档">编译文档</a></h3>
<pre><code class="language-python">doc.generate_pdf(
   filepath=None,      
   clean=True,         # 是否删除编译生成的辅助文件
   clean_tex=True,     # 是否删除生成的tex文件
   compiler=None,      # 编译引擎名，默认依次尝试latexmk和pdflatex
   compiler_args=None, # 编译引擎选项
   silent=True         # 是否输出编译日志
)
</code></pre>
<blockquote>
<p>如果要使用<code>latexmk/xelatex</code>编译，需要指定编译选项<code>-xelatex</code>（检测到<code>latexmkrc</code>配置没有生效）。</p>
</blockquote>
<h2 id="-2"><a class="header" href="#-2"></a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="数学运算"><a class="header" href="#数学运算">数学运算</a></h1>
<h2 id="python内置运算符和计算库"><a class="header" href="#python内置运算符和计算库">Python内置运算符和计算库</a></h2>
<h3 id="运算符-2"><a class="header" href="#运算符-2">运算符</a></h3>
<h4 id="算术运算符"><a class="header" href="#算术运算符">算术运算符</a></h4>
<p><code>+</code>、<code>-</code>、<code>*</code>：</p>
<p><code>/</code>：在python 2.x中对于整数除法，只返回整数部分；在python 3.x都返回浮点数；</p>
<p><code>x**y</code> ：幂运算，返回$x^y$；</p>
<p><code>//</code>：取整除 - 返回商的整数部分；<code>%</code> ：取模 - 返回除法的余数。</p>
<h4 id="比较运算符-1"><a class="header" href="#比较运算符-1">比较运算符</a></h4>
<div class="table-wrapper"><table><thead><tr><th>运算符</th><th>描述</th><th>运算符</th><th>描 述</th></tr></thead><tbody>
<tr><td><code>==</code></td><td>==比较对象的值是否相等==</td><td><code>!=</code> ：</td><td>不等于，比较对象的值</td></tr>
<tr><td><code>&gt;</code></td><td></td><td><code>&lt;</code></td><td></td></tr>
<tr><td><code>&gt;=</code></td><td></td><td><code>&lt;=</code></td><td></td></tr>
</tbody></table>
</div>
<blockquote>
<p><code>&lt;&gt;</code>在Python3中不是合法的“不等于”运算符。</p>
</blockquote>
<p>使用<code>is</code>运算符确定是否引用相同对象。<code>==</code>和<code>!=</code>运算符的默认行为与<code>is</code>一致，但多数==内置类型覆盖了默认行为，提供值比较功能==，包括：内置数值类型、字符串、序列类型（同类型）、字典、集合。</p>
<blockquote>
<p>由同一字面值构造的字符串引用同一对象，某些字符串运算（如切片）得到的字串将产生新的对象（即使具有相同值）。因此比较字符串是否相等应该使用<code>==/!=</code>。</p>
<p><code>bool</code>值在系统中为常量，因此引用<code>True/False</code>的变量为相同对象（使用<code>is</code>和<code>==</code>等价）。较小的整数值（测试256以内）在系统也为常量，但大整数不是常量，因此应该同一使用<code>==</code>进行比较。</p>
<p><code>None</code>在程序中具有唯一引用，可使用<code>is</code>或<code>==</code>与之进行比较，但某些符合数据类型（如<code>pd.DataFrame</code>）重载了比较运算符用于比较元素而非对象，使用<code>==</code>时需要注意场景。</p>
</blockquote>
<blockquote>
<p>&quot;<code>x &lt; y &lt;= z</code>&quot; is equivalent to &quot;<code>x &lt; y and y &lt;= z</code>&quot;</p>
</blockquote>
<h4 id="赋值运算符"><a class="header" href="#赋值运算符">赋值运算符</a></h4>
<div class="table-wrapper"><table><thead><tr><th>运算符</th><th>描述</th><th>运算符</th><th>描述</th><th>运算符</th><th>描述</th></tr></thead><tbody>
<tr><td><code>=</code></td><td></td><td><code>+=</code></td><td></td><td><code>-=</code></td><td></td></tr>
<tr><td><code>*=</code></td><td></td><td><code>/=</code></td><td></td><td><code>%=</code></td><td>取模赋值</td></tr>
<tr><td><code>**=</code></td><td>幂运算赋值</td><td><code>//=</code></td><td>整除赋值</td><td></td><td></td></tr>
</tbody></table>
</div>
<h4 id="二进制数值运算符"><a class="header" href="#二进制数值运算符">二进制数值运算符</a></h4>
<p>整数位运算按<code>bit</code>进行，<code>bool</code>类型按逻辑关系运算。注意运算符优先级。
| 运算符 | 描述 | 运算符 | 描述   | 运算符 | 描述   |
| ------ | ---- | ------ | ------ | ------ | ------ |
| <code>&amp;</code>    |      | <code>|</code>  |        | <code>~</code>    | 非     |
| <code>^</code>    | 异或 | <code>&lt;&lt;</code>   | 左移位 | <code>&gt;&gt;</code>   | 右移位 |</p>
<blockquote>
<p>整数的二进制表示（补码）有符号前缀位（0表示整数，1表示负数）。前缀也会参与执行位运算。</p>
<p><code>|</code>的优先级比<code>==</code>高，因此使用<code>|</code>连接两个比较表达式时应该使用<code>()</code>保证优先计算比较表达式。</p>
</blockquote>
<h3 id="数学函数"><a class="header" href="#数学函数">数学函数</a></h3>
<p><code>math</code>包集成了常用的数学函数，包括三角函数、双曲函数、近似运算、指数、对数等。</p>
<p><code>cmath</code></p>
<h3 id="时间日期"><a class="header" href="#时间日期">时间日期</a></h3>
<h4 id="时间差"><a class="header" href="#时间差">时间差</a></h4>
<p><code>timedelta</code>：时间增量，可与<code>datetime</code>或<code>date</code>类型进行运算（与<code>date</code>类型运算时时，时间字段无效）；<code>timedelta</code>自身也可以与数值进行运算，内部存储转换为按天、秒和微妙计数。</p>
<blockquote>
<p><code>date</code>对象仅与<code>timedelta</code>对象的日期部分运算。</p>
</blockquote>
<pre><code class="language-python">delta = dt.timedelta(days=1,hours=0,...)  # 构造时间差
delta = day2 - day1                       # 计算时间差
day = day + delta                         # 和时间对象运算
y = delta2/delta1                         # 时间差对象可进行除法，结果为实数
delta = delta2%delta1                     # 求余数运算，结果仍为时间差
</code></pre>
<blockquote>
<p><code>pd.Timedelta</code>具有类似功能。</p>
</blockquote>
<p><code>Offset</code>：时间偏移量，具有固定单位；不同于<code>timedelta</code>，==支持年、月等非固定周期==。</p>
<pre><code class="language-python">offset = pd.offsets.Day(5)  # offset.delta is &lt;Timedelta&gt;
offset.n                    # =&gt; number of unit e.g., 5
offset.name                 # =&gt; name of unit, e.g., 'D'
day = day + offset          # python时间对象也可以和pandas.Offset进行计算
</code></pre>
<blockquote>
<p><code>MonthBegin/MonthEnd</code>偏移指定月份，并定位起始日期到月初/月末；<code>YearBegin/YearEnd</code>等同理。</p>
</blockquote>
<h4 id="时间周期"><a class="header" href="#时间周期">时间周期</a></h4>
<p><code>Period</code>可与数值、时间增量、时间偏移进行运算，实现周期平移。</p>
<pre><code class="language-python">p = pd.Period(...)
p = p + 1                     # 起始时间增加一个周期
p = p + dt.timedelta(days=1)  # =&gt; pd.Timedelta
p = p + offset                # 起始时间增加一定偏移量
</code></pre>
<blockquote>
<p>时间周期与时间偏移计算时，时间偏移的单位<code>offset.name</code>应该不小于时间周期的单位<code>p.freq.name</code>；类似地，<code>timedelta</code>的最小增量单位应该不小于时间周期的单位。</p>
</blockquote>
<p>比较大小：</p>
<pre><code class="language-python">tf = p2 &gt; p1       # MUST have the same freq
</code></pre>
<p>计算偏移：</p>
<pre><code class="language-python">offset = p2 - p1  # =&gt; pd.Offset
p1.freq           # =&gt; pd.Offset
</code></pre>
<p><strong>对齐时间周期</strong>：调整其中一个时间周期对象，使两个时间周期相差整数倍的周期偏移：</p>
<pre><code class="language-python">offset = p_align - p_base
n_offset = offset.n - offset.n % p_align.freq.n  
offset = pd.offsets.Day(n_offset)   # 假设周期单位为Day
p_align = p_base + p_align
</code></pre>
<h2 id="矩阵-1"><a class="header" href="#矩阵-1">矩阵</a></h2>
<h3 id="查找筛选"><a class="header" href="#查找筛选">查找筛选</a></h3>
<pre><code class="language-python">indices = np.where(bool_expr[, x, y])
</code></pre>
<p>返回表达式<code>boo_expr</code>（例如<code>x==b</code>）的值为真的元素的下标，按行评估元素的值。返回类型为<code>tuple</code>，<code>indices[i]</code>为所有值为真的元素的第<code>i</code>维下标构成的<code>1D</code>向量。==当提供三个参数时，根据<code>bool_expr</code>的真值决定返回<code>x</code>或<code>y</code>的元素==（三个参数的维度需要兼容）。</p>
<blockquote>
<pre><code class="language-python"># 将返回值转换为每个元素对应的坐标对
idx_pair = np.array(indices).transpose() 
</code></pre>
</blockquote>
<p>查找非零元素：</p>
<pre><code class="language-python">idx_pair = np.argwhere(a)  # 即使a是一维向量，仍返回二维矩阵
</code></pre>
<p>返回一个二维矩阵，矩阵的每一行对应一个元素的坐标。</p>
<blockquote>
<pre><code class="language-python">idx_pair = np.argmax()		# see argwhere()
idx_pair = np.argmin()		# see argwhere()
</code></pre>
<p>返回元素的坐标分量单独保存：</p>
<pre><code class="language-python">indices = np.where(a!=0)   # 各维度坐标分别返回为一维向量
indices = a.nonzero()	     # =&gt; np.where(a!=0) 
</code></pre>
</blockquote>
<p>从矩阵中查找指定元素：</p>
<pre><code class="language-python">indices = np.where(x==a0)
idx_pair = np.argwhere(x==a0)
</code></pre>
<blockquote>
<p>对于一维向量，可以转换为Python序列（<code>list</code>），使用<code>index()</code>方法查找。</p>
</blockquote>
<p>从矩阵中筛选满足条件的元素：</p>
<pre><code class="language-python">a0 = np.extract(bool_expr,a)  # b = a[bool_expr]
</code></pre>
<h3 id="计算"><a class="header" href="#计算">计算</a></h3>
<p>矩阵计算方法通常通过<code>np</code>模块访问，矩阵对象<strong>主要</strong>提供面向矩阵元素的数值计算方法。</p>
<h4 id="运算符-3"><a class="header" href="#运算符-3">运算符</a></h4>
<p>按元素计算：<code>+(add),-(substract),*(multiply),/(divide)</code>，<code>**(pow)</code>（幂），<code>%</code>（余数），<code>//</code>（向下取整整除），<code>+=,-=,...</code>（自运算符），<code>-(negative)</code>（一元取反运算符），<code>&gt;,&lt;,&gt;=,&lt;=,==,~=</code>；执行按元素计算时，如果运算数的维度不同，则会尝试自动扩展为维度相同的矩阵后进行计算（如行向量与列向量运算）。</p>
<pre><code class="language-python">y=x**a  # =&gt; y=np.pow(x,a)
</code></pre>
<p>位运算符及其函数形式：<code>&amp;(bitwise_and), |(bitwise_or), ^(bitwise_xor), ~(invert), &gt;&gt;(leftshift) &lt;&lt;(right_shift)</code>。</p>
<p><strong>广播机制</strong>：矩阵/表格可以和维度兼容的序列类型进行运算（此时重载的是矩阵/表格的运算符而非序列类型运算符）。</p>
<p>矩阵运算规则（如矩阵乘法）计算。注意：<code>matrix</code>和稀疏矩阵的运算符<code>*</code>代表矩阵乘法，而非元素乘法。</p>
<pre><code class="language-python">X=A@B		# 矩阵乘法 A.dot(B)
</code></pre>
<h4 id="计算函数"><a class="header" href="#计算函数">计算函数</a></h4>
<pre><code class="language-python">np.absolute(a) # fabs(a)
np.divmod(a,b) # 返回商和余数
np.pow(a,x)    # exp(a), sqrt(a), square(a)
np.exp(x)      # e^x, exp2: 2^x, expm1: (e^x)-1
np.log(x)      # log2 log10
np.log1p(x)    # log(1+x)
np.logaddexp() # log(sum(exp()))
</code></pre>
<h4 id="复数运算"><a class="header" href="#复数运算">复数运算</a></h4>
<pre><code class="language-python">np.angle(c)
np.real(c)
np.imag(c)
np.conj(c)   # conjugate(x), complex conjugate
</code></pre>
<h4 id="比较运算"><a class="header" href="#比较运算">比较运算</a></h4>
<p><code>&lt;</code>，<code>&lt;=</code>，<code>&gt;</code>，<code>&gt;=</code>，<code>==</code>，<code>!=</code></p>
<pre><code class="language-python">np.maximum(a,b) # minimum(a,b), find max/min among a,b; preserve nan
np.fmax(a,b)    # fmin(a,b), drop nan
</code></pre>
<blockquote>
<p>上述方法用于比较两个对象，返回两者之中较大（小）的元素组成的对象。</p>
</blockquote>
<p><code>NaN</code>（<code>float('nan')</code>和<code>np.nan</code>）与任何数值计算都返回<code>np.nan</code>；且<code>NaN!=NaN</code>，要比较两个<code>NaN</code>值，可以首先使用<code>np.isnan(x)</code>判断数值（矩阵）是否为<code>NaN</code>。</p>
<blockquote>
<p><code>np.isnan()</code>不能用于非数值类型（如字符串）的矩阵。</p>
</blockquote>
<h4 id="近似"><a class="header" href="#近似">近似</a></h4>
<pre><code class="language-python">round(decimal)
floor
fix
ceil
trunc
</code></pre>
<h4 id="三角和双曲线函数"><a class="header" href="#三角和双曲线函数">三角和双曲线函数</a></h4>
<pre><code class="language-python">np.sin(a)
</code></pre>
<h4 id="特征值"><a class="header" href="#特征值">特征值</a></h4>
<pre><code class="language-python">e,v = np.linalg.eig(array) 
scipy.linalg.eig(array,...)
e,v = scipy.linalg.eigh(array, subset_by_index=[n-3,n-1])
</code></pre>
<p>返回特征值以升序排列。</p>
<h4 id="稀疏矩阵运算"><a class="header" href="#稀疏矩阵运算">稀疏矩阵运算</a></h4>
<p>为了防止运算破坏矩阵的稀疏性，稀疏矩阵运输算不支持：</p>
<ul>
<li>广播机制，因此必须保证参与运算的矩阵维数相同（广播机制容易）。</li>
<li>与标量进行加/减运算。</li>
</ul>
<p>稀疏矩阵与普通矩阵运算结果为普通矩阵（<code>matrix</code>）。</p>
<h3 id="统计"><a class="header" href="#统计">统计</a></h3>
<pre><code class="language-python">np.sum(a, axis, keepdims=None) 
np.cumsum(a)
np.max(a, axis)   # a.min(), find max/min in a
np.mean(a)
np.var(a)
np.std(a)
np.prod(a)
np.cumprod(a)
np.all(a, axis)	# return true if all is true
np.any(a, axis) # return true if any is true
np.count_nonzero(a, axis)
</code></pre>
<p>数值计算函数通常不仅能用于<code>ndarray</code>，也支持<code>list</code>等序列类型以及==表格类型==<code>pd.DataFrame</code>，因此使用<code>np.func(obj)</code>的调用方式比<code>array.func()</code>更加通用。</p>
<p><code>axis=None</code>：默认对数组所有元素执行运算；如果设置为数值$i$，则对第$i$个维度方向的所有元素执行运算。对于矩阵，<code>0</code>代表行索引方向（即对一列数据进行运算），<code>1</code>代表列索引方向（对一行数据进行运算）。==<code>axis</code>对应数组的维度顺序（即<code>0</code>总是代表最前维度），与数组元素存储方式（<code>order='C'|'F'</code>）无关。==</p>
<p><code>keepdims=True</code>：将保持计算结果维数不变（计算方向上长度为1）。</p>
<blockquote>
<p>Python自带<code>max</code>、<code>min</code>等函数是对序列类型元素或参数列表进行比较。</p>
</blockquote>
<p>如果返回值为<code>True|False</code>，其类型为<code>numpy.bool_</code>而非Python内置<code>bool</code>类型，因此需要使用<code>==</code>而非<code>is</code>进行<a href="Python/Python%E6%95%B0%E5%80%BC%E8%AE%A1%E7%AE%97.html#%E6%AF%94%E8%BE%83%E8%BF%90%E7%AE%97%E7%AC%A6">比较</a>。</p>
<h5 id="向量矩阵差分"><a class="header" href="#向量矩阵差分">向量矩阵差分</a></h5>
<pre><code class="language-python">np.diff(a, n=1, axis=-1, prepend=None, append=None)
</code></pre>
<p><code>n</code>：每<code>n</code>个点进行差分，如果<code>n=0</code>则返回原数据；
<code>axis</code>：默认沿最后一个坐标轴进行差分；
<code>prepend|append</code>：添加默认元素，以保证所有输入数据完成差分。如果未指定，==则输出结果将根据差分距离<code>n</code>减少==（默认不会包含<code>NaN</code>）；反之，指定值的维度需要与除差坐标轴外的其他维度一致，坐标轴方向长度至少为<code>n</code>；特别地，如果输入为向量，且<code>n=1</code>，则可以指定输入为标量。</p>
<h4 id="频数和概率密度"><a class="header" href="#频数和概率密度">频数和概率密度</a></h4>
<pre><code class="language-python">hist, bin_edges = np.histogram(data, bins=10, range=None, weights=None, density=None)
</code></pre>
<p><code>range</code>手动指定数据的边界（默认为<code>data.min(), data.max()</code>）。<code>density=True</code>计算概率密度函数（在指定区间上积分为1）。<code>bin_edges</code>为每个分区的边界（分组数+1）。</p>
<blockquote>
<p>不分维度，计算所有数据的统计信息。</p>
</blockquote>
<h4 id="排序-1"><a class="header" href="#排序-1">排序</a></h4>
<p>沿指定坐标轴排序，修改当前矩阵。</p>
<pre><code class="language-python">a.sort(axis=-1,kind='quicksort')
</code></pre>
<blockquote>
<p>若<code>axis=-1</code>，则沿最后一维坐标轴排序；<code>kind</code>表示排序算法，包括 <code>'quicksort', 'mergesort', 'heapsort', 'stable'</code>。</p>
</blockquote>
<p>==该方法对所有行或列分别进行排序==。若要基于某一行/列对矩阵整体排序，将其转换为<code>Pandas.DataFrame</code>的<a href="Python/Python%E6%95%B0%E5%80%BC%E8%AE%A1%E7%AE%97.html#%E8%A1%A8%E6%A0%BC%E6%8E%92%E5%BA%8F">排序方法</a>。</p>
<h3 id="线性代数"><a class="header" href="#线性代数">线性代数</a></h3>
<h3 id="其他"><a class="header" href="#其他">其他</a></h3>
<pre><code class="language-python">convolve(a,b)		# 卷积
a.clip(min,max)		#将取值裁剪到[min,max]之间
</code></pre>
<h2 id="随机数"><a class="header" href="#随机数">随机数</a></h2>
<p>随机数发生器由<code>BitGenerator</code>和<code>Generator</code>两部分组成：<code>BitGenerator</code>负责生成随机字节序列，而<code>Generator</code>负责将字节序列转换为服从相应分布的随机数。</p>
<blockquote>
<p>推荐使用随机数生成器提供的方法代替<code>np.random</code>模块中方法。</p>
</blockquote>
<p>获取随机数发生器：</p>
<pre><code class="language-python">from numpy.random import default_rng
rng = default_rng()   # 使用默认BitGenerator（PCG64）
rng = default_rng(seed)
rng = Generator(PCG64(12345))  #指定并初始化序列发生器
</code></pre>
<p>产生随机数：</p>
<pre><code class="language-python">rng.random(size=[m,n],dtype=np.float64)  # [0.0, 1.0)均匀分布浮点随机数
rng.integers(low,high,dtype,endpoint=True)  #整数随机数
rng.standard_normal(10)  # 标准正态分布
</code></pre>
<blockquote>
<p><a href="https://numpy.org/doc/stable/reference/random/generator.html#distributions">支持的分布</a>包括：<code>exponential</code>、<code>logistic</code>、<code>lognormal</code>、<code>normal</code>、<code>poisson</code>等分布。</p>
</blockquote>
<p>随机置换：</p>
<pre><code class="language-python">array = rng.permutaiton(x, axis=0)
rng.shuffle(x, axis=0)    # 置换输入数组
</code></pre>
<blockquote>
<p>如果<code>x</code>为整数，则随机置换（<code>range(x)</code>），<code>axis</code>指定随机置换的方向。</p>
</blockquote>
<p>随机排列一个序列，或<code>range</code>对象（如果<code>x</code>是整数）。</p>
<p>随机采样：</p>
<pre><code class="language-python">rng.choice(a, size, replace,...)   #从a中随机抽样并组成新数组
</code></pre>
<pre><code class="language-python">rng.bytes(length)  #返回随机序列
</code></pre>
<h2 id="数据表运算"><a class="header" href="#数据表运算">数据表运算</a></h2>
<h3 id="缺失数据"><a class="header" href="#缺失数据">缺失数据</a></h3>
<p>Pandas读取数据源时，默认使用<code>np.nan</code>代替缺失数据。</p>
<p>判断数据是否为有效数据（ 数值矩阵中<code>NaN</code> , 对象矩阵中<code>None</code> 或 <code>NaN</code>，日期中<code>NaT</code>）：</p>
<pre><code class="language-python">df_tf = pd.isna(df)   # ==&gt; df.isna()
df_tf = pd.notna(df)  # ==&gt; df.notna()
</code></pre>
<blockquote>
<p>静态方法还支持除Panda内置数据以外的类型，例如<code>ndarray</code>、<code>list</code>等，且返回类型与输入类型。==按元素比较，实例类型返回值类型与实例一致==。</p>
<p><code>isnull</code>是<code>isna</code>的别名；<code>notnull</code>是<code>notna</code>的别名。</p>
</blockquote>
<p>丢弃缺失数据的行：</p>
<pre><code class="language-python">df1.dropna(how='any')
</code></pre>
<p>填充缺失数据：</p>
<pre><code class="language-python">df1.fillna(value=5)
</code></pre>
<p>如果某一列数据为<code>category</code>，则需要将填充的值添加到类别中。</p>
<pre><code class="language-python">df.col_name = df.col_name.cat.add_categories(&quot;D&quot;)
df.col_name.fillna(&quot;D&quot;)
</code></pre>
<h3 id="比较大小"><a class="header" href="#比较大小">比较大小</a></h3>
<p>按元素比较，类似与<code>np.ndarray</code>：</p>
<pre><code class="language-python">df.gt(df2) #  eq, ne, lt, gt, le, and ge
df == val  # =&gt; df.eq(val) 比较维度兼容的标量、序列、数组、Series/DataFrame
</code></pre>
<blockquote>
<p>当两个表格比较时，其行列标签必须相等（否则出错）。</p>
</blockquote>
<p>整体比较：判断两个表格的数据是否完全相等。</p>
<pre><code class="language-python">tf_equal = df.equals(df2)  
tf_equal = (df1==df2).all(axis=None)  # 此处axis用法与np.ndarray一致
</code></pre>
<p><code>equals()</code>比较两个对象是否具有完全相同的元素（对象类型相同，即同为<code>DataFrame</code>/<code>Series</code>，数据类型相同，表头的数据类型不需要相同）；与按元素比较不同的是，对应的<code>NaN</code>元素被视为相等。</p>
<blockquote>
<p><code>==</code>和<code>!=</code>是<code>DataFrame</code>的元素比较，<code>df.equals</code>是元素比较后的汇总结果，而<code>is</code>和<code>is not</code>运算符则是判断是否引用为同一对象。</p>
<pre><code class="language-python">x1=np.array(['dos', 'normal'])
x2 = pd.Series(x1)
x1 == x2
# 0    True
# 1    True
x2.equals(x1)  # False
</code></pre>
</blockquote>
<h3 id="矩阵计算"><a class="header" href="#矩阵计算">矩阵计算</a></h3>
<p>表格兼容<code>numpy</code>的矩阵运算方式，函数名称与<code>numpy</code>保持一致。在元素处理规则方面：1) 由于表格每一列数据类型可能不同，因此沿<code>axis=1</code>方向的运算可能不可用。2) <code>numpy</code>默认对所有元素执行计算，<code>pandas</code>默认对列执行计算。</p>
<pre><code class="language-python">df.add(other, fill_value=None) #  element-wise add, sub, mul, div, mod, pow
</code></pre>
<p><code>other</code>：标量、矩阵、序列等数值运算规则兼容的类型。</p>
<p>==对于索引不同的表格，默认将索引对齐进行运算，计算结果的索引将按序排列==，可能产生非预料的结果（为对齐索引产生缺失元素，其参与运算使结果变为<code>NaN</code>）。如果要忽略索引可以使用<code>reset_index</code>或将其中至少一个转换为<code>ndarray</code>（<code>to_numpy()</code>）。</p>
<h4 id="差分"><a class="header" href="#差分">差分</a></h4>
<p><code>df.diff</code>仅包含默认的差分设置，使==运算前后表格维度不变==，可使用<a href="Python/Python%E6%95%B0%E5%80%BC%E8%AE%A1%E7%AE%97.html#%E5%90%91%E9%87%8F%E7%9F%A9%E9%98%B5%E5%B7%AE%E5%88%86"><code>np.diff</code>进行自定义</a>。</p>
<pre><code class="language-python">df.diff(periods=1, axis=0)  # ss.diff
</code></pre>
<blockquote>
<p>前<code>peirods</code>行/列对应的差分值为<code>NaN</code>。</p>
</blockquote>
<h3 id="统计-1"><a class="header" href="#统计-1">统计</a></h3>
<p>总体统计信息：</p>
<pre><code class="language-python">df.describe(percentiles=None, include=None, exclude=None)		
</code></pre>
<p>获取数据表中的统计特征：<code>sum</code>、<code>mean</code>、<code>median</code>、 <code>cumsum</code> 、<code>cumprod</code>、<code>max</code>、<code>min</code>、<code>idmax</code>、<code>idmin</code>、<code>any</code>、<code>all</code>等。</p>
<pre><code class="language-python">df.max(axis=0, skipna=True, level=None, numeric_only=only)
ss.max(...)
</code></pre>
<p><code>axis</code>：仅支持行/列统计（<code>axis=0|1</code>），不支持全局统计。</p>
<blockquote>
<p>执行数值运算时（求和、均值等），缺失数据默认按<code>0</code>处理；<code>skipna=True</code>跳过<code>NaN</code>元素。</p>
<p>如果指定了<code>level</code>，则分别对不同索引值对应的数据进行统计，等效于<code>df.groupby(level,sort=False).max()</code>；</p>
<p>如果<code>numeric_only=True</code>，则只返回数值列的统计结果。</p>
<p>字符串运算：可以比较大小，求和与累加为字符串拼接，其他运算未定义。==字符串与数值混合的列默认不会包含在统计结果中==。</p>
<p>累计运算：计算结果的第一个值为原数据的第一个元素。</p>
</blockquote>
<p>按列/行统计有效数值（<code>non-NA</code>）的数量：</p>
<pre><code class="language-python">ss = df.count(axis=0)
</code></pre>
<p><strong>统计非零值</strong>：可直接比较后求和，或使用<code>np.count_nonzero()</code>（返回标量或<code>ndarray</code>）。</p>
<h5 id="boolean-reduction-1"><a class="header" href="#boolean-reduction-1">Boolean Reduction</a></h5>
<pre><code class="language-python">df.all(axis=[0,1,None])  # see also df.any()
df.isna().all(axis=0)  # 判断列是否全为Nan
</code></pre>
<h5 id="查找唯一项"><a class="header" href="#查找唯一项">查找唯一项</a></h5>
<p><code>Series</code>可以判断序列是否唯一，或返回唯一元素组成的矩阵（<code>nx1 np.ndarray</code>）。</p>
<pre><code class="language-python">tf = ss.is_unique
array = df[col_name].unique()		# return ndarray
</code></pre>
<p><code>DataFrame</code>的<code>groupby</code>方法可以通过分组后的组名确定唯一项（参考列的值），同时确定唯一项对应的行索引/下标。</p>
<p>统计频数：</p>
<pre><code class="language-python">df.value_counts(subset=None,normalize=False,sort=True,ascending=False)
ss.value_counts(normalize=False,sort=True,ascending=False,bins=None,dropna=True)
</code></pre>
<ul>
<li><code>normalize</code>：将结果归一化为比例；</li>
<li><code>bins</code>：分区间计数而非按值计数（仅适用于数值类型）。</li>
</ul>
<blockquote>
<p><code>df.value_counts</code>可统计多列联合的频数（等效于使用<code>groupby(by=cols).size()</code>）。<code>pd.value_counts</code>用法与<code>ss.value_counts</code>相同，且支持非Pandas序列类型。</p>
</blockquote>
<h5 id="直方图"><a class="header" href="#直方图">直方图</a></h5>
<pre><code class="language-python">hist = df.hist(bins=3)  
</code></pre>
<p><code>DataFrame</code>和<code>Series</code>提供<code>hist()</code>方法<a href="Python/Python%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA.html#Pandas">绘制直方图</a>，但不会返回直方图的数据。使用<code>np.histogram</code>计算统计信息。</p>
<h5 id="相关系数"><a class="header" href="#相关系数">相关系数</a></h5>
<p>计算特征列间的相关系数：</p>
<pre><code class="language-python">df.corr(method='pearson')
</code></pre>
<p><code>method='pearson'|'kendall'|'spearman'|callable</code>：相关系数计算方法：</p>
<blockquote>
<p>计算离散类型的相关性。</p>
<p>https://blog.csdn.net/sky88088/article/details/51737136</p>
</blockquote>
<h3 id="采样"><a class="header" href="#采样">采样</a></h3>
<h4 id="随机抽样"><a class="header" href="#随机抽样">随机抽样</a></h4>
<pre><code class="language-python">df.sample(n=None, frac=None, random_state=None, axis=None, replace=False)
</code></pre>
<p><code>n</code>和<code>frac</code>：采样个数或比列，两者不能同时设置。当<code>frac</code>未设置时，<code>n=1</code>。</p>
<h3 id="自定义数值计算"><a class="header" href="#自定义数值计算">自定义数值计算</a></h3>
<h4 id="applymap"><a class="header" href="#applymap">Apply/Map</a></h4>
<pre><code class="language-python">x=df.apply(func, axis=0, raw=False, args=(), **kwds)
x=df.apply(np.sqrt)
x=df.apply(np.sum, axis=0)		# 将执作为计算单元
def f(x,a,b=0):
  return x + a + b
x=df.apply(lambda x: f(x, a, b), axis=1) # 将行作为计算单元
x=df.apply(f, axis=1, args=(a,), b=10) # 将行作为计算单元
</code></pre>
<p>将数据表的==每一行（<code>axis=1</code>）/每一列（<code>axis=0</code>，默认）==提供给<code>func</code>执行计算（对于<code>Series</code>则直接按元素计算）并返回结果。</p>
<ul>
<li>如果<code>func</code>的计算结果为标量，则<code>apply</code>返回值为<code>Series</code>（索引与<code>axis</code>遍历方向一致）；</li>
<li>计算结果为<code>Series</code>，则<code>apply</code>返回值为<code>DataFrame</code>（索引与<code>axis</code>遍历方向一致）；</li>
</ul>
<blockquote>
<p>利用<code>apply</code>可以实现<code>1-&gt;n</code>行变换，特别地，将<code>Series</code>扩展为<code>DataFrame</code>，或将<code>DataFrame</code>汇总为一列<code>Series</code>。</p>
</blockquote>
<p><code>args</code>和<code>kwds</code>可分别向计算函数传递除计算对象以外的位置参数和键值参数。</p>
<blockquote>
<p><code>apply</code>/<code>applymap</code>会对第一行/列调用函数两次，以确定是否能快速执行代码。</p>
<p>通常存在向量化的函数，因此应该优先调用向量化函数，而非<code>apply</code>/<code>applymap</code>。</p>
</blockquote>
<p><code>applymap</code>和<code>transform</code>保持源数据维度不变。<code>applymap</code>专门用于按元素计算（<code>Series</code>不提供<code>applymap</code>，其与使用<code>apply</code>效果一致）。<code>transform</code>仍传递行或列给<code>func</code>，可以进行行列内变换，但返回值需要与输入<code>DataFrame</code>保持一致，即<code>func</code>不改变输入行列的维度。可为不同列指定不同的<a href="Python/Python%E6%95%B0%E5%80%BC%E8%AE%A1%E7%AE%97.html#Aggregate(Reduce)">变换方法</a></p>
<pre><code class="language-python">applymap(self, func, na_action = 'ignore')
df.transform(func, axis=0, *args, **kwargs)  #DataFrame
</code></pre>
<h4 id="aggregatereduce"><a class="header" href="#aggregatereduce">Aggregate(Reduce)</a></h4>
<p><em><strong>Aggregate</strong></em>方法将数据进行统计汇总，使数据的维度降低。</p>
<ul>
<li>计算对象为<code>Series</code>且聚合函数只有一个，则返回标量；</li>
<li>对象为<code>Series</code>且汇聚函数有多个，返回以函数名索引的<code>Series</code>；</li>
<li>对象为<code>DataFrame</code>且汇聚函数只有一个，则返回以列名索引的<code>Series</code>；</li>
<li>对象为<code>DataFrame</code>且而汇聚函数有多个，返回<code>DataFrame</code>，函数名作为行索引<code>index</code>，列名作为列索引。</li>
</ul>
<pre><code class="language-python">df = df.aggregate(func:[func|list_func|dict_func], axis=0,...)   # agg
</code></pre>
<p>使用给定的聚合函数<code>func</code>对每个分组进行汇总计算，并将计算结果汇聚到同一个表格。支持的函数参数：</p>
<ul>
<li>函数，函数名或函数和函数名的列表（混合）：将函数应用到数据的每一列，返回各个函数的计算结果（==组成函数名和列名索引的表格==）。</li>
<li>列名和函数/函数名/列表组成的字典，对==不同列应用不同的函数==，返回结果中没有应用某函数的列的值设置为<code>nan</code>。</li>
<li>如果计算对象为<code>Series</code>，输入多个聚合函数，则默认输出列名为函数名；如果输入字典，则以字典的<code>key</code>作为输出列名。</li>
</ul>
<h3 id="分组计算"><a class="header" href="#分组计算">分组计算</a></h3>
<h4 id="离散值分组"><a class="header" href="#离散值分组">离散值分组</a></h4>
<p>根据列的值（或多列值的组合）进行分组：</p>
<pre><code class="language-python">grouped = df.groupby(by=col_names)        # -&gt; &lt;DataFrameGroupBy&gt; object
grouped = ss.groupby(by=sequence)         # -&gt; &lt;SeriesGroupBy&gt; object
grouped = df.groupby(level=[l1,l2,...])   # by index (number or )
</code></pre>
<h5 id="参数说明"><a class="header" href="#参数说明">参数说明</a></h5>
<p><code>by=func|dict|series|ndarray|label|[labels,...]</code>：</p>
<ul>
<li>函数，则作用于对象的索引，计算结果作为分组参考；</li>
<li><code>dict</code>或<code>Series</code>，将其值作为对应数据行的分组依据；</li>
<li><code>ndarray</code>，将每行作为对应数据行的分组依据；</li>
<li>标签或标签列表，使用待分组对象的对应==数据列或索引列==的数值作为分组依据；数据和索引不能存在同名。</li>
</ul>
<blockquote>
<p>对<code>Series</code>分组时，根据传入<code>sequence</code>的值进行分组，并应用到<code>Series</code>上。因此，对自身的值进行分组：<code>ss.groupby(by=ss)</code>。</p>
</blockquote>
<p><code>level={0,1,...}|name</code>：指定级别的索引作为分组依据；</p>
<p><code>sort=True</code>：对返回分组排序按分组列进行==排序==（==关闭该选项可提高性能==）；</p>
<p><code>dropna=True</code>：默认将分组列值为<code>Nan</code>的丢弃，如果希望分组后的计算返回结果<strong>与原表格一一对应</strong>，应将该参数设置为<code>False</code>。</p>
<p>通过遍历分组对象迭代器，可迅速获得分组中的数据条目：</p>
<pre><code class="language-python">for group_label, subframe in gs:
	group_idx = gs.groups[group_label]   # group_label -&gt; index *
	sub_group = df.loc[group_idx]	     # == group_frame
	group_iloc = gs.indices[group_label] # group_label -&gt; location
	sub_group = df.iloc[group_iloc]      # == group_frame
</code></pre>
<blockquote>
<p><code>subframe</code>是分组对象内部数据，对其进行修改不会影响原数据。</p>
</blockquote>
<p>分组的组名由参考列的值或参考列的值构成的<code>tuple</code>，分组对象的属性包括：</p>
<ul>
<li>
<p><code>groups</code>：组名和**组内记录的行索引<code>Index</code>**组成的字典；</p>
</li>
<li>
<p><code>indices</code>：组名和分组所属元素的行下标<code>Array</code>组成的字典；</p>
<blockquote>
<p>如果基于<code>MultiIndex</code>进行分组且其中包含<code>NaN</code>值，则<code>indices</code>中不包含<code>NaN</code>值索引（==待测试==）。</p>
</blockquote>
</li>
<li>
<p><code>size()</code>：返回各组的记录数量（等效于对任意一列使用<code>count()</code><a href="Python/Python%E6%95%B0%E5%80%BC%E8%AE%A1%E7%AE%97.html#%E5%AF%B9%E5%88%86%E7%BB%84%E7%9A%84%E8%AE%A1%E7%AE%97">运算</a>。）</p>
</li>
</ul>
<h5 id="对分组的计算"><a class="header" href="#对分组的计算">对分组的计算</a></h5>
<p>通过<code>groupby</code>返回的分组结果<code>grouped</code>，可以同时对各个分组的每列进行统计聚合（<code>max, min, hist...</code>）<a href="Python/Python%E6%95%B0%E5%80%BC%E8%AE%A1%E7%AE%97.html#Reduce/Aggregate">自定义聚合运算</a> 或<a href="Python/Python%E6%95%B0%E5%80%BC%E8%AE%A1%E7%AE%97.html#Apply/Map">自定义映射运算</a>（<code>apply</code>）。应优先调用用<code>aggregate/transform</code>等内置函数。</p>
<pre><code class="language-python">grouped.mean()   # count, max, avg, min, sum, ... on each column
grouped.aggregate({
 {'A': 'max', 'B': 'count', ...} # customied func on specified columns
})  # customized reduce computation
</code></pre>
<pre><code class="language-python">grouped.apply(func, axis=0)                 # customized map computation
grouped.transform(func, *args, engine=None) # return a same size DataFrame
</code></pre>
<blockquote>
<p>如果运算规约到标量（<code>reduce</code>），则返回结果以分组名作为索引；如果运算不改变规模（<code>map</code>），则返回结果与原数据表的索引结构一致。</p>
<p>在<code>transform</code>中，如果<code>func</code>返回值==降维，则将返回值复制到组内每一行记录==；反之，输出与输入对应。</p>
</blockquote>
<p>或单独对某列进行统计：</p>
<pre><code class="language-python">grouped.col_name.count()  
grouped['colname'].count()
grouped.aggregate({'col_name': 'count'})
</code></pre>
<p><strong>注意</strong>：==如果使用索引进行分组==，即使在分组时添加<code>dropna=False</code>，如果直接调用聚合函数，结果仍会忽略包含<code>NaN</code>的组。通过<code>grouped.groups</code>查看分组信息发现分组结果包含<code>NaN</code>组，因此仍可显式对各分组进行汇聚计算。</p>
<h4 id="二维分组"><a class="header" href="#二维分组">二维分组</a></h4>
<p>将指定列数据映射到二维表格(<em><strong>pivot table</strong></em>)：指定为<code>index</code>的列的值作为新表格的行名，指定为<code>columns</code>的列的值作为新表格的列名，指定为<code>values</code>的列的值作为新表格中对应行列的值。</p>
<img src="Python/Python数值计算.assets/image-20211223211731600.png" alt="image-20211223211731600" style="zoom:60%;" />
<blockquote>
<p>类似于：$\mathrm{df}(m, [i,j,k]) \rightarrow \mathrm{df}_{pivot}(\mathrm{df}(m,i),\mathrm{df}(m,j))=\mathrm{df}(m,k)$。</p>
</blockquote>
<pre><code class="language-python">df_pivote = df.pivot(index=cols1, columns=cols2, values=cols3)
</code></pre>
<blockquote>
<p>可以为<code>index</code>/<code>columns/values</code>指定多个列，从而生成表格的索引为<code>MultiIndex</code>。</p>
</blockquote>
<p>当行列索引值对应多条表格行时，将产生<code>ValueError</code>。此时，应选择<code>pivot_table</code>，都重复记录进行聚合。</p>
<pre><code class="language-python">df.pivot_table(index='name', columns='ctg', values=None, aggfunc='mean', 
               fill_value=None, dropna=True)
</code></pre>
<blockquote>
<p><code>fill_value</code>为结果中不存在的元素填充值；<code>dropna</code>丢弃输入数据中<code>NaN</code>。如果<code>columns=None</code>，可为<code>aggfunc</code>单独指定每列的聚合函数（等效于<code>aggregate()</code>）。</p>
</blockquote>
<h4 id="时序分组"><a class="header" href="#时序分组">时序分组</a></h4>
<p>对以时间（<code>DatetimeIndex</code>，<code>PeriodIndex</code>以及<code>TimedeltaIndex</code>）为索引的数据按时间维度进行分组。基于分组结果可进行统计等运算，从而生成时序特征数据。</p>
<pre><code class="language-python">rs = df.resample(rule, axis=0, closed='left', label='left', kind=None, 
                 on, level, origin='start_day', offset = None) -&gt; Resampler
</code></pre>
<blockquote>
<p><code>rule</code>：<code>DateOffset</code>, <code>Timedelta</code>或==使用字符串类型表示<a href="Python/Python%E6%95%B0%E5%80%BC%E8%AE%A1%E7%AE%97.html#Python%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.md#%E6%97%B6%E9%97%B4%E7%B4%A2%E5%BC%95">采样周期</a>==；根据指定的周期以及数据的时间粒度，采样方式可能是下采样或上采样。
<code>origin</code>：调整分组起始时间点，可在此基础上再增加<code>offset</code>。可设置为：</p>
<ul>
<li><code>epoch</code>：<code>1970-01-01 00:00:00</code>；</li>
<li><code>start|end</code>：数据第一个/最后一个点的时间；</li>
<li><code>start_day|end_day</code>：数据第一个（最后一个）点当天（次日）的零点（<code>1.3</code>新增，<code>end_day</code>用于反向采样）；</li>
<li><code>str|timestamp</code>：表示时间的字符串或时间戳。</li>
</ul>
<p><code>closed={'left|right'}</code>：指定==下采样==的闭合边界；<code>closed='right'</code>相当于逆时间轴==反向采样==。
<code>label={'left'|'right'}</code>：指定==下采样==后的数据标签为原始数据的左/右边界；
<code>on</code>：指定采样的列代替索引（<a href="Python/./Python%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.html#%E6%97%B6%E9%97%B4%E7%B4%A2%E5%BC%95">构造方法参考时间索引</a>）；<code>level</code>：指定采样使用的索引列；
<code>kind={'timestamp'|'period'}</code>：<code>timestamp</code>将采样指定列转换为<code>DateTimeIndex</code>；<code>period</code>将采样指定列转换为<code>PeriodIndex</code>。</p>
</blockquote>
<h5 id="下采样"><a class="header" href="#下采样">下采样</a></h5>
<p>每个周期分组内包含多个原始数据的样本（参考<code>groupby</code>对每个分组进行迭代）。</p>
<ul>
<li>
<p>对采样后的各个区间数据的各列进行汇总（不含缺失数据）：</p>
<pre><code class="language-python">rs.sum/count/nunique/first/last/max/min/mean/median/ohlc/prod/size()
rs.sem() # standard error
rs.std/var() # standard deviation of groups
</code></pre>
<p>也可仅对给定的列汇总：</p>
<pre><code class="language-python">rs[['A','B']].sum()
</code></pre>
</li>
<li>
<p>自定义采样后的计算（参考<code>groupby, aggregate</code>）：</p>
<pre><code class="language-python">df.resample('3T').apply(func)
rs[&quot;A&quot;].agg([np.sum, np.mean, np.std])  # =&gt; aggregate
</code></pre>
</li>
</ul>
<h5 id="上采样"><a class="header" href="#上采样">上采样</a></h5>
<p>如果输入时序数据的数据点间的周期要高于采样周期，则发生上采样。</p>
<pre><code class="language-python">df.resample('3T', convention='start') 
</code></pre>
<p><img src="Python/Python数值计算.assets/image-20210724151531134.png" alt="image-20210724151531134" style="float:right; zoom:40%;" />上采样后，原数据的一个点映射到新数据的多个点，<code>convention</code>指定原数据如何映射到新数据中（分配给起点或终点<code>'start'|'end'</code>）。<code>convention</code>仅用于采样指定的时间序列为<code>PeriodIndex</code>的情况。</p>
<blockquote>
<p>上采样后的聚合不能直接采用<code>rs.func</code>的方式；需要调用<code>rs[cols].aggregate(func_list|func_dict)</code>（注意：调用单个函数的形式<code>.agg(func)</code>等效于<code>rs.func</code>）。</p>
</blockquote>
<p>使用非零点的值填充上采样后缺失信息，可限制每个周期填充的点数：</p>
<pre><code class="language-python">rs.fillna(method, limit=None) # method=ffill|bfill|nearest...
rs.ffill(limit=None)  # 前向填充缺失值，limit限制填充点数===rs.pad()
rs.bfill(limit=None)  # === backfill()
rs.nearest(limit=None)# 使用最近有效数据填充缺失值
</code></pre>
<p>也可采用插值函数进行填充：</p>
<pre><code class="language-python">rs.interpolate(method='linear',...)
</code></pre>
<h5 id="反向采样r13"><a class="header" href="#反向采样r13">反向采样（<code>R1.3</code>）</a></h5>
<p>将<code>origin</code>设置为<code>end|end_day</code>，则默认以结束时间/结束日期的次日零点为原点，反向计算分组区间（默认左开右闭，即<code>closed=right</code>）。</p>
<h2 id="图运算"><a class="header" href="#图运算">图运算</a></h2>
<h3 id="networkx-1"><a class="header" href="#networkx-1">NetworkX</a></h3>
<p><a href="https://networkx.org/documentation/stable/tutorial.html#graph-generators-and-graph-operations">Tutorial — NetworkX 2.5 documentation</a></p>
<h2 id="加速运算"><a class="header" href="#加速运算">加速运算</a></h2>
<h3 id="向量运算"><a class="header" href="#向量运算">向量运算</a></h3>
<p>安装<code>numexpr</code>和<code>bottleneck</code>库：</p>
<blockquote>
<p><code>numexpr</code>库使用smart chunking, caching, and multiple cores ；</p>
<p><code>bottleneck</code>库使用<code>cpython</code>库的方法加速具有<code>nan</code>值的矩阵。</p>
</blockquote>
<p>支持整数/boolean类型数据的某些二元运算加速。</p>
<ol>
<li><a href="https://developer.ibm.com/technologies/python/articles/ba-accelerate-python/">Accelerating Python for scientific research - Optimize your Python code for research</a>.</li>
<li></li>
</ol>
<h3 id="dask"><a class="header" href="#dask">dask</a></h3>
<h4 id="应用场景"><a class="header" href="#应用场景">应用场景</a></h4>
<h5 id="简单并行运算"><a class="header" href="#简单并行运算">简单并行运算</a></h5>
<ul>
<li>
<p>按元素算术运算</p>
<p><code>map_partitions(func, *args, **kwargs)</code>：以分区为计算单元输入执行<code>map</code>操作，再将返回结果合并。</p>
</li>
<li>
<p>按行运算：<code>df[df.x&gt;0]</code></p>
</li>
<li>
<p>切片：<code>df.loc[1:10]</code></p>
</li>
<li>
<p>统计聚合：<code>df.max()</code></p>
</li>
<li>
<p>查找：<code>df[df.x.isin([1,2,3])]</code></p>
</li>
<li>
<p>时间日期：<code>df.timestamp.month</code></p>
</li>
</ul>
<h5 id="智能并行运算"><a class="header" href="#智能并行运算">智能并行运算</a></h5>
<ul>
<li>
<p>groupby-aggregate：<code>df.groupby('x').y.max()</code></p>
<p><code>apply-concat-apply</code></p>
</li>
<li>
<p>groupby-apply on index：</p>
<blockquote>
<p>common groupby operations like <code>df.groupby(columns).reduction()</code> for known reductions like <code>mean, sum, std, var, count, nunique</code> are all quite fast and efficient.</p>
</blockquote>
</li>
<li>
<p>统计计数：<code>df.x.value_counts()</code></p>
</li>
<li>
<p>去重： <code>df.x.drop_duplicates()</code></p>
<blockquote>
<p>对整个表格去重会很慢，因为需要交换大量数据以及进行比较。</p>
</blockquote>
</li>
<li>
<p>Join on index, join with small Pandas DataFrames/single partition Dask DataFrame</p>
<pre><code class="language-python"># Large join small
small = small.repartition(npartitions=1)
result = big.merge(small)
# Join on index
left = left.set_index('id').persist()
left.merge(right_one, left_index=True, ...)
</code></pre>
</li>
<li>
<p>分区/列之间的按元素计算：<code>df.x+df.y</code></p>
</li>
<li>
<p>相关系数：<code>df[['col1', 'col2']].corr()</code></p>
</li>
</ul>
<h5 id="需要shuffle的运算除非在index上否则较慢"><a class="header" href="#需要shuffle的运算除非在index上否则较慢">需要shuffle的运算（除非在index上，否则较慢）</a></h5>
<ul>
<li>groupby-apply not on index：需要设置索引</li>
<li>Join not on the index：需要设置索引</li>
</ul>
<blockquote>
<p>https://docs.dask.org/en/latest/dataframe-groupby.html</p>
</blockquote>
<h4 id="方法"><a class="header" href="#方法">方法</a></h4>
<h5 id="汇聚"><a class="header" href="#汇聚">汇聚</a></h5>
<pre><code class="language-python">df.apply(func, axis=1, meta=('name', type))
</code></pre>
<p><strong>返回值类型推断</strong>：需要通过<code>meta</code>关键字提供输出的元信息：根据返回对象类型，提供相应的空对象进行类型推断；快捷设置方式，==如果计算对象是<code>DataFrame</code>，则<code>meta</code>可以是字典或元组列表；如果是<code>Series</code>，则<code>meta</code>是元组==。如果没有声明<code>meta</code>，则Dask将尝试根据数据推断类型（可能导致非预期结果）。</p>
<p><code>DataFrame</code>仅支持<code>axis=1</code>（按行计算）。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="系统编程"><a class="header" href="#系统编程">系统编程</a></h1>
<p>Python封装与系统底层交互的接口。</p>
<ul>
<li>
<p><code>shutil</code>：封装Shell命令；</p>
</li>
<li>
<p><code>os</code>：封装NT/Posix系统底层接口（部分是跨平台通用接口）；</p>
<blockquote>
<p><code>sys</code>模块主要封装Python程序的运行环境，非系统接口；</p>
</blockquote>
</li>
<li>
<p><code>socket</code>：封装系统底层的套接字通信接口；</p>
</li>
<li>
<p><code>fcntl</code>：封装Unix的<code>fcntl</code>和<code>ioctl</code>接口；</p>
</li>
<li>
<p><code>multiprocessing</code>和<code>subprocess</code>：对多进程接口的高层封装；</p>
</li>
<li>
<p><code>psutil</code>：<em>process and system utilities</em>，封装了系统监控功能（==非内置库==）；</p>
</li>
</ul>
<h2 id="运行环境-2"><a class="header" href="#运行环境-2">运行环境</a></h2>
<h3 id="硬件信息"><a class="header" href="#硬件信息">硬件信息</a></h3>
<h5 id="cpu"><a class="header" href="#cpu">CPU</a></h5>
<p>获取CPU数量：</p>
<pre><code class="language-python">os.cpu_count()
psutil.cpu_count() # CPU逻辑数量
multiprocessing.cpu_count()
</code></pre>
<p>统计CPU的用户/系统/空闲时间：</p>
<pre><code class="language-python">psutil.cpu_times()
</code></pre>
<h5 id="内存"><a class="header" href="#内存">内存</a></h5>
<p>获取内存容量：</p>
<pre><code class="language-python">vmem = psutil.virtual_memory() # return total, available, percent, used, free,...
swap = psutil.swap_memory()
</code></pre>
<h5 id="磁盘"><a class="header" href="#磁盘">磁盘</a></h5>
<pre><code class="language-python">psutil.disk_partition()
psutil.disk_usage('/')   # total, used, free, percent
psutil.disk_io_counters()
</code></pre>
<h5 id="网络"><a class="header" href="#网络">网络</a></h5>
<pre><code class="language-python">psutil.net_io_counters()  # 获取网络读写字节／包的个数
psutil.net_if_addrs()     # 获取网络接口信息
psutil.net_if_stats()     # 获取网络接口状态
psutil.net_connections()  # 获取网络连接信息
</code></pre>
<h3 id="用户信息"><a class="header" href="#用户信息">用户信息</a></h3>
<h5 id="用户家目录"><a class="header" href="#用户家目录">用户家目录</a></h5>
<p>路径字符串中的<code>&quot;~&quot;</code>不会像Shell自动替换为用户家目录路径。</p>
<pre><code class="language-python">from pathlib import Path			# python 3.5+
home = str(Path.home())
realpath = os.path.expanduser(&quot;~/subpath&quot;)
</code></pre>
<h3 id="python运行环境"><a class="header" href="#python运行环境">Python运行环境</a></h3>
<p><code>sys.path</code>：Python库的<a href="Python/./Python%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80.html#%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83">搜索路径</a>构成的序列；</p>
<blockquote>
<p>使用<code>python -m site|sysconfig</code>可输出路径等信息。</p>
</blockquote>
<p><code>sys.modules</code> 是一个字典对象，表示程序当前已加载的模块信息(包括模块所在路径）。</p>
<p><code>sys.version_info</code>：Python版本信息（<code>major, minor, micro</code>）。</p>
<p><code>sys.args</code>：<a href="Python/Python%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80.html#%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0%E5%A4%84%E7%90%86">命令行参数</a>。</p>
<h5 id="系统信息"><a class="header" href="#系统信息">系统信息</a></h5>
<pre><code class="language-python">os.uname()   
# posix.uname_result(sysname='Linux', nodename='WS-GARY', release='5.4.72-microsoft-standard-WSL2', version='#1 SMP Wed Oct 28 23:40:43 UTC 2020', machine='x86_64')
</code></pre>
<blockquote>
<p>封装系统<code>uname</code>方法并将输出信息抽取到多个字段中。</p>
</blockquote>
<p><code>sys.platform</code> ：获取操作系统平台，包括<code>win32</code>，<code>linux</code>。</p>
<h5 id="系统环境变量"><a class="header" href="#系统环境变量">系统环境变量</a></h5>
<p><code>os.environ</code>：环境变量字典。</p>
<pre><code class="language-python">os.getenv('USER')        # os.environ['USER'] -&gt; os.path.expanduser
os.path.expandvars(path) # 展开字符串中环境变量，未知变量不会被展开
</code></pre>
<blockquote>
<p>Windows下的用户名变量为<code>USERNAME </code>。</p>
</blockquote>
<h5 id="工作目录"><a class="header" href="#工作目录">工作目录</a></h5>
<p><code>os.getcwd()</code>：直接返回工作目录的绝对路径；<code>os.curdir</code>是当前目录的相对[路径标识](# 跨平台路径标识)。</p>
<p><code>os.chdir(path)</code>：切换工作目录。</p>
<h2 id="文件系统"><a class="header" href="#文件系统">文件系统</a></h2>
<h3 id="路径"><a class="header" href="#路径">路径</a></h3>
<pre><code class="language-python">import os.path as path
p=path.dirname()
p=path.basename()
p = path.abspath(p)  # 绝对路径 (=&gt;realpath)
p = path.relpath(p)  # 相对路径
tf = path.isabs()    # 检查是否为绝对路径
</code></pre>
<p>拼接路径：</p>
<pre><code class="language-python">path.join(parent, child)
</code></pre>
<blockquote>
<p>如果<code>parent</code>为空，则结果为<code>child</code>；如果<code>parent='.'</code>，则结果为<code>./child</code>。</p>
<p>如果<code>parent</code>于<code>child</code>之间没有路径分隔符，则添加路径分隔符。</p>
</blockquote>
<h5 id="跨平台路径标识"><a class="header" href="#跨平台路径标识">跨平台路径标识</a></h5>
<p><code>os.curdir</code>：当前路径标识，即<code>.</code>；使用<code>path.abspath</code>返回当前路径的绝对路径；</p>
<p><code>os.pardir</code>：父路径标识，即<code>..</code>；</p>
<p><code>os.sep</code>：路径分隔符，Linux中为<code>/</code>，Windows中为<code>\\</code>；</p>
<p><code>os.pathsep</code>：环境变量分隔符，Linux中为<code>:</code>，Windows中为<code>;</code>；</p>
<p><code>os.linesep</code>：换行符，Linux为<code>\n</code>，Windows为<code>\r\n</code>；输出换行符时总是使用<code>\n</code>，底层会根据系统自动转换。</p>
<p><code>os.devnull</code>：Linux为<code>/dev/null</code>；Windows为<code>nul</code>。</p>
<h3 id="检查文件文件夹"><a class="header" href="#检查文件文件夹">检查文件/文件夹</a></h3>
<pre><code class="language-python">from os import path
tf = path.isfile(filename)		# test regular file
tf = path.isdir(dirname)		  # test existing dir
tf = path.islink(filename)    # test symbolic link
tf = path.exists(filename)	
tf = path.ismount(path)       # test mount point(or driver/share root)
</code></pre>
<blockquote>
<p><code>isdir</code>等效于<code>exists and not isfile</code>。</p>
</blockquote>
<blockquote>
<p><code>pathlib</code>将路径封装为<code>Path</code>对象。</p>
<pre><code class="language-python">import pathlib
my_file = pathlib.Path(&quot;/path/to/file&quot;)
tf = my_file.is_file()
tf = my_file.is_dir()
tf = my_file.exists()
</code></pre>
</blockquote>
<h4 id="文件信息"><a class="header" href="#文件信息">文件信息</a></h4>
<pre><code class="language-python">s = path.getsize(filename)    # get file size
</code></pre>
<h3 id="管理文件夹"><a class="header" href="#管理文件夹">管理文件夹</a></h3>
<h5 id="创建文件夹"><a class="header" href="#创建文件夹">创建文件夹</a></h5>
<pre><code class="language-python">os.mkdir(dir_path)                    # 父目录必须存在
os.makedirs(dir_path, exist_ok=False) # 父目录不存在则创建父目录，exist_ok防止抛出异常
</code></pre>
<h5 id="删除文件夹"><a class="header" href="#删除文件夹">删除文件夹</a></h5>
<p><code>os.rmdir(path)</code>：仅当这文件夹是空的才可以，否则抛出<code>OSError</code>。</p>
<p><code>os.removedirs(path)</code>：删除文件夹树（同样也只能删除空目录）。</p>
<p><code>shutil.rmtree(path, ignore_errors=True)</code>：==可删除非空目录==。</p>
<h5 id="列举文件夹内容"><a class="header" href="#列举文件夹内容">列举文件夹内容</a></h5>
<p>列出文件夹中所有内容的名称，不保证文件的列举顺序（对返回列表进行排序）。</p>
<pre><code class="language-python">contents = [f for f in os.listdir(dirname)]
files = [for f in contents if path.isfile(path.join(dirname, f))]
</code></pre>
<blockquote>
<p><code>os.listdir</code>返回内容仅包含名称(<code>basename</code>)，==不包含路径==。</p>
</blockquote>
<p>递归遍历目录：</p>
<pre><code class="language-python">for dirpath, dirnames, filenames in os.walk():
   for d in dirnames:
      print(os.path.join(dirname, d))
   for f in filenames:
      print(os.path.join(dirname, f))
</code></pre>
<blockquote>
<p><code>dirpath</code>是当前遍历的目录路径；<code>dirnames</code>为当前目录下子目录的集合（不包括<code>.</code>和<code>..</code>）；<code>filenames</code>为当前目录下文件的集合。</p>
</blockquote>
<h3 id="管理文件"><a class="header" href="#管理文件">管理文件</a></h3>
<p><code>rename</code>重命名文件</p>
<p><code>remove</code>删除文件</p>
<pre><code class="language-python">os.remove(filepath)
</code></pre>
<p>移动/复制文件：</p>
<pre><code class="language-python">shutil.copyfile(src, dst) # only file
shutil.copy(src, dst)  # dst can be a folder; use shutil.copy2() to preserve timestamp
shutil.move(src, dst)  # 内部使用copy2进行复制
</code></pre>
<h3 id="文件权限"><a class="header" href="#文件权限">文件权限</a></h3>
<p><code>os.chmod(path,mode)</code></p>
<p><code>os.chown(path,mode)</code></p>
<p><code>os.access(path,mode)</code>：使用<code>real uid/gid </code>测试文件是否具有访问权限（<code>mode=os.F_OK</code>测试文件存在；<code>R_OK|W_OK|X_OK</code>测试文件的读写执行权限）；</p>
<h3 id="监控文件系统变化"><a class="header" href="#监控文件系统变化">监控文件系统变化</a></h3>
<p>使用<code>watchdog</code>模块可对文件系统变化进行监控并执行相应处理。</p>
<pre><code class="language-python">class MyEventHandler(watchdog.events.FileEventHandler): 
   def on_any_event(self, event: FileSystemEvent):
      pass
event_handler = MyEventHandler()
observer = watchdog.observers.Observer()
observer.schedule(event_handler, path, recursive=True)
observer.start()
try:
   while True:
      time.sleep(3)
finally:
   observer.stop()
   observer.join()
</code></pre>
<h2 id="输入输出-1"><a class="header" href="#输入输出-1">输入输出</a></h2>
<h3 id="文件描述符"><a class="header" href="#文件描述符">文件描述符</a></h3>
<p><code>os.open(file, flags, mode)</code>：底层<code>open</code>函数；</p>
<p><code>os.close(fd)</code>：</p>
<p><code>os.dup2()</code>方法用于将一个文件描述符复制到另一个文件描述符（必要时先关闭后一个文件描述符）。</p>
<pre><code class="language-python">os.dup2(se.fileno(), sys.stderr.fileno())
</code></pre>
<h3 id="标准输入输出-1"><a class="header" href="#标准输入输出-1">标准输入输出</a></h3>
<p><code>sys.stdout/stdin/stderr</code> 分别表示标准输入、输出和错误输出的文件对象。</p>
<ul>
<li><code>stdin.readline()</code> 从标准输入读一行；</li>
<li><code>stdout.write(&quot;a&quot;)</code> 屏幕输出；</li>
</ul>
<h4 id="日志-2"><a class="header" href="#日志-2">日志</a></h4>
<p><a href="https://www.jianshu.com/p/abb6148c15b4">Python syslog 浅谈</a>。</p>
<h3 id="套接字接口"><a class="header" href="#套接字接口">套接字接口</a></h3>
<pre><code class="language-python">s = socket.socket(family=AF_INET, type=SOCK_STREAM, proto=0)
s = socket.create_connection(...)   # =&gt; s.connect()
s = socket.create_server(...)
socket.close(s)  # s.close()
</code></pre>
<h5 id="socket对象"><a class="header" href="#socket对象">socket对象</a></h5>
<pre><code class="language-python">conn = s.accept()
s.bind(address)
s.listen(address)
s.connect(address)
s.fileno()  # for select()
s.recv/recvfrom/recvmsg/recv_into/recvmsg_into/recvfrom_into()
s.send/sendall/sendto/sendmsg/sendfile(...)
s.shutdown()
s.close()
</code></pre>
<h3 id="io多路复用"><a class="header" href="#io多路复用">IO多路复用</a></h3>
<p>Python <code>select</code>库封装了<a href="Python/../Linux/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.html#IO%E5%A4%8D%E7%94%A8%E6%8E%A5%E5%8F%A3">LinuxIO多路复用接口</a>，使用<code>select</code>、<code>poll</code>和<code>epoll</code>方法来监听文件描述符状态。</p>
<h5 id="select"><a class="header" href="#select">select</a></h5>
<p><code>select</code>方法返回就绪的每类文件描述符，用户需要对描述符的状态进行查询（<code>sock_poll</code>）。</p>
<pre><code class="language-python">r,w,x = select.select(rlist, wlist, xlist, timeout=None, /)
</code></pre>
<blockquote>
<p><code>Windows</code>仅支持<code>select</code>方法监听<code>socket</code>。</p>
</blockquote>
<p><code>rlist</code>：读取准备就绪的文件描述符列表；</p>
<blockquote>
<p>文件描述符是<code>socket</code>、文件对象或文件对象的<code>fileno()</code>方法返回的整数值。</p>
</blockquote>
<p><code>wlist</code>：写入准备就绪的文件描述符列表；</p>
<p>三类文件描述符中不需要监听的将对应参数设置为空列表（<code>[]</code>）。</p>
<h5 id="epoll"><a class="header" href="#epoll">epoll</a></h5>
<p>使用<code>epoll</code>的程序通常会执行以下步骤：</p>
<ol>
<li>
<p>创建一个<code>epoll</code>类型对象<code>epl</code></p>
</li>
<li>
<p>让对象监听指定文件描述符上的上的指定事件</p>
<pre><code class="language-python">epl.register(fd, select.EPOLLIN)
</code></pre>
</li>
<li>
<p>轮询所有监听的文件描述符</p>
<pre><code class="language-python">events = epl.poll(timeout=None, maxevents=-1)
</code></pre>
<blockquote>
<p><code>timeout=None</code>则等待直到其中某个文件发生监听事件，<code>maxevents</code>表示最大返回事件数，默认无限制。</p>
</blockquote>
</li>
<li>
<p>基于轮询结果确定发生事件的文件及其对应的事件，从而执行相应的文件读写操作，然后修改相关文件的监听状态</p>
</li>
<li>
<p>重复上述过程，直到程序推出前销毁<code>epoll</code>对象。</p>
</li>
</ol>
<p>以下给出了使用套接字的示例：</p>
<pre><code class="language-python">import select 
EOF = b'\n\r\n'   # End of Request
epl = select.epoll()       #: 创建一个epoll对象
epl.register(serversocket.fileno(), select.EPOLLIN) # 注册socket读事件
while True:
  events = epl.poll(0.1)  # 等待0.1s进行轮询
  for fn, event in events:
    if fn == serversocket.fileno(): # accept new connection
      connection, address = socket.accept()
      connection.setblocking(0)   # 将新的socket设为非阻塞并注册读事件
      epl.register(connection.fileno(), select.EPOLLIN)
      # 记录连接对象和文件描述符的映射
      connections[connection.fileno()] = connection # dict
    elif event &amp; select.EPOLLIN:
      # 对发生读事件的socket读取数据
      requests[fn] += connections[fn].recv(1024)
      if EOR in requests[fn]:
        print(requests[fn]) # 处理客户请求
        # 注册写事件（EPOLLOUT），响应客户端请求；
        # 如果用户还有后续输入，则使用epl.register()
        epl.register(fn, select.EPOLLOUT)
        # 反之将注册时间修改为EPOLLOUT
        eplmodify(fn, select.EPOLLOUT)         
    elif event &amp; select.EPOLLOUT:
      # 当套接字准备好发送新数据（可能之前有数据还未发送完成需要等待）
      # 每次向客户端发送一定长度的响应内容，每次都更新余下待发送的响应内容
      byteswritten = connections[fn].send(responses[fn])
      responses[fn] = responses[fn][byteswritten:]
      if len(responses[fn]) == 0:
        epl.modify(fn, 0)  # 单次响应：完成服务，不再监听事件，关闭连接
        close_connection(fn, socket.SHUT_RDWR);
        # 如果是多次响应的服务，则使用epl.unregister()暂时取消输出就绪查询,
        # 直到再次接收到数据或用户发送EOF指令或用户断开连接。
        if requests[fn].endswith(EOF): 
          close_connection(fn, socket.SHUT_RDWR)
        else: 
          el.unregister(fn, select.EPOLLOUT)
    elif event &amp; select.EPOLLHUP: # HUP（挂起）表明客户端断开了连接
      epl.unregister(fn)
      close_connection(fn)
epl.unregister(serversocket.fileno())
epl.close()
serversocket.close()
</code></pre>
<p>当一个连接中由多个请求需要处理时，需要在输入流中添加分隔各请求的序列<code>EOF</code>（例如非文本的特殊字符<code>\n\r\n</code>）；从而在服务器接收信息后检查请求接收完成并注册<code>EPOLLOUT</code>事件进行响应输出。<code>EOF</code>不应在请求内容中出现。</p>
<blockquote>
<p>等待输出准备完成：当并发数量较大时，多个输出Sockets将共享网络输出，使得输出数据消耗较慢，一个Sockets在完成输出并就绪之前可能收到新的输出请求，此时该Sockets将等待输出准备完成。</p>
<pre><code class="language-python">def close_connection(fn, socket_opt=None):  # 服务端关闭连接，释放资源
  if socket_opt is socket.SHUT_RDWR:
      connections[fn].shutdown(socket.SHUT_RDWR)
     else:
      connections[fn].close(socket_opt)
     del connections[fn], recv_buffer[fn], send_buffer[fn]
</code></pre>
</blockquote>
<p><strong>Edge Triggered</strong>只在文件状态变化时通知应用。</p>
<p>管道IO：假设需要从输入流<code>fd_read</code>读取数据并写入输出流<code>fd_write</code>，其中一个没准备好都不能完成读写。如果使用LT模式（Level Triggered），则在两者全部准备好之前会持续收到其中已准备好的文件的通知，从而浪费资源。在ET（Edge Triggered）模式下，在收到某个文件准备好的通知时，记录其状态，当所有相关文件状态都就绪时，进行读写操作直到返回<code>EAGAIN</code>，然后重置状态进入下一次读写准备阶段。</p>
<p><a href="https://www.cnblogs.com/anker/p/3265058.html">select、poll、epoll之间的区别总结 - Rabbit_Dale - 博客园 (cnblogs.com)</a>。</p>
<h3 id="非阻塞io"><a class="header" href="#非阻塞io">非阻塞IO</a></h3>
<p>设置非阻塞IO：<code>read()</code>方法仅读取流中已有数据，并立即返回。为文件描述符添加<code>os.O_NONBLOCK</code>标识。</p>
<pre><code class="language-python">import fcntl
old_flags = fcntl.fcntl(f.fileno(), fcntl.F_GETFL)
fcntl.fcntl(f.fileno(), fcntl.F_SETFL, old_flags | os.O_NONBLOCK)
</code></pre>
<blockquote>
<p><code>fcntl</code>仅支持Linux。Windows上仅支持套接字的非阻塞模式（系统调用<code>socket.ioctl(control, option)</code>）。</p>
</blockquote>
<p>非阻塞方式通常与<a href="Python/Python%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B.html#IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8">IO多路复用</a>或<a href="Python/Python%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B.html#%E5%BC%82%E6%AD%A5IO">异步接口</a>结合使用，从而保证相应文件准备好读写内容。</p>
<p><code>socket.SOCK_NONBLOCK=&gt;s.setblocking(False)=&gt;s.settimeout(0.0)</code></p>
<h2 id="多任务执行"><a class="header" href="#多任务执行">多任务执行</a></h2>
<p>多线程共享代码、内存数据，用于<strong>输入输出密集型</strong>（<em>IO-bound</em>）任务并行；多进程具有独立的代码、内存空间，用于<strong>计算密集型</strong>（<em>CPU-bound</em>）任务的并行。</p>
<h3 id="线程"><a class="header" href="#线程">线程</a></h3>
<p><code>threading</code>将线程封装为<code>threading.Thread</code>类。</p>
<pre><code class="language-python">th = threading.Thread(traget=func_my_thread, args=(args,))
class myThread(threading.Thread):  # 支持继承`threading.Thread`类：
  def __init__(self, target, *args, **kwargs):
    threading.Thread.__init__(self, target, *args, **kwargs)
    # do customized init
    pass
 	def run(self):
    # thread code
    pass
th = myThread(args) # 创建线程
</code></pre>
<p>CPython（Python解释器）设置了<a href="http://cenalulu.github.io/python/gil-in-python/">全局解释器锁GIL(Global Interpreter Lock )</a>，导致多线程中仅有一个线程获取到互斥锁，因此==无法实现真正地多线程并行执行。但多线程能够切换，因此能应用于I/O密集型任务避免IO阻塞==。基于C扩展的模块，例如<code>numpy</code>、<code>pandas</code>在调用内部C代码时不受GIL限制，因此能够实现并行。</p>
<blockquote>
<p><code>thread</code>提供了低级别的、原始的线程以及一个简单的锁。<code>thread</code>模块已被废弃。用户可以使用<code>threading</code>模块代替。为了兼容性，Python3将 <code>thread</code>重命名为&quot;<code>_thread</code>&quot;。</p>
<pre><code class="language-python">import _thread as thread
thread.start_new_thread(func_thread, args)
</code></pre>
</blockquote>
<h5 id="线程信息"><a class="header" href="#线程信息">线程信息</a></h5>
<p><code>threading.currentThread()</code>：返回当前的线程变量（同<code>current_thread()</code>）。</p>
<p><code>threading.main_thread()</code>：返回主线程信息。</p>
<p><code>threading.enumerate()</code>：返回当前进程包含正在运行的线程的列表。</p>
<p><code>threading.active_count()</code>：活动线程数量（<code>activeCount</code>）。</p>
<p><code>th.setName(name)</code>：设置线程名。<code>th.getName()</code>获取线程名。</p>
<blockquote>
<p><code>th.name</code>。</p>
<p><code>th.ident</code>：线程ID；<code>th.native_id</code>：内核返回的线程编号，与<code>ident</code>不同。</p>
<p><code>th.daemon</code>：是否为守护线程（<code>th.isDaemon()</code>，仅当守护线程退出时整个程序才完全退出），新线程继承父线程的守护属性（默认为<code>False</code>）。</p>
</blockquote>
<h4 id="线程调度"><a class="header" href="#线程调度">线程调度</a></h4>
<pre><code class="language-python">th.start()     # 启动线程
th.join(time)  # 等待线程结束或超时
</code></pre>
<blockquote>
<p>根据<code>th.is_alive()</code>判断线程是否已结束运行或超时。</p>
</blockquote>
<p>可在全局空间中声明一个对应线程的停止标识，当目标线程检测到该标识后，主动退出（从线程函数返回），而非从其他线程<a href="https://www.geeksforgeeks.org/python-different-ways-to-kill-a-thread/">强制停止该线程</a>。</p>
<blockquote>
<p>强制停止线程可能导致线程申请的资源未正确释放。</p>
</blockquote>
<h4 id="线程同步"><a class="header" href="#线程同步">线程同步</a></h4>
<h5 id="互斥锁"><a class="header" href="#互斥锁">互斥锁</a></h5>
<p>互斥锁变量可作为全局变量或作为参数传递给线程，多个线程可尝试申请互斥锁的使用权避免共享资源竞争。</p>
<pre><code class="language-python">lock = threading.Lock()
lock.aqcuire()
lock.release()
</code></pre>
<p>参考<a href="Python/Python%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B.html#%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5">进程同步原语</a>。</p>
<p>Python的<code>queue</code>模块中提供了同步的、线程安全的队列类，包括<code>Queue</code>（FIFO)，<code>LifoQueue</code>（LIFO），和优先级队列 <code>PriorityQueue</code>。这些队列都实现了锁原语，能够在多线程中直接使用，可以使用队列来实现线程间的同步。</p>
<p>https://harveyqing.gitbooks.io/python-read-and-write/content/python_advance/python_thread_sync.html</p>
<h3 id="创建进程"><a class="header" href="#创建进程">创建进程</a></h3>
<p>在Unix系统中，创建进程包括两种方式：</p>
<ul>
<li>复制进程并共享代码空间，子进程与父进程执行不同的代码块；</li>
<li>替换（复制）进程，子进程执行其他文件内容。</li>
</ul>
<p>Python提供上述两种方式的系统接口封装，并提供了抽象的类型封装。父进程可选择阻塞等待子进程执行结束或启动子进程后立即返回。</p>
<h4 id="系统接口"><a class="header" href="#系统接口">系统接口</a></h4>
<p><a href="Python/../Linux/Unix%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B.html#%E5%88%9B%E5%BB%BA%E8%BF%9B%E7%A8%8B"><code>os.fork()</code></a>复制当前进程创建新进程（Unix-Only）。</p>
<p><code>os.system()</code>封装了标准C函数<code>system()</code>，启动一个shell环境（子进程）执行命令，并返回命令的完成状态。命令的输出将合并到当前进程。</p>
<pre><code class="language-python">n = os.system('ls -l /home/user')  
# &gt;&gt;&gt; sh -c ls -l /home/user  # -c read argumments as commands
</code></pre>
<blockquote>
<p>Python封装了许多系统程序接口（<code>os</code>库），可直接访问这些Python接口函数，而无需使用<code>system()</code>函数调用shell命令。</p>
</blockquote>
<p><a href="https://docs.python.org/3/library/os.html#inheritance-of-file-descriptors">Inheritance of File Descriptors os — Miscellaneous operating system interfaces — Python 3.9.5 documentation</a></p>
<h5 id="进程信息和控制接口"><a class="header" href="#进程信息和控制接口">进程信息和控制接口</a></h5>
<pre><code class="language-python">os.getpid()
os.getppid()
os.kill(pid, signal.SIGTERM)
</code></pre>
<pre><code class="language-python">(repid, status) = os.waitpid(pid, options=0)    # 等待任意一个子进程结束
(repid, status) = os.wait()      # 等待任意一个子进程结束
(repid, status, resinfo) = os.wait3()
(repid, status, resinfo) = os.wait4(pid,options)
siginfo = os.waitid(os.P_PID|os.P_PGID|os.P_ALL, id, options) 
</code></pre>
<blockquote>
<p>如果<code>pid=0</code>，获取当前进程所在进程组的任意子进程的状态；如果<code>pid=-1</code>，则等效于<code>wait()</code>；*如果<code>pid&lt;-1</code>，则获取进程组<code>|pid|</code>中任意进程的状态（可能应该是当前进程所在进程组）。*在Windows上<code>pid</code>只能是正数，且不需要是一个子进程。</p>
</blockquote>
<p><code>options</code>：<code>os.WNOHANG</code>（Unix）：立即返回，如果没有子进程终止，则返回<code>(0,0)</code>；</p>
<p><code>status</code>：16位整数，低字节为终止进程的信号，高字节为返回值（信号为0）。如果产生core dump，则信号字节的最高位被设置（<code>waitstatus_to_exitcode()</code>）。</p>
<p>通过<code>psutil</code>可以获取到所有进程的详细信息：</p>
<pre><code class="language-python">psutil.pids()
psutil.test()              # 模拟shell的ps命令
p = psutil.Process(3776)   # 获取指定进程ID=3776的信息
</code></pre>
<p>通过<code>psutil.Process</code>可访问进程相关的信息。</p>
<h4 id="共享代码的进程类型"><a class="header" href="#共享代码的进程类型">共享代码的进程类型</a></h4>
<p><code>multiprocessing</code>库提供<code>Process</code>类创建子进程并运行指定代码（使用<code>Pool</code>创建<a href="Python/Python%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B.html#%E8%BF%9B%E7%A8%8B%E6%B1%A0">进程池</a>）。</p>
<pre><code class="language-python">p = Process(target=func, name='ProcName', args=(), kwargs={}, daemon=None)
p.start()   # 启动进程
p.join()    # 等待并清理进程
</code></pre>
<p>调用<code>p.start()</code>启动子进程，子进程的运行函数为<code>p.run()</code>，其默认调用初始化的<code>target()</code>。父进程记录子进程信息后从<code>start()</code>方法返回（<strong>非阻塞模式</strong>）。</p>
<blockquote>
<p>可继承<code>Process</code>并重载<code> Process.run()</code>方法，添加子进程初始化以及清理代码。</p>
</blockquote>
<p><strong>阻塞模式</strong>：父进程在启动子进程后可调用<code>p.join()</code>阻塞等待子进程结束。</p>
<blockquote>
<p>使用<code>Process</code>创建的进程在子进程退出前不会主动退出（等效于退出前调用了<code>join()</code>）。==如果子进程是不会退出的服务，则主进程会阻塞而无法结束。==</p>
</blockquote>
<h5 id="进程启动方法"><a class="header" href="#进程启动方法">进程启动方法</a></h5>
<pre><code class="language-python">import multiprocessing as mp
if __name__ == '__main__':
	mp.set_start_method('spawn')   # 在main中设置默认进程创建方法，不能调用多次
   mp.set_executable(PYTHON_PATH) # 设置运行子进程的Python解释器路径
</code></pre>
<ul>
<li>
<p><code>spawn</code>：父进程启动一个<strong>全新的Python解释器进程</strong>。子进程只会继承那些运行进程对象的 <a href="https://docs.python.org/zh-cn/3/library/multiprocessing.html#multiprocessing.Process.run"><code>run()</code></a> 方法所需的资源，不必要的文件描述符等不会从父进程继承。使用此方法相对其他两种方法较慢但最可靠，Windows的默认设置。</p>
</li>
<li>
<p><code>fork</code>：使用<code>os.fork()</code>复制Python解释器，因此子进程启动时与父进程相同，父进程的所有资源都由子进程继承。Unix中的默认值（仅UNIX可用）。==为了减少进程创建开销，应该使父进程尽量轻量，即避免在父进程中创建不必要的资源==。</p>
<blockquote>
<p>避免对具有多线程的进程执行复制操作，<code>fork</code>系统调用是面向单线程进程的，只有地址空间被复制，线程不能被继承。</p>
</blockquote>
</li>
<li>
<p><code>forkserver</code>：首先启动一个轻量的<code>server</code>进程（通过<code>spawn</code>方法创建），当需要创建进程时，复制<code>server</code>进程而不是当前进程。可在Unix平台上使用。<em>使用<code>context.set_forkserver_preload([modules])</code>为<code>server</code>进程<a href="http://www.bnikolic.co.uk/blog/python/parallelism/2019/11/13/python-forkserver-preload.html">预加载部分模块</a>（<code>modules</code>将会在主进程和<code>server</code>进程分别被导入一次，后续复制<code>server</code>进程是直接复制内存空间所以不会再加载模块）。</em></p>
<blockquote>
<p><code>server</code>进程为单线程，因此使用<code>os.fork()</code>时是安全的。</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>在<code>Unix</code>上使用<code>spawn</code>或<code>forkserver</code>方法还会启动一个资源追踪进程（resource tracker process），以追踪由进程创建的未连接的命名系统资源（例如命名信号量或共享内存对象）。当所有进程退出后，该追踪进程释放追踪的资源对象。如果一个进程被信号终止而未及时释放上述资源，可能导致资源泄漏。</p>
</blockquote>
<p>可以在同一个程序中建立多个上下文（Context），以使用不同的进程启动方法。<code>get_context()</code>返回<code>Context</code>对象并提供与<code>multiprocessing</code>模块相同的接口。</p>
<pre><code class="language-python">ctx = mp.get_context('spawn')
q = ctx.Queue()
p = ctx.Process(target=foo, args=(q,))
p.start()
</code></pre>
<ol>
<li>Python forkserver and set_forkserver_preload()：http://www.bnikolic.co.uk/blog/python/parallelism/2019/11/13/python-forkserver-preload.html</li>
</ol>
<h5 id="进程属性"><a class="header" href="#进程属性">进程属性</a></h5>
<ul>
<li>
<p><code>ident</code>和<code>pid</code>：进程ID。</p>
</li>
<li>
<p><code>authkey</code>：当<code>multiprocessing</code>初始化时，主进程被分配的一个随机字符串；当进程被创建时继承父进程的<code>authkey</code>（可以手动修改该字符串）；</p>
</li>
<li>
<p><code>Process.name</code></p>
</li>
<li>
<p><code>Process.exitcode</code>：进程退出代码；</p>
</li>
<li>
<p><code>Process.daemon</code>：必须在调用<code>start()</code>前设置（该值继承自父进程，并可以通过构造函数设置）。<strong>注意</strong>：<code>daemon=True</code>的进程不是UNIX守护程序或服务，其不再被允许创建子进程，父进程退出前会主动结束并清理此类进程。</p>
</li>
<li>
<p><code>mp.current_process()</code>：返回当前进程。</p>
</li>
<li>
<p><code>mp.active_children()</code>：返回活动子进程列表。</p>
</li>
<li>
<p><code>mp.parent_process()</code>：获取父进程。</p>
</li>
<li>
<p><code>is_alive()</code>：进程是否存活；</p>
</li>
</ul>
<blockquote>
<p><code>start</code>, <code>join</code>, <code>is_alive</code>, <code>terminate</code>和<code>exitcode</code>仅应该再父进程中被调用。</p>
</blockquote>
<h5 id="进程控制"><a class="header" href="#进程控制">进程控制</a></h5>
<ul>
<li><code>terminate()</code>：中止进程，发送<code>SIGTERM</code>信号（Linux）或使用<code>TerminateProcess()</code>（Windows）；进程立即退出，不会调用退出处理程序和<code>finally</code>语句块。<code>kill()</code>与<code>terminate()</code>一样，但发送<code>SIGKILL</code>信号；</li>
</ul>
<p><code>p.join(timeout=None)</code>：<strong>合并</strong>子进程并清理子进程资源；</p>
<blockquote>
<p>进程不能在自己的进程中调用<code>join</code>（会形成死锁，不允许这样调用会产生错误）；</p>
<p><code>join()</code>不会返回进程退出状态，检查<code>exitcode</code>确定子进程的退出状态；</p>
<p>已结束但还未合并的进程变为僵尸进程。每次新建子进程，调用<code>active_children()</code>或调用已完成进程的<code>is_alive()</code>方法时，所有已完成的子进程会被自动清理；仍然建议尽可能手动合并子进程。</p>
<p>==如果父进程可能先于子进程退出，则应该在父进程中调用<code>join()</code>等待子进程退出，防止子进程变成僵尸进程后不会再被合并==。当一个子进程需要持续运行时，父进程调用<code>join()</code>来合并该子进程会导致阻塞而无法继续工作，令<code>daemon=True</code>可自动在主进程结束前尝试结束所有<code>daemonic</code>子进程防止其变为僵尸进程。</p>
</blockquote>
<h4 id="执行文件的进程类型"><a class="header" href="#执行文件的进程类型">执行文件的进程类型</a></h4>
<p><code> subprocess</code>库提供方法在子进程中运行文件，用于替代<code>os.system(), os.spawn*()</code>。最常用的模式为接口为<code>run()</code>：给定执行命令与参数，在给定时间内等待子进程执行完成并获取其输出内容和返回值。（<strong>如果子进程需要脱离前台进程运行</strong>，则需要调用<code>Popen()</code>方法自定义与子进程的交互过程）。</p>
<blockquote>
<p><code>run()</code>等效于调用<code>Popen()</code>、<code>communicate()</code>和<code>wait()</code>。</p>
<ul>
<li><code>timeout</code>，<code>input</code>传递给<code>communicate()</code>；</li>
<li><code>check</code>, 和<code>capture_output</code>外，其他参数都传递给<code>Popen()</code> 。</li>
</ul>
</blockquote>
<pre><code class="language-python">import subprocess as sp
sp.run(args, *,               
       input=None,            # True =&gt; stdin=sp.PIPE
       capture_output=False,  # True =&gt; stdout=sp.PIPE, stderr=sp.PIPE
       timeout=None,
       check=False,           # True =&gt; can raiseCalledProcessError
       stdin,sdtout,stderr,
       shell=False, 
       cwd=None
       text,                  # True =&gt; 文本模式
       encoding,              # 使用文本模式并指定文本编码
       errors,
       env,                   # 环境变量字典
       **popen_kwargs) -&gt; sp.CompletedProcess # 返回进程结束状态
</code></pre>
<p><code>args</code>：命令行参数为字符串或参数序列。在Windows上，参数序列将被转换为字符串传递给<a href="Python/Python%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B.html#%E4%BD%BF%E7%94%A8Popen%E5%88%9B%E5%BB%BA%E5%AD%90%E8%BF%9B%E7%A8%8B">底层进程创建函数</a>；在Linux上，==如果为字符串则整体视为执行的命令（不含参数）；如果为参数序列，则首个参数为可执行命令，其他为该命令的参数==。</p>
<p><code>shell=True</code>：创建并使用Shell解释执行命令。在Linux上，如果传递的是参数序列，则首个参数作为Shell的命令输入（类似于命令行上输入的所有内容），<strong>其他参数作为Shell环境的参数</strong>；</p>
<blockquote>
<p>在Linux上需要设置<code>shell=True</code>的情况，</p>
<ul>
<li>需要对执行命令的Shell设置参数；</li>
<li>命令中包含非命令参数的字符，例如==通配符、管道和重定向==运算符。</li>
</ul>
<p>在Windows上，参数表示方式对执行方式没有影响。但某些命令内置于shell中（如<code>dir</code>），因此需要设置<code>shell=True</code>使用Shell来解释命令以及参数，以免产生<code>FileNotFoundError</code>。</p>
</blockquote>
<h5 id="进程间输入输出"><a class="header" href="#进程间输入输出">进程间输入输出</a></h5>
<p>默认子进程与父进程使用相同的标准输入输出流，无法捕获输出内容。可以将子进程的标准输入输出重定向到文件或者管道。</p>
<ul>
<li>管道：<code>sp.PIPE</code>表示创建一个连接到子进程的管道；
<ul>
<li><code>stdin=sp.PIPE</code>：<a href="Python/Python%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B.html#%E8%87%AA%E5%AE%9A%E4%B9%89%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E4%BA%A4%E4%BA%92%E6%B5%81%E7%A8%8B">父进程可以输入信息到子进程的标准输入</a>；</li>
<li><code>stdout=sp.PIPE</code>：父进程可以从子进程的标准输出读取信息；</li>
<li>合并标准输出和标准错误输出：<code>stdout=sp.PIPE</code>和<code>stderr=sp.STDOUT</code>；</li>
</ul>
</li>
<li><code>sp.DEVNULL</code>将输出内容丢弃。</li>
<li>其他合法的文件描述符。</li>
</ul>
<p>如果使用文本模式，则 <code>stdin</code>、<code>stdout</code>和 <code>stderr</code>传递字符串；反之为字节流模式，使用<code>bytes.decode('utf-8')</code>方法将输出的字节数组转换为字符串，以及<code>str.encode()</code>将字符串转换为输入的字节数组。</p>
<blockquote>
<p><code>Windows</code>终端默认编码是<code>GBK/GB2312</code>。</p>
</blockquote>
<p><strong>返回值</strong>：包含了命令行参数<code>args</code>（传递给<code>run()</code>方法的）、返回值<code>returncode</code>、捕获的标准/错误输出数据<code>stdout/stderr</code>（<code>capture_output=True</code>）等。</p>
<pre><code class="language-python">proc = sp.run(['ps', '-ef'], capture_output=True, text=True)
print(proc.returncode)
print(proc.stdout)
</code></pre>
<blockquote>
<p><code>os.popen()</code>由<code>sp.Popen()</code>实现，执行命令并捕获输出内容（相比于<code>sp.run()</code>，==不会返回命令的返回值==，捕获的标准输出和错误输出合并）。</p>
<pre><code class="language-python">stream = os.popen('echo ps -ef')   # 返回标准输出的错误输出的流
output = stream.read()  
for r in stream.readlines(): print(r)
</code></pre>
</blockquote>
<h5 id="使用popen创建子进程"><a class="header" href="#使用popen创建子进程">使用<code>Popen</code>创建子进程</a></h5>
<pre><code class="language-python">proc = sp.Popen(args, *, bufsize, executable, ...) -&gt; sp.Popen
</code></pre>
<blockquote>
<p>Linux上使用类似<code>os.execvp()</code>的方式创建子进程；Windows上使用<code>CreateProcess()</code>函数。</p>
<p><code>executable</code>指定命令以代替<code>args</code>中的命令（如果<code>shell=True</code>，则代替shell；原来的命令作为进程的名称）。</p>
<p>返回值封装子进程相关信息（参数、输入输出流、pid、返回值），后续调用可更新该对象。</p>
</blockquote>
<p>非阻塞执行：子进程创建后立即返回，使用<code>proc.poll()</code>查询命令执行状态（储存在<code>proc.returncode</code>），程序执行完成前返回<code>None</code>；</p>
<p>阻塞执行：调用<a href="https://docs.python.org/3/library/subprocess.html#subprocess.Popen.wait"><code>wait()</code>方法</a>等待子进程结束并清理子进程。</p>
<pre><code class="language-python">process.wait(timeout=10)  # [except TimeoutExpired] 等待和回收子进程
</code></pre>
<blockquote>
<p>子进程结束后，需要在父进程中回收资源，避免子进程成为僵尸进程，浪费系统资源。</p>
</blockquote>
<p><strong>终止进程</strong>：</p>
<pre><code class="language-python">proc.terminate()  # SIGTERM / TerminateProcess()
proc.kill()       # SIGKILL / TerminateProcess()
proc.send_signal(sig)
</code></pre>
<h5 id="自定义输入输出交互流程"><a class="header" href="#自定义输入输出交互流程">自定义输入输出交互流程</a></h5>
<p>使用<code>communicate()</code>向子进程发送数据作为输入，并从标准输出流读取数据直到流结束（子进程退出），同时也执行<code>wait()</code>的功能清理子进程。</p>
<pre><code class="language-python">try:
	outs, errs = proc.communicate(input='input content', timeout=None)
except TimeoutExpired: # 异常不会导致接收的数据丢失
  proc.kill()  # 强制终止进程
  outs, errs = proc.communicate()
</code></pre>
<blockquote>
<p>使用<code>communicate</code>的前提是子进程与父进程已经<a href="Python/Python%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B.html#%E8%BF%9B%E7%A8%8B%E9%97%B4%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA">建立管道连接</a>。</p>
<p>输入内容的类型（字节序列或字符串）与编码输入输出流的编码对应。</p>
<p>父进程从子进程读到的数据缓存在内存中，因此<code>commucate()</code>不适合与子进程交换过大的数据。</p>
</blockquote>
<p>如果子进程与父进程建立了对应的管道，那么在主进程中<code>proc.stdin</code>可写入子进程的输入流，<code>proc.stdout,proc.stderr</code>可读取子进程的输出。</p>
<blockquote>
<p><code>readlines()</code>方法将读取子进程的所有输出，直到进程结束。<code>readline</code>或<code>readlines</code>将阻塞进程，如果在终端中强制终止该方法，将导致管道损坏，无法继续读写数据。</p>
</blockquote>
<p>使用管道将两个或多个子进程的输入输出连接：</p>
<pre><code class="language-python">child1 = Popen(args1, stdout=subprocess.PIPE)  # 将子进程1的输出提供给父进程
child2 = Popen(args2, stdin=child1.stdout)     # 子进程2将子进程1的输出作为输入
</code></pre>
<p><strong>创建ssh连接进程</strong>：</p>
<p>如果输入输出缓存<code>bufsize</code>不为0，可能导致子进程不能及时接收到父进程发送的数据，可以使用<code>flush</code>强制刷新输入缓存。</p>
<p>如果要向子进程发送多次信息，并且在每次发送后获取输出，需要在父进程中将读取<code>proc.stdout</code>设置为<a href="Python/Python%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B.html#%E9%9D%9E%E9%98%BB%E5%A1%9EIO">非阻塞模式</a>，使用异步方式读取输出内容。同时，添加特殊序列<code>EOF</code>以识别响应内容结束，从而进入下一条命令的发送。</p>
<blockquote>
<p>在文本模式下(<code>encoding='UTF-8'</code>)使用特殊字符作为EOF时注意，Linux终端会将输出内容中的<code>\r</code>转换为<code>\n</code>，从而可能导致未检测到<code>EOF</code>。</p>
<p>如果子进程连续输出内容，为保证获取足够多的输出内容，可以在每次查询（<code>select</code>、<code>epoll</code>）输出是否可用前休眠一段时间。</p>
<p><strong>注意</strong>：如果使用阻塞模式读取内容，则只能每次读取1个字节，以避免在读取到<code>EOF</code>之前发生阻塞。这种方式效率太低。</p>
</blockquote>
<pre><code class="language-python">proc_ssh = subprocess.Popen([&quot;ssh&quot;, &quot;-T&quot;, &quot;gary@myserver&quot;],
                            stdin=subprocess.PIPE, 
                            stdout=subprocess.PIPE, stderr=subprocess.PIPE)
EOF = b'\r\n\r'
proc_ssh.stdin.write(b&quot;uname -a; echo -n {0}\n&quot;.format(EOF))
proc_ssh.stdin.flush()   # 刷新缓冲区，使输入立即送到子进程
# Fetch output
for line in proc_ssh.stdout:
    print(line.strip())
proc_ssh.stdin.close()   # 关闭输入将使ssh退出
proc_ssh.wait()
</code></pre>
<blockquote>
<p><code>stderr=subprocess.STDOUT</code>导致输出提示<em>Pseudo-terminal will not be allocated because stdin is not a terminal</em>。使用<code>ssh -T</code>禁用伪终端分配可消除该信息。</p>
</blockquote>
<h5 id="subprocess提供的其他方法"><a class="header" href="#subprocess提供的其他方法">subprocess提供的其他方法</a></h5>
<pre><code class="language-python">sp.call(args, *, stdin, stdout, stderr, shell)
sp.check_call()  # 退出值非0抛出异常CalledProcessError
sp.check_output() # 输出子进程的输出，退出值非0抛出异常
</code></pre>
<p><a href="https://janakiev.com/blog/python-shell-commands/">How to Execute Shell Commands with Python</a>。</p>
<h5 id="spawn"><a class="header" href="#spawn">spawn</a></h5>
<p><code>os.spawn*()</code>系列函数使用可执行文件创建<strong>新进程</strong>（<em><a href="Python/../Linux/Unix%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B.html#Copy-on-Write">fork and exec</a> on Linux</em>）。</p>
<pre><code class="language-python">pid = os.spawnl(mode, file, *args)  # see also: spawnle
os.spawnlpe(os.P_NOWAIT, 'python', 'python', 'ff.py', env)
# l: 传递可变参数列表；v: 将参数列表封装为一个序列传递
# p：使用环境变量中的PATH搜索可执行文件
# e：传递自定义环境变量（默认不传递）
</code></pre>
<p><code>mode={P_NOWAIT|P_WAIT}</code>：非阻塞模式下返回进程ID，反之返回进程的退出值。</p>
<blockquote>
<p><a href="https://docs.python.org/3/library/os.html#os.spawnvpe">需要将首个参数指定为命令名</a>。<em>In either case, the arguments to the child process must start with the name of the command being run.</em></p>
<p>无法重定向输入输出（使用subprocess）。</p>
</blockquote>
<h3 id="守护进程"><a class="header" href="#守护进程">守护进程</a></h3>
<p>使新进程脱离父进程（<code>double-fork</code>）：</p>
<pre><code class="language-python">import os
from multiprocessing import Process

def daemonize(func):
  def wrapper(*args, **kwargs):
    pid = os.fork()
    if pid == 0:
      # setsid()
      ppid = os.fork()
      if ppid == 0:
        func(*args, **kwargs)
      elif ppid &gt; 0:
        sys.exit(0)   # intermediate process exit
      else:
        warnings.warn('create daemon process error.')
    elif pid &gt; 0:  # parent process
		  if waitpid(pid) != pid:
        warnings.warn(f'wait sub-process [{pid}] error.')
    else:   # sub-process
      warnings.warn('create sub-process error.')
  return wrapper

def daemonize(func):
  def subsubproc(*args, **kwargs):
    # setsid()
    # 让first child成为session leader并与控制终端脱离，
    # 这样second child就无法再获得控制终端了（非session leader)
    proc_daemon = Process(target=func, *args, **kwargs)
    proc_daemon.start()
    # &gt;&gt;&gt; proc_temp exit here &lt;&lt;&lt;
    # &gt;&gt;&gt; proc_daemon becomes daemon (managed by init) &lt;&lt;&lt;
  def subproc(*args, **kwargs):
    proc_temp = Process(target=subsubproc, *args, **kwargs)
    proc_temp.start()
    proc_temp.join()  # waitpid，防止proc_temp成为僵尸进程
 return subproc

daemonize(f)('Async and detached!!!')

@daemonize
def func_daemon(message):
    while True:
	    time.sleep(5)
  	  log(message)
func_daemon('Async and detached!!!')  

class DaemonProcess(Process):
  def __init__(self, target=None, name=None, args=(), kwargs={}, daemon=None):
    Process.__init__(self, target=target, name=name, args=args, kwargs=kwargs)
 	def run(self):
    setsid()
    proc = Process(target=func, *args, **kwargs)
    proc.start()

</code></pre>
<h4 id="-3"><a class="header" href="#-3"></a></h4>
<p>==在守护进程中创建<code>Manager</code>，以管理共享对象==。</p>
<h3 id="进程同步"><a class="header" href="#进程同步">进程同步</a></h3>
<p>==<code>multiprocessing</code>包含来自<a href="Python/Python%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B.html#%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5"><code>threading</code></a>的所有同步原语的等价物。==<code>multiprocessing</code>具有多种锁类型，根据使用情况自行选择：</p>
<ul>
<li>
<p><a href="Python/../Linux/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.html#%E9%9D%9E%E9%80%92%E5%BD%92%E9%94%81">非递归锁</a><code>multiprocessing.synchronize.Lock</code></p>
<pre><code class="language-python">from multiprocessing import Process, Lock
def f(l, i):
    l.acquire(block=True, timeout=None)   # 防止各子进程输出内容混杂
    try:
        print('hello world', i)
    finally:
        l.release()
if __name__ == '__main__':
  lock = Lock()
  procs = [Process(target=f, args=(lock, num)) for num in range 10]
  for p in procs: 
    p.start()
  for p in procs:
    p.join()
</code></pre>
</li>
<li>
<p><a href="Python/../Linux/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.html#%E9%80%92%E5%BD%92%E9%94%81">递归锁</a>：<code>RLock()</code> ；</p>
</li>
<li>
<p>信号量：<code>Semaphore(value=1)</code> 计数器锁（信号量锁），<code>value</code>为初始计数；</p>
</li>
<li>
<p><code>BoundedSemaphore(value=1)</code> 带上限的计数器锁（信号量锁），<code>value</code>即是初始计数，同时也是允许的计数上限；</p>
</li>
<li>
<p><code>Barrier</code></p>
</li>
<li>
<p><code>Condition(lock=None)</code></p>
</li>
<li>
<p><code>Event</code></p>
</li>
</ul>
<h3 id="进程间通信"><a class="header" href="#进程间通信">进程间通信</a></h3>
<ul>
<li>避免在进程间传递大量数据。</li>
<li>尽可能使用进程间共享对象类型（例如队列或管道），避免直接使用低层次的同步原语。</li>
<li>避免调用<code>terminate()</code>方法，防止共享资源（例如锁、信号量、管道和队列）被损坏或不可用；</li>
</ul>
<h4 id="参数传递-1"><a class="header" href="#参数传递-1">参数传递</a></h4>
<p>创建进程时将需要共享的对象通过参数传递给子进程，例如<a href="Python/Python%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B.html#%E7%AE%A1%E9%81%93">管道对象</a>、<a href="Python/Python%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B.html#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><code>Queue</code>对象</a>、同步锁、信号量等。</p>
<h4 id="文件锁"><a class="header" href="#文件锁">文件锁</a></h4>
<p>锁定文件描述符：</p>
<pre><code class="language-python">fcntl.flock(fd, operation)    # man flock(2), emulated using fcntl()
fcntl.lockf(fd, cmd, len=0, start=0, whence=0)
</code></pre>
<blockquote>
<p><code>cmd=LOCK_UN, LOCK_SH, LOCK_EX</code>：分别代表解锁、共享锁和互斥锁。可以与<code>LOCK_NB</code>共同使用以避免阻塞（产生<code>OSError</code>，异常属性包括<code>EACCESS</code>或<code>EAGAIN</code>）。<code>lockf</code>可通过<code>len, start, whence</code>来控制锁定文件的部分内容。</p>
</blockquote>
<p><code>filelock</code>是一个跨平台的库。</p>
<pre><code class="language-python">from filelock import FileLock
import logging
logging.getLogger(&quot;filelock&quot;).setLevel(logging.ERROR)
with FileLock('filename.lock', timeout=10): #=&gt; with FileLock(...).acquire():
   open('filename', &quot;a&quot;).write(msg)
</code></pre>
<blockquote>
<p>==加锁文件与需要读写的文件需要分开==。加锁文件所在的目录必须存在，加锁文件不存在将自动创建。</p>
</blockquote>
<p><a href="https://pypi.org/project/pid/">pid · PyPI</a></p>
<h4 id="共享内存"><a class="header" href="#共享内存">共享内存</a></h4>
<p>可以使用 <a href="https://docs.python.org/zh-cn/3/library/multiprocessing.html#multiprocessing.Value"><code>Value</code></a> 或 <a href="https://docs.python.org/zh-cn/3/library/multiprocessing.html#multiprocessing.Array"><code>Array</code></a> 将数据存储在共享内存映射中。在调用顺序不确定的情况下，应该结合同步机制访问共享内存中的数据。</p>
<pre><code class="language-python">from multiprocessing import Process, Value, Array
def f(n, a):
  n.value = 3.1415927
  for i in range(len(a)):
    a[i] = -a[i]
if __name__ == '__main__':
    num = Value('d', 0.0)       # double type value
    arr = Array('i', range(10)) # singed integer array
    p = Process(target=f, args=(num, arr))
    p.start()
    p.join()
    print(num.value)
    print(arr[:])
</code></pre>
<h4 id="管道和消息队列"><a class="header" href="#管道和消息队列">管道和消息队列</a></h4>
<p>管道和消息队列内部实现了同步机制，因此用户无需管理同步。</p>
<h5 id="管道"><a class="header" href="#管道">管道</a></h5>
<p>管道用于连接两个进程：</p>
<pre><code class="language-python">from multiprocessing import Pipe
def f(conn):
  conn.send([42, None, 'hello'])
  conn.close()

if __name__ == '__main__':
  parent_conn, child_conn = Pipe()  # 返回Connection对象
  p = Process(target=f, args=(child_conn,)) # 将管道对端传递给子进程
  p.start()
  print(parent_conn.recv())   # prints &quot;[42, None, 'hello']&quot;
  p.join()
</code></pre>
<blockquote>
<p>管道对端连接描述符（<code>child_conn</code>）传递给子进程时会进行复制（连接计数+1），使得父进程和子进程都可以从管道对端读写数据。为了使父进程能够感知子进程已经关闭连接（或已经无数据可接收），父进程必须首先关闭管道对端。</p>
</blockquote>
<p><code>Connection</code>对象：用于传递可序列化的（<code>picklable</code>）对象或字节序列。</p>
<ul>
<li><code>conn.send(obj)</code>：</li>
<li><code>obj = conn.recv()</code>：阻塞直到有数据收到，如果对端关闭或无数据可接收，返回<code>EOFError</code>（==实际运行发现未返回错误并一直阻塞==）。</li>
<li><code>close()</code>：关闭连接（垃圾回收时自动关闭，但发送方主动关闭可让接收方感知到发送数据结束而不必持续等待）。</li>
<li><code>poll(timeout)</code>；查询是否有数据可接收。如果未指定参数则立即返回，如果<code>timeout=None</code>则持续等待。</li>
<li><code>send_bytes(buffer, offset=0, size=None)</code>：buffer类型为<a href="Python/Python%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B#%E5%AD%97%E8%8A%82%E5%BA%8F%E5%88%97%E7%B1%BB%E5%9E%8B%EF%BC%88bytes%EF%BC%89">字节序列类型</a>，例如<code>bytes</code>。</li>
<li><code>recv_bytes(maxlength=None)</code>：阻塞模式参考<code>recv</code>；</li>
<li><code>recv_bytes_into(buffer, offset=0)</code>：</li>
</ul>
<p><code>mp.connection.wait(conn_list, timeout=None)</code>：等待<code>Connection</code>、<code>socket</code>、<code>Process.sentinel</code>等对象就绪（==有数据可读，或对端已经关闭==）；如果当前进程要同时接收其他多个进程的数据，则可以使用该方法实现IO复用。</p>
<blockquote>
<p>Unix：与<code>select.select(object_list, [], [], timeout)</code>几乎相同。</p>
</blockquote>
<p><code>conn.close()</code>：关闭连接并释放资源，支持<code>with</code>语法。</p>
<h5 id="消息队列"><a class="header" href="#消息队列">消息队列</a></h5>
<p>消息队列允许连接多个进程（生产者和消费者）。</p>
<pre><code class="language-python">from multiprocessing import Queue,SimpleQueue,JoinableQueue
def f(q):
	q.put(obj, block, timeout)  # block控制阻塞，timeout控制阻塞时长
  
if __name__ == '__main__':
   q = Queue(maxsize)   # qisze(), empty(), full()
   p = Process(target=f, args=(q,))
   p.start()
   obj = q.get(block, timeout)
   print(obj)    # &quot;[42, None, 'hello']&quot;
   p.join()
</code></pre>
<blockquote>
<p><code>Queue</code>使用标准库的<code>queue.Queue</code>，并基于管道、锁和信号量。</p>
</blockquote>
<p>https://docs.python.org/3/library/multiprocessing.html?highlight=process#pipes-and-queues</p>
<h4 id="信号"><a class="header" href="#信号">信号</a></h4>
<p>信号处理函数：</p>
<pre><code class="language-python">def on_terminate(signum, frame):
   print('Terminated by signal.', file=sys.stderr)
   sys.exit(0)
   
signal.signal(signal.SIGTERM, on_terminate)
</code></pre>
<blockquote>
<p>应用程序不能处理：<code>SIGKILL</code>、<code>SIGSTOP</code>信号。</p>
<p><code>frame</code></p>
</blockquote>
<p><code>time.sleep(s)</code></p>
<h4 id="套接字连接"><a class="header" href="#套接字连接">套接字连接</a></h4>
<pre><code class="language-python">from multiprocessing.connection import Client, Listener
client_conn = Client(address, family=, authkey=)
listener = Listener(address, family=, backlog=, authkey=)
with listener.accept() as conn: # 建立连接
	conn.send(data)
   conn.recv(data)
</code></pre>
<p>地址格式：</p>
<ul>
<li>TCP/IP套接字<code>AF_INET</code>：<code>(hostname, port)</code>；</li>
<li>Unix域套接字<code>AF_UNIX</code>：文件路径名；</li>
<li>命名管道<code>AF_PIPE</code>（Windows）：<code>r'\.\pipe{PipeName}'</code>或<code>r'\ServerName\pipe{PipeName}'</code>（远程）。</li>
</ul>
<p>建立连接后与<a href="Python/Python%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B.html#%E7%AE%A1%E9%81%93">管道</a>读写数据的方法一致。*但如果<code>Listener</code>要持续接受新的连接，则可能在读取连接的数据前阻塞在<code>Listener</code>处。*此时应该使用<code>socket</code>模块提供的<a href="Python/Python%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B.html#IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8">套接字接口</a>。</p>
<h4 id="manager"><a class="header" href="#manager">Manager</a></h4>
<p><code>Manager</code>创建一个服务进程并管理共享对象，其他进程通过代理访问共享对象。</p>
<h5 id="syncmanager"><a class="header" href="#syncmanager">SyncManager</a></h5>
<p>使用<code>SyncManager</code>自动生成子进程，已经注册了常用的数据类型以及用于进程同步数据类型，因此用户可直接创建这些类型变量进行共享。如果<code>SyncManager</code>对象被垃圾回收或者父进程退出，则<code>SyncManager</code>对应的进程也随之退出。</p>
<pre><code class="language-python">from multiprocessing import Manager
manager = Manager()  # Returns a started SyncManager object
manager.shutdown()
with Manager() as manager:
  d = manager.dict()
  l = manager.list(range(10))
  p = Process(target=f, args=(d, l))  # 传递Manager管理的数据对象给子进程
  # ...
</code></pre>
<blockquote>
<p><code>SyncManager</code>不能直接传递给其他进程，而是应该传递其管理的数据（<code>Proxy</code>）。<code>SyncManager</code>没有公开的地址（内部使用Unix域套接字地址），无法通过地址远程访问（进程重新启动后无法再次访问原来的管理对象）。</p>
<p>每个进程有自己独立的<code>SyncManager</code>。</p>
</blockquote>
<p>特殊数据类型：</p>
<ul>
<li>
<p><code>Namespace</code>：在该命名空间中可创建变量，并通过空间名称引用；</p>
<pre><code class="language-python">with Manager() as manager:
  ns = manager.Namespace()
  ns.x = 10
  ns.y = 'hello'
  print(ns)     # =&gt; Namespace(x=10, y='hello')
</code></pre>
</li>
</ul>
<h5 id="basemanager"><a class="header" href="#basemanager">BaseManager</a></h5>
<p><code>BaseManager</code>支持远程进程访问共享对象（使用套接字）。</p>
<pre><code class="language-python">from multiprocessing.managers import BaseManager
manager = BaseManager(address=('', 50000), authkey=b'abc')
manager.get_server().serve_forever() # 前台阻塞执行
manager.start()  # 启动后台进程，类似于SyncManager
</code></pre>
<p>使用<code>Manager</code>管理共享队列，需要手动注册共享对象。</p>
<pre><code class="language-python">from multiprocessing.managers import BaseManager
from queue import Queue
queue = Queue()   # 创建一个队列
BaseManager.register('get_queue', callable=lambda:queue)
m = BaseManager(address=('', 50000), authkey=b'abc')
queue = m.get_queue()
queue.put('hello')
</code></pre>
<pre><code class="language-python">m = BaseManager(address=('127.0.0.1', 50000), authkey=b'abc')
BaseManager.register('get_queue')
m.connect()   # connect to a manager server
queue = m.get_queue()
queue.get()
</code></pre>
<p><code>BaseManager.register</code>：</p>
<h5 id="proxy对象"><a class="header" href="#proxy对象">Proxy对象</a></h5>
<p>使用<code>Manager</code>创建的共享数据类型基于<code>BaseProxy</code>类型，通过该类型对象可访问被引用的共享对象。<code>Proxy</code>类型可以被序列化，因此能在进程间传递。</p>
<p><code>Proxy</code>对象包含弱引用回调函数，当其被垃圾回收时，会向<code>Manager</code>注销其对共享对象的引用。当共享对象的引用数量减少为0时，<code>Manager</code>将删除共享对象。</p>
<h3 id="服务框架"><a class="header" href="#服务框架">服务框架</a></h3>
<p>使用<a href="Python/Python%E7%BC%96%E7%A8%8B%E5%BA%94%E7%94%A8.html#Flask">Flask</a>等服务模型，简化请求响应式的多进程/线程的程序编写。开发人员只需编写对应请求的处理逻辑。</p>
<h2 id="并行任务调度"><a class="header" href="#并行任务调度">并行任务调度</a></h2>
<img src="Python/Python高级编程.assets/PythonProcess.png" alt="image-20210414161141996" style="zoom:50%;" />
<h3 id="并发模型"><a class="header" href="#并发模型">并发模型</a></h3>
<p>由于GIL限制，Python多线程模型并非正真的并发，因此需要靠多进程实现并发。</p>
<h4 id="进程池"><a class="header" href="#进程池">进程池</a></h4>
<p><code>multiprocessing.Pool</code>类表示一个工作进程池，它允许以几种不同方式将任务分配到工作进程。适用于大并发短任务场景，无需反复创建销毁进程从而减小开销</p>
<pre><code class="language-python">import multiprocessing
def some_work(args):
  pass
pool = multiprocessing.Pool(processes=nproc) # start in __main__
# 将任务发送给到进程池，可以反复调用发送任务
async_result = pool.apply_async(some_work, (args)) 
pool.close()
with multiprocessing.Pool(processes=nproc):  # 使用上下文管理器
   pool.apply_async(some_work, (args,))
</code></pre>
<p><code>apply</code>方法是阻塞的，不能实现并行。<code>apply_async</code>方法返回运算结果指示器<code>AsyncResult</code>，主程序后续可以通过适当方式查询<code>AsyncResult</code>的状态然后获取计算结果。</p>
<h5 id="批量提交"><a class="header" href="#批量提交">批量提交</a></h5>
<p><code>map/map_async</code>：将一批计算的参数构造成序列，序列的每个元素分别对应一个计算任务的输入，返回计算结果构成的序列。</p>
<pre><code class="language-python">map(func, [args1,args2,...], chunksize)  # =&gt; starmap, starmap_async
</code></pre>
<p><a href="https://docs.python.org/3/library/multiprocessing.html#module-multiprocessing.pool">multiprocessing — Process-based parallelism — Python 3.9.6 documentation</a></p>
<h4 id="pathos"><a class="header" href="#pathos"><code>pathos</code></a></h4>
<p><code>pathos</code>是一个较为综合性的模块，既能多进程，也能多线程。其主要采用进程池/线程池方法。<code>pathos</code>本身有一套进程池方法，同时也集成了<code>multiprocess</code>、<code>pp</code>模块的进程池方法。</p>
<h4 id="concurrentfutures"><a class="header" href="#concurrentfutures"><code>concurrent.futures</code></a></h4>
<p><code>concurrent.futures</code>模块的接口与<code>multiprocessing</code>差异比较大，要理解如何用它，需要搞清楚<code>executor</code>和<code>future</code>两个概念：</p>
<h5 id="executor"><a class="header" href="#executor">Executor</a></h5>
<p><code>executor</code>可以类比为<code>multiprocessing</code>的进程池、<code>threading</code>的线程池，相当于一个多进程或多线程的环境。</p>
<pre><code class="language-python">with ThreadPoolExecutor(max_workers=1) as executor:
    future = executor.submit(pow, 323, 1235)
    executor.submit(shutil.copy, 'src1.txt', 'dest1.txt')
    print(future.result())
</code></pre>
<p>或：</p>
<pre><code class="language-python">executor = ThreadPoolExecutor(max_workers=2)
a = executor.submit(wait_on_b)
b = executor.submit(wait_on_a)
</code></pre>
<h5 id="future"><a class="header" href="#future">Future</a></h5>
<p><code>future</code>对象可以类比为添加到进程池或线程池的一条条具体任务。</p>
<pre><code class="language-python">future.result(timeout=None)
</code></pre>
<p>等待直到完成任务或超时，返回计算结果或<code>concurrent.future.TimeoutError</code>。默认无时间限制。</p>
<pre><code class="language-python">add_done_callback(fn)
</code></pre>
<p>当<code>future</code>完成或取消时会调用<code>fn</code>。使用<code>cancelled()</code>、<code>done()</code>和<code>running()</code>判断<code>future</code>的状态。</p>
<h3 id="parallel-python"><a class="header" href="#parallel-python">Parallel Python</a></h3>
<p><code>pp</code>模块（也即parallel python模块）是用纯Python编写的开源、跨平台、轻巧并行模块。</p>
<p><code>pp</code>模块实现并行的方式与<code>multiprocessing</code>等不同，他是通过修改Python的GIL机制突破这个限制，而非开启多个解释器（未详细确认）。可能也是因为以上原因，<strong>pp模块调用子进程中的print函数可以正常输出到主进程标准输出</strong>，不像在<code>multiprocessing</code>、<code>multiprocess</code>、<code>pathos.multiprocessing.ProcessPool</code>、<code>concurrent.futures</code>等模块中还必须通过进程间通信传递给主进程操作。</p>
<p>要建立多进程，首先需通过Server类创建进程服务器（类似于进程池）；然后，在这个服务中，创建具体的子进程任务Task。</p>
<h2 id="终端"><a class="header" href="#终端">终端</a></h2>
<p>获取终端的行列数：</p>
<pre><code class="language-python">rc = os.get_terminal_size()
# os.terminal_size(columns=80, lines=24)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="python高级编程"><a class="header" href="#python高级编程">Python高级编程</a></h1>
<p>Python语言的高级特性。</p>
<h2 id="协程和任务"><a class="header" href="#协程和任务">协程和任务</a></h2>
<blockquote>
<p><em><code>asyncio</code> is used as a foundation for multiple Python asynchronous frameworks that provide high-performance network and web-servers, database connection libraries, distributed task queues, etc.</em></p>
</blockquote>
<p>asyncio适用于IO密集型任务，提供<strong>high-level</strong> APIs：</p>
<ul>
<li><a href="https://docs.python.org/3/library/asyncio-task.html#coroutine">run Python coroutines</a> concurrently and have full control over their execution;</li>
<li>perform <a href="https://docs.python.org/3/library/asyncio-stream.html#asyncio-streams">network IO and IPC</a>;</li>
<li>control <a href="https://docs.python.org/3/library/asyncio-subprocess.html#asyncio-subprocess">subprocesses</a>;</li>
<li>distribute tasks via <a href="https://docs.python.org/3/library/asyncio-queue.html#asyncio-queues">queues</a>;</li>
<li><a href="https://docs.python.org/3/library/asyncio-sync.html#asyncio-sync">synchronize</a> concurrent code;</li>
</ul>
<p>以及底层API用于开发库和框架。</p>
<h3 id="异步方法"><a class="header" href="#异步方法">异步方法</a></h3>
<p>基于<code>async/await</code>语法定义异步函数：异步方法中可嵌套调用异步方法，也可仅是普通耗时IO操作。</p>
<pre><code class="language-python">import asyncio
async say_after(length, msg):
   await asyncio.sleep(length)
   print(msg*length)
async def main():
   print('start')
   await asyncio.sleep(1)
   task1 = asyncio.create_task(say_after(1, 'hello'))
   task2 = asyncio.create_task(say_after(2, 'hello'))
   await task1
   await task2
   print('end')
</code></pre>
<h4 id="运行异步方法"><a class="header" href="#运行异步方法">运行异步方法</a></h4>
<h5 id="入口函数"><a class="header" href="#入口函数">入口函数</a></h5>
<p>执行异步方法，管理异步事件循环和线程池。</p>
<pre><code class="language-python">asyncio.run(main())
</code></pre>
<h5 id="嵌套调用异步方法"><a class="header" href="#嵌套调用异步方法">嵌套调用异步方法</a></h5>
<p>直接访问异步方法返回的是<code>coroutines</code>对象，需要通过<code>await</code>关键字来启用协程。</p>
<pre><code class="language-python">await async_method()
await function_that_returns_a_future_object()  # await Future object
</code></pre>
<p><em><strong>awaitable</strong></em> objects: <strong>coroutines</strong>, <strong>Tasks</strong>, and <strong>Futures</strong>.</p>
<h5 id="并发调用异步方法"><a class="header" href="#并发调用异步方法">并发调用异步方法</a></h5>
<p>使用<code>asyncio.create_task</code>创建并调度多个协程并返回<code>Task</code>对象，可在后续等待一批协程执行完成。</p>
<p>https://docs.python.org/3/library/asyncio-task.html</p>
<p>https://docs.python.org/3/library/asyncio.html</p>
<h2 id="反射"><a class="header" href="#反射">反射</a></h2>
<h3 id="获取动态属性"><a class="header" href="#获取动态属性">获取动态属性</a></h3>
<pre><code class="language-python">value = getattr(obj, name) # exception if not exist
tf = hasattr(obj, name)
</code></pre>
<h3 id="动态增删属性"><a class="header" href="#动态增删属性">动态增删属性</a></h3>
<pre><code class="language-python">setattr(obj, name, value)  # obj.attr = value
delattr(obj, name)         # del obj.attr
</code></pre>
<blockquote>
<p><code>object.__set_attr__()</code>：子类内部可覆盖该方法，以改变设置属性时的行为。只有在没有找到属性的情况下，才调用<code>__getattr__</code>，已有的属性，比如<code>name</code>，不会在<code>__getattr__</code>中查找。</p>
<p>注意：如果存在成员函数名<code>name</code>，则不能设置同名属性，否则产生（<code>AttributeError</code>）。</p>
</blockquote>
<p><a href="https://www.liaoxuefeng.com/wiki/1016959663602400/1017590712115904">定制类 - 廖雪峰的官方网站 (liaoxuefeng.com)</a></p>
<h2 id="装饰器"><a class="header" href="#装饰器">装饰器</a></h2>
<p>装饰器（<em>Decorator</em>）可以基于函数的闭包构建，为已有函数<code>some_func</code>增加前置/后置处理。</p>
<pre><code class="language-python">def decorator(some_func):
   def wrapper(*args,**kwargs):  # warpper for some_func
      print &quot;before some_func&quot;
      ret = some_func(*args,**kwargs) 
      return ret + 1
   return wrapper
# 等效于回调函数
def decorator(some_func, *args, **kwargs):
   print &quot;before some_func&quot;
   ret = some_func(*args,**kwargs) 
   return ret + 1
</code></pre>
<p>使用装饰器：</p>
<pre><code class="language-python">@decorator
def some_func(*args,**kwargs):
  pass
# equivalent form
some_func = decorator(som_func)(*args,**kwargs)
</code></pre>
<p>向装饰器传递参数需要再定义一层装饰器：</p>
<pre><code class="language-python">def decorator_with_args(deco_args):
   def decorator(some_func):
      def wrapper(*args,**kwargs): 
         # use deco_args in the the wrapper function.
         return some_func(*args,**kwargs) 
      return wrapper
   return decorator
# define function with decorator
@decorator_with_args(deco_args)
def some_func(*args, **kwargs)
</code></pre>
<h5 id="基于类的装饰器"><a class="header" href="#基于类的装饰器">基于类的装饰器</a></h5>
<p>装饰器实际是<code>callable</code>对象。除函数外，实现<code>__call__</code>方法的类也是<code>callable</code>对象（等效于将基于函数定义的内容放到了<code>__call__</code>方法中）。带参数的基于类的装饰器定义（在构造函数中定义传递给装饰器的参数，装饰目标传递给<code>__call__</code>方法）：</p>
<pre><code class="language-python">class logger(object):
  def __init__(self, level='INFO'):
    self.level = level
  def __call__(self, func): # 实现callable接口
    def wrapper(*args, **kwargs):
      print(&quot;[{level}]: the function {func}() is running...&quot;\
            .format(level=self.level, func=func.__name__))
      func(*args, **kwargs)
    return wrapper # 返回包装后的函数对象

@logger(level='WARN')
def somefunc(*args, **kwargs): # =&gt; logger(level='WARN')(somefunc,...)
  pass
</code></pre>
<p>如果装饰器不带参数（类比于基于函数的装饰器，比带参数的少了一层函数定义；装饰目标传递给装饰器的构造方法）：</p>
<pre><code class="language-python">class logger(object):
   def __init__(self, func):
      self.func = func
      def __call__(self, *args, **kwargs): # 实现callable接口
         print(&quot;[INFO]: the function {func}() is running...&quot;\
               .format(func=self.func.__name__))
         return self.func(*args, **kwargs)
@logger
def somefunc(*args,**kwargs): # =&gt; logger(somefunc)(...)
  pass
</code></pre>
<h5 id="装饰类的装饰器"><a class="header" href="#装饰类的装饰器">装饰类的装饰器</a></h5>
<p>装饰器的参数由函数名变为类。</p>
<pre><code class="language-python">class singleton:    # &lt;== 基于类的装饰器，用于装饰Singleton Class
   _instances = {}  # &lt;== 记录所有Singleton实例
   def __init__(self, cls):
      self._cls = cls
   def __call__(self, *args,**kwargs):
      if self._cls.__name__ not in singleton._instances:
         singleton._instances[self._cls.__name__] = cls(*args, **kwargs)
      return singleton._instances[self._cls.__name__]
@singleton
class User:
   def __init__(self, name):
      self.name = name
user = User('gary')   # =&gt; singleton(User)('gary')
</code></pre>
<h2 id="跨语言编程"><a class="header" href="#跨语言编程">跨语言编程</a></h2>
<h3 id="matlab"><a class="header" href="#matlab">Matlab</a></h3>
<h4 id="python调用matlab"><a class="header" href="#python调用matlab">Python调用Matlab</a></h4>
<pre><code class="language-shell">cd &quot;matlabroot\extern\engines\python&quot;
python setup.py install   # conda activate
</code></pre>
<blockquote>
<p><a href="https://www.mathworks.com/content/dam/mathworks/mathworks-dot-com/support/sysreq/files/python-support.pdf">查看支持的Python版本</a>。</p>
</blockquote>
<pre><code class="language-python">import matlab.engine
eng = matlab.engine.start_matlab()
eng.addpath(r'path\to\work\dir')
</code></pre>
<h5 id="在python程序中创建matlab矩阵类型"><a class="header" href="#在python程序中创建matlab矩阵类型">在Python程序中创建Matlab矩阵类型</a></h5>
<pre><code class="language-python">matlab.type(initializer=None,size=None,is_complex=False)
</code></pre>
<p><code>type</code>包括：<code>double</code>、<code>single</code>、<code>intXX</code>、<code>uintXX</code>、<code>logical</code>。</p>
<blockquote>
<p><code>matlab.int64</code>在Matlab中转换为<code>int32</code>；<code>matlab.uint64</code>在Matlab中转换为<code>uint32</code>；<code>logical</code>类型不能用于构造复数（无<code>is_complex</code>参数）。</p>
</blockquote>
<p><code>initializer</code>为矩阵初始值，即Python序列类型（<code>list</code>和<code>tuple</code>）；<code>size</code>为矩阵维度，需要与初始化值的维度匹配。未指定<code>size</code>时，矩阵维度默认为$1\times N$；如果初始化数据中元素为序列类型，矩阵维度为$m\times N$。未指定初始化值时，元素值设为默认值（<code>0</code>）。</p>
<p><code>matlab.type.size</code>：获取矩阵的维度；
<code>matlab.type.reshape(size)</code>：修改矩阵维度；
<code>pyarray[i]</code>：索引矩阵的行。Matlab矩阵默认为二维矩阵。
<code>pyarray[i][j]</code>:索引矩阵元素。Matlab中索引起始为1，在Python代码中索引起始为0；
<code>pyarray[i][j:k]</code>：切片；</p>
<blockquote>
<p>如果使用Matlab矩阵自身元素更新自身可能得到造成非预期结果。</p>
<pre><code class="language-python">mlarray[0] = mlarray[0][::-1]
</code></pre>
</blockquote>
<p>将数据从Python程序传递至Matlab程序：</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Python Input Argument Type</th><th style="text-align: left">Resulting MATLAB Data Type</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>matlab.type</code> (<a href="Python/Python%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B.html#%E5%9C%A8Python%E7%A8%8B%E5%BA%8F%E4%B8%AD%E5%88%9B%E5%BB%BAMatlab%E7%9F%A9%E9%98%B5%E7%B1%BB%E5%9E%8B">数值矩阵</a>)</td><td style="text-align: left">数值矩阵</td></tr>
<tr><td style="text-align: left"><code>float</code></td><td style="text-align: left"><code>double</code></td></tr>
<tr><td style="text-align: left"><code>complex</code></td><td style="text-align: left">Complex <code>double</code></td></tr>
<tr><td style="text-align: left"><code>int</code></td><td style="text-align: left"><code>int32</code>(Windows)<code>int64</code>(Linux/Mac)</td></tr>
<tr><td style="text-align: left"><code>float('nan'\|'inf')</code></td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left"><code>bool</code></td><td style="text-align: left"><code>logical</code></td></tr>
<tr><td style="text-align: left"><code>str</code></td><td style="text-align: left"><code>char</code></td></tr>
<tr><td style="text-align: left"><code>bytearray</code>/<code>bytes</code></td><td style="text-align: left"><code>uint8</code> array</td></tr>
<tr><td style="text-align: left"><code>dict</code></td><td style="text-align: left">结构体（key必须为字符串）</td></tr>
<tr><td style="text-align: left"><code>list</code>/<code>set</code>/<code>tuple</code>/<code>range</code></td><td style="text-align: left">Cell array</td></tr>
<tr><td style="text-align: left"><code>memoryview</code>/<code>None</code></td><td style="text-align: left">Not supported</td></tr>
</tbody></table>
</div>
<p>从Matlab程序返回至Python的数据：</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">MATLAB Output Argument Type</th><th style="text-align: left">Resulting Python Data Type</th></tr></thead><tbody>
<tr><td style="text-align: left">数值矩阵</td><td style="text-align: left"><code>matlab</code> 数值矩阵</td></tr>
<tr><td style="text-align: left"><code>double</code> <code>single</code></td><td style="text-align: left"><code>float</code></td></tr>
<tr><td style="text-align: left">复数(any numeric type)</td><td style="text-align: left"><code>complex</code></td></tr>
<tr><td style="text-align: left"><code>int8</code> <code>uint8</code> <code>int16</code> <code>uint16</code> <code>int32</code></td><td style="text-align: left"><code>int</code></td></tr>
<tr><td style="text-align: left"><code>uint32</code> <code>int64</code> <code>uint64</code></td><td style="text-align: left"><code>int</code> <code>long</code></td></tr>
<tr><td style="text-align: left"><code>NaN</code></td><td style="text-align: left"><code>inf</code></td></tr>
<tr><td style="text-align: left"><code>logical</code></td><td style="text-align: left"><code>bool</code></td></tr>
<tr><td style="text-align: left"><code>char</code> array (1-by-<code>N</code>, <code>N</code>-by-1)</td><td style="text-align: left"><code>str</code></td></tr>
<tr><td style="text-align: left">结构体</td><td style="text-align: left"><code>dict</code></td></tr>
<tr><td style="text-align: left">1D cell array</td><td style="text-align: left"><code>list</code></td></tr>
</tbody></table>
</div>
<h3 id="在matlab中调用python"><a class="header" href="#在matlab中调用python">在Matlab中调用Python</a></h3>
<p>在Matlab会话中启用Python环境：</p>
<pre><code class="language-matlab">pe = pyenv('Version','C:/tools/miniconda3/envs/data/python.exe')
pe = pyenv   # read curent python environment
</code></pre>
<blockquote>
<p>在整个会话中只能导入一次Python环境，可根据<code>pe.Status</code>来判断是否已经导入。</p>
</blockquote>
<p>调用python的包无需使用<code>import</code>语句</p>
<pre><code class="language-matlab">syspath = py.sys.path
syspath.append(pwd)
import py.textwrap.wrap
S2 = wrap('another string');
mm = py.importlib.import_module('mymod');
% Use mm as an alias to access functionality in mymod
py.help('object')
</code></pre>
<h3 id="java"><a class="header" href="#java">Java</a></h3>
<p><a href="https://www.py4j.org/">Welcome to Py4J — Py4J</a></p>
<h2 id="python项目"><a class="header" href="#python项目">Python项目</a></h2>
<h5 id="basic-layout"><a class="header" href="#basic-layout">Basic Layout</a></h5>
<pre><code class="language-shell">projectname/
├── .gitignore
├── projectname.py
├── LICENSE           # if you’re distributing code.
├── README.md
├── requirements.txt  # Python dependencies and versions
├── setup.py          # installation
└── tests.py
</code></pre>
<h5 id="modulized-layout"><a class="header" href="#modulized-layout">modulized layout</a></h5>
<pre><code class="language-shell">helloworld/
├── bin/              # 可编写脚本调用模块的主程序
├── docs/
│   ├── hello.md
│   └── world.md
├── helloworld/       # package contains sub-modules
│   ├── __init__.py   # indicator of package
│   ├── helloworld.py # 可包括多层内部package进行功能划分
│   └── helpers.py
├── tests/            # 对应功能模块结构编写测试
│   ├── helloworld_tests.py
│   └── helpers_tests.py
└── ...   # other files in basic layout
</code></pre>
<h3 id="测试"><a class="header" href="#测试">测试</a></h3>
<h4 id="性能测试"><a class="header" href="#性能测试">性能测试</a></h4>
<p>代码片段的运行时间统计。</p>
<pre><code class="language-python">from timeit import timeit
print(timeit('[n**2 for n in range(10) if n%2==0]', number=10000))
</code></pre>
<h4 id="单元测试-1"><a class="header" href="#单元测试-1">单元测试</a></h4>
<blockquote>
<p><em>A unit is a specific piece of code to be tested, such as a function or a class. Unit tests are then other pieces of code that specifically exercise the code unit with a full range of different inputs, including boundary and edge cases.</em></p>
</blockquote>
<p><code>unittest</code>用于单元测试。<code>setUp</code>（由<code>__init__()</code>调用）和<code>tearDown</code>用于为每个测试用例初始化和回收资源，与<code>test_case()</code>组成一个测试配置。<code>unittest.main()</code>为测试类中的每个测试用例构造一个测试类实例，并调用该测试用例方法（因此在一个测试类中<code>setUp</code>等方法调用次数与测试样例数一致）。</p>
<pre><code class="language-python">import unittest
class MyTestCases(unittest.TestCase):
  def setUp(self):
    pass
  def tearDown(self):
    pass
  def test_case(self): # 测试项
    self.assertTrue(True, msg='Test Pass.')  # 使用assert语句判断并记录测试结果
if __name__ == '__main__':
  unittest.main()   # 使用Python运行该脚本自动执行所有测试
</code></pre>
<p>执行测试。测试项的执行顺序依据测试方法名称排序。</p>
<pre><code class="language-shell">python test/components/test_operators.py
</code></pre>
<pre><code class="language-shell">python -m unittest test.components.test_operators 
python -m unittest test/components/test_operators.py
# 需要相应目录下有__init__.py，否则无法将对应文件夹视为模块
</code></pre>
<h5 id="构造测试组"><a class="header" href="#构造测试组">构造测试组</a></h5>
<pre><code class="language-python">if __name__ == '__main__':
  suite = unittest.TestSuite()
  suite.addTests([
    TestCases('test_scalar_operator'),  # 参数为测试类中的测试方法名
  ])
  runner = unittest.TextTestRunner()
  runner.run(suite)
</code></pre>
<p><code>TextTestRunner</code>以文本形式显示测试结果，包括：</p>
<ul>
<li>测试名称；</li>
<li>测试过程中的错误信息；</li>
<li>测试结果汇总。</li>
</ul>
<h3 id="编译打包"><a class="header" href="#编译打包">编译打包</a></h3>
<pre><code class="language-shell">python -m compileall pysrc.py # compile to .pyc file
python -m zipfile \
       -c demo.zip demo/*   # 将源文件打包为zip =&gt; 执行：python demo.zip
python3 -m zipapp demo -m &quot;main:main&quot;
</code></pre>
<h3 id="分发和安装"><a class="header" href="#分发和安装">分发和安装</a></h3>
<pre><code class="language-python">from setuptools import setup, find_packages
setup(
   name=&quot;mytest&quot;,
   version=&quot;1.0&quot;,
   author=&quot;wangbm&quot;,
   author_email=&quot;wongbingming@163.com&quot;,
   description=&quot;Learn to Pack Python Module&quot;,
   url=&quot;http://iswbm.com/&quot;, 
   packages=find_packages(),
   python_requires='&gt;=2.7, &lt;=3',
	install_requires=['docutils&gt;=0.3'],  # 自动下载安装依赖包
   setup_requires=['pbr'],              # 当前环境必须存在依赖包
   entry_points={
        'console_scripts': [
            'foo = foo.main:main'  # 生成/usr/bin/foo -&gt; foo.main模块中的main函数
        ]
    },
   scripts=['bin/foo.sh', 'bar.py'] # 将脚本复制到系统路径中
)
</code></pre>
<p><a href="https://zhuanlan.zhihu.com/p/276461821">花了两天，终于把 Python 的 setup.py 给整明白了 - 知乎 (zhihu.com)</a></p>
<p><a href="https://setuptools.pypa.io/en/latest/userguide/quickstart.html">setuptools Quickstart - setuptools 60.5.2 documentation (pypa.io)</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="java编程"><a class="header" href="#java编程">JAVA编程</a></h1>
<p>Java语言不使用指针，而是引用。</p>
<h2 id="java程序"><a class="header" href="#java程序">Java程序</a></h2>
<h3 id="编写"><a class="header" href="#编写">编写</a></h3>
<h4 id="代码结构"><a class="header" href="#代码结构">代码结构</a></h4>
<p>一个<code>*.java</code>文件可以包含多个类的定义：</p>
<ul>
<li>只能有一个<code>public</code>类/接口，源文件名与<code>public</code>类名相同；</li>
</ul>
<h5 id="打包声明"><a class="header" href="#打包声明">打包声明</a></h5>
<p>包用于描述代码的逻辑组织结构（类似于C#的命名空间）：</p>
<ul>
<li>
<p>把功能相似或相关的类或接口组织在同一个包中，方便类的查找和使用</p>
</li>
<li>
<p>并防止命名冲突。</p>
</li>
</ul>
<p>如果一个public类要包含在某个包内，需要在代码的第一行使用<code>package</code>关键字进行声明。</p>
<pre><code class="language-java">package org.develop.app;
</code></pre>
<p>在指定的源代码根目录下，<strong>层级的打包声明也对应源代码（编译输出字节码）文件树目录结构</strong>。</p>
<blockquote>
<p>不同类型项目的源文件根目录设置可能不同，例如<a href="https://stackoverflow.com/questions/3004710/what-is-the-advantage-of-the-src-main-java-convention">Maven项目的源代码根目录</a>为<code>src/main/java</code>，则上述源代码对应的路径为<code>src\main\java\org\develop\App.java</code>。</p>
</blockquote>
<h5 id="导入包声明"><a class="header" href="#导入包声明">导入包声明</a></h5>
<p>为了使用外部代码（例如Java库），源文件文件中可以导入（<code>import</code>）外部依赖包的内容。</p>
<p>导入语句位于打包语句之后。</p>
<pre><code class="language-java">import java.io.*;		// import all
import java.io.File;	// import single class
</code></pre>
<p>包具有层级嵌套结构，导入声明仅能引用当前层级包中的类，而不能引用下一层级的包中的类（需要单独声明）。</p>
<h5 id="模块系统java-9"><a class="header" href="#模块系统java-9">模块系统（Java 9）</a></h5>
<p>同一个<code>jar</code>文件中的<code>.class</code>文件并没有依赖关系限制；模块则附加依赖关系，还可包含二进制代码。</p>
<pre><code class="language-shell">oop-module
├── bin                           # 存放编译后的class文件
├── build.sh
└── src                           # 源码：按包名的目录结构存放
    ├── com
    │   └── hello
    │       └── world
    │           ├── Greeting.java
    │           └── Main.java
    └── module-info.java          # 模块的描述文件，包含依赖声明
</code></pre>
<p>在Java代码中仅能引用模块描述文件中声明的依赖库。</p>
<pre><code class="language-java">module hello.world {
   requires java.base;       // 可不写，任何模块都会自动引入java.base
   requires java.xml;
   exports com.hello.world;  // 只有声明导出的包，外部代码才能问。(进一步隔离了代码的访问权限)
}
</code></pre>
<blockquote>
<p><code>java --list-modules</code>显示JDK自带模块。
<code>java -d,describe-module module_name</code>显示模块的描述信息。</p>
</blockquote>
<h3 id="执行java程序"><a class="header" href="#执行java程序">执行Java程序</a></h3>
<h4 id="编译"><a class="header" href="#编译">编译</a></h4>
<p>Java程序被<a href="Java/Java%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83.html#%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7">编译</a>为字节码格式（<code>*.class</code>文件）。在运行时，Java平台中的Java解释器对这些字节码进行解释执行，执行过程中需要的类在联接阶段被载入到运行环境中。</p>
<h4 id="运行"><a class="header" href="#运行">运行</a></h4>
<p>Java应用程序是由若干类定义组成的独立的解释型程序，其中必须有一个包含Main方法的主类；执行Java应用程序时，需要使用Java解释器（<code>java.exe</code>）来执行这个主类的字节码文件（<code>.class</code>）。</p>
<pre><code class="language-shell">java App.java                                  # 直接编译执行源文件
java [options] -jar package-name.jar [args...] # 执行jar包中包含Main方法的class文件
java [options] -cp &lt;classpath&gt; package.ClassName [args...] # 指定搜索路径下的class
</code></pre>
<p><code>package.ClassName</code>：程序执行时应该执行入口函数所在的类，解释器在<a href="Java/JAVA%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80.html#%E7%B1%BB%E6%90%9C%E7%B4%A2%E8%B7%AF%E5%BE%84">搜索路径</a>下寻找指定类。Java应用程序的入口函数为类中的名为<code>Main</code>的<a href="Java/JAVA%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80.html#%E6%96%B9%E6%B3%95">静态方法</a>。使用<code>-jar</code>选项执行时，<code>jar</code>包中需要在<code>manifest</code>中声明主类。</p>
<blockquote>
<p><code>--dry-run</code>：创建VM并加载主类，但不执行主方法。用于验证命令行参数是否有效。</p>
<p>Java小程序（Java Applet）的源代码编辑与字节码编译生成过程与Java应用程序相同，但它不是一类可独立运行的程序。<strong>Applet程序的字节码</strong>文件必须嵌入到HTML文件中并由负责解释HTML文件的浏览器充当其解释器。将Java Applet引入HTML中，使得网页能够提供动态信息。Java小程序与Java应用程序最大不同在于Applet不需要<code>Main</code>方法，而要求程序中必须有且只有一个类是<code>Applet</code>类的子类。系统类<code>Applet</code>类中已经定义了许多成员，它们规定了<code>Applet</code>如何与执行它的解释器——浏览器配合工作。</p>
</blockquote>
<h4 id="java环境变量"><a class="header" href="#java环境变量">Java环境变量</a></h4>
<pre><code class="language-shell">-D&lt;name&gt;=&lt;value&gt;  # 系统属性(system.Properties),传递应用程序
-X                # 输出所有`-X`（extra）虚拟机选项的名称；
</code></pre>
<h5 id="java虚拟机选项"><a class="header" href="#java虚拟机选项">Java虚拟机选项</a></h5>
<p><code>-Xms</code>：Java虚拟机的初始<a href="http://docs.oracle.com/cd/E13150_01/jrockit_jvm/jrockit/geninfo/diagnos/garbage_collect.html">堆内存分配量</a>，例如<code>-Xms256m</code>；单位包括：<code>k,m,g,...</code>。</p>
<p><code>-Xmx</code>：JVM最大堆内存分配量，例如<code>-Xmx2048m</code>，通常默认值为<code>256m</code>；如果超过最大内存分配限制，程序将触发<code>java.lang.OutOfMemoryError</code>异常。</p>
<h5 id="java系统属性"><a class="header" href="#java系统属性">Java系统属性</a></h5>
<h4 id="路径-1"><a class="header" href="#路径-1">路径</a></h4>
<h5 id="当前路径"><a class="header" href="#当前路径">当前路径</a></h5>
<p>执行Java程序时所在的工作目录。</p>
<h5 id="类搜索路径"><a class="header" href="#类搜索路径">类搜索路径</a></h5>
<p>Java解释器需要在搜索路径<code>CLASSPATH</code>中寻找<code>.class</code>文件进行执行。==类文件（<code>*.class</code>）可能位于文件夹、<code>jar</code>文件或<code>zip</code>文件==，使用以下选项添加搜索路径。</p>
<pre><code class="language-shell">-{cp,class-path,classpath} libpath1:libpath2/*:lib3.jar:...
</code></pre>
<p>特别地，==如果文件夹以<code>/*</code>结尾，那么该文件夹下的所有<code>jar/zip</code>文件都会被加入搜索路径==。</p>
<blockquote>
<p>JVM自带的标准库<code>rt.jar</code>不要写到<code>CLASSPATH</code>中，写了反而会干扰JVM的正常运行。<code>*</code>不能视为通配符，因此<code>*.jar</code>的写法将无效且造成错误。</p>
</blockquote>
<h5 id="连接动态库"><a class="header" href="#连接动态库">连接动态库</a></h5>
<p>如果程序依赖共享库（JNI），而不能定位，则会引发<code>java.lang.UnsatisfiedLinkError</code>。</p>
<p>使用<code>-Djava.library.path=/your/lib/path</code>选项指定。</p>
<p>另一种方法是在执行程序之前（或加入<code>/etc/profit</code>）设置环境变量 <code>LD_LIBRARY_PATH</code>。</p>
<blockquote>
<p>不建议修改共享库搜索路径。如果使用的共享库在系统中存在其他版本，可能影响程序使用的共享库版本，使程序出错（<code>ImportError: tensorflow/python/_pywrap_tensorflow_internal.so: undefined symbol</code>）。</p>
</blockquote>
<pre><code class="language-shell">export LD_LIBRARY_PATH=:~/Workspace/lib/java/tensorflow/
</code></pre>
<h5 id="模块搜索路径"><a class="header" href="#模块搜索路径">模块搜索路径</a></h5>
<pre><code class="language-shell">-p,--module-path &lt;module path&gt; path1:path2:...
</code></pre>
<h2 id="语法"><a class="header" href="#语法">语法</a></h2>
<p>标识符大小写敏感。命名规则：</p>
<ul>
<li>类名：单词首字母大写；</li>
<li>方法名：首字母小写，其余单词首字母大写；</li>
</ul>
<h3 id="注释和文档-2"><a class="header" href="#注释和文档-2">注释和文档</a></h3>
<p>注释：</p>
<ul>
<li>使用<code>//</code>或<code>/*...*/</code>添加单行注释；</li>
<li>使用<code>/*...*/</code>添加多行注释。</li>
</ul>
<h4 id="文档化注释"><a class="header" href="#文档化注释">文档化注释</a></h4>
<pre><code class="language-java">/**
* &lt;h1&gt;Find average of three numbers!&lt;/h1&gt; 
* &lt;p&gt;The FindAvg program implements an application that 
* simply calculates average of three integers and Prints 
* the output on the screen. &lt;/p&gt;
*
* @param parameter_name description 	[Parameters” section]
* @return description					[“Returns” section]
* @exception ExceptionClass				[Throws subheading]
* @author Author Name
* @version version						[“Version” subheading]
* @since release-date					[“Since” subheading]
* @see reference 						[See Also” heading]
* @deprecated Indicating Deprecated components
* {@link package.class#member label}
* {@code text}
*/
</code></pre>
<p>使用<code>javadoc</code>生成格式化文档。</p>
<pre><code class="language-sh">javadoc Program.java
</code></pre>
<p>https://www.geeksforgeeks.org/comments-in-java/</p>
<p>https://www.oracle.com/technetwork/java/javase/documentation/index-137868.html</p>
<h4 id="标注annotation"><a class="header" href="#标注annotation">标注（Annotation）</a></h4>
<p>标注以<code>@</code>开始，用于辅助程序元素与元信息的关联，并控制编译器的行为，但对编译后的程序不起作用。</p>
<pre><code class="language-java">@MarkerAnnotation
@SingleValueAnnotation(&quot;info&quot;)
@FullAnnotation(key1=&quot;value1&quot;,key2=&quot;value2&quot;)
</code></pre>
<p>预定义标注：</p>
<pre><code class="language-java">import java.lang.annotations.*;
@Deprecated		// indicate an oboslated declaration
@Override		// must override a method from superclass
@SuppressWarnings({&quot;checked&quot;, &quot;deprecation&quot;}) // 参数可为空
@FunctionalInterface
@SafeVarargs   // 标注的方法不会对可变参数执行不安全操作
</code></pre>
<p>标注可用于类、方法、语句等的开头（上一行），<code>for</code>语句等的条件语句的开头。</p>
<p>自定义标注，类似于定义接口（使用<code>@interface</code>关键字），自定义标注本身还可添加标注信息（<em><strong>meta annotations</strong></em>）：</p>
<pre><code class="language-java">@Documented                         // 添加所定义标注的元素信息文档化（javadoc etc.）
@Target(ElementType.METHOD)         // 标注的目标TYPE, METHOD, FIELD...
@Inherited                          // 子类是否继承父类元素的该标注
@Retention(RetentionPolicy.RUNTIME) // === SOURCE,CLASS, RUNTIME
@Repeatable                         // 该标注是否可重复声明
public @interface MethodInfo{
   String author() default &quot;gary&quot;;  // 方法不能包含参数
   int revision() default 1;        // 方法返回值仅限基本类型
}
</code></pre>
<p><a href="https://www.journaldev.com/721/java-annotations">Java Annotations - JournalDev</a></p>
<p>https://www.geeksforgeeks.org/annotations-in-java/</p>
<h3 id="变量声明"><a class="header" href="#变量声明">变量声明</a></h3>
<p>变量在使用前必须声明：</p>
<pre><code class="language-java">type var_name[ = value, var_name2[ = value]...];
</code></pre>
<p>变量根据作用域可分为：类变量（静态字段）、实列变量（<a href="Java/JAVA%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80.html#%E5%AD%97%E6%AE%B5">字段</a>）和局部变量。</p>
<p>局部变量是<em>在栈上分配</em>的，在所在作用域（方法、代码块）被执行时创建，执行完即被销毁。</p>
<p><strong>局部变量没有默认值，所以局部变量被声明后，必须经过初始化，才可以使用。</strong></p>
<h3 id="流程控制-2"><a class="header" href="#流程控制-2">流程控制</a></h3>
<h3 id="条件-2"><a class="header" href="#条件-2">条件</a></h3>
<pre><code class="language-java">if(condition){
  
}else if (condition){
  
}else{
  
}
</code></pre>
<h4 id="循环-2"><a class="header" href="#循环-2">循环</a></h4>
<h5 id="while"><a class="header" href="#while">while</a></h5>
<pre><code class="language-java">while (condition){
    do_something;
}
</code></pre>
<p>赋值语句的返回值可作为条件语句，例如：<code>(line = reader.readLine()) != null</code>（<code>null</code>本身不能直接作为条件语句）。</p>
<h5 id="do-while"><a class="header" href="#do-while">do-while</a></h5>
<pre><code class="language-java">do{
	do_something;
}while(true);
</code></pre>
<h5 id="for"><a class="header" href="#for">for</a></h5>
<pre><code class="language-java">for(int i=0; i&lt;len; ++i){
    do_something;
}
</code></pre>
<p>增强<code>for</code>循环，结合迭代器。</p>
<pre><code class="language-java">for(String name : names){
   do_something;
}
</code></pre>
<h5 id="stream-api"><a class="header" href="#stream-api">Stream API</a></h5>
<p>定义对元素的计算函数，由Stream框架执行内部迭代，从而实现并行计算、过滤、映射等功能特性。</p>
<p><a href="https://www.journaldev.com/2774/java-8-stream">Java 8 Stream - Java Stream - JournalDev</a></p>
<pre><code class="language-java">return list.stream().filter(x -&gt; x &gt; 10).mapToInt(x -&gt; x).sum();
</code></pre>
<h4 id="switch-case"><a class="header" href="#switch-case">switch-case</a></h4>
<pre><code class="language-java">switch(expr){
    case const_val1:
        statements;
        break;
    case const_val2:
    case const_val3:
        statements;
        break;
    default:
        statements;
}
</code></pre>
<p>说明：</p>
<ol>
<li>变量类型可以是：<code>byte</code>、<code>short</code>、<code>int</code>、<code>char</code>以及<code>string</code>（Java 7）;</li>
<li><code>case</code>语句的值为<strong>常量</strong>或<strong>字面值常量</strong>；</li>
</ol>
<h4 id="try-catch-finally"><a class="header" href="#try-catch-finally">try-catch-finally</a></h4>
<p>用于<a href="Java/JAVA%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80.html#%E5%A4%84%E7%90%86%E5%BC%82%E5%B8%B8">处理程序异常</a>的控制结构。</p>
<pre><code class="language-java">try {
	do_something;
} catch (ExceptionTypeA | ExceptionTypeB e) {
	handle_exception;
} finally {
	clean_work;
}
</code></pre>
<h4 id="try-with-resource"><a class="header" href="#try-with-resource">try-with-resource</a></h4>
<p>简化资源关闭与异常处理流程（Java 7）。</p>
<pre><code class="language-java">try (open_resources){
	do_something;
}
catch(exception e){
	handle_exception;
}
</code></pre>
<p>为了能够配合<code>try-with-resource</code>，资源必须实现<code>AutoClosable</code>接口。</p>
<h3 id="运算符-4"><a class="header" href="#运算符-4">运算符</a></h3>
<h5 id="instanceof"><a class="header" href="#instanceof">instanceof</a></h5>
<p>检查该对象是否是一个特定类型（类类型或接口类型）</p>
<pre><code class="language-java">Object instanceof ClassName
</code></pre>
<h3 id="函数-2"><a class="header" href="#函数-2">函数</a></h3>
<h4 id="lambda表达式匿名函数"><a class="header" href="#lambda表达式匿名函数">Lambda表达式（匿名函数）</a></h4>
<p>使用Lambda表达式：可减少代码量，传递函数作为参数，在使用时定义函数。</p>
<pre><code class="language-java">(args)-&gt;{statements} // 参数和方法内容均可省略，单语句可省略&quot;{}&quot;
</code></pre>
<blockquote>
<p>无返回值的方法体以最后语句的返回值作为方法的返回值。</p>
<p>参数类型可==同时==省略（自动推断）。</p>
</blockquote>
<h4 id="方法引用java-8"><a class="header" href="#方法引用java-8">方法引用（Java 8）</a></h4>
<h2 id="面向对象的编程"><a class="header" href="#面向对象的编程">面向对象的编程</a></h2>
<p>Java中所有内容均包含在类的定义中。</p>
<h3 id="类与对象"><a class="header" href="#类与对象">类与对象</a></h3>
<pre><code class="language-java">[public] [modifier] class ClassName [extends BaseClass][implements Interfaces,...]{
   [protected] [modifier] int PropertyName [= value];
   [public] ClassName(int param,...) throw exceptions{
      super(param,...)
         do_initialization;
   }
   [private] [modifer] void methodName(int param,...)throw exceptions{
      statements;
      this.another_method(param,...);
      super.base_method(param,...);
   }
   public int static main(String[] args){
      ClassName c = new ClassName(...);
   }
   protected class InternalClass{
      class_definitions;
   }
}
</code></pre>
<p>使用<code>new</code>关键字创建对象。创建对象时将调用类的<a href="Java/JAVA%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80.html#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95">构造方法</a>。</p>
<p><strong>注意</strong>：类的实例都是通过引用来使用的，使用<code>new</code>创建的对象都会在内存中开辟独立的空间，两个对象即使内容相同，但是在内存中的地址不同，所以<strong>如果使用<code>==</code>进行比较，会得到<code>false</code>；但是使用类的方法<code>equals</code>比较两个实例的内容</strong>。使用对象相互赋值的方法，则只是复制了对象的引用，并没有开辟新空间，所以两者指向同样的区域。==对于字符串来说，如果直接将带引号的字符串赋值给两个字符串对象，则由于Java处理字符串的特性，两个对象将指向内存中的同一位置（内存中的特殊区域String Pool），使用==<code>==</code>==也会返回<code>true</code>==。</p>
<p>类的成员包括方法和字段。在类内部可直接通过名称访问成员。当成员名称与参数名或局部变量重名时，使用<code>this</code>关键字访问成员。<em><code>this</code>还可用于在构造方法内部引用该类的其他构造方法（只能出现在构造方法内部的第一行，即只能调用一次）。</em></p>
<h4 id="修饰符"><a class="header" href="#修饰符">修饰符</a></h4>
<h5 id="访问控制"><a class="header" href="#访问控制">访问控制</a></h5>
<ul>
<li>
<p><code>public</code>：这个类可以被其他所有类访问和引用，只能被定义在同名文件中。</p>
</li>
<li>
<p><em>default</em>：即没有访问控制符修饰，这样的类只能被同一个包内的类引用，而对其他包内的类不可见。</p>
</li>
<li>
<p><code>protected</code>：</p>
</li>
<li>
<p><code>private</code>：只用于内部类。</p>
</li>
</ul>
<h5 id="其他-1"><a class="header" href="#其他-1">其他</a></h5>
<ul>
<li><code>abstract</code>：抽象类，<strong>不能直接被实例化的类，但是可以声明对象的引用</strong>，只是声明的对象引用默认值都是<code>null</code>，必须使用可实例化的子类的构造函数对其赋值。抽象类内部可以包含任意个抽象方法，也可以包含构造方法、字段和实体方法。</li>
<li><code>final</code>：不能被继承的类。</li>
</ul>
<h4 id="字段"><a class="header" href="#字段">字段</a></h4>
<p>字段（Fields，属性Attributes）是类内部定义的<a href="Java/JAVA%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80.html#%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E">变量</a>。</p>
<h5 id="访问控制修饰符"><a class="header" href="#访问控制修饰符">访问控制修饰符</a></h5>
<ul>
<li><code>public</code>: 允许任何位置对字段的访问。由于具有默认访问权限的类本身只能被同一包内的成员所访问，所以这种类中的成员即使具有<code>public</code>权限也只能被同一包内的其他类访问。</li>
<li><em>default</em>：同一个包内的位置可对字段进行访问。</li>
<li><code>protected</code>：允许该类及其子类中对该字段进行访问。</li>
<li><code>private</code>：允许在该类内部对该字段进行访问。访问控制是针对类而言的，而并非针对具体实例而言，即同一个类的不同实例可以互相访问它们的私有成员。<em>而通过继承关系生成的子类，其新定义的方法则不能访问父类的私有成员，但继承自父类的成员函数因为本来可以访问父类成员，所以在子类中仍然可以访问父类成员。</em></li>
</ul>
<h5 id="其他修饰符"><a class="header" href="#其他修饰符">其他修饰符</a></h5>
<ul>
<li>
<p><code>static</code>：同一个类所有的实例共享静态字段。</p>
<p>静态成员不属于对象，所以推荐使用类名来访问静态成员（在类内部可直接使用字段名）。</p>
<pre><code class="language-java">ClassName.StaticProperty;
</code></pre>
<p>由于静态字段从属于类，而不属于实例，所以不能用构造函数进行初始化。同时由于除了通过在声明字段时对字段赋初值，还可以通过<strong>静态代码块</strong>对静态字段进行初始化。</p>
<pre><code class="language-java">static{ initialize-statements; }
</code></pre>
</li>
<li>
<p><code>final</code>：常量字段，通常用<strong>大写字母作为常量标识符</strong>。</p>
</li>
<li>
<p><code>transient</code>：<a href="Java/JAVA%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80.html#%E5%AF%B9%E8%B1%A1%E5%BA%8F%E5%88%97%E5%8C%96">序列化</a>对象时，跳过该类变量。</p>
</li>
<li>
<p><code>volatile</code>：在每次被线程访问时，都强制从共享内存中重新读取该成员变量的值。而且，当成员变量发生变化时，会强制线程将变化值回写到共享内存。这样在任何时刻，两个不同的线程总是看到某个成员变量的同一个值。</p>
</li>
</ul>
<h4 id="方法-1"><a class="header" href="#方法-1">方法</a></h4>
<p>方法的访问控制与字段一致。</p>
<h5 id="修饰符-1"><a class="header" href="#修饰符-1">修饰符</a></h5>
<ul>
<li>
<p><code>abstract</code>：只有函数声明（declaration/signature），而没有函数体。具有抽象方法的类即抽象类。抽象类的类必须重载这些抽象方法才能实例化，否则子类也必须声明为抽象类。</p>
</li>
<li>
<p><code>final</code>：不能被类的子类重写。</p>
</li>
<li>
<p><code>static</code>：静态方法，只能访问和修改类的静态成员，通过类名调用。</p>
<pre><code class="language-java">ClassName.StaticMethod(args);
</code></pre>
<p>名为<code>main</code>的静态方法可作为Java程序的入口函数。</p>
<pre><code class="language-java">public static void main(String[] args)   // args not contain program name
</code></pre>
<blockquote>
<p>主函数无须返回值（<code>return</code>）。由于程序由<code>java</code>解释器执行，因此从主函数返回值并不能被shell接收。<code>java</code>解释器将获取由<code>System.exit(value)</code>返回的值，并返回给shell。</p>
</blockquote>
</li>
<li>
<p><code>synchronized</code>：方法同一时间只能被一个线程访问。</p>
</li>
</ul>
<h5 id="方法重载overload"><a class="header" href="#方法重载overload">方法重载（Overload）</a></h5>
<p>重载的方法必须拥有不同的参数列表。不能仅依据修饰符或者返回类型的不同来重载方法。</p>
<h5 id="可变参数"><a class="header" href="#可变参数">可变参数</a></h5>
<p>一个方法中只能指定一个可变参数，它必须是方法的最后一个参数，在参数类型后加一个省略号(...)。</p>
<pre><code class="language-java">public static void printMax( double... numbers)
</code></pre>
<h4 id="命令行参数解析"><a class="header" href="#命令行参数解析">命令行参数解析</a></h4>
<h5 id="picocli"><a class="header" href="#picocli">picocli</a></h5>
<p>可以通过外部依赖或源代码（<code>CommandLine.java</code>）的方式使用。以下为通过Maven配置依赖项。</p>
<pre><code class="language-xml">&lt;dependency&gt;
  &lt;groupId&gt;info.picocli&lt;/groupId&gt;
  &lt;artifactId&gt;picocli&lt;/artifactId&gt;
  &lt;version&gt;4.2.0&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>启用<strong>Annotation Processor</strong>：</p>
<pre><code class="language-xml">&lt;plugin&gt;
  &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
  &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;
  &lt;version&gt;3.5.0&lt;/version&gt; &lt;!-- 3.5 or higher --&gt;
  &lt;configuration&gt;
    &lt;annotationProcessorPaths&gt;
      &lt;path&gt;
        &lt;groupId&gt;info.picocli&lt;/groupId&gt;
        &lt;artifactId&gt;picocli-codegen&lt;/artifactId&gt;
        &lt;version&gt;4.2.0&lt;/version&gt;
      &lt;/path&gt;
    &lt;/annotationProcessorPaths&gt;
    &lt;compilerArgs&gt;
      &lt;arg&gt;-Aproject=${project.groupId}/${project.artifactId}&lt;/arg&gt;
    &lt;/compilerArgs&gt;
  &lt;/configuration&gt;
&lt;/plugin&gt;
</code></pre>
<p>示例代码：</p>
<pre><code class="language-java">@Command(name=&quot;App&quot;, version=&quot;v1.0.0&quot;, header=&quot;Example App.&quot;)
class Tar {
    @Option(names=&quot;-c&quot;, description=&quot;create a new archive&quot;)
    boolean create;
    @Option(names={&quot;-f&quot;,&quot;--file&quot;}, paramLabel=&quot;ARCHIVE&quot;, ...)
    File archive;
    @Parameters(paramLabel=&quot;FILES&quot;, description = &quot;one ore more files...&quot;)
    File[] files;  // all positional arguments
    @Option(names = { &quot;-h&quot;, &quot;--help&quot; }, usageHelp = true, ...)
    private boolean helpRequested = false;
    @Parameters(index = &quot;0&quot;)   // index=&quot;2-4&quot;, index=&quot;3-*&quot;
    String command = &quot;save&quot;;   // first  positional arguments
    public static void main(String args){
        Tar tar = new Tar();
        new CommandLine(tar).parseArgs(args);
        if (tar.helpRequested){
            CommandLine.usage(app, System.out);
            System.exit(0);
        }
    }
}
</code></pre>
<h5 id="commoncli"><a class="header" href="#commoncli">CommonCLI</a></h5>
<p><a href="https://commons.apache.org/proper/commons-cli/index.html"><strong>Commons CLI</strong></a> https://commons.apache.org/proper/commons-cli/usage.html</p>
<p><a href="https://picocli.info/"><strong>picocli</strong> - a mighty tiny command line interface</a></p>
<p><a href="http://jcommander.org/">jcommander</a></p>
<p><a href="https://stackoverflow.com/questions/367706/how-do-i-parse-command-line-arguments-in-java">How do I parse command line arguments in Java?</a></p>
<h4 id="构造方法"><a class="header" href="#构造方法">构造方法</a></h4>
<p>用于对类的成员变量进行初始化。</p>
<p>构造方法的特点：方法名与类名相同；没有返回值。</p>
<p>构造方法同一般方法一样，可以重载；如果一个类没有声明构造方法，则系统会为类添加一个默认构造方法，其方法体为空，访问权限与类相同；如果自己声明了构造方法，则系统就不再添加默认构造方法。</p>
<h5 id="finalize"><a class="header" href="#finalize">finalize</a></h5>
<p><code>finalize()</code>方法在对象被垃圾收集器析构(回收)之前调用，用来清除回收对象，确保一个对象打开的文件被关闭了。</p>
<h4 id="内部类"><a class="header" href="#内部类">内部类</a></h4>
<p>在某个类内部定义的类称为内部类。一个类如同使用其它类一样使用自己的内部类，包括创建内部类的对象并调用其方法。而<strong>内部类拥有对外层类所有字段和方法成员的访问权</strong>。</p>
<p>内部类的访问权限除了默认权限和<code>public</code>外，还可以是<code>protected</code>和<code>private</code>。如果为<code>private</code>，则该内部只能在本类中使用；如果为protected，则外层类、处于同一包中的类及外层类的子类可以访问它。</p>
<p><strong>内部类还可以定义在方法内部</strong>，其作用域仅限于该方法内部。内部类可以在使用的地方，声明的同时使用。</p>
<h3 id="继承"><a class="header" href="#继承">继承</a></h3>
<p>所有的类都是继承于<code>java.lang.Object</code>。当一个类没有声明继承，则默认继承<code>Object</code>。</p>
<p>Java只能进行单继承。</p>
<p>子类可以从父类那里继承非<code>private</code>成员：即子类可以直接访问父类的非private成员，private成员在子类中不可见，仅能通过父类提供的非<code>private</code>成员作为接口间接访问。</p>
<p>子类不继承父类的构造方法。子类在构造方法中使用<code>super</code>关键字调用父类的构造方法对父类的成员进行初始化：</p>
<pre><code class="language-java">super(args);  //出现在构造方法内部的第一行
</code></pre>
<p>如果子类的构造方法中不调用父类的构造方法，则系统会自动调用父类的默认构造方法（如果父类已经声明了构造方法，则需要显式添加默认构造方法，否则不能实现自动调用）。</p>
<p>类成员的初始化过程：</p>
<ol>
<li>
<p>分配内存空间，并将字段单元初始化；</p>
</li>
<li>
<p>使用字段在声明时赋的值，对字段初始化；</p>
</li>
<li>
<p>调用构造函数，在构造函数中，首先对父类进行初始化，再初始化子类字段。</p>
</li>
</ol>
<h4 id="重写覆盖隐藏override"><a class="header" href="#重写覆盖隐藏override">重写/覆盖/隐藏（Override）</a></h4>
<p>在子类中声明的成员与父类的成员完全一致，则父类的成员称为被子类成员隐藏。</p>
<p>一般不推荐对父类的字段进行隐藏，这样会导致类的结构混乱。</p>
<p>进行方法隐藏时，子类声明的方法必须和父类的方法原型一致，而且子类方法的访问限制不能比父类严格（否则就直接访问父类方法了）。</p>
<p>子类不能直接访问到父类的同名方法，通过<code>super</code>关键字访问父类方法。</p>
<p>规则：</p>
<ul>
<li>如果不能继承一个方法，则不能重写这个方法。</li>
<li>访问权限不能比父类中被重写的方法的访问权限更低。</li>
<li>回类型与被重写方法的返回类型可以不相同，但是必须是父类返回值的派生类。</li>
<li>声明为<code>final</code>、<code>static</code>的方法不能被重写</li>
</ul>
<h4 id="抽象类"><a class="header" href="#抽象类">抽象类</a></h4>
<p>使用<code>abstract</code>关键字声明的类（可能并不包含抽象方法）。</p>
<p>如果一个类包含未实现方法，则该类必须被声明为抽象类：</p>
<ul>
<li>
<p>继承的接口未实现的类；</p>
</li>
<li>
<p>包含使用<code>abstract</code>关键字声明的抽象方法的类；</p>
</li>
</ul>
<p>不能被继承的方法，如构造方法，静态方法，不能声明为抽象方法。</p>
<h4 id="接口"><a class="header" href="#接口">接口</a></h4>
<p>接口是<strong>包含若干抽象方法和常量</strong>的一个集合，提供对某一种功能的抽象，使实现接口的类具有统一的外部访问方式。</p>
<pre><code class="language-java">public interface 接口名 [extends 父接口名列表]{
    public static final int CONST_VAR = const_value;
    public abstract [native] int methodName(params)[throw exceptions];
}
</code></pre>
<p>实现接口：首先在类的声明中使用<code>implements</code>添加要实现的接口名，如<a href="Java/JAVA%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80.html#%E7%B1%BB">类的声明格式</a>所示；如果声明继承某接口的类，则接口的所有方法都必须实现，否则该类为抽象类；类在实现接口的方法时，必须保证方法原型与接口中声明的原型一致，否则就成了方法的重载。</p>
<p><strong>接口的方法的访问限制符都限定为<code>public</code>，所以类在实现方法时，也必须使用public修饰符</strong>。</p>
<p>与抽象类相似，不能声明不能被继承的方法，如静态方法；</p>
<p>接口不能包含成员变量，除了<code>static final</code>变量。</p>
<h5 id="标记接口"><a class="header" href="#标记接口">标记接口</a></h5>
<p>标记接口是没有任何方法和字段的接口。</p>
<ul>
<li>向一个类添加数据类型：通过引用多态使该类对象可以作为接口类型引用，供其他代码来测试类型。</li>
<li>建立公共的父接口。</li>
</ul>
<h5 id="函数接口"><a class="header" href="#函数接口">函数接口</a></h5>
<p>An interface with exactly one abstract method is called <em><strong>Functional Interface</strong></em>（可使用<code>@FunctionInterface</code>对接口进行标注，以避免在该接口中声明多个方法）。</p>
<p><code>java.util.function</code></p>
<h3 id="对象引用多态"><a class="header" href="#对象引用多态">对象引用多态</a></h3>
<p>对象引用的多态是指：声明对象的类型不由对象的引用类型（类似于指针）决定，而是由创建对象时调用的构造方法决定。虽然对象本身是确定的，但是因为子类对象可以作为父类对象来引用，所以可以实现对象引用的多态。</p>
<p>引用多态的三个必要条件：继承、重写、父类引用子类对象。</p>
<p>示例：</p>
<pre><code class="language-java">SuperClass sc = new SuperClass();		//父类的引用实际表示父类对象
SuperClass sc1 = new SubClass();			//父类的引用实际表示子类对象
</code></pre>
<h4 id="动态绑定"><a class="header" href="#动态绑定">动态绑定</a></h4>
<p>==通过<strong>父类/接口</strong>引用子类对象的方法时，总是调用子类方法，而非父类同名方法==。区别于C++，C++中只有<strong>虚函数</strong>才具有此性质，否则使用父类指针将访问父类同名函数。也就是说Java中的成员方法具有C++虚函数的性质。如果 Java 中不希望某个方法具有虚函数特性，可以加上<code>final</code>关键字变成非虚函数。</p>
<p>判断一个引用究竟指向那种类的对象可以使用<code>instanceof</code>运算符来进行判断。</p>
<pre><code class="language-java">if (object instanceof ClassName){
    do_something
}
</code></pre>
<p>对象引用多态的使用情形：</p>
<ol>
<li>
<p><strong>参数传递</strong>。当一个函数需要接收的参数可能是某个类的多个子类时，就可将参数声明为父类的引用，实际传参时，则传递实际的子类对象引用。</p>
</li>
<li>
<p><strong>存储</strong>。在存储一系列不同子类的对象时，可以声明一个父类对象的数组进行存储，每个数组元素可以是具体的子类对象。</p>
</li>
<li>
<p><strong>强制类型转换</strong>。虽然将各种子类统一使用父类引用进行管理非常方便，但使用父类的引用就只能访问到子类中父类的成员。如果要访问子类的成员，就需要将父类引用强制转换为子类引用，强制类型转换的前提是引用对象本身必须是转换目标所属的类，这时可以先使用<code>instanceof</code>先判断，再转换。</p>
<pre><code class="language-java">Object [] list = {&quot;abc&quot;, &quot;def&quot;, &quot;ghi&quot;};
for (String str : list){
  // String str = (String)list[i];
  do_some_things;
}
</code></pre>
</li>
</ol>
<h3 id="反射-1"><a class="header" href="#反射-1">反射</a></h3>
<p>https://www.journaldev.com/1789/java-reflection-example-tutorial#invoke-public-method</p>
<p>Poor Performance：动态解析类型</p>
<p><code>java.lang.Class</code>：类的元数据，用于查找类的属性以及创建新的实例。</p>
<h3 id="泛型generic"><a class="header" href="#泛型generic">泛型（Generic）</a></h3>
<p>泛型提供了编译时类型安全检测机制。泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。Java编译器使用<strong>类型擦除</strong>将泛型类型替换为通用类型（例如<code>Object, Comparable</code>）并适当添加类型转换。</p>
<blockquote>
<p>不同于C++模板，编译器不会将泛型类型替换为具体类型，从而不会产生新的类型。</p>
<p><a href="https://www.journaldev.com/1330/java-collections-interview-questions-and-answers#generics-sub-typing">泛型类型不支持类型转换，不能创建泛型数组</a>。</p>
</blockquote>
<h4 id="泛型方法"><a class="header" href="#泛型方法">泛型方法</a></h4>
<pre><code class="language-java">public [static] &lt;T1,T2&gt; void methodName(T1[] data, GenericsType&lt;T2&gt; info)
</code></pre>
<ul>
<li>类型参数声明：在在方法返回类型之前；</li>
<li>类型参数声明可以包含多个类型参数，</li>
<li>类型参数只能代表引用型类型，不能是基本类型。</li>
</ul>
<h5 id="有界类型参数"><a class="header" href="#有界类型参数">有界类型参数</a></h5>
<p>限制被允许传递到一个类型参数的类型种类。</p>
<pre><code class="language-java">public &lt;T extends Type[,...]&gt; void methodName(T[] data)
</code></pre>
<h4 id="泛型类"><a class="header" href="#泛型类">泛型类</a></h4>
<p>在声明的类名后面添加了类型参数声明部分：</p>
<pre><code class="language-java">[modifier] class ClassName &lt;T [extends Type][,...]&gt;{
   public void methodName(T data)
}
</code></pre>
<p>在类的定义中可以使用声明的类型参数来定义字段，或作为方法的参数类型。</p>
<h4 id="类型通配符"><a class="header" href="#类型通配符">类型通配符</a></h4>
<p>类型通配符一般是使用<code>?</code>代替泛型类的具体类型参数，<code>?</code>不需要放在类型参数声明列表中。</p>
<pre><code class="language-java">public static void getData(List&lt;?&gt; data)
public static void getUperNumber(List&lt;? extends Number&gt; data)
public static void getUperNumber(List&lt;? super Number&gt; data)
</code></pre>
<p><code>extends</code>定义类型参数的上限（该类及其子类）；<code>super</code>定义类型的下限（该类及其父类）。</p>
<p>在使用类型通配符具体化类型作为参数的方法中，仅使用泛型类提供的公共方法，而不使用具体类型相关的方法。</p>
<p>https://docs.oracle.com/javase/tutorial/extra/generics/index.html.</p>
<p><a href="https://www.journaldev.com/1663/java-generics-example-method-class-interface">Java Generics Example Tutorial - Generic Method, Class, Interface - JournalDev</a></p>
<h3 id="java包简介"><a class="header" href="#java包简介">Java包简介</a></h3>
<div class="table-wrapper"><table><thead><tr><th>类库</th><th>简介</th></tr></thead><tbody>
<tr><td><code>java.io</code></td><td>提供系统的输入输出，包括各类输入输出流。</td></tr>
<tr><td><code>java.lang</code></td><td>Java语言的基础，包括对基本数据类型的封装，以及<code>Math</code>、<code>Process</code>、<code>Thread</code>等类。<code>java.lang</code>包默认加载到所有的Java程序的。</td></tr>
<tr><td><code>java.net</code></td><td>提供Java访问网络的功能，包括对TCP/UDP套接字的封装以及对应用层协议的封装。</td></tr>
<tr><td><code>java.util</code></td><td>包括了容器框架的接口和类，日期和时间的处理，事件模型以及其他功能（随机数发生、字符串格式化等）。</td></tr>
<tr><td><code>java.applet</code></td><td>提供创建Java Applet程序所必要的类。</td></tr>
<tr><td><code>java.awt</code></td><td>提供图形界面编程的类和接口。</td></tr>
</tbody></table>
</div>
<h2 id="异常处理-2"><a class="header" href="#异常处理-2">异常处理</a></h2>
<h3 id="异常分类"><a class="header" href="#异常分类">异常分类</a></h3>
<p>所有的异常类是从<code>java.lang.Exception</code>类继承的子类。<code>Exception</code>类是<code>Throwable</code>类的子类。除了<code>Exception</code>类外，<code>Throwable</code>还有一个子类<code>Error</code>。</p>
<p><img src="Java/JAVA%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80.assets/exception-hierarchy.png.webp" alt="java exception hierarchy" /></p>
<p><a href="https://www.journaldev.com/1696/exception-handling-in-java">Exception Handling in Java - JournalDev</a></p>
<h3 id="处理异常"><a class="header" href="#处理异常">处理异常</a></h3>
<p>使用<a href="Java/JAVA%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80.html#try-catch-finally">try-catch</a>语句捕获异常。</p>
<p>使用捕获的异常对象，获取异常信息：</p>
<pre><code class="language-java">String getMessage()   // 关于发生的异常的详细信息
String toString()     // 返回异常类的名字
Throwable getCause()  // 异常原因
void printStackTrace() // 
</code></pre>
<p>抛出异常：</p>
<p>如果一个方法存在未捕获的异常，则方法的声明需要使用<code>throws</code>关键字来给出未处理异常列表。</p>
<pre><code class="language-java">public void method(···) throws XxxException, YyyException
</code></pre>
<p>在方法内部可以使用<code>throw</code>关键字抛出一个捕获到的异常或新实例化的异常。</p>
<h3 id="自定义异常"><a class="header" href="#自定义异常">自定义异常</a></h3>
<p>所有异常都必须是 Throwable 的子类。</p>
<p>如果希望写一个<em>检查性异常类</em>，则需要继承 Exception 类。</p>
<p>如果你想写一个<em>运行时异常类</em>，那么需要继承 RuntimeException 类。</p>
<h2 id="设计模式"><a class="header" href="#设计模式">设计模式</a></h2>
<p><a href="https://www.journaldev.com/1827/java-design-patterns-example-tutorial">==Java Design Patterns== - Example Tutorial - JournalDev</a></p>
<h2 id="参考文献-5"><a class="header" href="#参考文献-5">参考文献</a></h2>
<ol>
<li><a href="https://docs.oracle.com/javase/specs/jls/se14/jls14.pdf">The Java Language Specification, Java SE 14 Edition</a>.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="java编程-1"><a class="header" href="#java编程-1">JAVA编程</a></h1>
<p>Java语言不使用指针，而是引用。</p>
<h2 id="java程序-1"><a class="header" href="#java程序-1">Java程序</a></h2>
<h3 id="编写-1"><a class="header" href="#编写-1">编写</a></h3>
<h4 id="代码结构-1"><a class="header" href="#代码结构-1">代码结构</a></h4>
<p>一个<code>*.java</code>文件可以包含多个类的定义：</p>
<ul>
<li>只能有一个<code>public</code>类/接口，源文件名与<code>public</code>类名相同；</li>
</ul>
<h5 id="打包声明-1"><a class="header" href="#打包声明-1">打包声明</a></h5>
<p>包用于描述代码的逻辑组织结构（类似于C#的命名空间）：</p>
<ul>
<li>
<p>把功能相似或相关的类或接口组织在同一个包中，方便类的查找和使用</p>
</li>
<li>
<p>并防止命名冲突。</p>
</li>
</ul>
<p>如果一个public类要包含在某个包内，需要在代码的第一行使用<code>package</code>关键字进行声明。</p>
<pre><code class="language-java">package org.develop.app;
</code></pre>
<p>在指定的源代码根目录下，<strong>层级的打包声明也对应源代码（编译输出字节码）文件树目录结构</strong>。</p>
<blockquote>
<p>不同类型项目的源文件根目录设置可能不同，例如<a href="https://stackoverflow.com/questions/3004710/what-is-the-advantage-of-the-src-main-java-convention">Maven项目的源代码根目录</a>为<code>src/main/java</code>，则上述源代码对应的路径为<code>src\main\java\org\develop\App.java</code>。</p>
</blockquote>
<h5 id="导入包声明-1"><a class="header" href="#导入包声明-1">导入包声明</a></h5>
<p>为了使用外部代码（例如Java库），源文件文件中可以导入（<code>import</code>）外部依赖包的内容。</p>
<p>导入语句位于打包语句之后。</p>
<pre><code class="language-java">import java.io.*;		// import all
import java.io.File;	// import single class
</code></pre>
<p>包具有层级嵌套结构，导入声明仅能引用当前层级包中的类，而不能引用下一层级的包中的类（需要单独声明）。</p>
<h5 id="模块系统java-9-1"><a class="header" href="#模块系统java-9-1">模块系统（Java 9）</a></h5>
<p>同一个<code>jar</code>文件中的<code>.class</code>文件并没有依赖关系限制；模块则附加依赖关系，还可包含二进制代码。</p>
<pre><code class="language-shell">oop-module
├── bin                           # 存放编译后的class文件
├── build.sh
└── src                           # 源码：按包名的目录结构存放
    ├── com
    │   └── hello
    │       └── world
    │           ├── Greeting.java
    │           └── Main.java
    └── module-info.java          # 模块的描述文件，包含依赖声明
</code></pre>
<p>在Java代码中仅能引用模块描述文件中声明的依赖库。</p>
<pre><code class="language-java">module hello.world {
   requires java.base;       // 可不写，任何模块都会自动引入java.base
   requires java.xml;
   exports com.hello.world;  // 只有声明导出的包，外部代码才能问。(进一步隔离了代码的访问权限)
}
</code></pre>
<blockquote>
<p><code>java --list-modules</code>显示JDK自带模块。
<code>java -d,describe-module module_name</code>显示模块的描述信息。</p>
</blockquote>
<h3 id="执行java程序-1"><a class="header" href="#执行java程序-1">执行Java程序</a></h3>
<h4 id="编译-1"><a class="header" href="#编译-1">编译</a></h4>
<p>Java程序被<a href="Java/Java%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83.html#%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7">编译</a>为字节码格式（<code>*.class</code>文件）。在运行时，Java平台中的Java解释器对这些字节码进行解释执行，执行过程中需要的类在联接阶段被载入到运行环境中。</p>
<h4 id="运行-1"><a class="header" href="#运行-1">运行</a></h4>
<p>Java应用程序是由若干类定义组成的独立的解释型程序，其中必须有一个包含Main方法的主类；执行Java应用程序时，需要使用Java解释器（<code>java.exe</code>）来执行这个主类的字节码文件（<code>.class</code>）。</p>
<pre><code class="language-shell">java App.java                                  # 直接编译执行源文件
java [options] -jar package-name.jar [args...] # 执行jar包中包含Main方法的class文件
java [options] -cp &lt;classpath&gt; package.ClassName [args...] # 指定搜索路径下的class
</code></pre>
<p><code>package.ClassName</code>：程序执行时应该执行入口函数所在的类，解释器在<a href="Java/JAVA%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80.html#%E7%B1%BB%E6%90%9C%E7%B4%A2%E8%B7%AF%E5%BE%84">搜索路径</a>下寻找指定类。Java应用程序的入口函数为类中的名为<code>Main</code>的<a href="Java/JAVA%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80.html#%E6%96%B9%E6%B3%95">静态方法</a>。使用<code>-jar</code>选项执行时，<code>jar</code>包中需要在<code>manifest</code>中声明主类。</p>
<blockquote>
<p><code>--dry-run</code>：创建VM并加载主类，但不执行主方法。用于验证命令行参数是否有效。</p>
<p>Java小程序（Java Applet）的源代码编辑与字节码编译生成过程与Java应用程序相同，但它不是一类可独立运行的程序。<strong>Applet程序的字节码</strong>文件必须嵌入到HTML文件中并由负责解释HTML文件的浏览器充当其解释器。将Java Applet引入HTML中，使得网页能够提供动态信息。Java小程序与Java应用程序最大不同在于Applet不需要<code>Main</code>方法，而要求程序中必须有且只有一个类是<code>Applet</code>类的子类。系统类<code>Applet</code>类中已经定义了许多成员，它们规定了<code>Applet</code>如何与执行它的解释器——浏览器配合工作。</p>
</blockquote>
<h4 id="java环境变量-1"><a class="header" href="#java环境变量-1">Java环境变量</a></h4>
<pre><code class="language-shell">-D&lt;name&gt;=&lt;value&gt;  # 系统属性(system.Properties),传递应用程序
-X                # 输出所有`-X`（extra）虚拟机选项的名称；
</code></pre>
<h5 id="java虚拟机选项-1"><a class="header" href="#java虚拟机选项-1">Java虚拟机选项</a></h5>
<p><code>-Xms</code>：Java虚拟机的初始<a href="http://docs.oracle.com/cd/E13150_01/jrockit_jvm/jrockit/geninfo/diagnos/garbage_collect.html">堆内存分配量</a>，例如<code>-Xms256m</code>；单位包括：<code>k,m,g,...</code>。</p>
<p><code>-Xmx</code>：JVM最大堆内存分配量，例如<code>-Xmx2048m</code>，通常默认值为<code>256m</code>；如果超过最大内存分配限制，程序将触发<code>java.lang.OutOfMemoryError</code>异常。</p>
<h5 id="java系统属性-1"><a class="header" href="#java系统属性-1">Java系统属性</a></h5>
<h4 id="路径-2"><a class="header" href="#路径-2">路径</a></h4>
<h5 id="当前路径-1"><a class="header" href="#当前路径-1">当前路径</a></h5>
<p>执行Java程序时所在的工作目录。</p>
<h5 id="类搜索路径-1"><a class="header" href="#类搜索路径-1">类搜索路径</a></h5>
<p>Java解释器需要在搜索路径<code>CLASSPATH</code>中寻找<code>.class</code>文件进行执行。==类文件（<code>*.class</code>）可能位于文件夹、<code>jar</code>文件或<code>zip</code>文件==，使用以下选项添加搜索路径。</p>
<pre><code class="language-shell">-{cp,class-path,classpath} libpath1:libpath2/*:lib3.jar:...
</code></pre>
<p>特别地，==如果文件夹以<code>/*</code>结尾，那么该文件夹下的所有<code>jar/zip</code>文件都会被加入搜索路径==。</p>
<blockquote>
<p>JVM自带的标准库<code>rt.jar</code>不要写到<code>CLASSPATH</code>中，写了反而会干扰JVM的正常运行。<code>*</code>不能视为通配符，因此<code>*.jar</code>的写法将无效且造成错误。</p>
</blockquote>
<h5 id="连接动态库-1"><a class="header" href="#连接动态库-1">连接动态库</a></h5>
<p>如果程序依赖共享库（JNI），而不能定位，则会引发<code>java.lang.UnsatisfiedLinkError</code>。</p>
<p>使用<code>-Djava.library.path=/your/lib/path</code>选项指定。</p>
<p>另一种方法是在执行程序之前（或加入<code>/etc/profit</code>）设置环境变量 <code>LD_LIBRARY_PATH</code>。</p>
<blockquote>
<p>不建议修改共享库搜索路径。如果使用的共享库在系统中存在其他版本，可能影响程序使用的共享库版本，使程序出错（<code>ImportError: tensorflow/python/_pywrap_tensorflow_internal.so: undefined symbol</code>）。</p>
</blockquote>
<pre><code class="language-shell">export LD_LIBRARY_PATH=:~/Workspace/lib/java/tensorflow/
</code></pre>
<h5 id="模块搜索路径-1"><a class="header" href="#模块搜索路径-1">模块搜索路径</a></h5>
<pre><code class="language-shell">-p,--module-path &lt;module path&gt; path1:path2:...
</code></pre>
<h2 id="语法-1"><a class="header" href="#语法-1">语法</a></h2>
<p>标识符大小写敏感。命名规则：</p>
<ul>
<li>类名：单词首字母大写；</li>
<li>方法名：首字母小写，其余单词首字母大写；</li>
</ul>
<h3 id="注释和文档-3"><a class="header" href="#注释和文档-3">注释和文档</a></h3>
<p>注释：</p>
<ul>
<li>使用<code>//</code>或<code>/*...*/</code>添加单行注释；</li>
<li>使用<code>/*...*/</code>添加多行注释。</li>
</ul>
<h4 id="文档化注释-1"><a class="header" href="#文档化注释-1">文档化注释</a></h4>
<pre><code class="language-java">/**
* &lt;h1&gt;Find average of three numbers!&lt;/h1&gt; 
* &lt;p&gt;The FindAvg program implements an application that 
* simply calculates average of three integers and Prints 
* the output on the screen. &lt;/p&gt;
*
* @param parameter_name description 	[Parameters” section]
* @return description					[“Returns” section]
* @exception ExceptionClass				[Throws subheading]
* @author Author Name
* @version version						[“Version” subheading]
* @since release-date					[“Since” subheading]
* @see reference 						[See Also” heading]
* @deprecated Indicating Deprecated components
* {@link package.class#member label}
* {@code text}
*/
</code></pre>
<p>使用<code>javadoc</code>生成格式化文档。</p>
<pre><code class="language-sh">javadoc Program.java
</code></pre>
<p>https://www.geeksforgeeks.org/comments-in-java/</p>
<p>https://www.oracle.com/technetwork/java/javase/documentation/index-137868.html</p>
<h4 id="标注annotation-1"><a class="header" href="#标注annotation-1">标注（Annotation）</a></h4>
<p>标注以<code>@</code>开始，用于辅助程序元素与元信息的关联，并控制编译器的行为，但对编译后的程序不起作用。</p>
<pre><code class="language-java">@MarkerAnnotation
@SingleValueAnnotation(&quot;info&quot;)
@FullAnnotation(key1=&quot;value1&quot;,key2=&quot;value2&quot;)
</code></pre>
<p>预定义标注：</p>
<pre><code class="language-java">import java.lang.annotations.*;
@Deprecated		// indicate an oboslated declaration
@Override		// must override a method from superclass
@SuppressWarnings({&quot;checked&quot;, &quot;deprecation&quot;}) // 参数可为空
@FunctionalInterface
@SafeVarargs   // 标注的方法不会对可变参数执行不安全操作
</code></pre>
<p>标注可用于类、方法、语句等的开头（上一行），<code>for</code>语句等的条件语句的开头。</p>
<p>自定义标注，类似于定义接口（使用<code>@interface</code>关键字），自定义标注本身还可添加标注信息（<em><strong>meta annotations</strong></em>）：</p>
<pre><code class="language-java">@Documented                         // 添加所定义标注的元素信息文档化（javadoc etc.）
@Target(ElementType.METHOD)         // 标注的目标TYPE, METHOD, FIELD...
@Inherited                          // 子类是否继承父类元素的该标注
@Retention(RetentionPolicy.RUNTIME) // === SOURCE,CLASS, RUNTIME
@Repeatable                         // 该标注是否可重复声明
public @interface MethodInfo{
   String author() default &quot;gary&quot;;  // 方法不能包含参数
   int revision() default 1;        // 方法返回值仅限基本类型
}
</code></pre>
<p><a href="https://www.journaldev.com/721/java-annotations">Java Annotations - JournalDev</a></p>
<p>https://www.geeksforgeeks.org/annotations-in-java/</p>
<h3 id="变量声明-1"><a class="header" href="#变量声明-1">变量声明</a></h3>
<p>变量在使用前必须声明：</p>
<pre><code class="language-java">type var_name[ = value, var_name2[ = value]...];
</code></pre>
<p>变量根据作用域可分为：类变量（静态字段）、实列变量（<a href="Java/JAVA%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80.html#%E5%AD%97%E6%AE%B5">字段</a>）和局部变量。</p>
<p>局部变量是<em>在栈上分配</em>的，在所在作用域（方法、代码块）被执行时创建，执行完即被销毁。</p>
<p><strong>局部变量没有默认值，所以局部变量被声明后，必须经过初始化，才可以使用。</strong></p>
<h3 id="流程控制-3"><a class="header" href="#流程控制-3">流程控制</a></h3>
<h3 id="条件-3"><a class="header" href="#条件-3">条件</a></h3>
<pre><code class="language-java">if(condition){
  
}else if (condition){
  
}else{
  
}
</code></pre>
<h4 id="循环-3"><a class="header" href="#循环-3">循环</a></h4>
<h5 id="while-1"><a class="header" href="#while-1">while</a></h5>
<pre><code class="language-java">while (condition){
    do_something;
}
</code></pre>
<p>赋值语句的返回值可作为条件语句，例如：<code>(line = reader.readLine()) != null</code>（<code>null</code>本身不能直接作为条件语句）。</p>
<h5 id="do-while-1"><a class="header" href="#do-while-1">do-while</a></h5>
<pre><code class="language-java">do{
	do_something;
}while(true);
</code></pre>
<h5 id="for-1"><a class="header" href="#for-1">for</a></h5>
<pre><code class="language-java">for(int i=0; i&lt;len; ++i){
    do_something;
}
</code></pre>
<p>增强<code>for</code>循环，结合迭代器。</p>
<pre><code class="language-java">for(String name : names){
   do_something;
}
</code></pre>
<h5 id="stream-api-1"><a class="header" href="#stream-api-1">Stream API</a></h5>
<p>定义对元素的计算函数，由Stream框架执行内部迭代，从而实现并行计算、过滤、映射等功能特性。</p>
<p><a href="https://www.journaldev.com/2774/java-8-stream">Java 8 Stream - Java Stream - JournalDev</a></p>
<pre><code class="language-java">return list.stream().filter(x -&gt; x &gt; 10).mapToInt(x -&gt; x).sum();
</code></pre>
<h4 id="switch-case-1"><a class="header" href="#switch-case-1">switch-case</a></h4>
<pre><code class="language-java">switch(expr){
    case const_val1:
        statements;
        break;
    case const_val2:
    case const_val3:
        statements;
        break;
    default:
        statements;
}
</code></pre>
<p>说明：</p>
<ol>
<li>变量类型可以是：<code>byte</code>、<code>short</code>、<code>int</code>、<code>char</code>以及<code>string</code>（Java 7）;</li>
<li><code>case</code>语句的值为<strong>常量</strong>或<strong>字面值常量</strong>；</li>
</ol>
<h4 id="try-catch-finally-1"><a class="header" href="#try-catch-finally-1">try-catch-finally</a></h4>
<p>用于<a href="Java/JAVA%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80.html#%E5%A4%84%E7%90%86%E5%BC%82%E5%B8%B8">处理程序异常</a>的控制结构。</p>
<pre><code class="language-java">try {
	do_something;
} catch (ExceptionTypeA | ExceptionTypeB e) {
	handle_exception;
} finally {
	clean_work;
}
</code></pre>
<h4 id="try-with-resource-1"><a class="header" href="#try-with-resource-1">try-with-resource</a></h4>
<p>简化资源关闭与异常处理流程（Java 7）。</p>
<pre><code class="language-java">try (open_resources){
	do_something;
}
catch(exception e){
	handle_exception;
}
</code></pre>
<p>为了能够配合<code>try-with-resource</code>，资源必须实现<code>AutoClosable</code>接口。</p>
<h3 id="运算符-5"><a class="header" href="#运算符-5">运算符</a></h3>
<h5 id="instanceof-1"><a class="header" href="#instanceof-1">instanceof</a></h5>
<p>检查该对象是否是一个特定类型（类类型或接口类型）</p>
<pre><code class="language-java">Object instanceof ClassName
</code></pre>
<h3 id="函数-3"><a class="header" href="#函数-3">函数</a></h3>
<h4 id="lambda表达式匿名函数-1"><a class="header" href="#lambda表达式匿名函数-1">Lambda表达式（匿名函数）</a></h4>
<p>使用Lambda表达式：可减少代码量，传递函数作为参数，在使用时定义函数。</p>
<pre><code class="language-java">(args)-&gt;{statements} // 参数和方法内容均可省略，单语句可省略&quot;{}&quot;
</code></pre>
<blockquote>
<p>无返回值的方法体以最后语句的返回值作为方法的返回值。</p>
<p>参数类型可==同时==省略（自动推断）。</p>
</blockquote>
<h4 id="方法引用java-8-1"><a class="header" href="#方法引用java-8-1">方法引用（Java 8）</a></h4>
<h2 id="面向对象的编程-1"><a class="header" href="#面向对象的编程-1">面向对象的编程</a></h2>
<p>Java中所有内容均包含在类的定义中。</p>
<h3 id="类与对象-1"><a class="header" href="#类与对象-1">类与对象</a></h3>
<pre><code class="language-java">[public] [modifier] class ClassName [extends BaseClass][implements Interfaces,...]{
   [protected] [modifier] int PropertyName [= value];
   [public] ClassName(int param,...) throw exceptions{
      super(param,...)
         do_initialization;
   }
   [private] [modifer] void methodName(int param,...)throw exceptions{
      statements;
      this.another_method(param,...);
      super.base_method(param,...);
   }
   public int static main(String[] args){
      ClassName c = new ClassName(...);
   }
   protected class InternalClass{
      class_definitions;
   }
}
</code></pre>
<p>使用<code>new</code>关键字创建对象。创建对象时将调用类的<a href="Java/JAVA%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80.html#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95">构造方法</a>。</p>
<p><strong>注意</strong>：类的实例都是通过引用来使用的，使用<code>new</code>创建的对象都会在内存中开辟独立的空间，两个对象即使内容相同，但是在内存中的地址不同，所以<strong>如果使用<code>==</code>进行比较，会得到<code>false</code>；但是使用类的方法<code>equals</code>比较两个实例的内容</strong>。使用对象相互赋值的方法，则只是复制了对象的引用，并没有开辟新空间，所以两者指向同样的区域。==对于字符串来说，如果直接将带引号的字符串赋值给两个字符串对象，则由于Java处理字符串的特性，两个对象将指向内存中的同一位置（内存中的特殊区域String Pool），使用==<code>==</code>==也会返回<code>true</code>==。</p>
<p>类的成员包括方法和字段。在类内部可直接通过名称访问成员。当成员名称与参数名或局部变量重名时，使用<code>this</code>关键字访问成员。<em><code>this</code>还可用于在构造方法内部引用该类的其他构造方法（只能出现在构造方法内部的第一行，即只能调用一次）。</em></p>
<h4 id="修饰符-2"><a class="header" href="#修饰符-2">修饰符</a></h4>
<h5 id="访问控制-1"><a class="header" href="#访问控制-1">访问控制</a></h5>
<ul>
<li>
<p><code>public</code>：这个类可以被其他所有类访问和引用，只能被定义在同名文件中。</p>
</li>
<li>
<p><em>default</em>：即没有访问控制符修饰，这样的类只能被同一个包内的类引用，而对其他包内的类不可见。</p>
</li>
<li>
<p><code>protected</code>：</p>
</li>
<li>
<p><code>private</code>：只用于内部类。</p>
</li>
</ul>
<h5 id="其他-2"><a class="header" href="#其他-2">其他</a></h5>
<ul>
<li><code>abstract</code>：抽象类，<strong>不能直接被实例化的类，但是可以声明对象的引用</strong>，只是声明的对象引用默认值都是<code>null</code>，必须使用可实例化的子类的构造函数对其赋值。抽象类内部可以包含任意个抽象方法，也可以包含构造方法、字段和实体方法。</li>
<li><code>final</code>：不能被继承的类。</li>
</ul>
<h4 id="字段-1"><a class="header" href="#字段-1">字段</a></h4>
<p>字段（Fields，属性Attributes）是类内部定义的<a href="Java/JAVA%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80.html#%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E">变量</a>。</p>
<h5 id="访问控制修饰符-1"><a class="header" href="#访问控制修饰符-1">访问控制修饰符</a></h5>
<ul>
<li><code>public</code>: 允许任何位置对字段的访问。由于具有默认访问权限的类本身只能被同一包内的成员所访问，所以这种类中的成员即使具有<code>public</code>权限也只能被同一包内的其他类访问。</li>
<li><em>default</em>：同一个包内的位置可对字段进行访问。</li>
<li><code>protected</code>：允许该类及其子类中对该字段进行访问。</li>
<li><code>private</code>：允许在该类内部对该字段进行访问。访问控制是针对类而言的，而并非针对具体实例而言，即同一个类的不同实例可以互相访问它们的私有成员。<em>而通过继承关系生成的子类，其新定义的方法则不能访问父类的私有成员，但继承自父类的成员函数因为本来可以访问父类成员，所以在子类中仍然可以访问父类成员。</em></li>
</ul>
<h5 id="其他修饰符-1"><a class="header" href="#其他修饰符-1">其他修饰符</a></h5>
<ul>
<li>
<p><code>static</code>：同一个类所有的实例共享静态字段。</p>
<p>静态成员不属于对象，所以推荐使用类名来访问静态成员（在类内部可直接使用字段名）。</p>
<pre><code class="language-java">ClassName.StaticProperty;
</code></pre>
<p>由于静态字段从属于类，而不属于实例，所以不能用构造函数进行初始化。同时由于除了通过在声明字段时对字段赋初值，还可以通过<strong>静态代码块</strong>对静态字段进行初始化。</p>
<pre><code class="language-java">static{ initialize-statements; }
</code></pre>
</li>
<li>
<p><code>final</code>：常量字段，通常用<strong>大写字母作为常量标识符</strong>。</p>
</li>
<li>
<p><code>transient</code>：<a href="Java/JAVA%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80.html#%E5%AF%B9%E8%B1%A1%E5%BA%8F%E5%88%97%E5%8C%96">序列化</a>对象时，跳过该类变量。</p>
</li>
<li>
<p><code>volatile</code>：在每次被线程访问时，都强制从共享内存中重新读取该成员变量的值。而且，当成员变量发生变化时，会强制线程将变化值回写到共享内存。这样在任何时刻，两个不同的线程总是看到某个成员变量的同一个值。</p>
</li>
</ul>
<h4 id="方法-2"><a class="header" href="#方法-2">方法</a></h4>
<p>方法的访问控制与字段一致。</p>
<h5 id="修饰符-3"><a class="header" href="#修饰符-3">修饰符</a></h5>
<ul>
<li>
<p><code>abstract</code>：只有函数声明（declaration/signature），而没有函数体。具有抽象方法的类即抽象类。抽象类的类必须重载这些抽象方法才能实例化，否则子类也必须声明为抽象类。</p>
</li>
<li>
<p><code>final</code>：不能被类的子类重写。</p>
</li>
<li>
<p><code>static</code>：静态方法，只能访问和修改类的静态成员，通过类名调用。</p>
<pre><code class="language-java">ClassName.StaticMethod(args);
</code></pre>
<p>名为<code>main</code>的静态方法可作为Java程序的入口函数。</p>
<pre><code class="language-java">public static void main(String[] args)   // args not contain program name
</code></pre>
<blockquote>
<p>主函数无须返回值（<code>return</code>）。由于程序由<code>java</code>解释器执行，因此从主函数返回值并不能被shell接收。<code>java</code>解释器将获取由<code>System.exit(value)</code>返回的值，并返回给shell。</p>
</blockquote>
</li>
<li>
<p><code>synchronized</code>：方法同一时间只能被一个线程访问。</p>
</li>
</ul>
<h5 id="方法重载overload-1"><a class="header" href="#方法重载overload-1">方法重载（Overload）</a></h5>
<p>重载的方法必须拥有不同的参数列表。不能仅依据修饰符或者返回类型的不同来重载方法。</p>
<h5 id="可变参数-1"><a class="header" href="#可变参数-1">可变参数</a></h5>
<p>一个方法中只能指定一个可变参数，它必须是方法的最后一个参数，在参数类型后加一个省略号(...)。</p>
<pre><code class="language-java">public static void printMax( double... numbers)
</code></pre>
<h4 id="命令行参数解析-1"><a class="header" href="#命令行参数解析-1">命令行参数解析</a></h4>
<h5 id="picocli-1"><a class="header" href="#picocli-1">picocli</a></h5>
<p>可以通过外部依赖或源代码（<code>CommandLine.java</code>）的方式使用。以下为通过Maven配置依赖项。</p>
<pre><code class="language-xml">&lt;dependency&gt;
  &lt;groupId&gt;info.picocli&lt;/groupId&gt;
  &lt;artifactId&gt;picocli&lt;/artifactId&gt;
  &lt;version&gt;4.2.0&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>启用<strong>Annotation Processor</strong>：</p>
<pre><code class="language-xml">&lt;plugin&gt;
  &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
  &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;
  &lt;version&gt;3.5.0&lt;/version&gt; &lt;!-- 3.5 or higher --&gt;
  &lt;configuration&gt;
    &lt;annotationProcessorPaths&gt;
      &lt;path&gt;
        &lt;groupId&gt;info.picocli&lt;/groupId&gt;
        &lt;artifactId&gt;picocli-codegen&lt;/artifactId&gt;
        &lt;version&gt;4.2.0&lt;/version&gt;
      &lt;/path&gt;
    &lt;/annotationProcessorPaths&gt;
    &lt;compilerArgs&gt;
      &lt;arg&gt;-Aproject=${project.groupId}/${project.artifactId}&lt;/arg&gt;
    &lt;/compilerArgs&gt;
  &lt;/configuration&gt;
&lt;/plugin&gt;
</code></pre>
<p>示例代码：</p>
<pre><code class="language-java">@Command(name=&quot;App&quot;, version=&quot;v1.0.0&quot;, header=&quot;Example App.&quot;)
class Tar {
    @Option(names=&quot;-c&quot;, description=&quot;create a new archive&quot;)
    boolean create;
    @Option(names={&quot;-f&quot;,&quot;--file&quot;}, paramLabel=&quot;ARCHIVE&quot;, ...)
    File archive;
    @Parameters(paramLabel=&quot;FILES&quot;, description = &quot;one ore more files...&quot;)
    File[] files;  // all positional arguments
    @Option(names = { &quot;-h&quot;, &quot;--help&quot; }, usageHelp = true, ...)
    private boolean helpRequested = false;
    @Parameters(index = &quot;0&quot;)   // index=&quot;2-4&quot;, index=&quot;3-*&quot;
    String command = &quot;save&quot;;   // first  positional arguments
    public static void main(String args){
        Tar tar = new Tar();
        new CommandLine(tar).parseArgs(args);
        if (tar.helpRequested){
            CommandLine.usage(app, System.out);
            System.exit(0);
        }
    }
}
</code></pre>
<h5 id="commoncli-1"><a class="header" href="#commoncli-1">CommonCLI</a></h5>
<p><a href="https://commons.apache.org/proper/commons-cli/index.html"><strong>Commons CLI</strong></a> https://commons.apache.org/proper/commons-cli/usage.html</p>
<p><a href="https://picocli.info/"><strong>picocli</strong> - a mighty tiny command line interface</a></p>
<p><a href="http://jcommander.org/">jcommander</a></p>
<p><a href="https://stackoverflow.com/questions/367706/how-do-i-parse-command-line-arguments-in-java">How do I parse command line arguments in Java?</a></p>
<h4 id="构造方法-1"><a class="header" href="#构造方法-1">构造方法</a></h4>
<p>用于对类的成员变量进行初始化。</p>
<p>构造方法的特点：方法名与类名相同；没有返回值。</p>
<p>构造方法同一般方法一样，可以重载；如果一个类没有声明构造方法，则系统会为类添加一个默认构造方法，其方法体为空，访问权限与类相同；如果自己声明了构造方法，则系统就不再添加默认构造方法。</p>
<h5 id="finalize-1"><a class="header" href="#finalize-1">finalize</a></h5>
<p><code>finalize()</code>方法在对象被垃圾收集器析构(回收)之前调用，用来清除回收对象，确保一个对象打开的文件被关闭了。</p>
<h4 id="内部类-1"><a class="header" href="#内部类-1">内部类</a></h4>
<p>在某个类内部定义的类称为内部类。一个类如同使用其它类一样使用自己的内部类，包括创建内部类的对象并调用其方法。而<strong>内部类拥有对外层类所有字段和方法成员的访问权</strong>。</p>
<p>内部类的访问权限除了默认权限和<code>public</code>外，还可以是<code>protected</code>和<code>private</code>。如果为<code>private</code>，则该内部只能在本类中使用；如果为protected，则外层类、处于同一包中的类及外层类的子类可以访问它。</p>
<p><strong>内部类还可以定义在方法内部</strong>，其作用域仅限于该方法内部。内部类可以在使用的地方，声明的同时使用。</p>
<h3 id="继承-1"><a class="header" href="#继承-1">继承</a></h3>
<p>所有的类都是继承于<code>java.lang.Object</code>。当一个类没有声明继承，则默认继承<code>Object</code>。</p>
<p>Java只能进行单继承。</p>
<p>子类可以从父类那里继承非<code>private</code>成员：即子类可以直接访问父类的非private成员，private成员在子类中不可见，仅能通过父类提供的非<code>private</code>成员作为接口间接访问。</p>
<p>子类不继承父类的构造方法。子类在构造方法中使用<code>super</code>关键字调用父类的构造方法对父类的成员进行初始化：</p>
<pre><code class="language-java">super(args);  //出现在构造方法内部的第一行
</code></pre>
<p>如果子类的构造方法中不调用父类的构造方法，则系统会自动调用父类的默认构造方法（如果父类已经声明了构造方法，则需要显式添加默认构造方法，否则不能实现自动调用）。</p>
<p>类成员的初始化过程：</p>
<ol>
<li>
<p>分配内存空间，并将字段单元初始化；</p>
</li>
<li>
<p>使用字段在声明时赋的值，对字段初始化；</p>
</li>
<li>
<p>调用构造函数，在构造函数中，首先对父类进行初始化，再初始化子类字段。</p>
</li>
</ol>
<h4 id="重写覆盖隐藏override-1"><a class="header" href="#重写覆盖隐藏override-1">重写/覆盖/隐藏（Override）</a></h4>
<p>在子类中声明的成员与父类的成员完全一致，则父类的成员称为被子类成员隐藏。</p>
<p>一般不推荐对父类的字段进行隐藏，这样会导致类的结构混乱。</p>
<p>进行方法隐藏时，子类声明的方法必须和父类的方法原型一致，而且子类方法的访问限制不能比父类严格（否则就直接访问父类方法了）。</p>
<p>子类不能直接访问到父类的同名方法，通过<code>super</code>关键字访问父类方法。</p>
<p>规则：</p>
<ul>
<li>如果不能继承一个方法，则不能重写这个方法。</li>
<li>访问权限不能比父类中被重写的方法的访问权限更低。</li>
<li>回类型与被重写方法的返回类型可以不相同，但是必须是父类返回值的派生类。</li>
<li>声明为<code>final</code>、<code>static</code>的方法不能被重写</li>
</ul>
<h4 id="抽象类-1"><a class="header" href="#抽象类-1">抽象类</a></h4>
<p>使用<code>abstract</code>关键字声明的类（可能并不包含抽象方法）。</p>
<p>如果一个类包含未实现方法，则该类必须被声明为抽象类：</p>
<ul>
<li>
<p>继承的接口未实现的类；</p>
</li>
<li>
<p>包含使用<code>abstract</code>关键字声明的抽象方法的类；</p>
</li>
</ul>
<p>不能被继承的方法，如构造方法，静态方法，不能声明为抽象方法。</p>
<h4 id="接口-1"><a class="header" href="#接口-1">接口</a></h4>
<p>接口是<strong>包含若干抽象方法和常量</strong>的一个集合，提供对某一种功能的抽象，使实现接口的类具有统一的外部访问方式。</p>
<pre><code class="language-java">public interface 接口名 [extends 父接口名列表]{
    public static final int CONST_VAR = const_value;
    public abstract [native] int methodName(params)[throw exceptions];
}
</code></pre>
<p>实现接口：首先在类的声明中使用<code>implements</code>添加要实现的接口名，如<a href="Java/JAVA%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80.html#%E7%B1%BB">类的声明格式</a>所示；如果声明继承某接口的类，则接口的所有方法都必须实现，否则该类为抽象类；类在实现接口的方法时，必须保证方法原型与接口中声明的原型一致，否则就成了方法的重载。</p>
<p><strong>接口的方法的访问限制符都限定为<code>public</code>，所以类在实现方法时，也必须使用public修饰符</strong>。</p>
<p>与抽象类相似，不能声明不能被继承的方法，如静态方法；</p>
<p>接口不能包含成员变量，除了<code>static final</code>变量。</p>
<h5 id="标记接口-1"><a class="header" href="#标记接口-1">标记接口</a></h5>
<p>标记接口是没有任何方法和字段的接口。</p>
<ul>
<li>向一个类添加数据类型：通过引用多态使该类对象可以作为接口类型引用，供其他代码来测试类型。</li>
<li>建立公共的父接口。</li>
</ul>
<h5 id="函数接口-1"><a class="header" href="#函数接口-1">函数接口</a></h5>
<p>An interface with exactly one abstract method is called <em><strong>Functional Interface</strong></em>（可使用<code>@FunctionInterface</code>对接口进行标注，以避免在该接口中声明多个方法）。</p>
<p><code>java.util.function</code></p>
<h3 id="对象引用多态-1"><a class="header" href="#对象引用多态-1">对象引用多态</a></h3>
<p>对象引用的多态是指：声明对象的类型不由对象的引用类型（类似于指针）决定，而是由创建对象时调用的构造方法决定。虽然对象本身是确定的，但是因为子类对象可以作为父类对象来引用，所以可以实现对象引用的多态。</p>
<p>引用多态的三个必要条件：继承、重写、父类引用子类对象。</p>
<p>示例：</p>
<pre><code class="language-java">SuperClass sc = new SuperClass();		//父类的引用实际表示父类对象
SuperClass sc1 = new SubClass();			//父类的引用实际表示子类对象
</code></pre>
<h4 id="动态绑定-1"><a class="header" href="#动态绑定-1">动态绑定</a></h4>
<p>==通过<strong>父类/接口</strong>引用子类对象的方法时，总是调用子类方法，而非父类同名方法==。区别于C++，C++中只有<strong>虚函数</strong>才具有此性质，否则使用父类指针将访问父类同名函数。也就是说Java中的成员方法具有C++虚函数的性质。如果 Java 中不希望某个方法具有虚函数特性，可以加上<code>final</code>关键字变成非虚函数。</p>
<p>判断一个引用究竟指向那种类的对象可以使用<code>instanceof</code>运算符来进行判断。</p>
<pre><code class="language-java">if (object instanceof ClassName){
    do_something
}
</code></pre>
<p>对象引用多态的使用情形：</p>
<ol>
<li>
<p><strong>参数传递</strong>。当一个函数需要接收的参数可能是某个类的多个子类时，就可将参数声明为父类的引用，实际传参时，则传递实际的子类对象引用。</p>
</li>
<li>
<p><strong>存储</strong>。在存储一系列不同子类的对象时，可以声明一个父类对象的数组进行存储，每个数组元素可以是具体的子类对象。</p>
</li>
<li>
<p><strong>强制类型转换</strong>。虽然将各种子类统一使用父类引用进行管理非常方便，但使用父类的引用就只能访问到子类中父类的成员。如果要访问子类的成员，就需要将父类引用强制转换为子类引用，强制类型转换的前提是引用对象本身必须是转换目标所属的类，这时可以先使用<code>instanceof</code>先判断，再转换。</p>
<pre><code class="language-java">Object [] list = {&quot;abc&quot;, &quot;def&quot;, &quot;ghi&quot;};
for (String str : list){
  // String str = (String)list[i];
  do_some_things;
}
</code></pre>
</li>
</ol>
<h3 id="反射-2"><a class="header" href="#反射-2">反射</a></h3>
<p>https://www.journaldev.com/1789/java-reflection-example-tutorial#invoke-public-method</p>
<p>Poor Performance：动态解析类型</p>
<p><code>java.lang.Class</code>：类的元数据，用于查找类的属性以及创建新的实例。</p>
<h3 id="泛型generic-1"><a class="header" href="#泛型generic-1">泛型（Generic）</a></h3>
<p>泛型提供了编译时类型安全检测机制。泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。Java编译器使用<strong>类型擦除</strong>将泛型类型替换为通用类型（例如<code>Object, Comparable</code>）并适当添加类型转换。</p>
<blockquote>
<p>不同于C++模板，编译器不会将泛型类型替换为具体类型，从而不会产生新的类型。</p>
<p><a href="https://www.journaldev.com/1330/java-collections-interview-questions-and-answers#generics-sub-typing">泛型类型不支持类型转换，不能创建泛型数组</a>。</p>
</blockquote>
<h4 id="泛型方法-1"><a class="header" href="#泛型方法-1">泛型方法</a></h4>
<pre><code class="language-java">public [static] &lt;T1,T2&gt; void methodName(T1[] data, GenericsType&lt;T2&gt; info)
</code></pre>
<ul>
<li>类型参数声明：在在方法返回类型之前；</li>
<li>类型参数声明可以包含多个类型参数，</li>
<li>类型参数只能代表引用型类型，不能是基本类型。</li>
</ul>
<h5 id="有界类型参数-1"><a class="header" href="#有界类型参数-1">有界类型参数</a></h5>
<p>限制被允许传递到一个类型参数的类型种类。</p>
<pre><code class="language-java">public &lt;T extends Type[,...]&gt; void methodName(T[] data)
</code></pre>
<h4 id="泛型类-1"><a class="header" href="#泛型类-1">泛型类</a></h4>
<p>在声明的类名后面添加了类型参数声明部分：</p>
<pre><code class="language-java">[modifier] class ClassName &lt;T [extends Type][,...]&gt;{
   public void methodName(T data)
}
</code></pre>
<p>在类的定义中可以使用声明的类型参数来定义字段，或作为方法的参数类型。</p>
<h4 id="类型通配符-1"><a class="header" href="#类型通配符-1">类型通配符</a></h4>
<p>类型通配符一般是使用<code>?</code>代替泛型类的具体类型参数，<code>?</code>不需要放在类型参数声明列表中。</p>
<pre><code class="language-java">public static void getData(List&lt;?&gt; data)
public static void getUperNumber(List&lt;? extends Number&gt; data)
public static void getUperNumber(List&lt;? super Number&gt; data)
</code></pre>
<p><code>extends</code>定义类型参数的上限（该类及其子类）；<code>super</code>定义类型的下限（该类及其父类）。</p>
<p>在使用类型通配符具体化类型作为参数的方法中，仅使用泛型类提供的公共方法，而不使用具体类型相关的方法。</p>
<p>https://docs.oracle.com/javase/tutorial/extra/generics/index.html.</p>
<p><a href="https://www.journaldev.com/1663/java-generics-example-method-class-interface">Java Generics Example Tutorial - Generic Method, Class, Interface - JournalDev</a></p>
<h3 id="java包简介-1"><a class="header" href="#java包简介-1">Java包简介</a></h3>
<div class="table-wrapper"><table><thead><tr><th>类库</th><th>简介</th></tr></thead><tbody>
<tr><td><code>java.io</code></td><td>提供系统的输入输出，包括各类输入输出流。</td></tr>
<tr><td><code>java.lang</code></td><td>Java语言的基础，包括对基本数据类型的封装，以及<code>Math</code>、<code>Process</code>、<code>Thread</code>等类。<code>java.lang</code>包默认加载到所有的Java程序的。</td></tr>
<tr><td><code>java.net</code></td><td>提供Java访问网络的功能，包括对TCP/UDP套接字的封装以及对应用层协议的封装。</td></tr>
<tr><td><code>java.util</code></td><td>包括了容器框架的接口和类，日期和时间的处理，事件模型以及其他功能（随机数发生、字符串格式化等）。</td></tr>
<tr><td><code>java.applet</code></td><td>提供创建Java Applet程序所必要的类。</td></tr>
<tr><td><code>java.awt</code></td><td>提供图形界面编程的类和接口。</td></tr>
</tbody></table>
</div>
<h2 id="异常处理-3"><a class="header" href="#异常处理-3">异常处理</a></h2>
<h3 id="异常分类-1"><a class="header" href="#异常分类-1">异常分类</a></h3>
<p>所有的异常类是从<code>java.lang.Exception</code>类继承的子类。<code>Exception</code>类是<code>Throwable</code>类的子类。除了<code>Exception</code>类外，<code>Throwable</code>还有一个子类<code>Error</code>。</p>
<p><img src="Java/JAVA%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80.assets/exception-hierarchy.png.webp" alt="java exception hierarchy" /></p>
<p><a href="https://www.journaldev.com/1696/exception-handling-in-java">Exception Handling in Java - JournalDev</a></p>
<h3 id="处理异常-1"><a class="header" href="#处理异常-1">处理异常</a></h3>
<p>使用<a href="Java/JAVA%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80.html#try-catch-finally">try-catch</a>语句捕获异常。</p>
<p>使用捕获的异常对象，获取异常信息：</p>
<pre><code class="language-java">String getMessage()   // 关于发生的异常的详细信息
String toString()     // 返回异常类的名字
Throwable getCause()  // 异常原因
void printStackTrace() // 
</code></pre>
<p>抛出异常：</p>
<p>如果一个方法存在未捕获的异常，则方法的声明需要使用<code>throws</code>关键字来给出未处理异常列表。</p>
<pre><code class="language-java">public void method(···) throws XxxException, YyyException
</code></pre>
<p>在方法内部可以使用<code>throw</code>关键字抛出一个捕获到的异常或新实例化的异常。</p>
<h3 id="自定义异常-1"><a class="header" href="#自定义异常-1">自定义异常</a></h3>
<p>所有异常都必须是 Throwable 的子类。</p>
<p>如果希望写一个<em>检查性异常类</em>，则需要继承 Exception 类。</p>
<p>如果你想写一个<em>运行时异常类</em>，那么需要继承 RuntimeException 类。</p>
<h2 id="设计模式-1"><a class="header" href="#设计模式-1">设计模式</a></h2>
<p><a href="https://www.journaldev.com/1827/java-design-patterns-example-tutorial">==Java Design Patterns== - Example Tutorial - JournalDev</a></p>
<h2 id="参考文献-6"><a class="header" href="#参考文献-6">参考文献</a></h2>
<ol>
<li><a href="https://docs.oracle.com/javase/specs/jls/se14/jls14.pdf">The Java Language Specification, Java SE 14 Edition</a>.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="java开发环境"><a class="header" href="#java开发环境">Java开发环境</a></h1>
<h2 id="java-development-kit"><a class="header" href="#java-development-kit">Java Development Kit</a></h2>
<pre><code class="language-sh">choco install jdk8  # Windows: choco install jdk11, ojdkbuild11...
sudo apt install openjdk-8-jdk  # =&gt; yum install java-1.8.0-openjdk
</code></pre>
<blockquote>
<p><code>apt</code>：<code>openjdk-11-jdk</code>安装JDK；<code>openjdk-11-jre</code>仅安装JRE。</p>
<p><code>yum</code>：<code>java-11-openjdk-devel</code>安装JDK；<code>java-11-openjdk</code>：仅安装JRE。</p>
</blockquote>
<p><a href="https://docs.microsoft.com/zh-cn/azure/developer/java/fundamentals/reasons-to-move-to-java-11">迁移到 Java 11 的原因 - Azure | Microsoft Docs</a></p>
<p><a href="https://docs.microsoft.com/zh-cn/azure/developer/java/fundamentals/transition-from-java-8-to-java-11">从 Java 8 转换到 Java 11 - Azure | Microsoft Docs</a>（ClassLoader 注意事项）。</p>
<blockquote>
<p><em>Optimized to run Java™ applications cost-effectively in the cloud, <strong>Eclipse OpenJ9</strong> is a fast and efficient JVM that delivers power and performance when you need it most.</em></p>
</blockquote>
<h3 id="环境变量"><a class="header" href="#环境变量">环境变量</a></h3>
<p>通过软件包管理器安装的开发环境通常已经设置环境变量，如果是直接下载的软件包则需要手动设置。基于Java的软件依赖Java相关的环境变量来定位Java的可执行文件和库文件。其中：</p>
<ul>
<li><code>PATH</code>：可执行文件（Java编译器、解释器），位于JDK安装目录下的<code>bin</code>目录；</li>
<li><code>JAVA_HOME</code>：Java安装目录；</li>
<li><code>CLASSPATH</code>：外部库搜索路径，JVM通过<code>CLASSPATH</code>来寻找类。</li>
<li><code>LD_LIBRARY_PATH</code>：<em>shared native libraries like</em> <code>.DLL</code> <em>or</em> <code>.so</code> <em>not</em> <code>JARS</code> <em>or classes.</em></li>
</ul>
<p>在Linux中，通过系统安装的JDK会将可执行文件的符号链接（例如<code>/etc/alternatives/java</code>$\rightarrow$
<code>/usr/lib/jvm/java-6-openjdk-i386/jre/bin/java</code>）放在<code>/usr/bin</code>目录下，所以在终端中可以直接运行，而无需修改<code>PATH</code>变量。如果是手动安装的JDK，则不会有这些符号链接。要设置上述变量，则编辑<code>~/.bashrc</code>文件，添加以下内容：</p>
<pre><code class="language-shell">export PATH=$PATH:java_home/bin # echo $PATH
export JAVA_HOME=/usr/lib/jvm/java-7-openjdk-amd64  # echo $JAVA_HOME
export CLASSPATH=.:java_home/lib/dt.jar:java_home/lib/tools.jar
</code></pre>
<p>全局设置：在<code>/etc/profile.d/java.sh</code> 中添加</p>
<pre><code class="language-shell">export JAVA_HOME=/path/to/java_installation
</code></pre>
<p>或<code>/etc/environment</code>中添加</p>
<pre><code class="language-shell">JAVA_HOME=/path/to/java_installation
</code></pre>
<p>在Windows中则通过系统中的环境变量编辑窗口设置（如果是安装版软件，通常会设置上述变量）。</p>
<h5 id="确定java_home"><a class="header" href="#确定java_home">确定JAVA_HOME</a></h5>
<pre><code class="language-sh">update-alternatives --display java 
</code></pre>
<p>返回值为<code>java</code>可执行文件的路径，其父目录为<code>xxxjdk/jre/bin</code>。</p>
<blockquote>
<p>JDK目前会在<code>jre</code>的上层目录创建一个<code>bin</code>目录，其中部分可执行文件链接到<code>jre/bin</code>中的对应文件，但<code>jdk/bin</code>目录下包含更多可执行文件。因此两个位置都可以作为<code>JAVA_HOME</code>。</p>
</blockquote>
<p>如果安装了JDK，可以使用<code>jrunscript</code>程序查找<code>JAVA_HOME</code>：</p>
<pre><code class="language-shell">jrunscript -e 'java.lang.System.out.println(java.lang.System.getProperty(&quot;java.home&quot;));'
</code></pre>
<blockquote>
<p>JDK/JRE headless: 没有键盘、鼠标和显示系统支持，更适合服务器应用。</p>
</blockquote>
<h5 id="javafx"><a class="header" href="#javafx">JavaFX</a></h5>
<p>Java 11开始JavaFX从JDK拆分出来，独立发布。因此对于需要使用JavaFX的程序，需要在系统中单独进行安装。</p>
<p>Ubuntu 18.04 (LTS) 提供openjfx作为openjdk的JavaFX版本。在软件仓库中可以选择安装<code>openjdk-8-jdk</code>（JDK8）或<code>openjdk-11-jdk</code>（JDK11），但是默认提供最新版<code>openjfx</code>（JavaFX11），而<a href="https://bugs.launchpad.net/ubuntu/+source/openjfx/+bug/1799946">JavaFX11与JDK8不兼容</a>。因此如果使用JDK8，需要指定安装的JavaFX版本，并阻止其升级。</p>
<pre><code class="language-sh">sudo apt install \
  openjfx=8u161-b12-1ubuntu2 \
  libopenjfx-java=8u161-b12-1ubuntu2 \
  libopenjfx-jni=8u161-b12-1ubuntu2
# list all available openjfx version in the repository
# sudo apt show openjfx -a
sudo apt-mark hold openjfx libopenjfx-java libopenjfx-jni
</code></pre>
<h2 id="java编译器"><a class="header" href="#java编译器">Java编译器</a></h2>
<p>将<code>java</code>源文件编译为字节码文件。</p>
<pre><code class="language-sh">javac -d &lt;dir&gt; \
      --{class-path,classpath,cp} &lt;path&gt; \       # 依赖库搜索目录
      --{boot-class-path,bootclasspath} &lt;path&gt; \ # 启动类的路径
      -encoding &lt;encoding&gt; \                     # 指定源文件使用的字符编码
      -sourcepath &lt;project_path&gt; \               # 代码查找路径 =&gt; 项目根目录
      src/main/java/.../src.java
</code></pre>
<p>源代码默认位于项目根目录下的<code>src/main/java</code>目录（<a href="https://stackoverflow.com/questions/3004710/what-is-the-advantage-of-the-src-main-java-convention">Maven约定</a>），往下为包结构对应的目录。</p>
<p><code>-d</code>：指定编译输出的目录（默认为源代码所在目录），在该目录下，输出<a href="Java/./JAVA%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80.html#%E6%89%93%E5%8C%85%E5%A3%B0%E6%98%8E">字节码的存储路径与源代码中声明的包名对应</a>（不包含<code>src/main/java</code>）。</p>
<p><a href="Java/JAVA%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80.html#%E7%B1%BB%E6%90%9C%E7%B4%A2%E8%B7%AF%E5%BE%84">依赖库搜索路径</a>用于寻找源代码中导入的外部类<code>*.class</code>，可以为目录、<code>jar</code>文件和<code>zip</code>文件；<code>path/*</code>将包含该目录下的所有<code>jar</code>文件。</p>
<h3 id="反编译"><a class="header" href="#反编译">反编译</a></h3>
<p>使用<code>javap</code>可进行反编译代码（将字节码转换为可读格式），<a href="http://jd.benow.ca/">jd-gui</a>是一个图形化反编译工具，可根据字节码还原源代码。</p>
<pre><code class="language-shell">javap -c -verbose ... App.class
# -classpath 指定搜索路径
# -l 输出行号和本地变量表
# -public/protected/package/private: 要输出的成员访问级别，private输出所有成员
</code></pre>
<h3 id="归档"><a class="header" href="#归档">归档</a></h3>
<h5 id="查看档案文件内容"><a class="header" href="#查看档案文件内容">查看档案文件内容</a></h5>
<pre><code class="language-sh">jar tvf jarfile.jar
</code></pre>
<h2 id="工具链"><a class="header" href="#工具链">工具链</a></h2>
<h3 id="make"><a class="header" href="#make"><a href="Java/../CC++/C++%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83.html#make">Make</a></a></h3>
<pre><code class="language-makefile">target:
    javac ./package1/A.java -d ../classes
    javac ./package1/B.java -d ../classes
    javac ./package2/C.java -d ../classes
    javac ./main/Test.java  -d ../classes/main/ -classpath ../classes
run:
    java -classpath ../classes/main;../classes Test
clean:
    rm -rf ../classes/package1/*.class
    rm -rf ../classes/package2/*.class
    rm -rf ../classes/main/*.class
</code></pre>
<h3 id="maven"><a class="header" href="#maven">Maven</a></h3>
<p><a href="https://maven.apache.org/">Apache Maven</a>是软件项目管理和分析工具，基于项目对象模型（Project Object Model，<a href="https://maven.apache.org/ref/3.6.1/maven-model/maven.html">POM</a>），Maven可以管理项目的构建、报告和文档。</p>
<p>Maven程序<a href="https://mvnrepository.com/">仓库</a>：查找插件、项目的相关信息（例如版本）。</p>
<h4 id="安装和配置maven"><a class="header" href="#安装和配置maven">安装和配置Maven</a></h4>
<p>IDEA和Eclipse等IDE通常已集成Maven。独立安装方式：</p>
<pre><code class="language-sh">choco install maven    # Windows
sudo apt install maven # Linux
</code></pre>
<p>配置文件<code>settings.xml</code>：</p>
<ul>
<li>全局：<code>${maven.home}/conf</code>或<code>/etc/maven/settings.xml</code>；</li>
<li>用户：<code>${user.home}/.m2/settings.xml</code>（默认无此文件，可将全局文件复制过来修改）；</li>
</ul>
<pre><code class="language-xml">&lt;settings xmlns=&quot;http://maven.apache.org/SETTINGS/1.0.0&quot;
          xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
          xsi:schemaLocation=&quot;http://maven.apache.org/SETTINGS/1.0.0
                              https://maven.apache.org/xsd/settings-1.0.0.xsd&quot;&gt;
    &lt;mirrors&gt;
        &lt;mirror&gt;
            &lt;id&gt;central-mirror&lt;/id&gt;
            &lt;url&gt;https://maven.aliyun.com/repository/central&lt;/url&gt;
            &lt;mirrorOf&gt;*&lt;/mirrorOf&gt;
        &lt;/mirror&gt;
    &lt;/mirrors&gt;
&lt;/settings&gt;
</code></pre>
<p>使用<code>-s</code>选项切换默认用户配置文件，使用<code>-f</code>选项切换默认项目文件：</p>
<pre><code class="language-shell">mvn commands [...] -s settings.xml -f pom.xml
</code></pre>
<h5 id="全局配置"><a class="header" href="#全局配置">全局配置</a></h5>
<pre><code class="language-xml">&lt;profiles&gt;
   &lt;profile&gt;
      &lt;id&gt;nexus&lt;/id&gt;
      &lt;activation&gt;&lt;!--激活条件--&gt;
         &lt;activeByDefault&gt;false&lt;/activeByDefault&gt;
         &lt;jdk&gt;1.5&lt;/jdk&gt;        &lt;!-- JDK版本 --&gt;
         &lt;os&gt;...&lt;/os&gt;          &lt;!-- 操作系统版本 --&gt;
         &lt;property&gt;&lt;/property&gt; &lt;!-- POM中定义的属性是否满足条件：$${name}=value --&gt;
         &lt;file&gt;&lt;/file&gt;         &lt;!-- 判断文件是否存在exists/missing --&gt;              
      &lt;/activation&gt; 
      &lt;properties&gt;&lt;/properties&gt; &lt;!-- POM属性定义：覆盖全局定义 --&gt;
      &lt;repositories&gt;...&lt;/repositories&gt;
      &lt;pluginRepositories&gt;...&lt;/pluginRepositories&gt; 
   &lt;/profile&gt;
&lt;/profiles&gt;
&lt;activeProfiles&gt;   &lt;!-- 无论activation是否有效 --&gt;
   &lt;activeProfile&gt;nexus&lt;/activeProfile&gt;
&lt;/activeProfiles&gt;
</code></pre>
<h5 id="设置仓库"><a class="header" href="#设置仓库">设置仓库</a></h5>
<p>local and remote (public and internal)</p>
<p>Downloading in Maven is triggered by a project declaring a dependency that is not present in the local repository (or for a <code>SNAPSHOT</code>, when the remote repository contains one that is newer). </p>
<p>为提升下载速度，可使用距离较近的镜像仓库或本地仓库。修改<code>settings.xml</code>文件。依赖仓库的选择方式：依赖优先级关系</p>
<p>Maven执行构建时，由近(本地仓库)及远(远程仓库)获取依赖库，具体地：</p>
<ul>
<li>
<p>首先查找本地仓库，默认位于<code>$HOME/$.m2/repository</code>。本地仓库路径配置项位于<code>settings.xml</code>中。</p>
<pre><code class="language-xml">&lt;settings&gt;
   &lt;localRepository&gt;$PATH/.m2/repository&lt;/localRepository&gt;
&lt;/settings&gt;
</code></pre>
</li>
<li>
<p>其次，根据全局配置文件<code>settings.xml</code>以及项目配置文件<code>pom.xml</code>中关于仓库的配置信息，从已配置仓库中依次尝试下载依赖库，直到下载成功或尝试完所有仓库后失败。</p>
</li>
</ul>
<p>Maven[默认使用中央仓库](Maven POM.md#默认仓库)，如果上述配置文件中配置了任何仓库，将不再请求默认仓库。</p>
<blockquote>
<p>Note: The official Maven repository is at https://repo.maven.apache.org/maven2 hosted by the Sonatype Company and is distributed worldwide via CDN.</p>
<p><a href="https://maven.aliyun.com/mvn/guide">阿里云公共仓库</a>：线上可搜索包名、获取其Maven依赖配置语句以及直接下载包。将其仓库地址通过以下方式设置为项目使用的仓库地址。</p>
<div class="table-wrapper"><table><thead><tr><th>仓库名称</th><th>仓库地址</th><th></th></tr></thead><tbody>
<tr><td>central</td><td><code>https://maven.aliyun.com/repository/central</code></td><td>不包含spring库</td></tr>
<tr><td>spring</td><td><code>https://maven.aliyun.com/repository/spring</code></td><td></td></tr>
<tr><td>public</td><td><code>https://maven.aliyun.com/repository/public</code></td><td>central和jcenter的聚合</td></tr>
</tbody></table>
</div></blockquote>
<p>仓库的配置方式包括：</p>
<ul>
<li>
<p>通过项目的<code>pom.xml</code>中<code>project.repositories/pluginRepositories</code>声明一个或多个<code>repository</code>配置；</p>
<pre><code class="language-xml">&lt;repositories&gt;
  &lt;repository&gt;
    &lt;id&gt;central&lt;/id&gt;
    &lt;url&gt;http://127.0.0.1:8081/repository/maven-central/&lt;/url&gt;
  &lt;/repository&gt;
  &lt;reposirtory&gt;...&lt;/reposirtory&gt;
&lt;/repositories&gt;
&lt;pluginRepositories&gt;...&lt;/pluginRepositories&gt; 
</code></pre>
</li>
<li>
<p>可将上述声明置于项目的<code>project.profiles</code>声明的一个<code>profile</code>中；</p>
<pre><code class="language-xml">&lt;profiles&gt;
  &lt;profile&gt;
    &lt;id&gt;nexus&lt;/id&gt;
    &lt;repositories&gt;...&lt;/repositories&gt;
  &lt;/profile&gt;
&lt;/profiles&gt;
</code></pre>
</li>
<li>
<p>也可将较为固定的仓库配置以<code>profile</code>写在全局配置文件中，根据环境激活相应配置或手动激活；</p>
<pre><code class="language-xml">&lt;profiles&gt;
  &lt;profile&gt;
     &lt;id&gt;nexus&lt;/id&gt;
     &lt;activation&gt;...&lt;/activation&gt;
     &lt;repositories&gt;...&lt;/repositories&gt;
  &lt;/profile&gt;
&lt;/profiles&gt;
&lt;activeProfiles&gt;   &lt;!-- 无论activation是否有效 --&gt;
   &lt;activeProfile&gt;nexus&lt;/activeProfile&gt;
&lt;/activeProfiles&gt;
</code></pre>
</li>
</ul>
<h5 id="设置仓库镜像"><a class="header" href="#设置仓库镜像">设置仓库镜像</a></h5>
<p>此外，Maven支持配置仓库镜像转发，用于将对上述配置仓库的下载请求转发到第三方或本地仓库或代理。通过<code>settings.xml</code>中的<code>settings.mirrors.mirror</code>配置基于仓库ID匹配的转发规则，<strong>可以为不同仓库指定不同的镜像源</strong>。匹配从上向下进行，如果未匹配到任何项，则尝试使用第一条规则，然后使用匹配到的规则的URL进行请求下载。</p>
<pre><code class="language-xml">&lt;mirrors&gt;
  &lt;mirror&gt;
    &lt;id&gt;nexus-central&lt;/id&gt;   &lt;!-- mirror-rule-id --&gt;
    &lt;url&gt;http://127.0.0.1:8081/repository/maven-central/&lt;/url&gt; &lt;!--forward URL--&gt;
    &lt;mirrorOf&gt;*,!dev&lt;/mirrorOf&gt;  &lt;!-- 匹配要转发的仓库请求：默认响应central仓库请求 --&gt;
  &lt;/mirror&gt;
  &lt;mirror&gt;
    &lt;id&gt;nexus-dev&lt;/id&gt;   &lt;!-- mirror-rule-id: self-hosted repo --&gt;
    &lt;url&gt;http://127.0.0.1:8081/repository/maven-dev/&lt;/url&gt;
    &lt;mirrorOf&gt;dev&lt;/mirrorOf&gt;  &lt;!-- 仅响应dev仓库的请求 --&gt;
  &lt;/mirror&gt;
&lt;/mirrors&gt;
</code></pre>
<blockquote>
<p>匹配规则：</p>
<ul>
<li><code>*</code>：匹配所有仓库请求；</li>
<li><code>*,!repo</code>：除<code>repo</code>以外的所有仓库；</li>
<li></li>
</ul>
</blockquote>
<p>通过<strong>仓库管理器</strong>（如<a href="Java/../%E5%BA%94%E7%94%A8%E8%BD%AF%E4%BB%B6/%E7%BD%91%E7%BB%9C%E6%9C%8D%E5%8A%A1%E8%BD%AF%E4%BB%B6.html#nexus">Nexus</a>）可将不同仓库合并统一对外提供服务接口。仓库管理接收到请求后，将逐次尝试合并仓库中的每个仓库是否有请求的内容，并对外服务。通过这种方式可将上述<code>mirrors</code>或<code>repositroies</code>的配置简化为一项。</p>
<h5 id="声明依赖包"><a class="header" href="#声明依赖包">声明依赖包</a></h5>
<p>在项目的<code>pom.xml</code>文件中添加依赖包声明。</p>
<pre><code class="language-xml">&lt;dependencies&gt;
  &lt;dependency&gt;
    &lt;groupId&gt;org.apache.spark&lt;/groupId&gt;
    &lt;artifactId&gt;spark-sql_2.11&lt;/artifactId&gt;
    &lt;version&gt;2.4.5&lt;/version&gt;
  &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
<h5 id="声明项目使用的插件"><a class="header" href="#声明项目使用的插件">声明项目使用的插件</a></h5>
<p>应指定插件的<code>groupId</code>，<code>artifactId</code>和<code>version</code>。</p>
<h5 id="发布声明"><a class="header" href="#发布声明">发布声明</a></h5>
<p>在项目<code>pom.xml</code>的<code>project</code>块下声明<code>distributionManagement</code>，用于声明输出包的发布服务器信息（包括<code>releases</code>和<code>snapshot</code>版本）。</p>
<pre><code class="language-xml">&lt;distributionManagement&gt;
  &lt;repository&gt;  &lt;!-- snapshotRepository --&gt;
    &lt;id&gt;nexus&lt;/id&gt;
    &lt;url&gt;http://127.0.0.1:8081/repository/maven-releases/&lt;/url&gt;
  &lt;/repository&gt;
&lt;/distributionManagement&gt;
</code></pre>
<h4 id="maven工作流"><a class="header" href="#maven工作流">Maven工作流</a></h4>
<h5 id="编译-2"><a class="header" href="#编译-2">编译</a></h5>
<pre><code class="language-shell">mvn [clean] compile -s settings.xml -f pom.xml  # 指定配置文件
mvn verify
</code></pre>
<p>编译过程会自动从Maven程序<a href="https://mvnrepository.com/">仓库</a>下载依赖包，默认的本地存储路径为<code>$HOME/.m2/repository</code>。</p>
<p>编译时，在<code>resources</code>目录下的文件也将被复制到目标（<code>target/classes</code>）目录下，在打包时也一同输出至包。</p>
<h6 id="源代码文本编码"><a class="header" href="#源代码文本编码">源代码文本编码</a></h6>
<p>在Windows下，Maven传递给编译器的默认编码方式为GBK，而代码通常为UTF-8编码，如果代码中存在中文字符，则会出现<code>编码GBK的不可映射字符</code>。解决方法：1)在项目<code>pom.xml</code>的<code>project/properties</code>块中设置<code>project.build.sourceEncoding=UTF-8</code>；2) 如果上述设置无效或需要使用项目特定的编码方式，则在项目<code>/project/build/plugins</code>下的资源插件配置项中设置<code>encoding=UTF-8</code>。3) 在编译插件<code>maven-compiler-plugin</code>配置中指定编码方式。</p>
<pre><code class="language-xml">&lt;plugin&gt;
  &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt;
  &lt;configuration&gt;
    &lt;encoding&gt;UTF-8&lt;/encoding&gt;
  &lt;/configuration&gt;
&lt;/plugin&gt;
</code></pre>
<h5 id="打包"><a class="header" href="#打包">打包</a></h5>
<pre><code class="language-shell">mvn [clean] package
</code></pre>
<p>如果程序依赖其他软件包，则<a href="https://stackoverflow.com/questions/574594/how-can-i-create-an-executable-jar-with-dependencies-using-maven">打包的文件需要声明依赖软件包的路径，或者将依赖软件包同时打包至输出文件</a>。如果无法引用相应的依赖包，将造成<code>NoClassDefFoundError</code>等错误。</p>
<ol>
<li>
<p>指定程序的入口和依赖包的位置，在运行java程序时，<strong>查找依赖包的根目录为java程序包所在目录，而非Java解释器的当前工作目录</strong>。</p>
<blockquote>
<p>在Linux下使用<code>*.jar</code>文件的符号链接，仍然会以符号链接的目标文件路径作为查找根目录；而在Windows下的符号链接则以符号链接所在目录为根目录。</p>
</blockquote>
<pre><code class="language-xml">&lt;plugin&gt;
    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
    &lt;artifactId&gt;maven-jar-plugin&lt;/artifactId&gt;
    &lt;version&gt;3.1.0&lt;/version&gt;
    &lt;configuration&gt;
        &lt;archive&gt;
            &lt;manifest&gt;
                &lt;addClasspath&gt;true&lt;/addClasspath&gt;
                &lt;classpathPrefix&gt;lib/&lt;/classpathPrefix&gt;
                &lt;mainClass&gt;package.MainClass&lt;/mainClass&gt;
            &lt;/manifest&gt;
        &lt;/archive&gt;
    &lt;/configuration&gt;
&lt;/plugin&gt;
</code></pre>
<blockquote>
<p>如果项目的多个类包含<code>Main</code>函数，则需使用具体的类名<code>package.MainClass</code>指定程序入口函数所在类 。</p>
<p><em>将<code>${project.build.finalName}</code>作为<code>classpathPrefix</code>的前缀，导致搜索不到某些类（例如<code>picocli</code>）</em>。</p>
</blockquote>
</li>
<li>
<p>将依赖软件包作为库输出。在执行打包时，利用<code>maven-dependency-plugin</code>工具将依赖软件包输出至指定位置：</p>
<pre><code class="language-xml">&lt;plugin&gt;
    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
    &lt;artifactId&gt;maven-dependency-plugin&lt;/artifactId&gt;
    &lt;executions&gt;
        &lt;execution&gt;
            &lt;id&gt;copy-dependencies&lt;/id&gt;
            &lt;phase&gt;prepare-package&lt;/phase&gt;
            &lt;goals&gt;
                &lt;goal&gt;copy-dependencies&lt;/goal&gt;
            &lt;/goals&gt;
            &lt;configuration&gt;
                &lt;outputDirectory&gt;
                ${project.build.directory}/lib
                &lt;/outputDirectory&gt;
            &lt;/configuration&gt;
        &lt;/execution&gt;
    &lt;/executions&gt;
&lt;/plugin&gt;
</code></pre>
<p>依赖软件包应该与输出的包同时分发，避免无法引用。</p>
</li>
<li>
<p>将依赖包同时打包至输出软件包</p>
<p>在执行打包期间，利用<code>maven-shade-plugin</code>将依赖包添加至目标包。</p>
<pre><code class="language-xml">&lt;plugin&gt;
    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
    &lt;artifactId&gt;maven-shade-plugin&lt;/artifactId&gt;
    &lt;version&gt;3.2.1&lt;/version&gt;
    &lt;executions&gt;
        &lt;execution&gt;
            &lt;phase&gt;package&lt;/phase&gt;
            &lt;goals&gt;
                &lt;goal&gt;shade&lt;/goal&gt;
            &lt;/goals&gt;
        &lt;/execution&gt;
    &lt;/executions&gt;
&lt;/plugin&gt;
</code></pre>
<p>此方法将造成目标包体积过大。类似地，<code>maven-assembly-plugin</code>也可以完成此功能。</p>
<pre><code class="language-xml">&lt;plugin&gt;
    &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt;
  	&lt;version&gt;3.2.0&lt;/version&gt;
    &lt;configuration&gt;
        &lt;archive&gt;
            &lt;manifest&gt;
                &lt;mainClass&gt;fully.qualified.MainClass&lt;/mainClass&gt;
            &lt;/manifest&gt;
        &lt;/archive&gt;
        &lt;descriptorRefs&gt;
            &lt;descriptorRef&gt;jar-with-dependencies&lt;/descriptorRef&gt;
        &lt;/descriptorRefs&gt;
    &lt;/configuration&gt;
  	&lt;executions&gt;
   &lt;execution&gt;
        &lt;id&gt;make-assembly&lt;/id&gt;
        &lt;phase&gt;package&lt;/phase&gt;
        &lt;goals&gt;
          &lt;goal&gt;signle&lt;/goal&gt;
        &lt;/goals&gt;
      &lt;/execution&gt;
  &lt;/executions&gt;
&lt;/plugin&gt;
</code></pre>
<p><strong>完成打包后，还需执行<code>mvn assembly:assembly</code>将依赖包添加进目标包。</strong></p>
<pre><code class="language-sh">mvn clean package assembly:single
</code></pre>
<blockquote>
<p>If your project wants to package your artifact in an uber-jar, the assembly plugin provides only basic support. For more control, use the <a href="http://maven.apache.org/plugins/maven-shade-plugin/">Maven Shade Plugin</a>.</p>
</blockquote>
<p><a href="https://stackify.com/gradle-vs-maven/">Gradle vs. Maven: Performance, Compatibility, Builds, &amp; More – Stackify</a></p>
</li>
</ol>
<h4 id="maven常见问题"><a class="header" href="#maven常见问题">Maven常见问题</a></h4>
<ol>
<li>下载依赖包的过程中出现<code>Checksum failed on download:...</code>的错误。有可能是因为下载过程为多线程，依赖包先于其校验文件被下载到本地无法完成校验。这种情况可尝试重新执行编译命令看是否依赖包已下载完成，或设置<code>-Dmaven.artifact.threads=1</code>使用单线程下载依赖包。</li>
</ol>
<h2 id="集成开发环境"><a class="header" href="#集成开发环境">集成开发环境</a></h2>
<h3 id="visual-studio-code"><a class="header" href="#visual-studio-code">Visual Studio Code</a></h3>
<p>安装Java Extension Pack，其中的扩展包括： Language Support for Java™ by Red Hat，Debugger for Java，Java Test Runner，<a href="Java/Java%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83.html#maven">Maven</a> Project Explorer，Java Dependency Viewer，Visual Studio IntelliCode。</p>
<h4 id="java开发环境配置"><a class="header" href="#java开发环境配置">Java开发环境配置</a></h4>
<p>配置系统中可用的Java运行环境及其版本信息（<code>name</code>的值为内置用于识别Java版本，可进行选择）。</p>
<pre><code class="language-json">&quot;java.configuration.runtimes&quot;: [
   {
      &quot;name&quot;: &quot;JavaSE-11&quot;,
      &quot;path&quot;: &quot;C:/Program Files/AdoptOpenJDK/jdk-11.0.11.9-hotspot&quot;,
      &quot;default&quot;: true
   },{
      &quot;name&quot;: &quot;JavaSE-1.8&quot;,
      &quot;path&quot;: &quot;C:/tools/jdk8u275-b01&quot;
   }
]
</code></pre>
<h5 id="调试环境配置"><a class="header" href="#调试环境配置">调试环境配置</a></h5>
<p>设置环境变量，以及程序的传入参数等。</p>
<pre><code class="language-json">&quot;configurations&quot;: [
    {
        &quot;args&quot;: &quot;tfapi&quot;,  # input arguments
        &quot;env&quot;:{	&quot;LD_LIBRARY_PATH&quot;: &quot;your/path&quot; } # environment variables
    }
]
</code></pre>
<h4 id="基于maven的java项目"><a class="header" href="#基于maven的java项目">基于Maven的Java项目</a></h4>
<p><a href="Java/Java%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83.html#Maven">安装Maven</a>，使用maven插件，快速创建项目<code>maven-archtype-quickstart</code>。</p>
<p><code>maven.compiler.source</code>和<code>maven.compiler.target</code>如果与默认JDK版本不同，将产生警告，需要首先<a href="Java/Java%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83.html#Java%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE">配置相应的JDK版本</a>。</p>
<h3 id="eclipse"><a class="header" href="#eclipse">Eclipse</a></h3>
<p><strong>Maven支持</strong>：Eclipse内置Maven支持（<code>m2e</code>）。</p>
<h3 id="intellij-idea"><a class="header" href="#intellij-idea">IntelliJ IDEA</a></h3>
<p>IDEA内置maven插件，支持直接创建基于maven的项目（自动生成<code>pom.xml</code>）。</p>
<h4 id="项目配置"><a class="header" href="#项目配置">项目配置</a></h4>
<p>入口：菜单项<code>File/Project Structure...</code>（项目管理器没有配置入口）。</p>
<p>配置项目使用的JDK等信息。</p>
<img src="Java/Java开发环境.assets/image-20210810133548736.png" alt="image-20210810133548736" style="zoom:50%;" />
<h5 id="加载依赖项"><a class="header" href="#加载依赖项">加载依赖项</a></h5>
<p>在<code>pom.xml</code>中添加依赖项定义（<code>dependency</code>）后，不会自动下载依赖项，需要重新加载Maven项目。</p>
<img src="Java/Java开发环境.assets/image-20210810132118089.png" alt="image-20210810132118089" style="zoom: 40%;" />
<h2 id="常见问题-3"><a class="header" href="#常见问题-3">常见问题</a></h2>
<ol>
<li>
<p>依赖项冲突</p>
<p>出现<code>NoSuchMethodError</code>或<code>UndefinedClassError</code>：引用的依赖库版本不正确，API不兼容导致找不到调用的类或方法。</p>
</li>
<li></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="maven-project-object-model"><a class="header" href="#maven-project-object-model">Maven Project Object Model</a></h1>
<p>https://maven.apache.org/pom.html</p>
<h2 id="项目对象模型"><a class="header" href="#项目对象模型">项目对象模型</a></h2>
<p>采用xml描述项目的所有配置信息。</p>
<h3 id="super-pom"><a class="header" href="#super-pom">Super POM</a></h3>
<p><a href="https://maven.apache.org/guides/introduction/introduction-to-the-pom.html#Super_POM">Super POM</a>是Maven项目的默认设置，Maven项目的POM文件继承自Super POM，项目文件中的设置将覆盖默认设置。</p>
<h5 id="默认仓库"><a class="header" href="#默认仓库">默认仓库</a></h5>
<pre><code class="language-xml">&lt;repositories&gt;  &lt;!--  &lt;pluginRepositories&gt; 也是同一地址 --&gt;
   &lt;repository&gt;
      &lt;id&gt;central&lt;/id&gt;
      &lt;name&gt;Central Repository&lt;/name&gt;
      &lt;url&gt;https://repo.maven.apache.org/maven2&lt;/url&gt;
      &lt;layout&gt;default&lt;/layout&gt;
      &lt;snapshots&gt;
         &lt;enabled&gt;false&lt;/enabled&gt;
      &lt;/snapshots&gt;
   &lt;/repository&gt;
&lt;/repositories&gt;
</code></pre>
<p><a href="http://maven.apache.org/settings.html#servers">Maven – Settings Reference (apache.org)</a>: certain settings such as <code>username</code> and <code>password</code> should not be distributed along with the <code>pom.xml</code>. This type of information should exist on the build server in the <code>settings.xml</code>.</p>
<h4 id="变量-2"><a class="header" href="#变量-2">变量</a></h4>
<p>Any field of the model that is a single value element can be referenced as a variable. </p>
<h5 id="特殊变量"><a class="header" href="#特殊变量">特殊变量</a></h5>
<div class="table-wrapper"><table><thead><tr><th>变量</th><th>含义</th></tr></thead><tbody>
<tr><td></td><td></td></tr>
<tr><td></td><td></td></tr>
<tr><td></td><td></td></tr>
</tbody></table>
</div>
<h2 id="元素说明"><a class="header" href="#元素说明">元素说明</a></h2>
<p><a href="https://maven.apache.org/ref/3.8.3/maven-model/maven.html">Maven Model – Maven (apache.org)</a></p>
<h3 id="项目信息"><a class="header" href="#项目信息">项目信息</a></h3>
<pre><code class="language-xml">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; 
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
   &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

   &lt;!--unique id: groupId-artifactId-version--&gt;
   &lt;groupId&gt;gary.deeplearning4j&lt;/groupId&gt;  &lt;!--unique org ID--&gt;
   &lt;artifactId&gt;dl4j-start-app&lt;/artifactId&gt; &lt;!--project name--&gt;
   &lt;version&gt;1.0.0.0&lt;/version&gt;

   &lt;packaging&gt;jar&lt;/packaging&gt;  &lt;!--pom for parent project--&gt;

   &lt;!--Information of project--&gt;
   &lt;name&gt;DeepLearning4j Start&lt;/name&gt;
   &lt;url&gt;http://deaplearning.gary.net&lt;/url&gt;
   &lt;description&gt;
      The start application for learning the Deeplearnig4J project.
   &lt;/description &gt;

   &lt;properties&gt;...&lt;/properties&gt;
   &lt;dependency&gt;...&lt;/dependency&gt;
   &lt;build&gt;....&lt;/build&gt;
&lt;/project&gt;
</code></pre>
<h4 id="pom信息"><a class="header" href="#pom信息">POM信息</a></h4>
<div class="table-wrapper"><table><thead><tr><th>标签</th><th>说明</th></tr></thead><tbody>
<tr><td><code>project</code></td><td>根元素：声明<a href="https://maven.apache.org/ref/3.6.1/maven-model/maven.html">POM</a>的<code>XML</code>命名空间。</td></tr>
<tr><td><code>modelVersion</code></td><td>POM版本，通常为4.0.0，不常变化</td></tr>
</tbody></table>
</div>
<h3 id="项目信息-1"><a class="header" href="#项目信息-1">项目信息</a></h3>
<div class="table-wrapper"><table><thead><tr><th>标签</th><th>说明</th></tr></thead><tbody>
<tr><td><code>groupId</code></td><td>创建项目的组织名称，通常基于有效的组织域名。</td></tr>
<tr><td><code>artifactId</code></td><td>输出文件名称。</td></tr>
<tr><td><code>packaging</code></td><td>输出文件打包格式（默认为<code>*.jar</code>）。</td></tr>
<tr><td><code>version</code></td><td>输出文件版本。</td></tr>
<tr><td><code>name</code></td><td>项目的显示名称。</td></tr>
<tr><td><code>url</code></td><td>项目的网站。</td></tr>
<tr><td><code>description</code></td><td>项目的描述信息。</td></tr>
<tr><td><code>modules</code></td><td>多项目管理。</td></tr>
<tr><td><code>parent</code></td><td>多项目的父项目信息。</td></tr>
<tr><td><code>licences</code></td><td></td></tr>
<tr><td><code>organization</code></td><td></td></tr>
<tr><td><code>developers</code></td><td></td></tr>
<tr><td><code>contributors</code></td><td></td></tr>
</tbody></table>
</div>
<h3 id="环境变量-1"><a class="header" href="#环境变量-1">环境变量</a></h3>
<p>获取环境变量：</p>
<p><code>env.PATH</code>：返回系统环境变量；</p>
<p><code>project.X.Y</code>：返回<code>POM.xml</code>中对应元素的值；</p>
<p><code>settings.xxx</code>：获取<code>settings.xml</code>中元素的值；</p>
<p>Java环境变量，例如<code>${java.home}</code>；</p>
<p><code>xxx.yyy.zzz</code>：在<code>properties</code>标签中设置的元素。</p>
<div class="table-wrapper"><table><thead><tr><th>标签</th><th>说明</th></tr></thead><tbody>
<tr><td><code>properties</code></td><td>声明环境变量用于在文件其他部分进行替换（<code>${dl4j.version}</code>）。<br /><u>作为过滤器</u>。</td></tr>
<tr><td><code>maven.compiler.source</code> <br /><code>maven.compiler.target</code></td><td>为Maven的编译任务指定Java版本（例如<code>1.8</code>，<code>11</code>）。</td></tr>
</tbody></table>
</div>
<pre><code class="language-xml">&lt;!--Define enviromnment variables for Maven--&gt;
&lt;properties&gt;
  &lt;nd4j.version&gt;1.0.0-beta4&lt;/nd4j.version&gt;
  &lt;dl4j.version&gt;1.0.0-beta4&lt;/dl4j.version&gt;
  &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt;
  &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt;
&lt;/properties&gt;
</code></pre>
<p>特殊变量：<code>${project.basedir}</code>  项目根目录。</p>
<h3 id="依赖库"><a class="header" href="#依赖库">依赖库</a></h3>
<div class="table-wrapper"><table><thead><tr><th>标签</th><th>说明</th></tr></thead><tbody>
<tr><td><code>dependencies</code></td><td>依赖库列表，其子元素为<code>dependency</code>。</td></tr>
<tr><td><code>dependency</code></td><td>依赖库声明，其子元素包括：<code>groupId</code>、<code>artifactId</code>和<code>version</code>。<br />依赖库的信息可以在<a href="https://mvnrepository.com/">Maven软件仓库</a>中查询。</td></tr>
<tr><td><code>dependencyManagement</code></td><td>用于父项目管理依赖项配置。</td></tr>
</tbody></table>
</div>
<pre><code class="language-xml">&lt;dependencies&gt;
  &lt;dependency&gt;
    &lt;groupId&gt;org.nd4j&lt;/groupId&gt;
    &lt;artifactId&gt;${nd4j.backend}&lt;/artifactId&gt;
    &lt;version&gt;${nd4j.version}&lt;/version&gt;
  &lt;/dependency&gt;
  &lt;dependency&gt;
    &lt;groupId&gt;org.deeplearning4j&lt;/groupId&gt;
    &lt;artifactId&gt;deeplearning4j-nlp&lt;/artifactId&gt;
    &lt;version&gt;${dl4j.version}&lt;/version&gt;
  &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
<h3 id="构建工具配置"><a class="header" href="#构建工具配置">构建工具配置</a></h3>
<div class="table-wrapper"><table><thead><tr><th>标签</th><th>说明</th></tr></thead><tbody>
<tr><td><code>build</code></td><td>构建工具配置。</td></tr>
<tr><td><code>plugins</code></td><td>位于<code>build</code>子节点，构建工具列表。</td></tr>
<tr><td><code>pluginManagement</code></td><td>位于<code>build</code>子节点，其子节点<code>plugins/plugin</code>声明全局的插件配置信息，任何子项目要使用其中的插件还需要在<code>build/plugins</code>子节点中声明。</td></tr>
<tr><td><code>plugin</code></td><td>构建工具声明，包括工具的<code>groupId</code>、<code>artifactId</code>、<code>version</code>以及相关配置信息。</td></tr>
<tr><td><code>configuration</code></td><td>构建工具配置信息，其包含的子元素取决于具体工具。</td></tr>
<tr><td><code>executions</code></td><td>指定构建工具的执行方式。</td></tr>
<tr><td><code>resources</code></td><td>specifying where resources exist within your project.</td></tr>
</tbody></table>
</div>
<pre><code class="language-xml">&lt;build&gt;
  &lt;sourceDirectory&gt;${basedir}/src/main/java&lt;/sourceDirectory&gt;
  &lt;scriptSourceDirectory&gt;${basedir}/src/main/scripts&lt;/scriptSourceDirectory&gt;
  &lt;testSourceDirectory&gt;${basedir}/src/test/java&lt;/testSourceDirectory&gt;
  &lt;outputDirectory&gt;${basedir}/target/classes&lt;/outputDirectory&gt;
  &lt;testOutputDirectory&gt;${basedir}/target/test-classes&lt;/testOutputDirectory&gt;
  &lt;defaultGoal&gt;install&lt;/defaultGoal&gt;  &lt;!--default goal/phase to execute--&gt;
  &lt;directory&gt;${basedir}/target&lt;/directory&gt; &lt;!--output dir--&gt;
  &lt;finalName&gt;${artifactId}-${version}&lt;/finalName&gt;  &lt;!--output name--&gt;
  ...
  &lt;plugins&gt;
    &lt;plugin&gt;
      &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
      &lt;artifactId&gt;maven-jar-plugin&lt;/artifactId&gt;
      &lt;version&gt;3.1.0&lt;/version&gt;
      &lt;configuration&gt;
        &lt;archive&gt;
          &lt;manifest&gt;
            &lt;addClasspath&gt;true&lt;/addClasspath&gt;
            &lt;classpathPrefix&gt;lib/&lt;/classpathPrefix&gt;
            &lt;mainClass&gt;gary.App&lt;/mainClass&gt;
          &lt;/manifest&gt;
        &lt;/archive&gt;
      &lt;/configuration&gt;
    &lt;/plugin&gt;
  &lt;/plugins&gt;
&lt;/build&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="数据类型"><a class="header" href="#数据类型">数据类型</a></h1>
<p>数据类型分为基本类型（值类型）和引用类型（类似于指针）。==基本类型默认初始化值为<code>0</code>，引用类型默认初始化值为<code>null</code>==。</p>
<h2 id="基本类型"><a class="header" href="#基本类型">基本类型</a></h2>
<p>数值类型：<code>byte</code>(8bit)、<code>short</code>(16bit)、<code>int</code>、<code>long</code>、<code>float</code>(32bit)、<code>double</code>(64bit)、<code>boolean</code>；</p>
<p>字符类型：<code>char</code>(16bit Unicode)。</p>
<p>基本类型作为类成员，</p>
<h3 id="字面值-1"><a class="header" href="#字面值-1">字面值</a></h3>
<p>前缀<code>0</code>表示八进制，而前缀<code>0x</code>代表十六进制。</p>
<p>字符串字面值（常量）包含在双引号间：<code>“Hello World”</code>。</p>
<p>字符常量和字符串常量可以<strong>包含转义字符</strong>以及Unicode字符编号：<code>‘\u0001’</code>。</p>
<h3 id="类型转换"><a class="header" href="#类型转换">类型转换</a></h3>
<p>进行运算时，低精度自动向高精度转换（例如<code>short</code>到<code>int</code>，<code>float</code>到<code>double</code>），使用强制转换从高精度向低精度转换（可能损失数据）。</p>
<pre><code class="language-java">long y = 1234;
int x = (int) y;  //强制类型转换
</code></pre>
<h3 id="包装类"><a class="header" href="#包装类">包装类</a></h3>
<p>当内置数据类型被当作对象使用的时候，编译器会把内置类型装箱为包装类，例如：<code>Integer</code>, <code>Long</code>, <code>Char</code>等。</p>
<p>数值类型包装类基于<code>Number</code>类，提供常用的<strong>静态</strong>方法：</p>
<h5 id="计算值"><a class="header" href="#计算值">计算值</a></h5>
<p>返回字符串所表示的对应类型的字面值。</p>
<pre><code class="language-java">static Type valueOf(String s[, int radix])
static int parseInt(String s[, int radix])
</code></pre>
<h5 id="数值转换为文本"><a class="header" href="#数值转换为文本">数值转换为文本</a></h5>
<pre><code class="language-java">static String toString(int i)		// for all basic types
</code></pre>
<p>字符类型对应的包装类为<code>Character</code>。</p>
<h2 id="字符串"><a class="header" href="#字符串">字符串</a></h2>
<p>由于字符串是常用的一类数据类型，因此将<code>String</code>也归为基本类型，默认值为<code>null</code>。<code>String </code>类是不可改变的，对字符串的修改方法都会返回新的字符串对象。如果需要对字符串做修改，应该选择使用 <a href="https://www.runoob.com/java/java-stringbuffer.html">StringBuffer &amp; StringBuilder 类</a>。</p>
<pre><code class="language-java">str = &quot;This is a string&quot;;
str = new String(byte[] buffer,int offset, int length);
</code></pre>
<h3 id="格式化字符串"><a class="header" href="#格式化字符串">格式化字符串</a></h3>
<pre><code class="language-java">String format(&quot;%d %f %s&quot;, args);
String valueOf(Type x); // == toString
</code></pre>
<h3 id="查找和索引"><a class="header" href="#查找和索引">查找和索引</a></h3>
<pre><code class="language-java">char charAt(int index);
int indexOf(int ch[, int fromIndex]);
int indexOf(String str[, int fromIndex]);
int lastIndexOf(int ch[, int fromIndex]);
int lastIndexOf(String str[, int fromIndex]);
boolean startWith(String prefix);
boolean endsWith(String suffix);
boolean matches(String regex);
String substring(int beginIndex[, int endIndex]);
</code></pre>
<h3 id="修改"><a class="header" href="#修改">修改</a></h3>
<p>替换：</p>
<pre><code class="language-java">String replace(char oldChar, char newChar);  // replace all
String replaceAll(String regex, String replacement);
String replaceFirst(String regex, String replacement);
</code></pre>
<p>根据正则表达式拆分字符串，注意转义字符。</p>
<pre><code class="language-java">String[] split(String regex[, int limit])
</code></pre>
<blockquote>
<p>使用正则表达式支持更加灵活地分割：<code>&quot; ?, ?&quot;</code>、<code>&quot; ?= ?&quot;</code>、<code>&quot; ?: ?&quot;</code>。</p>
</blockquote>
<p>字符串拼接：</p>
<pre><code class="language-java">String concat(String str)
String String.join(delimiters, Iterable);  // since 1.8
</code></pre>
<p>使用<code>+</code>操作符等效。</p>
<p>修剪</p>
<pre><code class="language-java">String trim();	// remove blank space
</code></pre>
<h3 id="stringbufferstringbuilder"><a class="header" href="#stringbufferstringbuilder">StringBuffer/StringBuilder</a></h3>
<p>StringBuilder 相较于 StringBuffer 有速度优势，但是StringBuilder的方法不是线程安全的（不能同步访问）。</p>
<h3 id="正则表达式-1"><a class="header" href="#正则表达式-1">正则表达式</a></h3>
<p>检测是否匹配模式：</p>
<pre><code class="language-java">import java.util.regex.Pattern
String text = &quot;this is a string&quot;;
String pattern = &quot;.*\\w{4}.*&quot;;
boolean matches = Pattern.matches(regex, text);
</code></pre>
<blockquote>
<p><code>String.matches</code>也可以执行匹配任务。</p>
</blockquote>
<p>返回匹配内容：</p>
<pre><code class="language-java">Pattern regex = Pattern.compile(pattern);  
Matches matches = regex.match(text);
while(matches.find()){
  println(matches.group(0))
}
n = matches.groupCount();  // 捕获组数量（不包括匹配）
String sub = matches.group(i);  //返回捕获内容
</code></pre>
<blockquote>
<p>Java字符串会解释转义字符“<code>\</code>”，因此当正则表达式中包含“<code>\</code>”时，需要使用“<code>\\</code>”。</p>
</blockquote>
<p><code>match</code>方法尝试匹配整个字符串，而<code>find</code>方法尝试匹配子串。<code>find</code>一次仅匹配一个字串，并记录匹配位置，可重复在同一<code>Matches</code>对象上调用<code>find</code>以返回后续匹配字串。</p>
<p>替换匹配内容：<code>replaceAll</code>，<code>replaceFirst</code>（等效于<code>String.replaceAll</code>和<code>String.replaceFirst</code>）。</p>
<p><a href="https://www.journaldev.com/634/regular-expression-in-java-regex-example">Regular Expression in Java - Java Regex Example - JournalDev</a></p>
<h2 id="容器框架"><a class="header" href="#容器框架">容器框架</a></h2>
<p>容器在<code>java.util</code>包中提供，<code>java.util.concurrent</code>提供线程安全容器类型。</p>
<h3 id="数组"><a class="header" href="#数组">数组</a></h3>
<h4 id="一维数组"><a class="header" href="#一维数组">一维数组</a></h4>
<p>数组是包装对象，封装了连续的同类型变量。<a href="https://www.geeksforgeeks.org/arrays-in-java/">对于基本类型，数据储存于连续的内存空间中；对于对象，则连续存储的为对象的引用，而实际对象储存于堆分段</a>。</p>
<p><img src="Java/./assets/objects-tenElementArray.gif" alt="array" /></p>
<p>声明数组（的引用）：</p>
<pre><code class="language-java">type[] array_name;	// preferred java ctyle
type array_name[];	// c/c++ style
</code></pre>
<p>数组在声明之后，具有默认值（<code>null</code>），必须经过初始化才能使用（可以和声明结合）。</p>
<h5 id="静态初始化"><a class="header" href="#静态初始化">静态初始化</a></h5>
<p>在声明数组时，使用“<code>{...}</code>”为数组的整体赋值，必须紧接在声明之后。</p>
<pre><code class="language-java">type array_name[] = {value1,value2,...,valuen};
</code></pre>
<h5 id="动态初始化"><a class="header" href="#动态初始化">动态初始化</a></h5>
<p>使用<code>new</code>创建具有指定长度的数组。动态初始化不用和声明语句写在一起，也可以将新创建的数组赋值给已定义的数组引用。</p>
<pre><code class="language-java">array_name = new type[array_size];
</code></pre>
<h5 id="访问数组元素"><a class="header" href="#访问数组元素">访问数组元素</a></h5>
<pre><code class="language-java">x = array_name[index];
</code></pre>
<p>通过下标访问数组元素，下标起始值为0，数组长度可通过字段<code>array_name.length</code>获得。提供的索引不应超过数组长度，否则引起<code>ArrayIndexOutOfBoundsException </code>异常。</p>
<h4 id="多维数组"><a class="header" href="#多维数组">多维数组</a></h4>
<p>多维数组又称为<strong>数组的数组</strong>，即数组元素储存了另一个数组的引用。</p>
<pre><code class="language-java">int[][] intArray = new int[10][20]; 		//a 2D array or matrix
int[][][] intArray = new int[10][20][10]; 	//a 3D array
</code></pre>
<h5 id="锯齿数组"><a class="header" href="#锯齿数组">锯齿数组</a></h5>
<p>根据多维数组的定义，我们其实可以先声明数组的最高维，然后为最高维的每一个元素初始化一个子数组。由于子数组长度可能不一样，因此称这样的数组为**<a href="https://www.geeksforgeeks.org/jagged-array-in-java/">锯齿数组</a>**。</p>
<pre><code class="language-java">int[][] array_name = new int[len1][];
for(int i = 0; i &lt; len1; ++i){
    array_name[i] = new int[len_i];
}
</code></pre>
<p>由于多维数组的构造方式，其底层数据的内存空间将不再是连续的。</p>
<h3 id="arrays类"><a class="header" href="#arrays类">Arrays类</a></h3>
<p>提供静态方法操作数组，包括排序、比较、查找、赋值等操作。</p>
<p>提供数组与容器类型转换的接口。</p>
<h3 id="容器接口"><a class="header" href="#容器接口">容器接口</a></h3>
<p>容器框架是一个用来代表和操纵集合的统一架构，包含如下内容：</p>
<ul>
<li><strong>接口</strong>：是代表集合的抽象数据类型。例如<code>Collection</code>、<code>List</code>、<code>Set</code>、<code>Map</code>等。之所以定义多个接口，是为了以不同的方式操作集合对象。</li>
<li><strong>实现（类）</strong>：是集合接口的具体实现，例如：<code>ArrayList</code>、<code>LinkedList</code>、<code>HashSet</code>、<code>HashMap</code>。</li>
<li><strong>算法</strong>：是实现集合接口的对象里的方法执行的一些有用的计算，例如：搜索和排序。相同的方法可以在相似的接口上有着不同的实现。</li>
</ul>
<p>Java 容器框架主要包括两种类型的容器，一种是集合（<code>Collection</code>），存储一个元素集合；另一种是图（<code>Map</code>），存储键/值对映射。</p>
<p><img src="Java/assets/2243690-9cd9c896e0d512ed.gif" alt="img" /></p>
<p><code>Collection</code>接口存储一组不唯一，无序的对象。</p>
<ul>
<li><code>List</code>接口存储一组不唯一，有序（插入顺序）的对象。</li>
<li><code>Set</code>接口存储一组唯一，无序的对象。
<ul>
<li><code>SortedSet</code>接口有序的集合</li>
</ul>
</li>
<li><code>Queue</code>：在容器首端取出元素。通常实现包括FIFO队列（在容器末端插入元素）与优先队列（<code>PriorityQueue</code>，插入位置与元素大小相关）。</li>
<li><code>Dequeue</code>（double-ended queue）：支持在容器的两端插入和删除元素。</li>
</ul>
<p>Map接口存储一组键值对象（字典）。</p>
<pre><code class="language-java">abstract interface Map&lt;KeyType,ValueType&gt;
</code></pre>
<ul>
<li><code>SortedMap</code>接口使<code>Key</code>保持在升序排列。</li>
</ul>
<h4 id="容器包装"><a class="header" href="#容器包装">容器包装</a></h4>
<h5 id="同步容器"><a class="header" href="#同步容器">同步容器</a></h5>
<p>每类容器提供了静态包装方法，返回线程安全的容器类型。</p>
<pre><code class="language-java">public static  Collection synchronizedCollection(Collection c);
</code></pre>
<h5 id="不可修改"><a class="header" href="#不可修改">不可修改</a></h5>
<p>检查所有容器操作，如有修改容器的操作则抛出异常。</p>
<pre><code class="language-java">public static  Collection unmodifiableCollection(Collection&lt;? extends T&gt; c);
</code></pre>
<h3 id="容器类型"><a class="header" href="#容器类型">容器类型</a></h3>
<p>Note that all the core collection interfaces are generic.</p>
<p><img src="Java/JAVA%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.assets/image-20210804123413178.png" alt="image-20210804123413178" /></p>
<h4 id="容器类型公共方法"><a class="header" href="#容器类型公共方法">容器类型公共方法</a></h4>
<pre><code class="language-java">collection.size();
collection.clear();
</code></pre>
<h4 id="list"><a class="header" href="#list">List</a></h4>
<p>可变长度<a href="Java/JAVA%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.html#%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84">数组</a>：</p>
<ul>
<li><code>ArrayList</code>在内部维护常规数组；如果数组容量不足，则需要重新分配数组；适用于频繁随机访问元素。</li>
<li><code>LinkedList</code>在内部维护链表；适用于频繁增删元素。</li>
</ul>
<pre><code class="language-java">ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();
// new ArrayList&lt;Type&gt;(Collection c);
// new ArrayList&lt;Type&gt;(int capacity);
list.add(element);
list.set(0, 100);      // =&gt; list.get(0);  // 不能使用[]运算符
list.remove(0);        // =&gt; list.clear(); 
list.sort((x,y)-&gt;x-y)  // =&gt; Collections.sort(list); 
n = list.size();
tf = list.contains(object);
</code></pre>
<blockquote>
<p>元素类型必须是引用类型，基本类型需要用包装类代替。</p>
</blockquote>
<p><code>LinkedList</code>提供额外方法（比普通方法更加高效）：<code>addFirst/addLast</code>、<code>removeFirst/removeLast</code>、<code>getFirst/getLast</code>。</p>
<h5 id="序列和数组相互转换"><a class="header" href="#序列和数组相互转换">序列和数组相互转换</a></h5>
<pre><code class="language-java">Integer[] intArray = list.toArray(new Integer[5]);  // cast to array
ArrayList&lt;Integer&gt; list = new Arrays.asList({2,3,0,-1});
</code></pre>
<h4 id="set"><a class="header" href="#set">Set</a></h4>
<p>操作方法类似于<code>ArrayList</code>。由于元素是无序存储的，没有基于索引的方法。</p>
<h5 id="hashset-and-linkedhashset"><a class="header" href="#hashset-and-linkedhashset">HashSet and <strong>LinkedHashSet</strong></a></h5>
<p><code>HashSet</code>为无序集合（backed by <code>HashMap</code>，迭代顺序是随机的）；</p>
<p><code>LinkedHashSet</code>通过双向链表维持元素的插入顺序。</p>
<h5 id="treesetsortedset"><a class="header" href="#treesetsortedset">TreeSet（SortedSet）</a></h5>
<blockquote>
<p>A <code>NavigableSet</code> implementation based on a <code>TreeMap</code>. The elements are ordered using their natural ordering, or by a <code>Comparator</code> provided at set creation time.</p>
</blockquote>
<h3 id="map"><a class="header" href="#map">Map</a></h3>
<p>存储<code>key-value</code>映射（即字典）。</p>
<h5 id="hashmap"><a class="header" href="#hashmap">HashMap</a></h5>
<pre><code class="language-java">public class HashMap&lt;K,V&gt; extends java.util.AbstractMap 
   implements Map, Cloneable, Serializable;
</code></pre>
<h5 id="treemapsortedmap"><a class="header" href="#treemapsortedmap">TreeMap（SortedMap）</a></h5>
<blockquote>
<p>A Red-Black tree based <code>NavigableMap</code> implementation. The map is sorted according to the natural ordering of its keys, or by a Comparator provided at map creation time.</p>
</blockquote>
<h5 id="用法"><a class="header" href="#用法">用法</a></h5>
<pre><code class="language-java">import java.util.HashMap;
HashMap&lt;String,Object&gt; map = new HashMap&lt;&gt;();
map.put(key ,value);   // =&gt; value = map.get(key)
map.remove(key);       // =&gt; map.clear()
tf = map.containsKey(key);
tf = map.containsValue(value);
for (Map.Entry&lt;String, Object&gt; entry : map.entrySet()) {
    String key = entry.getKey();
    Object value = entry.getValue();
}
for (String key : map.keySet()) {...}
for (Object value : map.values()) {...}
</code></pre>
<blockquote>
<p>https://stackoverflow.com/a/1066607</p>
<p>https://stackoverflow.com/questions/46898/how-do-i-efficiently-iterate-over-each-entry-in-a-java-map</p>
</blockquote>
<h4 id="queue"><a class="header" href="#queue">Queue</a></h4>
<blockquote>
<p><code>PriorityQueue</code> is an unbounded queue based on a <em><strong>priority heap</strong></em>.</p>
</blockquote>
<h3 id="旧式数据结构"><a class="header" href="#旧式数据结构">旧式数据结构</a></h3>
<h5 id="枚举"><a class="header" href="#枚举">枚举</a></h5>
<p>可以枚举（一次获得一个）对象集合中的元素。这种传统接口已被迭代器取代，虽然<code>Enumeration </code>还未被遗弃，但在现代代码中已经被很少使用了。尽管如此，它还是使用在诸如<code>Vector</code>和<code>Properties</code>这些传统类所定义的方法中。</p>
<p><strong>区别于C/C++等的枚举类型</strong>，其元素是通过其他类型（如<code>Vector.elements</code>），无法定义或直接访问其中的枚举元素。</p>
<h5 id="向量"><a class="header" href="#向量">向量</a></h5>
<p><code>Vector</code>类实现了一个动态数组，和<code>ArrayList</code>很相似，但是两者是不同的：</p>
<ul>
<li><code>Vector</code>是同步访问的。</li>
<li><code>Vector</code>包含了许多传统的方法，这些方法不属于集合框架。</li>
</ul>
<p><code>Vector</code>支持泛型，如果构造时未给出初始化类型，编译器会给出警告。</p>
<h5 id="栈"><a class="header" href="#栈">栈</a></h5>
<p><code>Stack</code>是<code>Vector</code>的一个子类，它实现了一个标准的后进先出的栈。</p>
<p>注意：<code>Vector</code>/<code>Stack</code>对象无法使用下标运算符<code>[]</code>访问其对象。</p>
<h5 id="位集合"><a class="header" href="#位集合">位集合</a></h5>
<p>一个<code>Bitset</code>类创建一种特殊类型的数组来保存位值。<code>BitSet</code>中数组大小会随需要增加</p>
<h5 id="字典"><a class="header" href="#字典">字典</a></h5>
<p><code>Dictionary</code>类是一个抽象类，用来存储键/值对，作用和<code>Map</code>类相似。<code>Dictionary</code>类已经过时了。在实际开发中，你可以实现<code>Map</code>接口来获取键/值的存储功能。</p>
<h5 id="哈希表"><a class="header" href="#哈希表">哈希表</a></h5>
<p><code>Hashtable</code>原本是<code>Dictionary</code>的一个具体实现 。</p>
<p>Java 2 重构的<code>Hashtable</code>实现了<code>Map</code>接口，因此，<code>Hashtable</code>现在集成到了集合框架中。它和<code>HashMap</code>类很相似，但是它支持同步。<strong>键经过哈希处理，所得到的散列码被用作存储在该表中值的索引</strong>。</p>
<h5 id="属性-1"><a class="header" href="#属性-1">属性</a></h5>
<p><code>Properties</code>继承于<code>Hashtable</code>，表示了一个持久的属性集。属性列表中每个键及其对应值都是一个字符串。</p>
<p><code>Properties</code>类被许多Java类使用。例如在获取环境变量时它就作为<code>System.getProperties()</code>方法的返回值。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="输入输出-2"><a class="header" href="#输入输出-2">输入输出</a></h1>
<p><a href="https://www.journaldev.com/942/java-io-tutorial">Java IO Tutorial - JournalDev</a></p>
<h2 id="文件读写file-io"><a class="header" href="#文件读写file-io">文件读写（File IO）</a></h2>
<p><code>open</code>：当程序需要从文件（例如数据文件、网络等）读取数据时，创建一个适当类型的输入流对象，建立与数据源的连接，然后调用该输入流对象的方法（<code>read</code>），来读取外设的数据。当程序需要输出数据时，应该创建一个输出流对象来完成对文件的连接，然后利用输出流对象的<code>write</code>方法将数据顺序写入到目标。</p>
<p><code>close</code>：完成读写后关闭对应的流，释放占用的资源。</p>
<h3 id="输入输出流"><a class="header" href="#输入输出流">输入输出流</a></h3>
<h4 id="流的类型"><a class="header" href="#流的类型">流的类型</a></h4>
<p>Java提供两类基本输入输出方式，即基于字节的（<code>InputStream</code>/<code>OutputStream</code>）和基于字符的（<code>Reader</code>/<code>Writer</code>对应了C的文件打开方式<code>b</code>和<code>t</code>）。</p>
<p>根据数据源的区别，可以将流分为：</p>
<ul>
<li>节点流：直接与输入输出目标相连的流；</li>
<li>过滤流（基于<code>FilterInputStream</code>/<code>FilterOutputStream</code>）：与另一个流相连的流。使用过滤流需要注意，当关闭过滤流时，其所连接的源输入流会被自动关闭，变得不能再使用。而在使用过滤流时，也不能提前关闭其所依赖的源输入流。</li>
</ul>
<p><img src="Java/assets/iostream2xx.png" alt="img" /></p>
<h4 id="字节流输入输出"><a class="header" href="#字节流输入输出">字节流输入输出</a></h4>
<h5 id="inputstream"><a class="header" href="#inputstream">InputStream</a></h5>
<p>数据作为字节流输入，其提供的读取方法包括：</p>
<pre><code class="language-java">int read()
int read(byte[] b)
int read(byte[] b,int off,int len)
</code></pre>
<blockquote>
<p>(1)读取1byte数据并返回读取数据值；如果读取到流的末端则返回-1；该方法发生阻塞直到流的数据可用、检测到已经到达流的结束或抛出异常。
(2) 将数据读入字节数组，返回实际读取的字节数（阻塞）；
(3) 从数组off下标开始的位置写入，并指定最大读取的字节数<code>len</code>。</p>
</blockquote>
<p>定位：</p>
<pre><code class="language-java">long skip(long n)
void mark(int readlimit)
void reset()
</code></pre>
<blockquote>
<p><code>skip</code>使位置指针从当前位置向后跳过<code>n</code>个字节，返回实际跳过的字节数。
<code>mark</code>标记当前位置，以备reset方法使用，标记以最后一次调用<code>mark</code>为准。
<code>reset</code>将位置指针移动到标记的位置处。</p>
</blockquote>
<p>基于<code>InputStream</code>实现的类型包括：</p>
<ul>
<li>
<p><code>ByteArrayInputStream</code>：以字节数组作为输入的数据源；</p>
</li>
<li>
<p><code>FileInputStream</code>：以数据文件作为数据源。</p>
<blockquote>
<pre><code class="language-java">InputStream f = new FileInputStream(path);	// path string
InputStream f = new FileInputStream(file);	// file object
</code></pre>
</blockquote>
</li>
</ul>
<p>基于<code>InputStream</code>的过滤流类型包括：</p>
<ul>
<li><code>BufferedInputStream</code>：<em>增加了输入缓冲区功能，支持mark和reset，显著提高了输入效率。</em></li>
<li><code>DataInputStream</code>：实现了<code>DataInput</code>接口中定义的独立于具体机器的带格式的读操作，从而实现了针对不同类型数据的字节读取，例如：<code>readByte</code>、<code>readBoolean</code>、<code>readShort</code>、<code>readChar</code>、<code>readInt</code>、<code>readLong</code>、<code>readFloat</code>、<code>readDouble</code>、<code>readLine</code>、<code>readUTF</code>等。<strong>注意</strong>：这种读取方式适合读取二进制文件、而不适合读取控制台的标准输入和文本文件后者应该使用<code>Reader</code>类。</li>
</ul>
<h5 id="outputstream"><a class="header" href="#outputstream">OutputStream</a></h5>
<pre><code class="language-java">void write(int b)
void write(byte[] b)
void write(byte[] b,int off,int len)
</code></pre>
<blockquote>
<p>(1) 向输出流写入一个字节，该字节为参数<code>b</code>的低8位，其余24位忽略。
(2) 将字节数组<code>b</code>的内容按字节写入流。
(3) 将字节数组从下标<code>off</code>开始的数据逐字节写入流，并指定要写入流的字节数。如果<code>len+off</code>大于数组的长度，则会引起<code>IndexOutOfBoundsException</code>。</p>
</blockquote>
<pre><code class="language-java">void flush()
</code></pre>
<p>将输出流缓冲区的数据立即输出到目标文件。</p>
<p>基于<code>OutputStream</code>的子类：</p>
<ul>
<li>
<p><code>ByteArrayOutputStream</code>：将数据输出到内存中的一个无名数组中。如果想获取无名数组中的数据，可以利用该输出流的以下方法</p>
<pre><code class="language-java">byte[] toByteArray()
String toString()
</code></pre>
</li>
<li>
<p><code>FileOutputStream</code>：输出至文件。</p>
<blockquote>
<pre><code class="language-java">OutputStream f = new FileOutputStream(path)  // path string
OutputStream f = new FileOutputStream(new File(path));
</code></pre>
</blockquote>
</li>
</ul>
<p>基于<code>OutputStream</code>的过滤流类：</p>
<ul>
<li>
<p><code>DataOutputStream</code>：提供了针对不同类型数据的写方法，如：<code>writeByte</code>、<code>writeBoolean</code>、<code>writeShort</code>、<code>WriteChar</code>、<code>WriteInt</code>、<code>WriteLong</code>、<code>WriteFloat</code>、<code>WriteDouble</code>、<code>WriteChars</code>等。需要注意写入目的地的数据是数据的二进制形式而非字符形式。</p>
</li>
<li>
<p><code>PrintStream</code>：<strong>即可作为过滤流，也可以作为节点流</strong>（直接以文件作为输出）。该输出流不产生IOException、具有自动刷新功能等特点。</p>
<pre><code class="language-java">PrintStream(String fileName) // option-args: encoding
PrintStream(File file)
PrintStream(OutputStream out) // out is an underlay output stream
</code></pre>
<p>该输出流提供了类似于一般高级语言的输出语句，例如：</p>
<pre><code class="language-java">print(int i);
println(String x);
</code></pre>
<p><em>在标准输出和文件输出，都输出数据的字符形式</em>，适合于写文本文档。</p>
<p><em>直接从File或文件名创建输出流默认未覆盖模式，需要使用底层输出流支持追加模式。</em></p>
</li>
</ul>
<h4 id="字符流输入输出"><a class="header" href="#字符流输入输出">字符流输入输出</a></h4>
<h5 id="reader"><a class="header" href="#reader">Reader</a></h5>
<p>数据作为编码后的字符流输入，Java使用Unicode字符编码。</p>
<ol>
<li>
<p>读取</p>
<pre><code class="language-java">int read()
int read(char[] cbuf)
</code></pre>
<blockquote>
<p>(1) 从输入流读取并返回一个字符。
(2) 从输入流中读取字符，并写入字符数组，返回实际读取的字符数。</p>
</blockquote>
</li>
<li>
<p>定位</p>
<pre><code class="language-java">long skip(long n)
void mark(int readAheadLimit)
void reset()
</code></pre>
<blockquote>
<p>以字符为单位进行定位。</p>
<p><code>mark</code>标记当前位置，并规定能返回当前位置的最大读取字符数<code>readAheadLimit</code>，当从当前位置读取的字符数超过这个上限，使用<code>reset</code>函数将不能返回标记位置。并不是所有输入字符流都支持标记功能。</p>
</blockquote>
</li>
</ol>
<p>基于<code>Reader</code>的子类：</p>
<ul>
<li><code>CharArrayReader</code>：</li>
<li><code>StringReader</code>：</li>
<li><code>FileReader</code>：</li>
</ul>
<p>基于<code>Reader</code>的过滤流类型：</p>
<ul>
<li>
<p><code>BufferedReader</code>：以一个<code>Reader</code>类对象为数据源，加入了缓冲功能，提供了读字符、数组和行的功能。</p>
</li>
<li>
<p><code>InputStreamReader</code>：<strong>该类型提供从字节流到字符流的桥梁</strong>。它可以从字节输入流获得数据，然后转换为字符数据交给程序。<code>InputStreamReader</code>虽然将字节流转换为字符流，但是没有提供更多的<code>read</code>方法，不方便文本的读取，例如：将<code>FileInputStream</code>和<code>InputStreamReader</code>联合使用，其效果相当于<code>FileReader</code>。如果要实现更方便的读功能，就要在字符流的基础上增加<code>BufferedReader</code>，即：</p>
<pre><code class="language-java">br = new BufferedReader(new InputStreamReader(new FileInputStream(...)))
br = new BufferedReader(new FileReader(...))
</code></pre>
</li>
</ul>
<h5 id="writer"><a class="header" href="#writer">Writer</a></h5>
<ol>
<li>
<p>写入</p>
<pre><code class="language-java">void write(char[] cbuf)
void write(String str)
void write(String str, int off,int len)  
</code></pre>
</li>
<li>
<p>刷新缓冲区</p>
<pre><code class="language-java">void flush()
</code></pre>
</li>
</ol>
<p>基于<code>Writer</code>的子类：</p>
<ul>
<li>
<p><code>CharArrayWriter</code>：该字符输出流的目的地是内存中的无名数组，其方式类似于<code>ByteArrayOutputStream</code>。</p>
</li>
<li>
<p><code>FileWriter</code>：</p>
<pre><code class="language-java">FileWriter(String fileName, ...)
FileWriter(File file, boolean append) // [append=False]
FileWriter(File file, Charset charset, boolean append)
</code></pre>
<blockquote>
<p>如果文件不存在，自动创建；默认为覆盖模式。 </p>
</blockquote>
</li>
</ul>
<p>基于<code>Writer</code>的过滤流子类：</p>
<ul>
<li>
<p><code>BufferedWriter</code>：参看<code>BufferedReader</code>。</p>
</li>
<li>
<p><code>OutputStreamWriter</code>：参看<code>InputStreamReader</code>。</p>
</li>
<li>
<p><code>PrintWriter</code>：类似于<code>PrintStream</code>。</p>
<pre><code class="language-java">PrintWriter(String fileName)		// auto-create and overwrite
PrintWriter(File file)
PrintWriter(OutputStream out)
PrintWriter(Writer out)
</code></pre>
</li>
</ul>
<h4 id="标准输入输出-2"><a class="header" href="#标准输入输出-2">标准输入输出</a></h4>
<p>标准输入/输出是<code>System</code>类中的两个静态成员字段（<code>System</code>类中所有字段和方法都是静态的）<code>System.in</code>和<code>System.out</code>。</p>
<p><code>System.in</code>是<code>InputStream</code>类的子类对象。使用<code>read</code>方法需要注意一下几点：</p>
<ol>
<li>
<p><code>System.in.read()</code><em>语句必须包含在<code>try</code>语句块中，且其后必须有一个可接收<code>IOException</code>的<code>catch</code>语句块</em>；</p>
</li>
<li>
<p>执行该语句虽然只读取一个字节的数据，但返回的是16bit的整型量，只有低8位的数据是真正的输入数据，高8位为0。</p>
</li>
<li>
<p>作为<code>InputStream</code>类的对象，<code>System.in</code>只能从键盘读取字节数据，要实现复杂输入，可以将<code>System.in</code>作为源，使用上述的过滤流（<code>BufferedReader</code>）来实现。</p>
<blockquote>
<p>java.util.Scanner 是 Java5 的新特征，我们可以通过 Scanner 类来获取用户的输入。</p>
<pre><code class="language-java">Scanner s = new Scanner(System.in);
</code></pre>
</blockquote>
</li>
<li>
<p><em>标准输入时，无论是字节流或字符流，若将数据输入到数组中，会将<code>Enter</code>键也算入输入，并且相当于&quot;回车(13,<code>\r</code>)&quot;和&quot;换行(<code>\n</code>,10)&quot;，所以在使用输入数据时应该去掉这两个字节（字符）的数据。当使用记事本等程序打开文件时，<code>\r\n</code>，<code>\r</code>，<code>\n</code>出现时，识别为一个换行。</em></p>
</li>
<li>
<p>当键盘缓冲区没有数据时，执行<code>System.in.read()</code>会引起阻塞。</p>
</li>
</ol>
<p><code>System.out</code>是<code>PrintStream</code>类的对象。</p>
<h3 id="日志-3"><a class="header" href="#日志-3">日志</a></h3>
<p><a href="https://www.journaldev.com/977/logger-in-java-logging-example">Logger in Java - Java Logging Example - JournalDev</a></p>
<h2 id="网络编程"><a class="header" href="#网络编程">网络编程</a></h2>
<h3 id="基本元素"><a class="header" href="#基本元素">基本元素</a></h3>
<h5 id="ip地址和端口号"><a class="header" href="#ip地址和端口号">IP地址和端口号</a></h5>
<p><code>InetAddress</code>封装了IP地址，端口号使用整数表示。</p>
<pre><code class="language-java">InetAddress.getByName(&quot;127.0.0.1&quot;);   // or domain.name
InetAddress.getLocalHost();
InetAddress.getHostAddress();  // return IP text
</code></pre>
<p><code>SocketAddress</code>封装了IP地址和端口号。</p>
<h5 id="udp通信"><a class="header" href="#udp通信">UDP通信</a></h5>
<p><code>DatagramSocket</code>类封装了UDP通信的服务端和客户端。</p>
<pre><code class="language-java">udp_conn = new DatagramSocket(); // client
udp_conn = new DatagramSocket(port[, inet_addr]); //server
udp_conn.send(packet);			// DatagramPacket
udp_conn.receive(packet);
sql_conn.getInetAddress();
ip_addr = udp_conn.getLocalAddress();
sql_conn.getPort()
port = udp_conn.getLocalPort();
sock_addr = sql_conn.getLocalSocketAddress();
sql_conn.getRemoteSocketAddress();  # return null if not connected
</code></pre>
<h6 id="数据报分组"><a class="header" href="#数据报分组">数据报分组</a></h6>
<p><code>DatagramPacket</code>封装了UDP协议分组，该类型包含一个数据缓存（<code>byte[]</code>）的引用，可通过构造函数或<code>setData</code>设置分组的数据缓存。</p>
<pre><code class="language-java">send_packet = new DatagramPacket(msg.getBytes(), msg.length(), server_addr, server_port);  // msg (String) convert to byte array.
send_packet = new DatagramPacket(msg.getBytes(), msg.length(), socket_addr);
send_packet.setData(msg.getBytes(), offset, msg.length());
byte[] recv_buffer = new byte[128];
recv_packet = new DatagramPacket(recv_buffer, recv_buffer.length);
</code></pre>
<p>待发送的分组需要设置目标套接字地址，接收到的分组可以读取远端的套接字地址。</p>
<pre><code class="language-java">send_packet.setAddress(inet_addr);
send_packet.setPort(port);
send_packet.setSocketAddress(inet_addr);
client_addr = recv_packet.getAddress();
client_port = recv_packet.getPort();
client_addr = recv_packet.getSocketAddress();
</code></pre>
<h3 id="tcp通信"><a class="header" href="#tcp通信">TCP通信</a></h3>
<p><code>ServerSocket</code>类代表服务器端。</p>
<pre><code class="language-java">ServerSocket([int port[, int backlog[, InetAddress address]]]) 
             throws IOException
Socket accept() throws IOException
void bind(SocketAddress host, int backlog)
</code></pre>
<p><code>Socket</code>类代表TCP客户端。</p>
<pre><code class="language-java">Socket()
Socket(String host, int port) throws UnknownHostException, IOException
Socket(InetAddress host, int port) throws IOException
Socket(String host, int port, InetAddress localAddress, int localPort) throws IOException
Socket(InetAddress host, int port, InetAddress localAddress, int localPort) throws IOException
void connect(SocketAddress host, int timeout) throws IOException
InputStream getInputStream() throws IOException
OutputStream getOutputStream() throws IOException
void close() throws IOException
</code></pre>
<h2 id="数据序列化"><a class="header" href="#数据序列化">数据序列化</a></h2>
<h3 id="对象序列化-1"><a class="header" href="#对象序列化-1">对象序列化</a></h3>
<p>一个对象可以被表示为一个字节序列，该字节序列包括该对象的数据、有关对象的类型的信息和存储在对象中数据的类型。将序列化对象写入文件之后，可以从文件中读取出来，并且对它进行反序列化。</p>
<blockquote>
<p>当序列化一个对象到文件时， 按照 Java 的标准约定是给文件一个<code>.ser</code>扩展名。</p>
</blockquote>
<p>类<code>ObjectInputStream</code>和<code>ObjectOutputStream</code>是高层次的数据流，它们包含反序列化和序列化对象的方法。</p>
<pre><code class="language-java">final void writeObject(Object x) throws IOException  // ObjectOutputStream
final Object readObject() throws IOException, 		  // ObjectInputStream
                                 ClassNotFoundException
</code></pre>
<p>对于 JVM 可以反序列化对象，它必须是能够找到字节码的类。</p>
<p>一个类的对象要实现序列化功能，必须：</p>
<ul>
<li>实现<code>java.io.Serializable</code>对象。</li>
<li>所有字段是可序列化的或<a href="Java/JAVA%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA.html#%E5%AD%97%E6%AE%B5"><code>transient</code>的</a>。</li>
</ul>
<h3 id="json-2"><a class="header" href="#json-2">JSON</a></h3>
<p><code>org.json</code>提供处理JSON数据的方法。</p>
<pre><code class="language-xml">&lt;!-- https://mvnrepository.com/artifact/org.json/json --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.json&lt;/groupId&gt;
    &lt;artifactId&gt;json&lt;/artifactId&gt;
    &lt;version&gt;20190722&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>JSON的数据类型主要分为两类，即</p>
<ol>
<li>
<p>对象<code>JSONObject</code>：包含一个或多个<code>key-value</code>（可以是<code>JSONArray</code>）的字典；</p>
<pre><code class="language-java">import org.json.JSONObject;
JSONObject jo = new JSONObject(); // creating empty JSONObject 
JSONObject jo = new JSONObject(JSON_String); // Parse from string 
jo.put(key, value);  // add or modify elements
jo.getString(key);	// throw exception if key not exist
jo.optString(key);  // return empty string if key not exist
jo.optString(key,default_value); // return default if key not exist
jo.getLong(key);   // get Numerical type
jo.optLong(key);
</code></pre>
<pre><code class="language-Java">jo.toString();		// convert to string
</code></pre>
<blockquote>
<p>转换为字符串时，特殊字符将使用转义字符执行逆向转换。</p>
</blockquote>
</li>
<li>
<p>数组<code>JSONArray</code>：包含<code>value</code>（可以是<code>JSONObject</code>）一个序列。<code>JSONArray</code>的方法与<code>JSONObject</code>类似，但没有<code>key</code>参数。</p>
</li>
</ol>
<p>https://www.geeksforgeeks.org/parse-json-java/</p>
<p>https://stackoverflow.com/questions/2591098/how-to-parse-json-in-java</p>
<h3 id="xml-1"><a class="header" href="#xml-1">XML</a></h3>
<p><a href="https://www.tutorialspoint.com/java_xml/java_xml_parsers.htm">Java XML - Parsers</a></p>
<p><a href="Java/../%E6%95%B0%E6%8D%AE%E4%BA%A4%E6%8D%A2%E8%AF%AD%E8%A8%80/XML.html#Java%E5%AE%9E%E7%8E%B0">XML解析</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="系统接口-1"><a class="header" href="#系统接口-1">系统接口</a></h1>
<h2 id="系统信息-1"><a class="header" href="#系统信息-1">系统信息</a></h2>
<pre><code class="language-java">String os_name = System.getProperty(&quot;os.name&quot;)
</code></pre>
<h2 id="日期和时间-2"><a class="header" href="#日期和时间-2">日期和时间</a></h2>
<pre><code class="language-java">import java.time.*;
</code></pre>
<p><code>LocalDate</code>封装日期，<code>LocalTime</code>封装时间，<code>LocalDateTime</code>封装日期和时间的组合。</p>
<blockquote>
<p>按使用场景选择相应的类型，不能访问类型未封装的时间字段。</p>
</blockquote>
<p>获取当前日期时间：</p>
<pre><code class="language-java">LocalDateTime datetime = LocalDateTime.now();
</code></pre>
<p>设定一个日期时间：</p>
<pre><code class="language-java">LocalDate date_set = LocalDate.of(2020, 2, 19);
</code></pre>
<p>修改日期时间对象：</p>
<pre><code class="language-java">datetime = datetime.withYear(2077).withDayOfMonth(1).withMonth(10);
datetime.plusYears(1);  // plus() method series
datetime.minusSeconds(seconds); // minus() method series
</code></pre>
<p>获取日期时间中的字段：</p>
<pre><code class="language-java">get(TemporalField field)
datetime.getYear(); // get() method series
</code></pre>
<h3 id="格式和解析"><a class="header" href="#格式和解析">格式和解析</a></h3>
<p><code>DateTimeFormatter</code>设置日期时间的格式：</p>
<pre><code class="language-java">formatter = DateTimeFormatter.ofPattern(&quot;dd-MM-yyyy HH:mm:ss&quot;);
System.out.println(datetime.format(formatter));
</code></pre>
<p>设定的格式也可以用于时间字符串的解析：</p>
<pre><code class="language-java">date_parse = LocalDateTime.parse(&quot;12-03-2010 11:22:33&quot;, formatter);
</code></pre>
<h3 id="时间间隔"><a class="header" href="#时间间隔">时间间隔</a></h3>
<p><code>Duration</code>：</p>
<pre><code class="language-java">Duration.between(datetime1, datetime2);
</code></pre>
<h3 id="时间戳timestamp"><a class="header" href="#时间戳timestamp">时间戳（Timestamp）</a></h3>
<p><code>Instant</code></p>
<pre><code class="language-java">Instant timestamp = Instant.parse(date.toString());
System.out.println(&quot;Timestamp: &quot; + timestamp.toString());
</code></pre>
<h3 id="旧式api"><a class="header" href="#旧式api">旧式API</a></h3>
<p><code>Date</code>表示一个时间点，精确到毫秒，相当于存储一个整数值。</p>
<pre><code class="language-java">import java.util.Date;
Date d = new Date();	// 获取当前日期和时间
Date d = new Date(long millisec);  //指定从1970年1月1日00:00:00开始的毫秒数
</code></pre>
<p><code>Date</code>的初始化可以通过指定年月日获字符串表达式等的方式设置，但是这些设置方式已被废弃，这些设置方式可以用在<code>Calender</code>或<code>DateFormat</code>类中。</p>
<pre><code class="language-java">int compareTo(Date anotherDate)
</code></pre>
<blockquote>
<p>使本对象与另一个时间比较。</p>
</blockquote>
<pre><code>long getTime()
void setTime(long time)
</code></pre>
<p>获取/设置时间。</p>
<p><code>Calendar</code>按照日历的表示形式来设置和获取日期。 <code>Calendar</code>是抽象类，不能用构造函数初始化；<code>Calendar</code>的表达与地区有关，使用<code>getInstance()</code>来获取合适的子类实例作为<code>Calendar</code>引用的对象。</p>
<pre><code class="language-java">import java.util.Calendar;
Calendar c = Calendar.getInstance();
year = c.get(Calendar.YEAR)  // MONTH, DAY_OF_MONTH, HOUR_OF_DAY, MINUTE, ...
</code></pre>
<p>使用<code>set()</code>，<code>add()</code>，<code>roll()</code>可以改变字段的值。</p>
<ul>
<li>
<p><code>set(f, value)</code>设置指定字段<code>f</code>的值。</p>
</li>
<li>
<p><code>add(f, delta)</code>增加指定字段<code>f</code>的值，如果超过了该字段的最大值，则会发生进位。</p>
</li>
<li>
<p><code>roll(f, delta)</code>与<code>add</code>一样，只是不会改变上一级字段的值。</p>
</li>
</ul>
<p>利用<code>Time</code>获取：唯一不足是取出时间只有24小时模式。</p>
<pre><code class="language-java">import java.util.Time;
Time t=new Time(); // or Time t=new Time(&quot;GMT+8&quot;); 加上Time Zone资料。
t.setToNow(); // 取得系统时间。
int year = t.year; // month, monthDay, hour, minute, second
</code></pre>
<p><code>DateFormat</code>表示日期或时间格式的抽象类。</p>
<pre><code class="language-java">import java.text.SimpleDateFormat;
SimpleDateFormat formatter = new SimpleDateFormat (&quot;yyyy年MM月dd日 HH:mm:ss &quot;);
String str = formatter.format(Date());
</code></pre>
<p>当然还有就是可以指定时区的时间：</p>
<pre><code class="language-java">df=DateFormat.getDateTimeInstance(DateFormat.FULL,Locale.CHINA);
System.out.println(df.format(new Date()));
</code></pre>
<h2 id="文件管理"><a class="header" href="#文件管理">文件管理</a></h2>
<p>目录和文件管理由<code>File</code>类实现。</p>
<pre><code class="language-java">package java.io;
public class File implements java.io.Serializable, java.lang.Comparable
</code></pre>
<p>每个<code>File</code>对象对应与一个磁盘文件或目录（以下统称文件），通过其字段可以查询对应文件的相关信息，调用它的方法可完成对文件或目录的常用操作，如创建、删除等。</p>
<h4 id="创建file对象"><a class="header" href="#创建file对象">创建<code>File</code>对象</a></h4>
<pre><code class="language-java">File(String pathname)		//使用文件或目录名创建对象
File(String parent,String child)//使用父目录+子目录创建对象
File(File parent,String child)//使用父目录对象+子目录创建对象
File(URI uri)		//使用URI（同一资源标识符）创建对象
</code></pre>
<blockquote>
<p>由于Windows系统中使用<code>\</code>作为分隔符，容易与转义字符发生混淆，所以在路径名中使用<code>\\</code>代替<code>\</code>，而在UNIX等系统中则使用<code>/</code>。当书写路径名或以驱动器名开头时，代表绝对路径；以<code>\\</code>或<code>/</code>开头，也代表绝对路径，此时驱动器默认为当前工作目录所在驱动器；若以<code>.</code>、<code>..</code>或其他单词开头则代表相对路径。</p>
</blockquote>
<h4 id="获取文件的属性"><a class="header" href="#获取文件的属性">获取文件的属性</a></h4>
<pre><code class="language-java"> boolean exists()
 boolean isDirectory()
 boolean isFile()
</code></pre>
<blockquote>
<p><code>exists()</code>判断文件是否存在；<code>isDirectory()</code>判断文件目录是否为目录；<code>isFile()</code>判断文件是否为普通文件。</p>
</blockquote>
<pre><code class="language-java">String getName()
String getPath()
String getAbsolutePath()
String getParent()
</code></pre>
<blockquote>
<p><code>getName()</code>返回文件名；<code>getPath()</code>返回文件路径（根据构造函数给的是相对路径还是绝对路径决定），等效于<code>toString()</code>；<code>getAbsolutePath()</code>返回绝对路径；<code>getParent()</code>返回父目录的路径。</p>
</blockquote>
<pre><code class="language-java">String[] list()
File[] listFiles()
</code></pre>
<blockquote>
<p><code>list()</code>列出目录下的所有文件和目录；<code>listFiles()</code>列出目录下的所有普通文件。</p>
<p>如果对像不是目录或是空目录则返回<code>null</code>。</p>
</blockquote>
<pre><code class="language-java">boolean canRead()
boolean canWrite()
</code></pre>
<blockquote>
<p>获取文件的读写权限。</p>
</blockquote>
<pre><code class="language-java">long length()
</code></pre>
<blockquote>
<p>获取文件的长度（对与目录则返回值无意义）。</p>
</blockquote>
<h4 id="文件操作"><a class="header" href="#文件操作">文件操作</a></h4>
<pre><code class="language-java">boolean renameTo(File dest)
</code></pre>
<blockquote>
<p>将文件或目录的名称改为指定的名称（移动文件或目录），该操作是平台相关的，可能造成文件不能从一个文件系统移动到另一个文件系统，另外如果目标路径已经存在，则不能完成移动。根据返回值确定移动操作是否成功进行。</p>
</blockquote>
<pre><code class="language-java">boolean delete()
</code></pre>
<blockquote>
<p>删除文件或目录，如果是目录，则目录必须为空才能执行删除。</p>
</blockquote>
<pre><code class="language-java">boolean mkdir()
boolean mkdirs()
</code></pre>
<blockquote>
<p>创建目录，返回是否创建成功。</p>
<p><code>mkdir()</code>要求文件的父目录存在；<code>mkdirs()</code>在父目录不存在的情况下先创建父目录。</p>
</blockquote>
<pre><code class="language-java">boolean createNewFile()  // return true if file not exist and created.
</code></pre>
<blockquote>
<p>仅在文件不存在时创建新文件，文件的父目录必须存在。</p>
<p><strong>注意</strong>：<code>File</code>对象本身只是对磁盘文件/目录的映射，并不代表相应的文件实际存在或已被打开。</p>
</blockquote>
<h2 id="进程和线程"><a class="header" href="#进程和线程">进程和线程</a></h2>
<h3 id="创建进程-1"><a class="header" href="#创建进程-1">创建进程</a></h3>
<h4 id="执行系统命令"><a class="header" href="#执行系统命令">执行系统命令</a></h4>
<h5 id="使用runtime"><a class="header" href="#使用runtime">使用Runtime</a></h5>
<pre><code class="language-java">Runtime rt = Runtime.getRuntime();
Process ps = rt.exec(cmd_string);
int exitCode = ps.waitFor();
</code></pre>
<p>https://www.javaworld.com/article/2071275/when-runtime-exec---won-t.html</p>
<h5 id="使用processbuilder"><a class="header" href="#使用processbuilder">使用ProcessBuilder</a></h5>
<pre><code class="language-java">ProcessBuilder builder = new ProcessBuilder();
builder.command(&quot;cmd.exe&quot;, &quot;/c&quot;, &quot;dir&quot;);	// &quot;sh&quot; for linux
builder.directory(new File(System.getProperty(&quot;user.home&quot;)));
Process process = builder.start();
int exitCode = process.waitFor();
</code></pre>
<h5 id="命令的输出"><a class="header" href="#命令的输出">命令的输出</a></h5>
<blockquote>
<p><em><a href="https://www.baeldung.com/run-shell-command-in-java">the output must be consumed</a> – otherwise the process doesn't return successfully, instead it will hang.</em></p>
</blockquote>
<pre><code class="language-java">StreamGobbler streamGobbler = 
  new StreamGobbler(process.getInputStream(), System.out::println);
// process.getErrorStream()
Executors.newSingleThreadExecutor().submit(streamGobbler);
</code></pre>
<h3 id="创建线程"><a class="header" href="#创建线程">创建线程</a></h3>
<p><a href="https://www.journaldev.com/1079/multithreading-in-java">Multithreading in Java - Everything You MUST Know - JournalDev</a></p>
<p><a href="https://www.journaldev.com/1016/java-thread-example">Java Thread Example - JournalDev</a></p>
<p>Java 提供了三种创建线程的方法：</p>
<ul>
<li>
<p>继承 <code>Thread</code>类，实现<code>run()</code>方法：</p>
<pre><code class="language-java">class MyThread extends Thread{
	public void run(){
		while(true){
			System.out.println(&quot;MyThread类的run()方法在运行&quot;);
		}
	}
}
MyThread myThread=new MyThread();
myThread.start();
</code></pre>
</li>
<li>
<p>继承 <code>Runnable</code>接口并实现<code>run()</code>方法的类。可以使用Lambda表达式定义函数接口。</p>
<pre><code class="language-java">Runnable runnable = () -&gt; {
   while(true){
      System.out.println(&quot;MyThread类的run()方法在运行&quot;);
   }
}
runnable.start();  // =&gt; thread.start(new Thread(runnable));
</code></pre>
</li>
<li>
<p>通过 <code>Callable</code>和 <code>Future</code>创建线程。</p>
<p><code>Callable</code>一般是和<code>ExecutorService</code>配合来使用的</p>
<pre><code class="language-java">&lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task);
&lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result);
Future&lt;?&gt; submit(Runnable task);
</code></pre>
<p><code>Future</code>就是对于具体的<code>Runnable</code>或者<code>Callable</code>任务的执行结果进行取消、查询是否完成、获取结果。</p>
<pre><code class="language-java">public interface RunnableFuture&lt;V&gt; extends Runnable, Future&lt;V&gt; {
    void run();
}
public class FutureTask&lt;V&gt; implements RunnableFuture&lt;V&gt;
</code></pre>
<p><a href="https://www.cnblogs.com/dolphin0520/p/3949310.html">Java并发编程：Callable、Future和FutureTask</a></p>
<p><a href="https://www.journaldev.com/1090/java-callable-future-example">Java Callable Future Example - JournalDev</a></p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="scala"><a class="header" href="#scala">Scala</a></h1>
<blockquote>
<p><em>The name Scala comes from the word <strong>scalable</strong>, and true to that name, the Scala language is used to power busy websites and analyze huge data sets.</em></p>
</blockquote>
<p>Scala特性：</p>
<ul>
<li>
<p>高级语言：无需处理底层概念，如指针和内存管理；</p>
</li>
<li>
<p>面向对象和函数式编程：函数也能当成值来使用，定义匿名函数，支持高阶函数，允许嵌套多层函数；支持函数式和面向对象混合编程。</p>
<blockquote>
<ul>
<li><em>Functions for the logic</em></li>
<li><em>Objects for the modularity</em></li>
</ul>
</blockquote>
</li>
<li>
<p>静态类型（编译时检查），具有表达性强的类型系统（可自动推测类型，而无需为<a href="Java/Scala.html#%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E">变量声明</a>固定类型）；</p>
</li>
<li>
<p>Scala源代码被编译成Java字节码运行在Java虚拟机上，可以无缝与现有的Java类库交互。</p>
</li>
<li>
<p>并发性：Scala使用Actor作为其并发模型，Actor是类似线程的实体，通过邮箱发收消息。</p>
</li>
<li>
<p>应用：服务、大数据应用、浏览器（Scala.js）。</p>
</li>
</ul>
<h2 id="安装-2"><a class="header" href="#安装-2">安装</a></h2>
<h3 id="使用coursier"><a class="header" href="#使用coursier">使用<a href="Java/Scala.html#Coursier%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7">Coursier</a></a></h3>
<h3 id="使用系统软件仓库或安装包"><a class="header" href="#使用系统软件仓库或安装包">使用系统软件仓库或安装包</a></h3>
<p>不推荐：不能一次性安装所有工具。</p>
<h4 id="ubuntu-scala-211"><a class="header" href="#ubuntu-scala-211">Ubuntu (scala-2.11)</a></h4>
<pre><code class="language-shell">apt install scala  # 包括scalac、scala、fsc、scaladoc
</code></pre>
<h5 id="安装sbt"><a class="header" href="#安装sbt">安装sbt</a></h5>
<pre><code class="language-shell">echo &quot;deb https://repo.scala-sbt.org/scalasbt/debian all main&quot; | sudo tee /etc/apt/sources.list.d/sbt.list
echo &quot;deb https://repo.scala-sbt.org/scalasbt/debian /&quot; | sudo tee /etc/apt/sources.list.d/sbt_old.list
curl -sL &quot;https://keyserver.ubuntu.com/pks/lookup?op=get&amp;search=0x2EE0EA64E40A89B84B2DF73499E82A75642AC823&quot; | sudo apt-key add
sudo apt update &amp;&amp; sudo apt install sbt
</code></pre>
<h3 id="windows"><a class="header" href="#windows">Windows</a></h3>
<pre><code class="language-powershell">winget install scala
winget install sbt
</code></pre>
<h2 id="scala程序"><a class="header" href="#scala程序">Scala程序</a></h2>
<h3 id="交互式编程"><a class="header" href="#交互式编程">交互式编程</a></h3>
<h3 id="脚本"><a class="header" href="#脚本">脚本</a></h3>
<pre><code class="language-scala">// class definition similar to JAVA
object ExampleClass {   // object is singleton class
   def main(args: Array[String]) {
      println(&quot;Hello, world!&quot;) // 输出 Hello World
   }
}
@main def main(args:Array[String]) = {...}  // scala3
</code></pre>
<h3 id="基本语法-2"><a class="header" href="#基本语法-2">基本语法</a></h3>
<p>语句可以用分号（;）结束或换行符。</p>
<h3 id="包"><a class="header" href="#包">包</a></h3>
<pre><code class="language-scala">package com.runoob  // java package style
class HelloWorld
</code></pre>
<pre><code class="language-scala">package com.runoob{ // c# Namespace style
	class HelloWorld    
}
</code></pre>
<p>导入依赖包：使用<code>_</code>代表包中所有可导入内容。</p>
<pre><code class="language-scala">import java.util.*		
import org.apache.spark.sla._

import scala.jdk.CollectionConverters.*
val scalaList: Seq[Integer] = JavaClass.getJavaList().asScala.toSeq
</code></pre>
<h4 id="流行的scala库"><a class="header" href="#流行的scala库">流行的Scala库</a></h4>
<ul>
<li><a href="https://www.playframework.com/">Play Framework</a>：Web应用服务；</li>
<li><a href="https://www.lagomframework.com/">Lagom</a>：微服务架构；</li>
<li><a href="https://spark.apache.org/">Apache Spark</a>：分布式大数据处理。</li>
<li><a href="https://www.scala-js.org/">Scala.js</a>：Web前端应用。</li>
<li><a href="https://github.com/lauris/awesome-scala">其他Scala应用</a>。</li>
</ul>
<h3 id="数据类型-1"><a class="header" href="#数据类型-1">数据类型</a></h3>
<p>Scala与Java有着相同的数据类型，scala没有java中的原生类型。空值是 scala.Null 类型。</p>
<h4 id="变量-3"><a class="header" href="#变量-3">变量</a></h4>
<h5 id="变量声明-2"><a class="header" href="#变量声明-2">变量声明</a></h5>
<pre><code class="language-scala">var myVar [: String] = &quot;Foo&quot;  // 变量
val myVal [: String] = &quot;Foo&quot;  // 常量
</code></pre>
<p>类型推断：根据初始化值推断变量类型，而无需指定变量类型。</p>
<h5 id="类型转换-1"><a class="header" href="#类型转换-1">类型转换</a></h5>
<p><code>Int</code>和<code>Long</code>不能自动类型转换（<code>ClassCastException</code>），需要使用强制类型转换：</p>
<pre><code class="language-scala">v.asInstanceOf[Type]
</code></pre>
<blockquote>
<p><code>Any</code>类型只向其实际类型转换，不能直接转换为其他类型；必须还原实际类型后执行强制转换。</p>
</blockquote>
<h5 id="运算符-6"><a class="header" href="#运算符-6">运算符</a></h5>
<ul>
<li>算术运算符：<code>+,-,*,/,%</code></li>
<li>比较运算符：<code>==,!=,&gt;,&lt;,&gt;=,&lt;=</code></li>
<li>逻辑运算符：<code>&amp;&amp;,||,!</code></li>
<li>位运算符：<code>&amp;,|,^,~,&lt;&lt;,&gt;&gt;,&gt;&gt;&gt;</code>（<code>&gt;&gt;&gt;</code>右移补零）</li>
<li>赋值运算符：<code>=,+=,-=,...</code></li>
<li></li>
</ul>
<h4 id="类-2"><a class="header" href="#类-2">类</a></h4>
<p>Scala中的类不声明为<code>public</code>，一个Scala源文件中可以有多个类。</p>
<pre><code class="language-scala">class Point(xc: Int, yc: Int)  extends baseclass(args) {
   var x: Int = xc
   var y: Int = yc
   def move(dx: Int, dy: Int) {   }
}
</code></pre>
<p>所有类继承自<code>Any</code>，其子类包括<code>AnyVal</code>（值类型）和<code>AnyRef</code>（引用类型，类似于Java）。</p>
<h5 id="traits"><a class="header" href="#traits">Traits</a></h5>
<p>Traits(特征) 相当于Java的接口。与接口不同的是，它还可以定义属性和方法的实现。</p>
<blockquote>
<p>使用<code>new</code>关键字创建对象。</p>
</blockquote>
<h4 id="数组array"><a class="header" href="#数组array">数组（Array）</a></h4>
<pre><code class="language-scala">import Array._
var array:Array[String] = new Array[String](3)
var array = new Array[String](3)
var myMatrix = ofDim[Int](3,3)  // 二维数组
var x = range(1,10,2)  //start stop step   Range
</code></pre>
<blockquote>
<p>下标访问符为<code>()</code>，而非<code>[]</code>。</p>
<p>泛型类型声明符为<code>[]</code>，而非<code>&lt;&gt;</code>（容器类型）。</p>
</blockquote>
<h4 id="容器collection"><a class="header" href="#容器collection">容器（Collection）</a></h4>
<p><img src="Java/Scala.assets/2fjoA.png" alt="enter image description here" /></p>
<h5 id="不可变对象"><a class="header" href="#不可变对象">不可变对象</a></h5>
<p>Scala默认使用不可变对象（<code>scala.collection.immutable</code>）。可以导入<code>collection.mutable</code>包使用可变对象版本。</p>
<pre><code class="language-scala">import scala.collection.mutable
var s = mutable.Set()
</code></pre>
<p>修改对象的操作返回新对象。</p>
<p>List</p>
<blockquote>
<p><code>Nil</code>表示空列表。</p>
<p><code>Seq</code>是List继承的特征（trait）。</p>
</blockquote>
<p>Set</p>
<blockquote>
<p><code>set(val)</code>判断值是否在集合中。</p>
<p>无法按下标返回元素。</p>
</blockquote>
<p>Map</p>
<pre><code class="language-scala">var A:Map[Char,Int] = Map()
A += ('I' -&gt; 1)  // add key-value
val colors = Map(&quot;red&quot; -&gt; &quot;#FF0000&quot;, &quot;azure&quot; -&gt; &quot;#F0FFFF&quot;)
println(colors(&quot;red&quot;))
for (c &lt;- colors){
  println(c)  // iterate c is (key,value) tuple
}
</code></pre>
<p>Tuple</p>
<blockquote>
<p>使用<code>t._idx</code>访问元组的元素（<code>idx 1-based</code>）；</p>
<p>目前 Scala 支持的元组最大长度为 22。</p>
</blockquote>
<p>Option</p>
<p>Iterator</p>
<h5 id="运算符-7"><a class="header" href="#运算符-7">运算符</a></h5>
<p><code>:</code>用于声明运算符与相邻对象的结合关系。</p>
<pre><code class="language-scala">var a = List(1,2,3), c = List(4,5,6), item = 10
val b = a:+item  // append a with item
val b = item+:a  // prepend a with item: item::a
val b = a++c     // appended c to a
val b = a++:c    // prepend a to c: also a:::c
</code></pre>
<blockquote>
<p><code>+</code>运算符用于字符串（<code>String</code>）拼接。</p>
<p><code>:++</code> error.</p>
</blockquote>
<h5 id="java容器"><a class="header" href="#java容器">Java容器</a></h5>
<h3 id="访问修饰符"><a class="header" href="#访问修饰符">访问修饰符</a></h3>
<h3 id="方法和函数"><a class="header" href="#方法和函数">方法和函数</a></h3>
<p>Scala 方法是类的一部分，而函数是一个对象可以赋值给一个变量。</p>
<h4 id="方法定义语法"><a class="header" href="#方法定义语法">方法定义语法</a></h4>
<p>方法声明中，可以选择指定参数类型、参数默认值、返回值类型。</p>
<pre><code class="language-scala">def sum(x: Int, y: Int = 0)[: Int]= x + y  // expression style
@Transaction
@throws(classOf[IOException])
def methodName ([arg1:Int, arg2 Double])[: Double] = // method style
{
   statements
   return [expr]
}
def matchState(x): Int=x match{...} // methods with single match
</code></pre>
<blockquote>
<p>公开方法需要声明返回类型，局部或私有方法可以省略返回类型声明（<code>: Int</code>）。</p>
<p>无返回值，则声明<code>: Unit</code>（类似于 <code>void</code>）。</p>
<p>类似于Java，可以声明标注（Annotations），包括抛出异常（Java使用关键字<code>throws</code>抛出异常）。</p>
</blockquote>
<h5 id="method-style"><a class="header" href="#method-style">method style</a></h5>
<p>与多数编程语言类似，使用<code>{}</code>代码块表示函数体。</p>
<h5 id="expression-style"><a class="header" href="#expression-style">expression style</a></h5>
<p>使用<code>=</code>运算符连接单句表达式作为函数体（类似于Lambda表达式）。</p>
<h5 id="match表达式"><a class="header" href="#match表达式">match表达式</a></h5>
<h4 id="函数对象"><a class="header" href="#函数对象">函数对象</a></h4>
<p>函数对象保存一个<strong>匿名函数</strong>定义，<code>=&gt;</code>运算符用于分隔参数列表和函数体。</p>
<pre><code class="language-scala">val f1 = (a: Int, b: Int) =&gt; a + b
val f2 = { (a: Int, b: Int) =&gt;
  val sum = a + b
  sum  // return sum
}
</code></pre>
<h5 id="闭包"><a class="header" href="#闭包">闭包</a></h5>
<p>匿名函数及其引用的外部作用域中的对象组成闭包。</p>
<pre><code class="language-scala">factor = 5
val multiplier = (i:Int) =&gt; i * factor
</code></pre>
<blockquote>
<p>注意函数返回值使用<code>=</code>，方法返回值使用<code>=&gt;</code>。</p>
</blockquote>
<h4 id="map-and-reduce"><a class="header" href="#map-and-reduce">Map and Reduce</a></h4>
<p>传递（匿名）函数对象作为<code>map</code>和<code>reduce</code>的参数。</p>
<pre><code class="language-scala">val l = List(2, 5, 3, 6, 4, 7)
val sum = l.reduce((x, y) =&gt; x+y)
val sqrt = l.map(x =&gt; x*x)
</code></pre>
<h4 id="模式匹配switch-case"><a class="header" href="#模式匹配switch-case"><a href="https://www.runoob.com/scala/scala-pattern-matching.html">模式匹配</a>（switch-case）</a></h4>
<pre><code class="language-scala">def matchTest(x: Any): Any = x match {
      case 1 =&gt; &quot;one&quot;
      case &quot;two&quot; =&gt; 2
      case y: Int =&gt; &quot;scala.Int&quot;
      case _ =&gt; &quot;many&quot;
   }
</code></pre>
<h4 id="正则表达式-2"><a class="header" href="#正则表达式-2">正则表达式</a></h4>
<pre><code class="language-scala">import scala.util.matching.Regex
</code></pre>
<h3 id="流程控制-4"><a class="header" href="#流程控制-4">流程控制</a></h3>
<h4 id="条件-4"><a class="header" href="#条件-4">条件</a></h4>
<pre><code class="language-scala">y = x match {
  case hd :: tail =&gt; hd + sum(tail)
  case Nil =&gt; 0
}
</code></pre>
<h4 id="循环-4"><a class="header" href="#循环-4">循环</a></h4>
<pre><code class="language-scala">for ( x &lt;- iterable ){
  println(x)
}
</code></pre>
<h4 id="异常处理-4"><a class="header" href="#异常处理-4">异常处理</a></h4>
<pre><code class="language-scala">try {
    val f = new FileReader(&quot;input.txt&quot;)
} catch {
    case ex: FileNotFoundException =&gt;{
        println(&quot;Missing file exception&quot;)
    }
    case ex: IOException =&gt; {
        println(&quot;IO Exception&quot;)
    }
} finally {
    println(&quot;Exiting finally...&quot;)
}
</code></pre>
<h3 id="输入输出-3"><a class="header" href="#输入输出-3">输入输出</a></h3>
<p>Scala 进行文件写操作，直接用的都是 java中 的 I/O 类 （<strong>java.io.File</strong>)。</p>
<ol>
<li><a href="https://www.scala-lang.org/">The Scala Programming Language</a>.</li>
<li></li>
</ol>
<p>Java的标准输入输出已经导入运行环境，可以直接调用函数如<code>print</code>、<code>println</code>，无需添加包名（<code>System.out</code>）。</p>
<h2 id="scala项目"><a class="header" href="#scala项目">Scala项目</a></h2>
<p><code>sbt</code>是首选的Scala项目管理工具，其他工具包括<code>ant</code>、<code>gradle</code>、<code>maven</code>……</p>
<h3 id="sbt项目"><a class="header" href="#sbt项目">sbt项目</a></h3>
<h4 id="创建项目"><a class="header" href="#创建项目">创建项目</a></h4>
<pre><code class="language-shell">sbt new scala/hello-world.g8  # Scala 3 project
sbt new scala/scala3.g8       # Scala 2 project
</code></pre>
<blockquote>
<p>需要下载运行环境（包括从Maven仓库下载依赖库，视网络环境可能占用一定时间）。</p>
</blockquote>
<h5 id="项目结构"><a class="header" href="#项目结构">项目结构</a></h5>
<pre><code class="language-shell">project-name
├── build.sbt  # sbt项目配置
├── project
│   └── build.properties
└── src
    └── main
        └── scala
            └── Main.scala  # 入口程序
</code></pre>
<h4 id="项目配置-1"><a class="header" href="#项目配置-1">项目配置</a></h4>
<p><code>build.sbt</code>：</p>
<pre><code class="language-ini">name := &quot;HelloWorld&quot;
version := &quot;1.0&quot;
scalaVersion := &quot;2.13.8&quot;  # *
</code></pre>
<blockquote>
<p><code>*</code>：项目可指定Scala版本而无需使用全局Scala版本。</p>
</blockquote>
<h2 id="开发环境-1"><a class="header" href="#开发环境-1">开发环境</a></h2>
<h3 id="coursier管理工具"><a class="header" href="#coursier管理工具">Coursier管理工具</a></h3>
<p>Coursier命令行工具用于安装Scala应用程序和设置开发环境<sup class="footnote-reference"><a href="#coursier">1</a></sup>。</p>
<h4 id="安装coursier"><a class="header" href="#安装coursier">安装Coursier</a></h4>
<p>==如果安装过程无法下载数据，首先检查网络状况，可能需要<a href="Java/Scala.html#Coursier%E4%BB%A3%E7%90%86%E9%85%8D%E7%BD%AE">设置代理</a>。==</p>
<h5 id="linux"><a class="header" href="#linux">Linux</a></h5>
<pre><code class="language-shell">CS_URL=https://github.com/coursier/launchers/raw/master/cs-x86_64-pc-linux.gz
curl -fL $CS_URL | gzip -d &gt; cs &amp;&amp; chmod +x cs &amp;&amp; ./cs [options] setup [options]
</code></pre>
<p>将安装<code>coursier</code>(<code>cs</code>)到默认位置，以及安装以下<strong>全局</strong>命令行工具和JVM（安装过程会提示是否更新用户配置文件（<code>.profile</code>）中的环境变量，从而使相应工具全局可用）：</p>
<ul>
<li><code>scala-cli</code>, a <a href="https://scala-cli.virtuslab.org/">convenient tool to compile / run / package Scala code</a></li>
<li><code>scala</code>, the Scala REPL</li>
<li><code>scalac</code>, the Scala compiler</li>
<li><code>sbt</code> and <code>sbtn</code>, the <a href="https://www.scala-sbt.org/">sbt build tools</a></li>
<li><code>ammonite</code>, <a href="https://ammonite.io/">an enhanced REPL</a> for Scala</li>
<li><code>scalafmt</code>, the <a href="https://scalameta.org/scalafmt/">Scala code formatter</a></li>
</ul>
<p>安装完成后可移除下载的<code>cs</code>文件，使用安装版本的<code>couriser/cs</code>进行管理。</p>
<pre><code class="language-shell">cs setup \
   --apps sbt-launcher,ammonite \ # 安装额外的命令行工具 
   --install-dir ~/.local/scala \ # 修改安装目录*
   --yes                          # 使用默认选项,取消交互
</code></pre>
<blockquote>
<p><code>*</code>：<code>--install-dir</code>仅适用于<code>cs</code>以及<code>scala</code>工具，不适用于JVM安装路径。</p>
</blockquote>
<h5 id="windows-1"><a class="header" href="#windows-1">Windows</a></h5>
<pre><code class="language-powershell">$Uri=&quot;https://github.com/coursier/launchers/raw/master/cs-x86_64-pc-win32.zip&quot;
Invoke-WebRequest -Uri $Uri -OutFile &quot;cs-x86_64-pc-win32.zip&quot;
Expand-Archive -Path &quot;cs-x86_64-pc-win32.zip&quot;
.\cs-x86_64-pc-win32.exe setup
get-command cs  # 重新打开终端执行
</code></pre>
<p>安装完成后，将自动添加<code>Coursier</code>目录<code>C:\Users\USER\AppData\Local\Coursier\data\bin</code>到路径环境变量中（如果未添加，可手动添加；如果不需要全局启用，可通过PowerShell <code>$Profile</code>设置）。</p>
<pre><code class="language-shell">$env:JAVA_HOME=&quot;C:\Users\gary\AppData\Local\Coursier\cache\arc\https\github.com\AdoptOpenJDK\openjdk8-binaries\releases\download\jdk8u292-b10\OpenJDK8U-jdk_x64_windows_hotspot_8u292b10.zip\jdk8u292-b10&quot;
$env:PATH=&quot;$env:JAVA_HOME\bin;C:\tools\scala;$env:PATH&quot;
</code></pre>
<h4 id="配置coursier"><a class="header" href="#配置coursier">配置Coursier</a></h4>
<h5 id="coursier网络代理配置"><a class="header" href="#coursier网络代理配置"><a href="https://get-coursier.io/docs/other-proxy">coursier网络代理配置</a></a></h5>
<p>Coursier的JVM不会自动使用系统的代理配置，需要将代理配置通过Java选项传递给JVM。</p>
<pre><code class="language-shell">coursier '-J-Dhttps.proxyHost=127.0.0.1' '-J-Dhttps.proxyPort=7890' [args] #*
sbt '-Dhttps.proxyHost=…' '-Dhttps.proxyPort=…' [args]  #**
</code></pre>
<blockquote>
<p>传递给<code>java.net.HttpURLConnection</code>的代理属性，HTTP同理。</p>
<p><code>*</code>：PowerShell会将<code>-XX</code>解释为PowerShell命令的选项，需要使用<code>''</code>将其视为普通参数传递。</p>
<p><code>**</code>：在环境变量<code>JAVA_OPTS</code>中配置（仅适用于<code>sbt</code>，不适用于<code>coursier</code>）：</p>
<pre><code class="language-shell">export JAVA_OPTS=&quot;$JAVA_OPTS -Dhttp.proxyHost= -Dhttp.proxyPort= ...&quot;
</code></pre>
</blockquote>
<h5 id="仓库配置"><a class="header" href="#仓库配置">仓库配置</a></h5>
<p>仓库列表：<code>~/.sbt/repositories</code>文件（不存在则手动创建）记录所有可用仓库列表。</p>
<pre><code class="language-ini">[repositories]
local          
maven-central   
</code></pre>
<blockquote>
<p>模板配置文件：<a href="https://github.com/delta-io/delta/blob/master/build/sbt-config/repositories">delta/repositories at master · delta-io/delta (github.com)</a></p>
</blockquote>
<p>默认仓库为：</p>
<ul>
<li><code>ivy2local</code>：Ivy2本地仓库，位于<code>~/.ivy2/local</code>；</li>
<li><code>central</code>：Maven中央仓库，即<code>https://repo1.maven.org/maven2</code>；</li>
</ul>
<p>上述默认配置可通过环境变量<code>COURSIER_REPOSITORIES</code>修改（使用镜像仓库代替Maven中央仓库<code>central</code>）。或通过命令行选项<code>-r,--repository</code>指定额外仓库（可指定多次以包含多个仓库）。提供<code>--no-default</code>将不使用默认或通过环境变量配置的仓库。</p>
<pre><code class="language-shell">export COURSIER_REPOSITORIES=&quot;ivy2Local|central|sonatype:releases|jitpack|http://&quot;
</code></pre>
<p><a href="https://www.scala-sbt.org/1.x/docs/Proxy-Repositories.html#sbt+Configuration">sbt Reference Manual — Proxy Repositories sbt Configuration</a></p>
<p><a href="https://www.scala-sbt.org/1.x/docs/Launcher-Configuration.html#3.+Repositories+Section">sbt Reference Manual — sbt Launcher Configuration 3. Repositories Section</a></p>
<p>相应地，可在项目配置文件（优先级更高）中添加：</p>
<pre><code class="language-scala">resolvers += &quot;central&quot; at &quot;http://maven.aliyun.com/nexus/content/groups/public/&quot;
externalResolvers :=
 Resolver.withDefaultResolvers(resolvers.value, mavenCentral = false)
</code></pre>
<p>镜像配置：<code>sbt</code>默认使用Maven中央仓库下载依赖，因此速度很慢。<code>~/.config/coursier/mirror.properties</code>（Linux）中配置代理转发规则（类似于Maven配置的<code>mirrorOf</code>）。</p>
<pre><code class="language-shell">central.from=https://repo1.maven.org/maven2
central.to=https://mirrors.huaweicloud.com/repository/maven  #*
</code></pre>
<blockquote>
<p><code>*</code>：阿里云/163中央仓库镜像缺少部分Scala插件包，<a href="http://mirrors.cloud.tencent.com/nexus/repository/maven-public">腾讯云</a>下载文件可能校验和不一致，实测<a href="https://mirrors.huaweicloud.com/repository/maven">华为云</a>镜像更新安装时不会报错。</p>
<p>该配置文件路径可通过<code>COURSIER_MIRRORS</code>环境变量或命令行选项<code>-Dcoursier.mirrors=</code>指定。</p>
</blockquote>
<h5 id="缓存路径"><a class="header" href="#缓存路径">缓存路径</a></h5>
<p>缓存用于存放不经常发生变化的依赖库，<a href="https://get-coursier.io/docs/cache#default-location">默认路径</a>为<code>~/.cache/coursier/v1</code>（Linux），配置<code>COURSIER_CACHE</code>环境变量或<code>coursier.cache</code>Java选项覆盖默认路径。</p>
<ul>
<li><code>coursier</code>使用的缓存路径：传递<code>--cache</code>选项覆盖上述配置；</li>
<li><code>sbt</code>使用的缓存路径：其位置可在<code>sbt</code>交互环境中使用<code>show csrCacheDirectory</code>查看。通过或传递<code>-Dsbt.coursier.home</code>选项来更改缓存路径。</li>
</ul>
<p><strong>缓存声明周期</strong>：以<code>-SNAPSHOT</code>结尾的包、Maven元数据等具有缓存周期（TTL，默认为24小时）。</p>
<h4 id="管理scala命令行应用程序"><a class="header" href="#管理scala命令行应用程序">管理Scala命令行应用程序</a></h4>
<pre><code class="language-shell">cs install &lt;app:version&gt; --install-dir DIR  # -&gt; cs setup --apps &lt;app:version&gt;
cs list|update|uninstall|search &lt;app:version&gt;
</code></pre>
<p>默认安装位置：<code>~/.local/share/coursier/bin</code>，可通过配置修改；需要将安装位置加入<code>PATH</code>以便通过命令名启动应用。环境变量<code>COURSIER_BIN_DIR|COURSIER_INSTALL_DIR</code>以及Java属性<code>coursier.install.dir</code>可覆盖上述默认位置（优先级由高到低）。==命令行选项<code>--dir,--install-dir</code>具有最高优先级==。</p>
<h5 id="管理jvm"><a class="header" href="#管理jvm">管理JVM</a></h5>
<pre><code class="language-shell">cs java --available                # 列出可用Java版本
cs java --installed                # 列出已安装Java版本
cs setup --jvm 11                  # 安装Java环境*
cs java --jvm 11 --env             # 输出设置Java环境变量的语句，可调用eval执行
cs java --jvm 11 [options] args... # 使用指定Java(不存在则自动下载安装)**
cs java --jvm VER --setup          # 设置默认Java版本
cs java-home [--jvm ver]...        # 显示指定环境的JAVA_HOME
</code></pre>
<blockquote>
<p><code>cs</code>会首先检查系统是否自带Java并尝试使用该版本；如果没有，则自动安装AdoptOpenJDK 1.8。通过<code>--jvm</code>指定的Java即使与自带版本相同（如<code>1.8</code>）还是会额外下载安装，如果版本仅指定数字，默认安装Adoptium发布的JDK（<code>adoptium</code>，与AdoptOpenJDK标识<code>adopt</code>不同）。安装后会提示是否更新环境变量，环境变量决定命令行工具依赖的Java版本。</p>
<p>如果使用指定版本Java执行命令时，该版本不存在，则<code>cs</code>会自动下载安装相应版本Java。</p>
<p>Adoptium OpenJDK是从GitHub下载，可能需要<a href="Java/Scala.html#%E7%BD%91%E7%BB%9C%E4%BB%A3%E7%90%86%E9%85%8D%E7%BD%AE">使用代理</a>。</p>
<p><code>*</code>：<em><code>--jvm-dir</code>（指定Java安装路径）不可用</em>。JVM安装路径可通过<code>COURSIER_JVM_CACHE</code>或<code>coursier.jvm.cache</code><a href="Java/Scala.html#%E5%90%AF%E5%8A%A8Scala%E5%BA%94%E7%94%A8">Java系统属性</a>设置。</p>
</blockquote>
<h5 id="启动scala应用"><a class="header" href="#启动scala应用">启动Scala应用</a></h5>
<p><code>install</code>命令会将安装的应用存放在上述路径下，因此通过命令名启动应用程序则是最近安装的版本。</p>
<pre><code class="language-shell">app [options] args...        # 启动默认版本
</code></pre>
<p>如果要启动其他版本，使用<code>cs launch</code>命令。</p>
<pre><code class="language-shell">cs launch &lt;app:version&gt; [cs_options] -- [app_args...] # app未经安装则直接从仓库源拉取
# cs launch scala:2.12.15
cs launch org.scalameta::scalafmt-cli:2.4.2
   -M,--main-class                       # 如果指定的库找不到主类，可通过该选项指定
   -java-opt -Dfoo=bar --java-opt -Xmx2g # 传递Java参数给应用
</code></pre>
<blockquote>
<p>应用程序支持接收<a href="Java/JAVA%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80.html#Java%E7%B3%BB%E7%BB%9F%E5%B1%9E%E6%80%A7">Java运行时参数</a>，如<code>&quot;-J-Xmx2g&quot;</code>；或通过环境变量设置，两种可混合使用。</p>
<pre><code class="language-shell">export JAVA_OPTS=&quot;-Xmx2g -Dfoo=bar&quot;
</code></pre>
</blockquote>
<p><code>bootstrap</code>将从指定的依赖库构造可执行的应用程序文件。</p>
<pre><code class="language-shell">cs bootstrap org.scalameta::scalafmt-cli:2.4.2 -o scalafmt
</code></pre>
<blockquote>
<p><a href="https://get-coursier.io/docs/cli-bootstrap">bootstrap · Coursier (get-coursier.io)</a></p>
</blockquote>
<h5 id="配置应用程序通道"><a class="header" href="#配置应用程序通道">配置应用程序通道</a></h5>
<p>默认使用主通道，即<code>io.get-coursier:apps</code>。</p>
<pre><code class="language-shell">cs install --contrib app  # io.get-coursier:apps-contrib*
           --channel &lt;custom-channel&gt;
</code></pre>
<blockquote>
<p><code>*</code>：<code>app</code>和<code>io.get-coursier:apps-contrib</code>是官方维护的仓库通道。</p>
</blockquote>
<h4 id="管理maven依赖项"><a class="header" href="#管理maven依赖项">管理Maven依赖项</a></h4>
<h5 id="解析依赖项"><a class="header" href="#解析依赖项">解析依赖项</a></h5>
<pre><code class="language-shell">cs resolve io.circe::circe-generic:0.12.3
</code></pre>
<h5 id="下载依赖项"><a class="header" href="#下载依赖项">下载依赖项</a></h5>
<pre><code class="language-shell">cs fetch io.circe::circe-generic:0.12.3
         --classpath    # 输出依赖包的CLASSPATH,而不是仅列出下载路径
         --source       # 下载源码包而非标准包
         --javadoc      # 下载文档而非标准包
         --default=true # 同时下载标准包
</code></pre>
<h5 id="scala依赖库和应用程序"><a class="header" href="#scala依赖库和应用程序">Scala依赖库和应用程序</a></h5>
<ol>
<li>
<p><a href="https://github.com/lauris/awesome-scala">lauris/awesome-scala: A community driven list of useful Scala libraries, frameworks and software. (github.com)</a></p>
</li>
<li>
<p><a href="https://index.scala-lang.org/">Scaladex (scala-lang.org)</a></p>
</li>
</ol>
<h3 id="命令行工具-1"><a class="header" href="#命令行工具-1">命令行工具</a></h3>
<h4 id="编译工具"><a class="header" href="#编译工具">编译工具</a></h4>
<pre><code class="language-shell">sbt     # 进入sbt交互环境
[~]run  # 使用&quot;~&quot;可在文件发生更改时自动重新执行, 输入exit退出
sbt run # 直接编译运行
</code></pre>
<h3 id="集成开发环境-1"><a class="header" href="#集成开发环境-1">集成开发环境</a></h3>
<p>集成开发环境可使用<a href="https://www.jetbrains.com/help/idea/managing-plugins.html">IntelliJ</a>或VSCode。</p>
<h4 id="vscodemetals"><a class="header" href="#vscodemetals"><em>VSCode+Metals</em></a></h4>
<h5 id="开发环境设置"><a class="header" href="#开发环境设置">开发环境设置</a></h5>
<p>设置下Metals语言服务器依赖库的仓库源。</p>
<pre><code class="language-json">{
    &quot;metals.customRepositories&quot;: [
        &quot;https://maven.aliyun.com/repository/central&quot;
    ]
}
</code></pre>
<h5 id="metal项目设置"><a class="header" href="#metal项目设置">Metal项目设置</a></h5>
<p><code>bloop</code></p>
<h2 id="scala3"><a class="header" href="#scala3">Scala3</a></h2>
<h3 id="新特性"><a class="header" href="#新特性">新特性</a></h3>
<h5 id="new-in-scala-3--scala-documentation-scala-langorg"><a class="header" href="#new-in-scala-3--scala-documentation-scala-langorg"><a href="https://docs.scala-lang.org/scala3/new-in-scala3.html">New in Scala 3 | Scala Documentation (scala-lang.org)</a></a></h5>
<h2 id="参考资料"><a class="header" href="#参考资料">参考资料</a></h2>
<div class="footnote-definition" id="scalabook"><sup class="footnote-definition-label">2</sup>
<p><a href="https://docs.scala-lang.org/scala3/book/introduction.html">Introduction | Scala 3 — Book | Scala Documentation (scala-lang.org)</a>
<sup class="footnote-reference"><a href="#scalaref">3</a></sup>: <a href="https://docs.scala-lang.org/scala3/reference/index.html">Scala 3 Reference (scala-lang.org)</a>
<sup class="footnote-reference"><a href="#scalafeat">4</a></sup>: <a href="https://docs.scala-lang.org/scala3/book/scala-features.html">Scala 3 Features | Scala 3 — Book | Scala Documentation (scala-lang.org)</a></p>
</div>
<div class="footnote-definition" id="coursier"><sup class="footnote-definition-label">1</sup>
<p><a href="https://get-coursier.io/docs/overview">Coursier is the Scala application and artifact manager</a>.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="开发框架"><a class="header" href="#开发框架">开发框架</a></h1>
<h2 id="play-framework"><a class="header" href="#play-framework">Play Framework</a></h2>
<h3 id="play框架简介"><a class="header" href="#play框架简介">Play框架简介</a></h3>
<img src="Java/ScalaFrameworks.assets/play-stack-1665913183112-3.png" alt="img" style="zoom: 30%;" />
<ul>
<li>Model-View-Controller (MVC) architecture</li>
<li>hot reloading：在接收请求时检查当前是否存在内容需要重新加载。</li>
</ul>
<h3 id="play项目"><a class="header" href="#play项目">Play项目</a></h3>
<pre><code class="language-powershell">sbt '-Dhttps.proxyHost=127.0.0.1' '-Dhttps.proxyPort=10809' new playframework/play-scala-seed.g8
</code></pre>
<p>将自动在当前目录下创建项目目录（目录名通过交互命令提供）。项目结构：</p>
<pre><code class="language-shell">
D:\USERS\GARY\ONEDRIVE\WORKSPACE\SCALA\LEARN-PLAY-FRAMEWORK
├─.g8
│  └─form
│      ├─app   # MVC
│      │  ├─controllers
│      │  └─views
│      └─test
│          └─controllers
├─app
│  ├─controllers
│  └─views
├─conf
├─project
├─public       # 静态资源
│  ├─images
│  ├─javascripts
│  └─stylesheets
└─test
    └─controllers
</code></pre>
<h4 id="routes"><a class="header" href="#routes">routes</a></h4>
<p><code>conf/routes</code>定义了URL的处理路径。</p>
<pre><code class="language-shell"># An example controller showing a sample home page
GET  /              controllers.HomeController.index()
GET  /hello         controllers.HomeController.hello(name: String)
# Map static resources from the /public folder to the /assets URL path
GET  /assets/*file  controllers.Assets.versioned(path=&quot;/public&quot;, file: Asset)
</code></pre>
<h3 id="mvc架构"><a class="header" href="#mvc架构">MVC架构</a></h3>
<p>使用MVC架构处理并响应URL。</p>
<h4 id="视图及模板"><a class="header" href="#视图及模板">视图及模板</a></h4>
<p><code>app/views</code>中定义了Web应用的视图，支持使用模板（<em><strong>Twirl</strong>+<strong>HTML</strong></em>）。</p>
<pre><code class="language-html">@(name:String)
@main(&quot;Hello&quot;) {
    &lt;section id=&quot;top&quot;&gt;
        &lt;div class=&quot;wrapper&quot;&gt;
            &lt;h1&gt;Hello World, @name!&lt;/h1&gt;
        &lt;/div&gt;
    &lt;/section&gt;
}
</code></pre>
<p>Twirl模板语法：</p>
<ul>
<li>
<p><code>@</code>开始的内容通过模板引擎生成内容。</p>
</li>
<li>
<p><code>@(var:Type)</code>定义从控制器调用页面时传入的参数，在模板中使用<code>@var</code>引用参数。</p>
</li>
<li>
<p><code>@main(&quot;Hello&quot;, assetsFinder)</code>引用其他模板内容，并传入参数。</p>
</li>
<li></li>
<li>
<p><code>{}</code>中的内容将被插入生成的HTML<code>body</code>。</p>
</li>
</ul>
<h4 id="控制器"><a class="header" href="#控制器">控制器</a></h4>
<p>以下定义控制器<code>app/controllers</code>及其包含的URL处理方法。通过在<code>routes</code>文件中添加声明，以调用该控制器中的URL处理方法。</p>
<pre><code class="language-scala">class HomeController extends BaseController {
  /* &quot;/&quot;根URL处理 */
  def index() = Action { implicit request: Request[AnyContent] =&gt;
    Ok(views.html.index())  // 对应app/views目录下的页面
  }
  /* URL参数处理和传递至视图 */
  def hello(name:String) = Action {
    Ok(views.html.hello(name))
  }
}
</code></pre>
<h3 id="示例教程"><a class="header" href="#示例教程">示例教程</a></h3>
<blockquote>
<p><em>Play’s documentation shows the available features and how to use them, but the documentation will not show how to create an application from start to finish. This is where tutorials and examples come in. Tutorials and examples are useful for showing a single application at work, especially when it comes to integrating with other systems such as databases or Javascript frameworks.</em></p>
</blockquote>
<p><a href="https://www.playframework.com/documentation/2.8.x/Tutorials">Play Tutorials - 2.8.x (playframework.com)</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="c-programming"><a class="header" href="#c-programming">C# Programming</a></h1>
<p>C#是面向对象的编程语言，支持面向组件的编程，通过属性、方法和事件来提供编程模型。</p>
<p>C# 特性：垃圾回收 (Garbage collection)；异常处理 (exception handling)；类型安全 (type-safe) 的语言设计。</p>
<h2 id="基本语法-3"><a class="header" href="#基本语法-3">基本语法</a></h2>
<p>应用程序 (application)以名为<code>Main</code>的<a href="CSharp.NET/CSharp%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80.html#%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95">静态方法</a>作为程序执行的起点。<code>Main</code>方法中可书写表达式语句或调用类库或自定义的其他方法。</p>
<pre><code class="language-c#">namespace NameSpace{
   class Program{ 
      static void Main(string[] args){
         /* statements ... */
      } // return void or int
      static async Task Main() { }
      static async Task&lt;int&gt; Main(string[] args) { }  // (C# 7.1)
   }   
}   // Libraries and services do not require a Main method.
</code></pre>
<blockquote>
<p><code>Main</code>方法：必须为<code>static</code>方法，不需要是<code>public</code>。</p>
<p><code>args</code>为除了程序名称以外的参数。</p>
</blockquote>
<p>一个类中最多包含一个名为<code>Main</code>的方法。在一个程序的多个类或结构中，可能都定义了<code>Main</code>方法。这样的情况下，必须利用某种外部机制（如命令行编译器的选项<code>-main</code>）来选择其中一个<code>Main</code>方法用作入口点。</p>
<p>应用程序入口点方法不能位于泛型类声明中。</p>
<blockquote>
<p>从C#9开始，可以省略Main方法，将位于全局命名空间的语句作为主函数内容。</p>
</blockquote>
<h3 id="变量-4"><a class="header" href="#变量-4">变量</a></h3>
<p>变量表示数据的存储位置。</p>
<h4 id="定义变量"><a class="header" href="#定义变量">定义变量</a></h4>
<pre><code class="language-c#">&lt;type&gt; varname = value;
</code></pre>
<p><strong>变量名称约定</strong></p>
<ul>
<li>
<p>使用驼峰式，即第一个单词以小写字母开始，后续每个单词的首字母采用大写形式。</p>
</li>
<li>
<p>变量名称不应包含变量的数据类型（在实际代码中可能不能代表实际类型）。</p>
</li>
</ul>
<p>隐式类型本地变量使用 <code>var</code> 关键字进行创建，该关键字指示 C# 编译器去推断类型。</p>
<pre><code class="language-c#">var age = 10;
</code></pre>
<blockquote>
<p>变量名应使用骆驼式命名法。</p>
</blockquote>
<h4 id="常量"><a class="header" href="#常量">常量</a></h4>
<p>对于数学常量，在<code>System.Math</code>类中有比较精确的定义，可以直接使用，例如<code>pi</code>和<code>e</code>。</p>
<h5 id="字面值-2"><a class="header" href="#字面值-2">字面值</a></h5>
<p>在数字后加上后缀，可以将字面值表示成不同类型的数值。</p>
<h6 id="整形"><a class="header" href="#整形">整形</a></h6>
<ul>
<li>没有后缀：解析成<code>int</code>、<code>uint</code>、<code>long</code>、<code>ulong</code>；</li>
<li>具有<code>u</code>后缀：解析成<code>uint</code>、<code>ulong</code>；</li>
<li>具有<code>l</code>后缀：解析成<code>long</code>、<code>ulong</code>；</li>
<li>具有<code>ul</code>或<code>lu</code>后缀：解析成<code>ulong</code>；</li>
<li>十六进制表示：添加前缀“<code>0x</code>”</li>
</ul>
<p><code>bool</code>类型的字面值：<code>true</code>、<code>false</code>。</p>
<h6 id="浮点型"><a class="header" href="#浮点型">浮点型</a></h6>
<ul>
<li>具有<code>D/d</code>后缀：解析成<code>double</code>；</li>
<li>具有<code>M/m</code>后缀：解析成<code>decimal</code>；</li>
<li>具有<code>F/f</code>后缀：解析成<code>float</code>。</li>
</ul>
<p><strong>指数记法</strong>：</p>
<ul>
<li>使用后缀<code>e</code>，在后缀后面添加一个整数，并在最后加一个后缀，表示整个数的类型。</li>
<li>后缀是不区分大小写的。</li>
</ul>
<h6 id="字符串-1"><a class="header" href="#字符串-1">字符串</a></h6>
<p>转义字符：C# 将反斜杠固定用于转义序列，如果出现非法转义序列将产生错误。</p>
<blockquote>
<p>使用 <code>\uFFFF</code> 转义序列在文本字符串中添加Unicode编码（UTF-16）字符。</p>
</blockquote>
<p>字符串的前面使用 <code>@</code> 指令避免转义。原始字符串：<code>@“this is \ a string.”</code></p>
<p>当字符串中含有“<code>\</code>”时，后面的字符以及“<code>\</code>”就会被编译程序解析为转义字符。如果要使用带“<code>\</code>”的字符串而屏蔽掉其转义字符的性质，可以在字符串(双引号)前添加字符“<code>@</code>”。</p>
<h3 id="运算符-8"><a class="header" href="#运算符-8">运算符</a></h3>
<p>复合赋值运算符：如 <code>+=</code>、<code>-=</code>、<code>*=</code>、<code>++</code> 和 <code>--</code>；</p>
<p>定位增量和减量运算符：<code>++</code>，<code>--</code>；</p>
<blockquote>
<p>同时<code>System.Threading.Interlocked</code>类提供了线程安全的方法<code>Increment()</code>和<code>Decrement()</code>。</p>
</blockquote>
<p>比较运算符：<code>==</code>、<code>&gt;</code>、<code>&lt;</code>、<code>&gt;=</code>、<code>&lt;=</code>、<code>!=</code>；继承自<code>Object</code>的类可以重写<code>Equals</code>方法，实现值比较（例如<code>String</code>类型的<code>==</code>比较的是字符串的值）。</p>
<blockquote>
<p><a href="CSharp.NET/CSharp%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80.html#%E5%80%BC%E7%9B%B8%E7%AD%89%E5%85%B3%E7%B3%BB">value equality</a> and <a href="CSharp.NET/CSharp%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80.html#%E5%BC%95%E7%94%A8%E7%9B%B8%E7%AD%89%E5%85%B3%E7%B3%BB">reference equality</a>。</p>
</blockquote>
<p>逻辑运算符：<code>&amp;&amp;</code>、<code>||</code>、``；</p>
<p>赋值运算符：对变量进行一次赋值会返回一个值，所以可以一次对多个变量进行赋值。</p>
<pre><code class="language-c#">string req,max;
req=max=&quot;It would take a miracle.&quot;
</code></pre>
<p>位运算符：<code>&amp;,|,^,~</code></p>
<p>移位运算符：<code>&gt;&gt;, &lt;&lt;</code></p>
<blockquote>
<p><code>op1st &gt;&gt; op2nd</code></p>
<p>如果第一个操作数为<code>int</code>或<code>uint</code>（32 位），则移位数由第二个操作数的低五位给出（<code>op2nd&amp;0x1f</code>，即最多移32位）。 如果第一个操作数为<code>long</code>或<code>ulong</code>（64位数），则移位数由第二个操作数的低六位给出（<code>op2nd&amp;0x3f</code>，即最多移64位）。 
如果第一个操作数为<code>int</code>或<code>long</code>，则右移位是<strong>算术移位</strong>（高序空位设置为符号位）。如果第一个操作数为<code>uint</code>或<code>ulong</code>类型，则右移位是<strong>逻辑移位</strong>（高位填充0）。 </p>
<p><code>op1st &lt;&lt; op2nd</code></p>
<p>如果第一个操作数是<code>int</code>或<code>uint</code>（32 位），第二个参数给出移动位数。
移位操作不会导致溢出：不在移位后第一个操作数类型范围内的任意高序位均不会使用，低序空位用零填充。</p>
</blockquote>
<h4 id="优先级"><a class="header" href="#优先级">优先级</a></h4>
<ol>
<li>圆括号 （括号内的内容首先执行）</li>
<li>指数 (<code>System.Math.Pow()</code>)</li>
<li>乘法和除法（从左至右）</li>
<li>加法和减法（从左至右）</li>
</ol>
<h3 id="代码"><a class="header" href="#代码">代码</a></h3>
<p>标识符：</p>
<blockquote>
<p>By convention, C# programs use <code>PascalCase</code> for type names, namespaces, and all public members. </p>
</blockquote>
<p>表达式：由多个字面值和运算符可以构成常量表达式。</p>
<p>代码块：使用<code>{}</code>定义的一行或多行代码的集合。代码块可以包含其他代码块。</p>
<p>“空格”：指的是由 <code>space bar</code> 生成的单个空格、由 <code>tab</code> 键生成的制表符以及由 <code>enter</code> 键生成的新行。C# 编译器会忽略空格。</p>
<h3 id="注释和文档-4"><a class="header" href="#注释和文档-4">注释和文档</a></h3>
<h5 id="注释的作用"><a class="header" href="#注释的作用">注释的作用</a></h5>
<ul>
<li>
<p>记下一段代码的意图，有助于描述用途或思考过程；</p>
<blockquote>
<p>勿添加关于单个代码行如何工作的注释，相关信息可通过文档获取；</p>
<p>不要完全相信注释。 在进行许多更改之后，它们可能不会反映代码的当前状态。</p>
</blockquote>
</li>
<li>
<p>暂时删除应用程序中的代码，以尝试其他方法；</p>
</li>
<li>
<p>添加类似于 <code>TODO</code> 的消息。</p>
</li>
</ul>
<p>单行注释以字符 <code>//</code> 开头并延续到源行的结尾。</p>
<p>带分隔符的注释 以字符 <code>/*</code> 开头，以字符 <code>*/</code> 结束。带分隔符的注释可以跨多行。</p>
<p>具有特殊格式的注释可用于指导某个工具根据这些注释 和它们后面的源代码元素生成 XML。这类注释是以三个斜杠 (<code>///</code>) 开始的单行注释，或者是以一个斜杠和两个星号 <code>/**</code>) 开始的分隔注释。</p>
<h3 id="流程控制-5"><a class="header" href="#流程控制-5">流程控制</a></h3>
<h4 id="选择-1"><a class="header" href="#选择-1">选择</a></h4>
<h5 id="if-else"><a class="header" href="#if-else">if-else</a></h5>
<pre><code class="language-c#">if (condition1){ statements }
else if (condition2) { statements }
else {statements}
</code></pre>
<p><code>if-else</code>可以嵌套使用。</p>
<h5 id="switch-case-2"><a class="header" href="#switch-case-2">switch-case</a></h5>
<pre><code class="language-c#">switch (condition) {
	case value1:
		statements;
		break;
	case value2:
		statements;
		break;
	default:
		statements;
		break;
	}
}
</code></pre>
<p>每一个非空的分支必须使用跳转语句（<code>break</code>，<code>return</code>等）。</p>
<p><code>condition</code>不仅可以是整数，还可以是字符串等类型。而<a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/switch">判断条件</a>也不仅包括值类型，还包括模式匹配（例如判断是否为整数/常量）。</p>
<h4 id="循环迭代"><a class="header" href="#循环迭代">循环迭代</a></h4>
<h5 id="do-while-2"><a class="header" href="#do-while-2">do-while</a></h5>
<pre><code class="language-c#">while (condition){
    statements;
}
do {
    statements
} while (consition);
</code></pre>
<h5 id="for-2"><a class="header" href="#for-2">for</a></h5>
<pre><code class="language-c#">for (int i = 0; i &lt; args.Length; i++) {
	statements;
}
</code></pre>
<h5 id="foreach"><a class="header" href="#foreach">foreach</a></h5>
<p><code>foreach</code>语句用于访问数组的所有元素或实现了接口<code>IEnumeralbe</code>或<code>IEnumerable&lt;T&gt;</code>的集合对象的所有元素。</p>
<pre><code class="language-c#">foreach(collection_type element in CollectionObject)
{ statements; }
</code></pre>
<p><code>foreach</code>用于迭代遍历集合查找信息，但是不能对源集合<strong>增加或删除</strong>元素以避免不可预知的后果。如果需要增加或删除元素，使用<code>for</code>循环。</p>
<p>在<code>foreach</code>语句块的任何点，都可以使用<code>break</code>跳出循环，或使用<code>continue</code>进入下一步迭代。<code>foreach</code>循环也可以使用<code>goto</code>、<code>return</code>或<code>throw</code>语句退出。</p>
<p><strong><code>yield</code>语句</strong>：使用<code>yield</code>语句的方法、操作符或<code>get</code>访问器相当于是一个建议的迭代器。</p>
<pre><code class="language-c#">class MyIterator {
  public IEnumerable MyEnumerator(int start, int end){
    for (int i = start; i &lt; end; i++){
      yield return i;
    } // 当使用foreach语句访问迭代器时，每次执行到yield语句则直接返回，并记录下当前位置
  }   // 下一次迭代则从上次中断位置继续运行。
}     // 可使用一系列yield语句构造迭代器的元素，或使用循环（本示例）实时构造迭代器元素
      // 或通过循环返回迭代器类型的内部成员变量。
</code></pre>
<h4 id="跳转"><a class="header" href="#跳转">跳转</a></h4>
<p><code>break</code>、<code>continue</code>、<code>goto</code>、<code>throw</code>、<code>return</code>和</p>
<h4 id="异常处理-5"><a class="header" href="#异常处理-5">异常处理</a></h4>
<pre><code class="language-c#">try {
    statements;
} catch (Exception e) {
    statements;
} finally { 
    statements; 
}
</code></pre>
<h5 id="using语句"><a class="header" href="#using语句"><code>using</code>语句</a></h5>
<p>当<code>fianlly</code>语句块仅存在单个语句用于释放<code>try</code>语句块中申请的资源，则可用<code>using</code>语句代替。</p>
<pre><code class="language-c#">using(File f = File.Open(name)){
   system.WriteLine(f.Readline())
}
</code></pre>
<h2 id="类型系统"><a class="header" href="#类型系统">类型系统</a></h2>
<p>变量大致具有7种用途，即静态变量、实例变量、数组元素、值参数、引用参数、输出参数和局部变量。</p>
<p>每个变量都具有一个类型，用于确定哪些值可以存储在该变量中。C#具有统一类型系统 (<em>unified type system</em>)，所有C#类型（包括<code>int</code>和<code>double </code>等基本类型）都继承于单个根类型<code>object</code>（<code>System.Object</code>）。</p>
<p><strong>根据变量在内存中的存储方式以及操作方式，可以分为值类型（<em>value-type</em>）和引用类型（<em>class-type</em>）两大类</strong>：</p>
<ul>
<li>值类型存储在堆栈中，一般都是直接访问；将一个变量值赋给另一个变量，会在内存中重新开辟一段空间，函数传递参数也会在内存中另外生成一个副本。</li>
<li>引用类型必须在托管堆中为引用类型变量的值分配内存，而引用类型对象的引用（地址）存储在栈中；引用类型是由垃圾回收机制来管理的；</li>
</ul>
<blockquote>
<p>所有值类型均从类<code>System.ValueType</code>隐式继承，后者又从类<code>object</code>继承。<code>System.ValueType</code>本身不是值类型，而是引用类型。（可以看成根类型<code>object</code>中不包含任何数据，因此该类型既可以视为值类型也可以视为引用类型。<code>System.ValueType</code>则定义了数据及其值类型操作规则，从而覆盖了引用类型的规则。其他继承自<code>object</code>的类型因为不包含这一套操作规则，因此具有引用类型的操作规则。）</p>
</blockquote>
<p>五种类型是用户可定义的：类 (<em>class type</em>)、结构类(<em>struct type</em>)、接口(<em>interface type</em>)、枚举(<em>enum type</em>) 和委托(<em>delegate type</em>)。</p>
<h3 id="值类型"><a class="header" href="#值类型">值类型</a></h3>
<p><img src="CSharp.NET/CSharp%E8%AF%AD%E6%B3%95.assets/image-20191109103126523.png" alt="image-20191109103126523" /></p>
<blockquote>
<p>布尔类型不能与其它类型进行转换；</p>
</blockquote>
<p>简单数值类型定义了该类型的取值范围：<code>MaxValue</code>和<code>MinValue</code>，可通过<code>GetTypeCode</code>获得类型名。</p>
<p>浮点数<code>float</code>和<code>double</code>类型，当一个数除0时，不会出现错误，而是产生“非零”结果，当打印结果时会得到“<code>NaN</code>”；当数值溢出时，也不会产生异常，而是记为“<code>Inf</code>”。当一个数，非常接近与0时，就会被近似为0，根据数的正负，近似后的数可能为“<code>+0</code>”，也可能为“<code>-0</code>”。</p>
<p><strong>字符类型（char）</strong>：定义了一系列判断字符类型的方法和转换大小写方法。</p>
<h5 id="值相等关系"><a class="header" href="#值相等关系">值相等关系</a></h5>
<p><code>==</code>运算符比较基本值类型的值是否相等。</p>
<h4 id="结构体"><a class="header" href="#结构体">结构体</a></h4>
<p>结构类型与类类型相似，结构类型除了是值类型以外，还不支持用户指定的继承，并且所有结构类型都隐式地从类型<code>object</code>继承。结构类型的成员默认访问权限为<code>private</code>，且不能为成员指定初始值，而必须通过构造方法进行初始化（不支持无参数构造方法）。</p>
<h4 id="枚举-1"><a class="header" href="#枚举-1">枚举</a></h4>
<p>每个枚举类型都有一个相应的整型类型，称为该枚举类型的基础类型 (underlying type)。没有显式声明基础类型的枚举类型所对应的基础类型是 int。枚举类型的存储格式和取值范围由其基础类型确定。</p>
<pre><code class="language-c#">enum Alignment: sbyte{	
    Left = -1,	
    Center = 0,	
    Right = 1
}
</code></pre>
<p>获取枚举类型的字符串表示：(1)<code>ToString()</code>；(2)<code>Enum.GetName()</code>。</p>
<h3 id="引用类型"><a class="header" href="#引用类型">引用类型</a></h3>
<p>构建C#应用程序的主要对象类型数据。引用类型在默认值都是<code>null</code>。</p>
<p><img src="CSharp.NET/CSharp%E8%AF%AD%E6%B3%95.assets/image-20191109105453972.png" alt="image-20191109105453972" /></p>
<h5 id="引用相等关系"><a class="header" href="#引用相等关系">引用相等关系</a></h5>
<p>引用类型在使用“<code>==</code>”或“<code>~=</code>”操作符时，默认比较的是其引用的地址，<code>Object.Equals()</code>等价于“<code>==</code>”。</p>
<p><strong>使用“<code>=</code>”操作符只使得多个引用类型引用同一个对象</strong>，即将一个引用类型变量赋值给另一个同类型变量，赋值的是这个类型对象的地址，所以两个引用都指向同一对象；通过任意一个引用修改该对象，都使得对象发生改变。</p>
<p><strong>必须使用<code>new</code>关键字来创建引用类型变量（实际创建了对象）</strong>，运算结果也会产生新的对象（运算结果也是通过<code>new</code>生成的）；</p>
<blockquote>
<p>变量引用：<em>variable-reference</em> 表示一个存储位置，访问它可以获取当前值以及存储新值，在 C 和 C++ 中，<em>variable-reference</em>称为<code>lvalue</code>。</p>
</blockquote>
<h5 id="字符串-2"><a class="header" href="#字符串-2"><a href="CSharp.NET/C#%E6%95%B0%E6%8D%AE%E5%AE%B9%E5%99%A8.html#%E5%AD%97%E7%AC%A6%E4%B8%B2"><strong>字符串</strong></a></a></h5>
<h5 id="数组-1"><a class="header" href="#数组-1"><a href="CSharp.NET/C#%E6%95%B0%E6%8D%AE%E5%AE%B9%E5%99%A8.html#%E6%95%B0%E7%BB%84"><strong>数组</strong></a></a></h5>
<h4 id="委托"><a class="header" href="#委托">委托</a></h4>
<p>委托类型 (delegate type)表示具有特定参数列表和返回类型的方法，即方法视为对象，==委托即方法的类型==。<strong>委托是用来处理其他语言（如 C++）需用函数指针来处理的情况的</strong>。与 C++ 函数指针不同，C++ 指针仅指向成员函数，而委托同时封装了对象实例和方法。</p>
<blockquote>
<p>函数对象（闭包）。</p>
</blockquote>
<p><strong>委托声明定义一个从 <code>System.Delegate</code>类派生的类</strong>，与方法声明语法一致（除了使用<code>delegate</code>关键字）：</p>
<pre><code class="language-c#">[modifier] delegate &lt;type&gt; delegateName(param_list);
</code></pre>
<p>委托类型使用函数或<a href="CSharp.NET/CSharp%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80.html#Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F">匿名函数</a>进行初始化。</p>
<pre><code class="language-c#">public delegate double Calculator(double x, double y);
public double Add(double x, double y);
public double Sub(double x, double y);
Calculator CalAdd = new Calculator(Add);   // 完整初始化写法
Calculator CalSub = Sub;                   // 简洁写法
</code></pre>
<h5 id="委托运算"><a class="header" href="#委托运算">委托运算</a></h5>
<p>委托实例封装了列表包括一个或多个函数对象。委托对象可使用 &quot;<code>+</code>&quot; 运算符进行合并。一个合并委托调用它所合并的两个委托。只有相同类型的委托可被合并。&quot;<code>-</code>&quot; 运算符可用于从合并的委托中移除组件委托。在执行委托时，调用列表中的方法被依次执行。</p>
<pre><code class="language-c#">Calulator MultiCal = CalAdd + CalSub;
MultiCal(10, 5);      // invoke two Calculator methods
</code></pre>
<p>**对于实例方法，可调用实体由该方法和一个相关联的实例组成，<strong>若该方法会修改实例，则委托中的可调用实体也会修改对应实例</strong>。对于静态方法，可调用实体仅由一个方法组成。**用一个适当的参数集来调用一个委托实例，就是用此给定的参数集来调用该委托实例的每个可调用实体。</p>
<h5 id="lambda表达式"><a class="header" href="#lambda表达式">Lambda表达式</a></h5>
<p>Lambda表达式是一个<strong>匿名函数（<em>anonymous function</em>）</strong>，可以用于创建委托；可以当作局部函数作为某些函数的参数。</p>
<pre><code class="language-c#">(input parameters) =&gt; expression;
(input parameters) =&gt; {statement;}
</code></pre>
<p>&quot;<code>=&gt;</code>&quot;操作符左边为输入参数列表，右侧为表达式或语句块。参数个数为1时，括号可以省略。可以没有输入参数。</p>
<h3 id="类型转换-2"><a class="header" href="#类型转换-2">类型转换</a></h3>
<h4 id="类型判断"><a class="header" href="#类型判断">类型判断</a></h4>
<p><code>is</code>关键字判断对象是否为给定类型。</p>
<p>语法：<code>obj is type</code></p>
<p>当<code>type</code>是一个类，而<code>obj</code>也是该类、或继承该类、或封箱到该类中的实例，结果为<code>true</code>；</p>
<p>当<code>type</code>是接口，而<code>obj</code>也是该接口类型、或继承该接口的类，结果为<code>true</code>。</p>
<h4 id="转换"><a class="header" href="#转换">转换</a></h4>
<p>自动转换：子类可以自动向父类转换</p>
<p>强制转换：父类转换为子类需要强制转换</p>
<pre><code class="language-c#">int first = 7, second = 5;
decimal quotient = (decimal)first / (decimal)second;
</code></pre>
<p><code>as</code>关键字：在类型兼容的引用类型之间进行类型转换。</p>
<p>​	语法：<code>type obj_type = obj as type</code></p>
<p>​	当能够进行转换时，执行转换；当不能转换时，返回<code>null</code>。</p>
<p>字符串与数值之间转换：使用<code>Parse()</code>方法、<code>System.Convert()</code>、<code>ToString()</code>方法。另外<code>TryParse()</code>方法和<code>Parse()</code>方法的区别在于如果转换不成功，不会引起异常而是返回<code>false</code>。</p>
<h4 id="装箱和拆箱"><a class="header" href="#装箱和拆箱">装箱和拆箱</a></h4>
<p>引用类型和值类型的相互转换。</p>
<pre><code class="language-c#">char ch = 'c';
Object obj_ch = ch;   // obj_ch boxing the value type ch
char ch2 = (char) obj_ch; // unboxing from ref-type obj_ch
</code></pre>
<blockquote>
<p>装箱：隐式将值类型转换为 object 类型。</p>
<p>取消装箱：显式地将一个对象类型转换为值类型，使用强制转换方法。这种转换方式必须类型兼容，否则出现异常。</p>
</blockquote>
<h2 id="面向对象编程"><a class="header" href="#面向对象编程">面向对象编程</a></h2>
<h3 id="类-3"><a class="header" href="#类-3">类</a></h3>
<p>类的定义语法：</p>
<pre><code class="language-c#">public class ClassName&lt;TypeName,...&gt;: baseClass, Interfaces
{ 
    private int fieldName;
    protected static int StaticField;
    public int propertyName {get{};set{}};
    public void methodName(args){statements;}
    // constructor
    public ClassName(args){statements}
    // indexer
    public TypeName this[int index]
    {statements; return items[index]}
    // event
    public event DelegateType ThingsChanged;
}
</code></pre>
<p><code>class</code>修饰符：<code>new</code>、<code>public</code>、<code>protected</code>、<code>internal</code>、<code>private</code>、<code>abstract</code>、<code>sealed</code>、<code>static</code>。</p>
<blockquote>
<p>当使用<code>new</code>关键字创建对象时，如果使用该对象的位置（函数参数）类型已知，则可省略对象名直接提供参数。</p>
<pre><code class="language-c#">new(0, &quot;Squeaky Bone&quot;, 20.99m)
</code></pre>
</blockquote>
<p>声明了类型参数（<code>TypeName</code>）的类型成为泛型类型。结构类型、接口类型和委托类型也可以是泛型。</p>
<p>如果类型定义时没有指定父类，则类继承于<code>System.Object</code>（<code>object</code>）。</p>
<h4 id="字段-2"><a class="header" href="#字段-2">字段</a></h4>
<p><em>如果需要一个具有常量值的符号名称，但该值的类型不允许在 <code>const</code>声明中使用，或者无法在编译时计算出该值，则<code>static readonly</code> 字段就可以发挥作用了。</em></p>
<h4 id="方法-3"><a class="header" href="#方法-3">方法</a></h4>
<pre><code class="language-c#">type functionName(args) { /*body*/}
type functionName(args) =&gt; single_expr;   // 方法表达式(C# 6)
</code></pre>
<blockquote>
<p>Lambda表达式是没有函数名的函数表达式。</p>
</blockquote>
<p>通常，为了保持程序的简洁，函数仅返回一个值。但如有必要从函数返回多个值，可以采用的方法：（1）创建一个包含多个值的类，并返回该类的对象；（2）将参数声明为<code>ref/out</code>类型。</p>
<blockquote>
<p>方法名后的<code>()</code>为函数调用运算符。</p>
</blockquote>
<h5 id="参数-2"><a class="header" href="#参数-2">参数</a></h5>
<p>值参数：是实际参数的副本。</p>
<p>引用参数（<code>ref</code>）引用参数与实际参数为同一个变量。</p>
<p>输出参数（<code>out</code>）输出参数可引用函数内部的局部变量，当函数返回时变量不会被释放。<code>ref</code>参数必须在传入前进行初始化，而<code>out</code>参数则不必。</p>
<p>参数数组允许向方法传递可变数量的实参。</p>
<h5 id="静态方法"><a class="header" href="#静态方法">静态方法</a></h5>
<p>静态方法的操作不需要引用特定对象。</p>
<h5 id="构造函数和析构函数"><a class="header" href="#构造函数和析构函数">构造函数和析构函数</a></h5>
<p>==<strong>静态构造函数</strong>==用于初始化类的静态成员。</p>
<p>子类构造函数调用基类构造函数（类似于<a href="CSharp.NET/../CC++/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%9F%BA%E7%A1%80.docx">C++构造方法</a>），使用“<code>:</code>”操作符，<code>base</code>关键字（由于C#是单继承的，因此不需要使用基类名称）。</p>
<pre><code class="language-c#">public ClassName(param_list): base(base_params){
    // 构造函数
}
public ClassName(arg) =&gt; Member = arg;      // (C# 7)
</code></pre>
<p>如果需要将参数传给基类构造器之前进行修改，可以在<code>base_params</code>中调用相关的函数并返回修改后的值。</p>
<p>析构函数不能带参数，不能具有可访问性修饰符，也不能被显式调用。垃圾回收期间会自动调用所涉及实例的析构函数。</p>
<pre><code class="language-c#">~Destroyer() { /*release resources*/ }
~Destroyer() =&gt; expr;    // (c# 7)
</code></pre>
<h4 id="对象初始化"><a class="header" href="#对象初始化">对象初始化</a></h4>
<p>除调用构造函数外，可直接提供成员变量初始化列表进行初始化。</p>
<pre><code class="language-c#">var instance3 = new ExampleClass(){
    Name=&quot;Desktop&quot;, ID=37414, Location=&quot;Redmond&quot;, Age=2.3 };
</code></pre>
<blockquote>
<p>等效于调用默认构造函数后，再对相应成员赋值。</p>
</blockquote>
<h4 id="属性-2"><a class="header" href="#属性-2">属性</a></h4>
<p>属性 (property) 提供对私有成员进行读写、计算的方法，可被视为公共的数据成员，实际上则是特殊的方法（访问器）。属性与字段的声明方法区别在于属性声明了访问器，因此对类的数据实现间接访问，而字段则是对类的数据的直接访问。</p>
<pre><code class="language-c#">modifiers int PropertyName{
    get{ return this.x; }
    set{ this.x = value; }
}
type PropertyName =&gt; expr;   // Read-only properties (C# 6)
type PropertyName {          // (C# 7)
   get =&gt; member;
   set =&gt; member = value;
}
</code></pre>
<p><code>get</code>访问器相当于有返回值的无形参方法。当在表达式中引用属性时，将调用该属性的<code>get</code>访问器以计算该属性的值。<strong>没有<code>get</code>访问器的属性是只写的</strong>。<code>set</code>访问器相当于具有单个形参（以关键字<code>value</code>作为隐形参）和<code>void</code>返回类型的方法。<strong>没有实现set访问器的属性是只读的</strong>。</p>
<p>属性的<a href="CSharp.NET/CSharp%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80.html#_%E8%AE%BF%E9%97%AE%E9%99%90%E5%AE%9A%E7%AC%A6">访问限定符</a>可以是五种中的任意一种。</p>
<p>属性不是变量，因此不能传递作为<code>ref</code>或<code>out</code>修饰的参数。</p>
<p><em>使用属性并不一定比直接公开字段效率低</em>。当属性是非虚的且只包含少量代码时，执行环境可能会用访问器的实际代码替换对访问器进行的调用。此过程称为<strong>内联 (inlining)</strong>，它使属性访问与字段访问一样高效，而且仍保留了属性的更高灵活性。</p>
<p>当属性不需要添加额外的读写逻辑时，声明属性的同时，编译器将自动为该属性创建对应的<strong>匿名字段</strong>，该字段只能被属性的<code>get</code>和<code>set</code>访问器所访问。这时属性等效于一个字段。</p>
<pre><code class="language-c#">public type PropertyName { get; set; }
</code></pre>
<p>当属性声明包含<code>static</code>修饰符时，称该属性为静态属性 (static property)；反之，该属性为实例属性 (instance property)。静态属性不与特定实例相关联，因此在静态属性的访问器内引用 <code>this</code>会导致编译时错误。静态属性需要通过类名进行访问，而实例属性需要通过实例名称进行访问。</p>
<p>属性的访问器可以是虚的。当属性声明包括 <code>virtual</code>、<code>abstract </code>或 <code>override</code>修饰符时，修饰符应用于该属性的访问器。</p>
<h4 id="索引器indexer"><a class="header" href="#索引器indexer">索引器(Indexer)</a></h4>
<p>索引器的定义方式类似属性。</p>
<pre><code class="language-c#">private string[] types = { &quot;Baseball&quot;, &quot;Basketball&quot;, &quot;Football&quot;};
public string this[int i]{
   get =&gt; types[i];
   set =&gt; types[i] = value;
}
</code></pre>
<h4 id="事件"><a class="header" href="#事件">事件</a></h4>
<p>事件 (<code>event</code>) 是一种使类或对象能够提供通知的成员。事件的声明与字段类似，不同的是，事件的声明使用<code>event</code>关键字修飾，值类型必须是<a href="CSharp.NET/CSharp%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80.html#_%E5%A7%94%E6%89%98">委托类型</a>，表示事件的处理方法。</p>
<pre><code class="language-c#">public event DelegateType SampleEvent;
</code></pre>
<p>使用<code>?.</code>运算符发起事件。</p>
<pre><code class="language-c#">SampleEvent?.Invoke(sender, event_args);
SampleEvent(sender, event_args)
</code></pre>
<p>事件参数：根据发起事件所对应的委托类型的参数<strong>数量和类型</strong>决定。</p>
<blockquote>
<p>可使用任意类型和数量的参数作为事件参数。</p>
<p><code>EventArgs</code>类是表示事件参数的基类，不包含任何数据。可从该类导出自定义类型将所有参数作为成员变量包括其中。使用单一类型作为事件处理方法的参数，便于代码自动生成。</p>
</blockquote>
<h5 id="事件处理函数event-handler"><a class="header" href="#事件处理函数event-handler">事件处理函数（event handler）</a></h5>
<p>委托类型可以进行加减操作，因此可以为事件添加一个或多个处理方法。事件处理方法签名与事件的委托类型一致。</p>
<pre><code class="language-c#">void event_handler(object sender, EventArgs e){}
sender.SampleEvent += listener.event_handler;
</code></pre>
<p>事件处理方法可以是发布事件的类（<code>sender</code>）中的成员函数，也可以是其他类的成员函数。在其他类中订阅发布者的事件必须能够获取发布者类的引用（<code>sender</code>）。</p>
<blockquote>
<p><a href="CSharp.NET/CSharp%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80.html#%E5%A7%94%E6%89%98">委托实际还封装了成员函数及其所属类型的实例</a>，因此事件发布和订阅在实例对象之间进行。</p>
</blockquote>
<p>解除订阅：使用<code>-=</code>运算符从事件委托中删除事件处理函数。</p>
<h5 id="异步事件处理"><a class="header" href="#异步事件处理">异步事件处理</a></h5>
<p>事件的发送和接收是同步的，即事件委托中所有事件处理函数被执行。为了实现异步，应该在将事件处理函数实现为<a href="CSharp.NET/CSharp%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80.html#%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B">异步方法</a>。</p>
<h4 id="运算符-9"><a class="header" href="#运算符-9">运算符</a></h4>
<p>可以定义三类运算符：一元运算符、二元运算符和转换运算符。</p>
<p>所有运算符都必须声明为<code>public static</code>。</p>
<h4 id="访问限定符"><a class="header" href="#访问限定符">访问限定符</a></h4>
<p>访问限定符用于声明类成员的访问能力。访问限定符包括以下四类：</p>
<ul>
<li><code>public</code></li>
<li><code>protected</code></li>
<li><code>internal</code></li>
<li><code>private</code></li>
</ul>
<p>使用以上访问限定符可以声明以下五类访问级别：</p>
<ul>
<li><code>public</code>：访问不受限制。</li>
<li><code>protected</code>：访问限制在本类型，或由本类派生的类型。</li>
<li><code>internal</code>：访问限制在当前程序集。</li>
<li><code>protected internal</code>：访问限制在当前程序集，或由本类派生的类型。</li>
<li><code>private</code>：访问限制于包含类型。</li>
</ul>
<h3 id="多态"><a class="header" href="#多态">多态</a></h3>
<p>类支持单一继承和多态，这些是派生类可用来扩展和专用化基类的机制。</p>
<h4 id="虚方法"><a class="header" href="#虚方法">虚方法</a></h4>
<p>使用“<code>virtual</code>”关键字修饰的方法，用于实现多态。当调用<a href="CSharp.NET/CSharp%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80.html#%E8%99%9A%E5%87%BD%E6%95%B0310">虚方法</a>时，运行时将确定调用对象是哪一个子类的实例，并调用适当的覆盖方法。</p>
<p>通过<code>override</code>关键字在子类中声明覆盖父类的虚方法。使用<code>override</code>关键字时不能同时使用<code>new</code>、<code>static</code>和<code>virtual</code>关键字修饰方法；使用<code>override</code>修饰符时，父类必须具有同名虚函数或抽象方法。（另一种覆盖父类方法的关键字是<code>new</code>，使用<code>new</code>关键字时，父类和基类中需要有同名的函数。这个过程叫做方法的隐藏。重写虚方法可以使用<code>override</code>或<code>new</code>，重写抽象方法只能用<code>override</code>。）</p>
<h4 id="抽象方法"><a class="header" href="#抽象方法">抽象方法</a></h4>
<p>用于抽象表示公共的方法，将具体的实现交给具体的类。</p>
<p>抽象 (<code>abstract</code>) 方法是没有实现的虚方法。用“<code>abstract</code>”关键字修饰的方法，只有函数原型，不能添加函数体。声明抽象方法的类必须被声明为抽象类（以“<code>abstract</code>”关键字修饰的类）。</p>
<p>在子类中，使用<code>overide</code>关键字重写父类中的抽象方法，同时该函数在父类中不能是私有成员。</p>
<p>不能用 “<code>sealed</code>”修饰符修饰抽象类，因为这两个修饰符的含义是相反的。</p>
<h4 id="方法重载"><a class="header" href="#方法重载">方法重载</a></h4>
<p>同一类中的多个方法具有相同名称，条件是这些方法具有唯一的签名（signature）。</p>
<h3 id="接口-2"><a class="header" href="#接口-2">接口</a></h3>
<p>接口 (<code>interface</code>) 定义了一个可由类和结构实现的协定，可以包含方法、属性、事件和索引器。</p>
<p>一个接口可以从多个基接口继承，而一个类或结构可以实现多个接口。</p>
<p>当类或结构实现某个特定接口时，该类或结构的实例可以隐式地转换为该接口类型。</p>
<h3 id="反射-3"><a class="header" href="#反射-3">反射</a></h3>
<blockquote>
<p>Function</p>
<p>obtain information about <em>loaded assemblies</em> and <em>the types</em> defined within them, such as <em>classes</em>, <em>interfaces</em>, and <em>value types</em>. </p>
<blockquote>
<p>Classes, Assembly, Module, ConstructorInfo, MethodInfo, FieldInfo, EventInfo, PropertyInfo, ParameterInfo, CustomAttributeData.</p>
</blockquote>
<p><em>create type instances at run time</em>, and to invoke and access them.</p>
</blockquote>
<p><code>nameof(identifier)</code>：生成变量、类型、成员的字符串表示名称。</p>
<pre><code class="language-c#">using System.Reflection;
using System.Type;
</code></pre>
<h4 id="运行时中的泛型"><a class="header" href="#运行时中的泛型">运行时中的泛型</a></h4>
<p>https://docs.microsoft.com/zh-cn/dotnet/csharp/programming-guide/generics/generics-in-the-run-time</p>
<h4 id="泛型和反射"><a class="header" href="#泛型和反射">泛型和反射</a></h4>
<p>https://docs.microsoft.com/zh-cn/dotnet/csharp/programming-guide/generics/generics-and-reflection</p>
<h4 id="特性attributes"><a class="header" href="#特性attributes">特性（Attributes）</a></h4>
<p>特性将元数据、声明性信息与代码（例如程序集、类型、方法、属性等）关联。可通过<a href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/attributes/accessing-attributes-by-using-reflection">反射</a>在程序运行时获取这些信息。</p>
<p>在代码声明前添加特性标签：</p>
<pre><code class="language-c#">[Serializable]
public class SampleClass{ 
  // Objects of this type can be serialized.
}
[System.Runtime.InteropServices.DllImport(&quot;user32.dll&quot;)]
extern static void SampleMethod();

</code></pre>
<p>https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/attributes/</p>
<h5 id="内置属性"><a class="header" href="#内置属性">内置属性</a></h5>
<pre><code class="language-c#">using System.Attribute;
[Required] string Name;               // 该属性非空
[Range(0.01, 9999.99)] decimal Price; // 数值范围
</code></pre>
<h2 id="程序结构-2"><a class="header" href="#程序结构-2">程序结构</a></h2>
<p>C#程序由一个或多个源文件（编译单元）组成，在逻辑上按命名空间进行组织。命名空间中定义类，类的定义中包含各类型成员。</p>
<h3 id="命名空间"><a class="header" href="#命名空间">命名空间</a></h3>
<p>命名空间（namespace）中定义以下内容：</p>
<ul>
<li>嵌套命名空间</li>
<li>类</li>
<li>接口</li>
<li>结构</li>
<li>枚举</li>
<li>委托</li>
</ul>
<p>定义命名空间</p>
<pre><code class="language-c#">namespace identifier {……}
</code></pre>
<p>命名空间隐式地具有公开（<code>public</code>）访问属性且不可被修改，在声明时不允许使用任何访问修饰符。它要么出现在编译单元第一行，要么作为成员出现在其他名字空间的声明中。</p>
<p>命名空间的声明空间是“开放式的”，两个具有相同的完全限定名的命名空间声明共同构成同一个声明空间，因此命名空间可以跨文件进行组织。</p>
<p>无论你是否在源代码中声明一个命名空间，编译器都会添加一个<strong>默认的命名空间</strong>。该命名空间有时称为全局命名空间，在每个文件中都出现。全局命名空间中的任何标识符在有名的命名空间中都可访问。</p>
<h4 id="引用命名空间中的内容"><a class="header" href="#引用命名空间中的内容">引用命名空间中的内容</a></h4>
<p>程序可以直接使用自身所在的命名空间内的名称。如果在程序中使用其他命名空间中的内容，可以将该命名空间引入当前程序。</p>
<pre><code class="language-c#">using Namespace;
</code></pre>
<blockquote>
<p>可使用该空间中的所有内容。</p>
</blockquote>
<p>或者通过命名空间名称索引要使用的内容</p>
<pre><code class="language-c#">space1.space2.class1
</code></pre>
<p>命名空间之间的层次结构只是一种组织上的形式：<strong>当引用父空间时，子空间对于引用程序来说是透明的，如果还要使用子空间需要另外声明引用</strong>。同时注意：如果在父空间和子空间都声明了同名的类，则同时引用两个空间，会导致引用混乱，编译器无法确定程序究竟是要使用哪一级的类。这是只能通过指明类的命名空间来进行访问。</p>
<p>定义命名空间别名：</p>
<pre><code class="language-c#">using co = Company.Proj.Nested;
</code></pre>
<p>.NET Framework的命名空间包括：<code>System</code>、<code>System.Windows.Forms</code>、<code>System.Drawing</code> ……</p>
<h4 id="partial-class"><a class="header" href="#partial-class">Partial Class</a></h4>
<p>将类、结构或接口的定义分离为多个部分到多个文件中。每个部分都必须使用<code>partial</code>关键字。每个部分必须在编译时可用，每个部分具有相同的访问权限，例如<code>public</code>、<code>private</code>等。</p>
<p>如果某个部分定义为<code>abstract</code>，则整个类被认为是<code>abstract</code>。如果某个部分定义为<code>sealed</code>，则整个类被认为是<code>sealed</code>。如果某个部分声明了基类，则整个类继承该基类（所有部分必须声明一致的基类，但是省略基类声明的部分仍然继承该基类。）。</p>
<p>每个部分可以声明不同的基类接口，且最终类型必须实现所有由每个部分声明的接口。任何类、结构、接口成员在每一个部分中都可用。最终类型是所有部分的组合。</p>
<p>以下几种情况应该将类的定义分离为多个部分：</p>
<ul>
<li>
<p>大型项目，将类分为几个文件允许多个程序员同时工作。</p>
</li>
<li>
<p>自动生成源代码的情况。</p>
</li>
</ul>
<h5 id="partial-methods"><a class="header" href="#partial-methods">Partial Methods</a></h5>
<p>局部类可以包含局部方法。类的一个部分可以包含方法的原型，可选的方法实现可以在同一个部分或其他部分。如果没有提供方法的实现，则该方法和该方法的所有调用在编译时被移除。</p>
<p>局部方法必须以partial修饰，并且返回void。</p>
<p>局部方法可以具有<code>ref</code>但是不能有<code>out</code>参数。</p>
<p>局部方法是隐式的私有方法，因此不能是抽象方法（<code>virtual</code>）。</p>
<p>局部方法不能被<code>extern</code>修饰，因为方法体的出现与否决定该方法是否被定义或实现。</p>
<p>局部方法可以具有<code>static</code>或<code>unsafe</code>修饰符。</p>
<h4 id="嵌套类型"><a class="header" href="#嵌套类型">嵌套类型</a></h4>
<p>在类或结构声明内部声明的类型称为嵌套类型 (nested type)。在命名空间内声明的类型称为非嵌套类型 (non-nested type)。</p>
<h3 id="异步编程"><a class="header" href="#异步编程">异步编程</a></h3>
<p>https://docs.microsoft.com/en-us/dotnet/csharp/async</p>
<h4 id="task-based-asynchronous-pattern-tap"><a class="header" href="#task-based-asynchronous-pattern-tap">Task-based Asynchronous Pattern (TAP)</a></h4>
<p>The <code>async</code> keyword turns a method into an <em><strong>async method</strong></em>, which allows you to use the <code>await</code> keyword in its body. The <code>await</code> keyword  ==yields control== to the caller of the method that performed <code>await</code>, and it ultimately allows a UI to be responsive or a service to be elastic.</p>
<blockquote>
<p>The compiler transforms your code into a state machine that keeps track of things like yielding execution when an <code>await</code> is reached and resuming execution when a background job has finished.</p>
</blockquote>
<p>IO密集型任务：<code>await</code> an operation that returns a <code>Task</code> or <code>Task&lt;T&gt;</code> inside of an <code>async</code> method.</p>
<blockquote>
<p>your code be &quot;waiting&quot; for something</p>
</blockquote>
<pre><code class="language-c#">public async Task&lt;int&gt; GetDotNetCountAsync(){
    var html = await client.GetStringAsync(&quot;https://dotnetfoundation.org&quot;); 
    return Regex.Matches(html, @&quot;\.NET&quot;).Count;
} // await GetDotNetCountAsync() at somewhere
public async Task&lt;string&gt; GetHtmlAsync(){
    var client = new HttpClient(); // Execution is synchronous here
    return client.GetStringAsync(&quot;https://www.dotnetfoundation.org&quot;);
}
</code></pre>
<p><img src="CSharp.NET/CSharp%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80.assets/image-20201119233012960.png" alt="image-20201119233012960" /></p>
<p>在一个方法中如果有后续计算依赖于异步方法的返回结果，应当使用<code>await</code>关键字。此时，<code>await</code>将创建并返回一个新的<code>Task&lt;T&gt;</code>对象，表示一个可能尚未完成的任务。<code>await</code>关键字之后的代码将封装到<code>Task&lt;T&gt;</code>对象中，稍后由系统调度并通过<code>Task</code>的方法和属性进行监视。此任务稍后完成时，将计算结果返回更新之前无计算结果的<code>Task&lt;T&gt;</code>对象。</p>
<blockquote>
<p>此处的返回机制类似于<code>fork</code>方法，即进程在此处分支，父进程立即返回<code>Task&lt;T&gt;</code>，子进程的代码则是<code>await</code>语句之后的内容。但是子进程不是立即启动执行，而是由系统管理。当系统收到<code>await</code>的任务执行完成时，将该任务的返回结果解封，并传递给子进程继续执行。</p>
<p>==一个方法如果使用了<code>await</code>关键字，则必须在方法声明上添加<code>async</code>修饰==；</p>
<p>一个方法如果调用了异步方法，但没有<code>await</code>获取结果，则该方法应该直接在异步方法处返回（后续代码依赖于异步方法返回的结果，否则也无需写在异步方法之后）；该方法中没有后续需要执行的代码，因此无需使用<code>await</code>创建一个新的<code>Task&lt;T&gt;</code>对象。</p>
</blockquote>
<p><strong>异步方法的起点</strong>：<code>Task&lt;T&gt;</code>的返回方式使得异步方法层层嵌套，并最终由系统调用进入内核启动真正的异步过程。例如系统与网络设备的交互，设备在收到系统指令后，准备通过网络发送数据，并向系统返回该过程的状态为挂起（<code>pending</code>），系统因此可以暂时从该任务返回执行其他任务。当请求完成且收到来自设备驱动的数据后，设备通过中断信号（interrupt）通知系统（CPU），系统的中断处理器将接收数据并向上传递到注册的任务（通过<code>system interop call</code>），这些结果将缓存在队列中直到将其解封并交给空闲线程执行任务中的剩余代码。</p>
<blockquote>
<p>异步过程实现的基本原理，仍然是并行处理模型。系统（CPU）和设备是并行运行的，两者间通过总线等方式进行通信。系统（CPU）内部内核进程和用户进程也是并行的，通过系统调用进行数据交换。</p>
<p><a href="https://docs.microsoft.com/en-us/dotnet/api/system.threading.tasks.taskcompletionsource-1.setresult#System_Threading_Tasks_TaskCompletionSource_1_SetResult__0_">TaskCompletionSource</a>. </p>
</blockquote>
<p><strong>共享线程池</strong>：异步方法在<code>await</code>之后将返回，从而释放占用的线程，可以由其他任务调用。而当异步任务完成后，系统将从线程池中分配线程以运行<code>Task&lt;T&gt;</code>对象中的剩余代码。当一个<code>Task&lt;T&gt;</code>执行完成时，将更新其上层<code>Task&lt;T&gt;</code>的状态，将其加入缓存队列，从而使得上层任务在未来某个时刻被空余线程执行。由此，层层向上经过一系列离散时间片段完成异步任务，直到顶层异步方法。==因此，异步方法真正占用线程的时间被大幅减少，从而提高系统的服务能力。==对于客户端而言，为了增加UI的响应能力，需要将耗时的计算或IO任务分配给额外线程。使用共享线程池可大幅减少手动创建专用线程的开销。对于IO任务而言，由于其并不消耗CPU资源，因此分配其单独的线程将严重浪费CPU资源。</p>
<p><strong>异步方法的终点</strong>：在<code>await</code>之后输出结果（终端、屏幕或文件等），而非再返回到上一层调用者。这意味者该方法的返回类型为<code>Task&lt;void&gt;</code>，这通常是事件处理器（event handler）。</p>
<blockquote>
<p><code>async Task&lt;void&gt;</code> <strong>should only be used for event handlers</strong>.</p>
<p>事件处理器的调用者（事件队列管理器）无需等待事件处理器执行完成并查看其结果。</p>
</blockquote>
<p>CPU密集型任务：<code>await </code>an operation that is started on a background thread with the <code>Task.Run</code> method.</p>
<blockquote>
<p>your code be performing an expensive computation</p>
<p>spawn off the work on another thread <em>with</em> <code>Task.Run</code></p>
<p><strong>concurrency and parallelism</strong>: <a href="https://docs.microsoft.com/en-us/dotnet/standard/parallel-programming/task-parallel-library-tpl">Task Parallel Library</a></p>
</blockquote>
<pre><code class="language-c#">calculateButton.Clicked += async (o, e) =&gt; {
    var damageResult = await Task.Run(() =&gt; CalculateDamageDone());
    DisplayDamage(damageResult);
}
</code></pre>
<h5 id="wait-for-multiple-tasks-to-complete"><a class="header" href="#wait-for-multiple-tasks-to-complete">Wait for multiple tasks to complete</a></h5>
<p>可以首先构造多个异步任务，再等待其执行完成。由于每个异步任务会在<code>wait</code>语句处立即返回，因此启动多个任务的延迟不会太大。待所有任务启动后，再等待最先结束的任务。</p>
<pre><code class="language-c#">var eggsTask = FryEggsAsync(2);    // =&gt; Task&lt;Egg&gt;
var baconTask = FryBaconAsync(3);
var toastTask = MakeToastWithButterAndJamAsync(2);
var eggs = await eggsTask;
var bacon = await baconTask;
var toast = await toastTask;
</code></pre>
<p>这些任务可同时被分发执行，可以首先等待预计最先完成的任务。</p>
<p><code>Task.WhenAll</code> and <code>Task.WhenAny</code></p>
<pre><code class="language-c#">public static async Task&lt;List&lt;User&gt;&gt; GetUsersAsync(List&lt;int&gt; userIds){
    var getUserTasks = new List&lt;Task&lt;User&gt;&gt;();
    foreach (int userId in userIds){
        getUserTasks.Add(GetUserAsync(userId));
    }
    return Task.WhenAll(getUserTasks);  // similar for `Task.WhenAny` 
}
</code></pre>
<blockquote>
<p><code>await Task.WhenAny</code>类似于Linux的<code>select</code>或<code>epoll</code>。</p>
</blockquote>
<h5 id="tips"><a class="header" href="#tips">Tips</a></h5>
<ul>
<li>
<p><strong>You should add &quot;Async&quot; as the suffix of every async method name you write.</strong></p>
</li>
<li>
<p><strong>Consider using</strong> <code>ValueTask</code> <strong>where possible</strong></p>
</li>
</ul>
<ol>
<li>
<p><a href="https://docs.microsoft.com/en-us/dotnet/standard/async-in-depth">Deeper Dive into Tasks for an I/O-Bound Operation</a>.</p>
</li>
<li>
<p><a href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/async/">Asynchronous programming with async and await</a></p>
</li>
<li>
<p><a href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/async/task-asynchronous-programming-model">Task asynchronous programming model</a></p>
</li>
<li>
<p><a href="https://docs.microsoft.com/en-us/dotnet/standard/asynchronous-programming-patterns/">Asynchronous programming patterns</a></p>
</li>
</ol>
<h4 id="task-and-taskt"><a class="header" href="#task-and-taskt"><code>Task</code> and <code>Task&lt;T&gt;</code></a></h4>
<p><a href="https://en.wikipedia.org/wiki/Futures_and_promises">Promise Model of Concurrency</a>.</p>
<p><code>Task</code> and <code>Task&lt;T&gt;</code> objects supported by the <code>async</code> and <code>await</code> keywords. </p>
<ul>
<li><code>Task</code> represents a single operation which does not return a value.</li>
<li><code>Task&lt;T&gt;</code> represents a single operation which returns a value of type <code>T</code>.</li>
</ul>
<p>By default, tasks execute on the current thread and ==delegate work to the Operating System==, as appropriate. Optionally, tasks can be explicitly requested to ==run on a separate thread== via the <code>Task.Run</code> API.</p>
<h5 id="构造task"><a class="header" href="#构造task">构造Task</a></h5>
<h3 id="预处理指令"><a class="header" href="#预处理指令">预处理指令</a></h3>
<h2 id="自动内存管理"><a class="header" href="#自动内存管理">自动内存管理</a></h2>
<h2 id="不安全代码"><a class="header" href="#不安全代码">不安全代码</a></h2>
<h3 id="指针"><a class="header" href="#指针">指针</a></h3>
<h2 id="附录"><a class="header" href="#附录">附录</a></h2>
<h3 id="关键字"><a class="header" href="#关键字">关键字</a></h3>
<p><code>const</code>：如果变量是<code>const</code>，则该变量也是<code>static</code>的。</p>
<p><code>using</code>：声明语句块，用于保证具有<code>Idisposable</code>接口的对象（非托管资源）的正确使用。</p>
<pre><code class="language-c#">using (declare DisposableObjects){ 
    statements; 
}
</code></pre>
<p>在语句块中，定义的对象为只读，不能修改或重新赋值。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="c-programming-1"><a class="header" href="#c-programming-1">C# Programming</a></h1>
<p>C#是面向对象的编程语言，支持面向组件的编程，通过属性、方法和事件来提供编程模型。</p>
<p>C# 特性：垃圾回收 (Garbage collection)；异常处理 (exception handling)；类型安全 (type-safe) 的语言设计。</p>
<h2 id="基本语法-4"><a class="header" href="#基本语法-4">基本语法</a></h2>
<p>应用程序 (application)以名为<code>Main</code>的<a href="CSharp.NET/CSharp%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80.html#%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95">静态方法</a>作为程序执行的起点。<code>Main</code>方法中可书写表达式语句或调用类库或自定义的其他方法。</p>
<pre><code class="language-c#">namespace NameSpace{
   class Program{ 
      static void Main(string[] args){
         /* statements ... */
      } // return void or int
      static async Task Main() { }
      static async Task&lt;int&gt; Main(string[] args) { }  // (C# 7.1)
   }   
}   // Libraries and services do not require a Main method.
</code></pre>
<blockquote>
<p><code>Main</code>方法：必须为<code>static</code>方法，不需要是<code>public</code>。</p>
<p><code>args</code>为除了程序名称以外的参数。</p>
</blockquote>
<p>一个类中最多包含一个名为<code>Main</code>的方法。在一个程序的多个类或结构中，可能都定义了<code>Main</code>方法。这样的情况下，必须利用某种外部机制（如命令行编译器的选项<code>-main</code>）来选择其中一个<code>Main</code>方法用作入口点。</p>
<p>应用程序入口点方法不能位于泛型类声明中。</p>
<blockquote>
<p>从C#9开始，可以省略Main方法，将位于全局命名空间的语句作为主函数内容。</p>
</blockquote>
<h3 id="变量-5"><a class="header" href="#变量-5">变量</a></h3>
<p>变量表示数据的存储位置。</p>
<h4 id="定义变量-1"><a class="header" href="#定义变量-1">定义变量</a></h4>
<pre><code class="language-c#">&lt;type&gt; varname = value;
</code></pre>
<p><strong>变量名称约定</strong></p>
<ul>
<li>
<p>使用驼峰式，即第一个单词以小写字母开始，后续每个单词的首字母采用大写形式。</p>
</li>
<li>
<p>变量名称不应包含变量的数据类型（在实际代码中可能不能代表实际类型）。</p>
</li>
</ul>
<p>隐式类型本地变量使用 <code>var</code> 关键字进行创建，该关键字指示 C# 编译器去推断类型。</p>
<pre><code class="language-c#">var age = 10;
</code></pre>
<blockquote>
<p>变量名应使用骆驼式命名法。</p>
</blockquote>
<h4 id="常量-1"><a class="header" href="#常量-1">常量</a></h4>
<p>对于数学常量，在<code>System.Math</code>类中有比较精确的定义，可以直接使用，例如<code>pi</code>和<code>e</code>。</p>
<h5 id="字面值-3"><a class="header" href="#字面值-3">字面值</a></h5>
<p>在数字后加上后缀，可以将字面值表示成不同类型的数值。</p>
<h6 id="整形-1"><a class="header" href="#整形-1">整形</a></h6>
<ul>
<li>没有后缀：解析成<code>int</code>、<code>uint</code>、<code>long</code>、<code>ulong</code>；</li>
<li>具有<code>u</code>后缀：解析成<code>uint</code>、<code>ulong</code>；</li>
<li>具有<code>l</code>后缀：解析成<code>long</code>、<code>ulong</code>；</li>
<li>具有<code>ul</code>或<code>lu</code>后缀：解析成<code>ulong</code>；</li>
<li>十六进制表示：添加前缀“<code>0x</code>”</li>
</ul>
<p><code>bool</code>类型的字面值：<code>true</code>、<code>false</code>。</p>
<h6 id="浮点型-1"><a class="header" href="#浮点型-1">浮点型</a></h6>
<ul>
<li>具有<code>D/d</code>后缀：解析成<code>double</code>；</li>
<li>具有<code>M/m</code>后缀：解析成<code>decimal</code>；</li>
<li>具有<code>F/f</code>后缀：解析成<code>float</code>。</li>
</ul>
<p><strong>指数记法</strong>：</p>
<ul>
<li>使用后缀<code>e</code>，在后缀后面添加一个整数，并在最后加一个后缀，表示整个数的类型。</li>
<li>后缀是不区分大小写的。</li>
</ul>
<h6 id="字符串-3"><a class="header" href="#字符串-3">字符串</a></h6>
<p>转义字符：C# 将反斜杠固定用于转义序列，如果出现非法转义序列将产生错误。</p>
<blockquote>
<p>使用 <code>\uFFFF</code> 转义序列在文本字符串中添加Unicode编码（UTF-16）字符。</p>
</blockquote>
<p>字符串的前面使用 <code>@</code> 指令避免转义。原始字符串：<code>@“this is \ a string.”</code></p>
<p>当字符串中含有“<code>\</code>”时，后面的字符以及“<code>\</code>”就会被编译程序解析为转义字符。如果要使用带“<code>\</code>”的字符串而屏蔽掉其转义字符的性质，可以在字符串(双引号)前添加字符“<code>@</code>”。</p>
<h3 id="运算符-10"><a class="header" href="#运算符-10">运算符</a></h3>
<p>复合赋值运算符：如 <code>+=</code>、<code>-=</code>、<code>*=</code>、<code>++</code> 和 <code>--</code>；</p>
<p>定位增量和减量运算符：<code>++</code>，<code>--</code>；</p>
<blockquote>
<p>同时<code>System.Threading.Interlocked</code>类提供了线程安全的方法<code>Increment()</code>和<code>Decrement()</code>。</p>
</blockquote>
<p>比较运算符：<code>==</code>、<code>&gt;</code>、<code>&lt;</code>、<code>&gt;=</code>、<code>&lt;=</code>、<code>!=</code>；继承自<code>Object</code>的类可以重写<code>Equals</code>方法，实现值比较（例如<code>String</code>类型的<code>==</code>比较的是字符串的值）。</p>
<blockquote>
<p><a href="CSharp.NET/CSharp%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80.html#%E5%80%BC%E7%9B%B8%E7%AD%89%E5%85%B3%E7%B3%BB">value equality</a> and <a href="CSharp.NET/CSharp%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80.html#%E5%BC%95%E7%94%A8%E7%9B%B8%E7%AD%89%E5%85%B3%E7%B3%BB">reference equality</a>。</p>
</blockquote>
<p>逻辑运算符：<code>&amp;&amp;</code>、<code>||</code>、``；</p>
<p>赋值运算符：对变量进行一次赋值会返回一个值，所以可以一次对多个变量进行赋值。</p>
<pre><code class="language-c#">string req,max;
req=max=&quot;It would take a miracle.&quot;
</code></pre>
<p>位运算符：<code>&amp;,|,^,~</code></p>
<p>移位运算符：<code>&gt;&gt;, &lt;&lt;</code></p>
<blockquote>
<p><code>op1st &gt;&gt; op2nd</code></p>
<p>如果第一个操作数为<code>int</code>或<code>uint</code>（32 位），则移位数由第二个操作数的低五位给出（<code>op2nd&amp;0x1f</code>，即最多移32位）。 如果第一个操作数为<code>long</code>或<code>ulong</code>（64位数），则移位数由第二个操作数的低六位给出（<code>op2nd&amp;0x3f</code>，即最多移64位）。 
如果第一个操作数为<code>int</code>或<code>long</code>，则右移位是<strong>算术移位</strong>（高序空位设置为符号位）。如果第一个操作数为<code>uint</code>或<code>ulong</code>类型，则右移位是<strong>逻辑移位</strong>（高位填充0）。 </p>
<p><code>op1st &lt;&lt; op2nd</code></p>
<p>如果第一个操作数是<code>int</code>或<code>uint</code>（32 位），第二个参数给出移动位数。
移位操作不会导致溢出：不在移位后第一个操作数类型范围内的任意高序位均不会使用，低序空位用零填充。</p>
</blockquote>
<h4 id="优先级-1"><a class="header" href="#优先级-1">优先级</a></h4>
<ol>
<li>圆括号 （括号内的内容首先执行）</li>
<li>指数 (<code>System.Math.Pow()</code>)</li>
<li>乘法和除法（从左至右）</li>
<li>加法和减法（从左至右）</li>
</ol>
<h3 id="代码-1"><a class="header" href="#代码-1">代码</a></h3>
<p>标识符：</p>
<blockquote>
<p>By convention, C# programs use <code>PascalCase</code> for type names, namespaces, and all public members. </p>
</blockquote>
<p>表达式：由多个字面值和运算符可以构成常量表达式。</p>
<p>代码块：使用<code>{}</code>定义的一行或多行代码的集合。代码块可以包含其他代码块。</p>
<p>“空格”：指的是由 <code>space bar</code> 生成的单个空格、由 <code>tab</code> 键生成的制表符以及由 <code>enter</code> 键生成的新行。C# 编译器会忽略空格。</p>
<h3 id="注释和文档-5"><a class="header" href="#注释和文档-5">注释和文档</a></h3>
<h5 id="注释的作用-1"><a class="header" href="#注释的作用-1">注释的作用</a></h5>
<ul>
<li>
<p>记下一段代码的意图，有助于描述用途或思考过程；</p>
<blockquote>
<p>勿添加关于单个代码行如何工作的注释，相关信息可通过文档获取；</p>
<p>不要完全相信注释。 在进行许多更改之后，它们可能不会反映代码的当前状态。</p>
</blockquote>
</li>
<li>
<p>暂时删除应用程序中的代码，以尝试其他方法；</p>
</li>
<li>
<p>添加类似于 <code>TODO</code> 的消息。</p>
</li>
</ul>
<p>单行注释以字符 <code>//</code> 开头并延续到源行的结尾。</p>
<p>带分隔符的注释 以字符 <code>/*</code> 开头，以字符 <code>*/</code> 结束。带分隔符的注释可以跨多行。</p>
<p>具有特殊格式的注释可用于指导某个工具根据这些注释 和它们后面的源代码元素生成 XML。这类注释是以三个斜杠 (<code>///</code>) 开始的单行注释，或者是以一个斜杠和两个星号 <code>/**</code>) 开始的分隔注释。</p>
<h3 id="流程控制-6"><a class="header" href="#流程控制-6">流程控制</a></h3>
<h4 id="选择-2"><a class="header" href="#选择-2">选择</a></h4>
<h5 id="if-else-1"><a class="header" href="#if-else-1">if-else</a></h5>
<pre><code class="language-c#">if (condition1){ statements }
else if (condition2) { statements }
else {statements}
</code></pre>
<p><code>if-else</code>可以嵌套使用。</p>
<h5 id="switch-case-3"><a class="header" href="#switch-case-3">switch-case</a></h5>
<pre><code class="language-c#">switch (condition) {
	case value1:
		statements;
		break;
	case value2:
		statements;
		break;
	default:
		statements;
		break;
	}
}
</code></pre>
<p>每一个非空的分支必须使用跳转语句（<code>break</code>，<code>return</code>等）。</p>
<p><code>condition</code>不仅可以是整数，还可以是字符串等类型。而<a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/switch">判断条件</a>也不仅包括值类型，还包括模式匹配（例如判断是否为整数/常量）。</p>
<h4 id="循环迭代-1"><a class="header" href="#循环迭代-1">循环迭代</a></h4>
<h5 id="do-while-3"><a class="header" href="#do-while-3">do-while</a></h5>
<pre><code class="language-c#">while (condition){
    statements;
}
do {
    statements
} while (consition);
</code></pre>
<h5 id="for-3"><a class="header" href="#for-3">for</a></h5>
<pre><code class="language-c#">for (int i = 0; i &lt; args.Length; i++) {
	statements;
}
</code></pre>
<h5 id="foreach-1"><a class="header" href="#foreach-1">foreach</a></h5>
<p><code>foreach</code>语句用于访问数组的所有元素或实现了接口<code>IEnumeralbe</code>或<code>IEnumerable&lt;T&gt;</code>的集合对象的所有元素。</p>
<pre><code class="language-c#">foreach(collection_type element in CollectionObject)
{ statements; }
</code></pre>
<p><code>foreach</code>用于迭代遍历集合查找信息，但是不能对源集合<strong>增加或删除</strong>元素以避免不可预知的后果。如果需要增加或删除元素，使用<code>for</code>循环。</p>
<p>在<code>foreach</code>语句块的任何点，都可以使用<code>break</code>跳出循环，或使用<code>continue</code>进入下一步迭代。<code>foreach</code>循环也可以使用<code>goto</code>、<code>return</code>或<code>throw</code>语句退出。</p>
<p><strong><code>yield</code>语句</strong>：使用<code>yield</code>语句的方法、操作符或<code>get</code>访问器相当于是一个建议的迭代器。</p>
<pre><code class="language-c#">class MyIterator {
  public IEnumerable MyEnumerator(int start, int end){
    for (int i = start; i &lt; end; i++){
      yield return i;
    } // 当使用foreach语句访问迭代器时，每次执行到yield语句则直接返回，并记录下当前位置
  }   // 下一次迭代则从上次中断位置继续运行。
}     // 可使用一系列yield语句构造迭代器的元素，或使用循环（本示例）实时构造迭代器元素
      // 或通过循环返回迭代器类型的内部成员变量。
</code></pre>
<h4 id="跳转-1"><a class="header" href="#跳转-1">跳转</a></h4>
<p><code>break</code>、<code>continue</code>、<code>goto</code>、<code>throw</code>、<code>return</code>和</p>
<h4 id="异常处理-6"><a class="header" href="#异常处理-6">异常处理</a></h4>
<pre><code class="language-c#">try {
    statements;
} catch (Exception e) {
    statements;
} finally { 
    statements; 
}
</code></pre>
<h5 id="using语句-1"><a class="header" href="#using语句-1"><code>using</code>语句</a></h5>
<p>当<code>fianlly</code>语句块仅存在单个语句用于释放<code>try</code>语句块中申请的资源，则可用<code>using</code>语句代替。</p>
<pre><code class="language-c#">using(File f = File.Open(name)){
   system.WriteLine(f.Readline())
}
</code></pre>
<h2 id="类型系统-1"><a class="header" href="#类型系统-1">类型系统</a></h2>
<p>变量大致具有7种用途，即静态变量、实例变量、数组元素、值参数、引用参数、输出参数和局部变量。</p>
<p>每个变量都具有一个类型，用于确定哪些值可以存储在该变量中。C#具有统一类型系统 (<em>unified type system</em>)，所有C#类型（包括<code>int</code>和<code>double </code>等基本类型）都继承于单个根类型<code>object</code>（<code>System.Object</code>）。</p>
<p><strong>根据变量在内存中的存储方式以及操作方式，可以分为值类型（<em>value-type</em>）和引用类型（<em>class-type</em>）两大类</strong>：</p>
<ul>
<li>值类型存储在堆栈中，一般都是直接访问；将一个变量值赋给另一个变量，会在内存中重新开辟一段空间，函数传递参数也会在内存中另外生成一个副本。</li>
<li>引用类型必须在托管堆中为引用类型变量的值分配内存，而引用类型对象的引用（地址）存储在栈中；引用类型是由垃圾回收机制来管理的；</li>
</ul>
<blockquote>
<p>所有值类型均从类<code>System.ValueType</code>隐式继承，后者又从类<code>object</code>继承。<code>System.ValueType</code>本身不是值类型，而是引用类型。（可以看成根类型<code>object</code>中不包含任何数据，因此该类型既可以视为值类型也可以视为引用类型。<code>System.ValueType</code>则定义了数据及其值类型操作规则，从而覆盖了引用类型的规则。其他继承自<code>object</code>的类型因为不包含这一套操作规则，因此具有引用类型的操作规则。）</p>
</blockquote>
<p>五种类型是用户可定义的：类 (<em>class type</em>)、结构类(<em>struct type</em>)、接口(<em>interface type</em>)、枚举(<em>enum type</em>) 和委托(<em>delegate type</em>)。</p>
<h3 id="值类型-1"><a class="header" href="#值类型-1">值类型</a></h3>
<p><img src="CSharp.NET/CSharp%E8%AF%AD%E6%B3%95.assets/image-20191109103126523.png" alt="image-20191109103126523" /></p>
<blockquote>
<p>布尔类型不能与其它类型进行转换；</p>
</blockquote>
<p>简单数值类型定义了该类型的取值范围：<code>MaxValue</code>和<code>MinValue</code>，可通过<code>GetTypeCode</code>获得类型名。</p>
<p>浮点数<code>float</code>和<code>double</code>类型，当一个数除0时，不会出现错误，而是产生“非零”结果，当打印结果时会得到“<code>NaN</code>”；当数值溢出时，也不会产生异常，而是记为“<code>Inf</code>”。当一个数，非常接近与0时，就会被近似为0，根据数的正负，近似后的数可能为“<code>+0</code>”，也可能为“<code>-0</code>”。</p>
<p><strong>字符类型（char）</strong>：定义了一系列判断字符类型的方法和转换大小写方法。</p>
<h5 id="值相等关系-1"><a class="header" href="#值相等关系-1">值相等关系</a></h5>
<p><code>==</code>运算符比较基本值类型的值是否相等。</p>
<h4 id="结构体-1"><a class="header" href="#结构体-1">结构体</a></h4>
<p>结构类型与类类型相似，结构类型除了是值类型以外，还不支持用户指定的继承，并且所有结构类型都隐式地从类型<code>object</code>继承。结构类型的成员默认访问权限为<code>private</code>，且不能为成员指定初始值，而必须通过构造方法进行初始化（不支持无参数构造方法）。</p>
<h4 id="枚举-2"><a class="header" href="#枚举-2">枚举</a></h4>
<p>每个枚举类型都有一个相应的整型类型，称为该枚举类型的基础类型 (underlying type)。没有显式声明基础类型的枚举类型所对应的基础类型是 int。枚举类型的存储格式和取值范围由其基础类型确定。</p>
<pre><code class="language-c#">enum Alignment: sbyte{	
    Left = -1,	
    Center = 0,	
    Right = 1
}
</code></pre>
<p>获取枚举类型的字符串表示：(1)<code>ToString()</code>；(2)<code>Enum.GetName()</code>。</p>
<h3 id="引用类型-1"><a class="header" href="#引用类型-1">引用类型</a></h3>
<p>构建C#应用程序的主要对象类型数据。引用类型在默认值都是<code>null</code>。</p>
<p><img src="CSharp.NET/CSharp%E8%AF%AD%E6%B3%95.assets/image-20191109105453972.png" alt="image-20191109105453972" /></p>
<h5 id="引用相等关系-1"><a class="header" href="#引用相等关系-1">引用相等关系</a></h5>
<p>引用类型在使用“<code>==</code>”或“<code>~=</code>”操作符时，默认比较的是其引用的地址，<code>Object.Equals()</code>等价于“<code>==</code>”。</p>
<p><strong>使用“<code>=</code>”操作符只使得多个引用类型引用同一个对象</strong>，即将一个引用类型变量赋值给另一个同类型变量，赋值的是这个类型对象的地址，所以两个引用都指向同一对象；通过任意一个引用修改该对象，都使得对象发生改变。</p>
<p><strong>必须使用<code>new</code>关键字来创建引用类型变量（实际创建了对象）</strong>，运算结果也会产生新的对象（运算结果也是通过<code>new</code>生成的）；</p>
<blockquote>
<p>变量引用：<em>variable-reference</em> 表示一个存储位置，访问它可以获取当前值以及存储新值，在 C 和 C++ 中，<em>variable-reference</em>称为<code>lvalue</code>。</p>
</blockquote>
<h5 id="字符串-4"><a class="header" href="#字符串-4"><a href="CSharp.NET/C#%E6%95%B0%E6%8D%AE%E5%AE%B9%E5%99%A8.html#%E5%AD%97%E7%AC%A6%E4%B8%B2"><strong>字符串</strong></a></a></h5>
<h5 id="数组-2"><a class="header" href="#数组-2"><a href="CSharp.NET/C#%E6%95%B0%E6%8D%AE%E5%AE%B9%E5%99%A8.html#%E6%95%B0%E7%BB%84"><strong>数组</strong></a></a></h5>
<h4 id="委托-1"><a class="header" href="#委托-1">委托</a></h4>
<p>委托类型 (delegate type)表示具有特定参数列表和返回类型的方法，即方法视为对象，==委托即方法的类型==。<strong>委托是用来处理其他语言（如 C++）需用函数指针来处理的情况的</strong>。与 C++ 函数指针不同，C++ 指针仅指向成员函数，而委托同时封装了对象实例和方法。</p>
<blockquote>
<p>函数对象（闭包）。</p>
</blockquote>
<p><strong>委托声明定义一个从 <code>System.Delegate</code>类派生的类</strong>，与方法声明语法一致（除了使用<code>delegate</code>关键字）：</p>
<pre><code class="language-c#">[modifier] delegate &lt;type&gt; delegateName(param_list);
</code></pre>
<p>委托类型使用函数或<a href="CSharp.NET/CSharp%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80.html#Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F">匿名函数</a>进行初始化。</p>
<pre><code class="language-c#">public delegate double Calculator(double x, double y);
public double Add(double x, double y);
public double Sub(double x, double y);
Calculator CalAdd = new Calculator(Add);   // 完整初始化写法
Calculator CalSub = Sub;                   // 简洁写法
</code></pre>
<h5 id="委托运算-1"><a class="header" href="#委托运算-1">委托运算</a></h5>
<p>委托实例封装了列表包括一个或多个函数对象。委托对象可使用 &quot;<code>+</code>&quot; 运算符进行合并。一个合并委托调用它所合并的两个委托。只有相同类型的委托可被合并。&quot;<code>-</code>&quot; 运算符可用于从合并的委托中移除组件委托。在执行委托时，调用列表中的方法被依次执行。</p>
<pre><code class="language-c#">Calulator MultiCal = CalAdd + CalSub;
MultiCal(10, 5);      // invoke two Calculator methods
</code></pre>
<p>**对于实例方法，可调用实体由该方法和一个相关联的实例组成，<strong>若该方法会修改实例，则委托中的可调用实体也会修改对应实例</strong>。对于静态方法，可调用实体仅由一个方法组成。**用一个适当的参数集来调用一个委托实例，就是用此给定的参数集来调用该委托实例的每个可调用实体。</p>
<h5 id="lambda表达式-1"><a class="header" href="#lambda表达式-1">Lambda表达式</a></h5>
<p>Lambda表达式是一个<strong>匿名函数（<em>anonymous function</em>）</strong>，可以用于创建委托；可以当作局部函数作为某些函数的参数。</p>
<pre><code class="language-c#">(input parameters) =&gt; expression;
(input parameters) =&gt; {statement;}
</code></pre>
<p>&quot;<code>=&gt;</code>&quot;操作符左边为输入参数列表，右侧为表达式或语句块。参数个数为1时，括号可以省略。可以没有输入参数。</p>
<h3 id="类型转换-3"><a class="header" href="#类型转换-3">类型转换</a></h3>
<h4 id="类型判断-1"><a class="header" href="#类型判断-1">类型判断</a></h4>
<p><code>is</code>关键字判断对象是否为给定类型。</p>
<p>语法：<code>obj is type</code></p>
<p>当<code>type</code>是一个类，而<code>obj</code>也是该类、或继承该类、或封箱到该类中的实例，结果为<code>true</code>；</p>
<p>当<code>type</code>是接口，而<code>obj</code>也是该接口类型、或继承该接口的类，结果为<code>true</code>。</p>
<h4 id="转换-1"><a class="header" href="#转换-1">转换</a></h4>
<p>自动转换：子类可以自动向父类转换</p>
<p>强制转换：父类转换为子类需要强制转换</p>
<pre><code class="language-c#">int first = 7, second = 5;
decimal quotient = (decimal)first / (decimal)second;
</code></pre>
<p><code>as</code>关键字：在类型兼容的引用类型之间进行类型转换。</p>
<p>​	语法：<code>type obj_type = obj as type</code></p>
<p>​	当能够进行转换时，执行转换；当不能转换时，返回<code>null</code>。</p>
<p>字符串与数值之间转换：使用<code>Parse()</code>方法、<code>System.Convert()</code>、<code>ToString()</code>方法。另外<code>TryParse()</code>方法和<code>Parse()</code>方法的区别在于如果转换不成功，不会引起异常而是返回<code>false</code>。</p>
<h4 id="装箱和拆箱-1"><a class="header" href="#装箱和拆箱-1">装箱和拆箱</a></h4>
<p>引用类型和值类型的相互转换。</p>
<pre><code class="language-c#">char ch = 'c';
Object obj_ch = ch;   // obj_ch boxing the value type ch
char ch2 = (char) obj_ch; // unboxing from ref-type obj_ch
</code></pre>
<blockquote>
<p>装箱：隐式将值类型转换为 object 类型。</p>
<p>取消装箱：显式地将一个对象类型转换为值类型，使用强制转换方法。这种转换方式必须类型兼容，否则出现异常。</p>
</blockquote>
<h2 id="面向对象编程-1"><a class="header" href="#面向对象编程-1">面向对象编程</a></h2>
<h3 id="类-4"><a class="header" href="#类-4">类</a></h3>
<p>类的定义语法：</p>
<pre><code class="language-c#">public class ClassName&lt;TypeName,...&gt;: baseClass, Interfaces
{ 
    private int fieldName;
    protected static int StaticField;
    public int propertyName {get{};set{}};
    public void methodName(args){statements;}
    // constructor
    public ClassName(args){statements}
    // indexer
    public TypeName this[int index]
    {statements; return items[index]}
    // event
    public event DelegateType ThingsChanged;
}
</code></pre>
<p><code>class</code>修饰符：<code>new</code>、<code>public</code>、<code>protected</code>、<code>internal</code>、<code>private</code>、<code>abstract</code>、<code>sealed</code>、<code>static</code>。</p>
<blockquote>
<p>当使用<code>new</code>关键字创建对象时，如果使用该对象的位置（函数参数）类型已知，则可省略对象名直接提供参数。</p>
<pre><code class="language-c#">new(0, &quot;Squeaky Bone&quot;, 20.99m)
</code></pre>
</blockquote>
<p>声明了类型参数（<code>TypeName</code>）的类型成为泛型类型。结构类型、接口类型和委托类型也可以是泛型。</p>
<p>如果类型定义时没有指定父类，则类继承于<code>System.Object</code>（<code>object</code>）。</p>
<h4 id="字段-3"><a class="header" href="#字段-3">字段</a></h4>
<p><em>如果需要一个具有常量值的符号名称，但该值的类型不允许在 <code>const</code>声明中使用，或者无法在编译时计算出该值，则<code>static readonly</code> 字段就可以发挥作用了。</em></p>
<h4 id="方法-4"><a class="header" href="#方法-4">方法</a></h4>
<pre><code class="language-c#">type functionName(args) { /*body*/}
type functionName(args) =&gt; single_expr;   // 方法表达式(C# 6)
</code></pre>
<blockquote>
<p>Lambda表达式是没有函数名的函数表达式。</p>
</blockquote>
<p>通常，为了保持程序的简洁，函数仅返回一个值。但如有必要从函数返回多个值，可以采用的方法：（1）创建一个包含多个值的类，并返回该类的对象；（2）将参数声明为<code>ref/out</code>类型。</p>
<blockquote>
<p>方法名后的<code>()</code>为函数调用运算符。</p>
</blockquote>
<h5 id="参数-3"><a class="header" href="#参数-3">参数</a></h5>
<p>值参数：是实际参数的副本。</p>
<p>引用参数（<code>ref</code>）引用参数与实际参数为同一个变量。</p>
<p>输出参数（<code>out</code>）输出参数可引用函数内部的局部变量，当函数返回时变量不会被释放。<code>ref</code>参数必须在传入前进行初始化，而<code>out</code>参数则不必。</p>
<p>参数数组允许向方法传递可变数量的实参。</p>
<h5 id="静态方法-1"><a class="header" href="#静态方法-1">静态方法</a></h5>
<p>静态方法的操作不需要引用特定对象。</p>
<h5 id="构造函数和析构函数-1"><a class="header" href="#构造函数和析构函数-1">构造函数和析构函数</a></h5>
<p>==<strong>静态构造函数</strong>==用于初始化类的静态成员。</p>
<p>子类构造函数调用基类构造函数（类似于<a href="CSharp.NET/../CC++/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%9F%BA%E7%A1%80.docx">C++构造方法</a>），使用“<code>:</code>”操作符，<code>base</code>关键字（由于C#是单继承的，因此不需要使用基类名称）。</p>
<pre><code class="language-c#">public ClassName(param_list): base(base_params){
    // 构造函数
}
public ClassName(arg) =&gt; Member = arg;      // (C# 7)
</code></pre>
<p>如果需要将参数传给基类构造器之前进行修改，可以在<code>base_params</code>中调用相关的函数并返回修改后的值。</p>
<p>析构函数不能带参数，不能具有可访问性修饰符，也不能被显式调用。垃圾回收期间会自动调用所涉及实例的析构函数。</p>
<pre><code class="language-c#">~Destroyer() { /*release resources*/ }
~Destroyer() =&gt; expr;    // (c# 7)
</code></pre>
<h4 id="对象初始化-1"><a class="header" href="#对象初始化-1">对象初始化</a></h4>
<p>除调用构造函数外，可直接提供成员变量初始化列表进行初始化。</p>
<pre><code class="language-c#">var instance3 = new ExampleClass(){
    Name=&quot;Desktop&quot;, ID=37414, Location=&quot;Redmond&quot;, Age=2.3 };
</code></pre>
<blockquote>
<p>等效于调用默认构造函数后，再对相应成员赋值。</p>
</blockquote>
<h4 id="属性-3"><a class="header" href="#属性-3">属性</a></h4>
<p>属性 (property) 提供对私有成员进行读写、计算的方法，可被视为公共的数据成员，实际上则是特殊的方法（访问器）。属性与字段的声明方法区别在于属性声明了访问器，因此对类的数据实现间接访问，而字段则是对类的数据的直接访问。</p>
<pre><code class="language-c#">modifiers int PropertyName{
    get{ return this.x; }
    set{ this.x = value; }
}
type PropertyName =&gt; expr;   // Read-only properties (C# 6)
type PropertyName {          // (C# 7)
   get =&gt; member;
   set =&gt; member = value;
}
</code></pre>
<p><code>get</code>访问器相当于有返回值的无形参方法。当在表达式中引用属性时，将调用该属性的<code>get</code>访问器以计算该属性的值。<strong>没有<code>get</code>访问器的属性是只写的</strong>。<code>set</code>访问器相当于具有单个形参（以关键字<code>value</code>作为隐形参）和<code>void</code>返回类型的方法。<strong>没有实现set访问器的属性是只读的</strong>。</p>
<p>属性的<a href="CSharp.NET/CSharp%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80.html#_%E8%AE%BF%E9%97%AE%E9%99%90%E5%AE%9A%E7%AC%A6">访问限定符</a>可以是五种中的任意一种。</p>
<p>属性不是变量，因此不能传递作为<code>ref</code>或<code>out</code>修饰的参数。</p>
<p><em>使用属性并不一定比直接公开字段效率低</em>。当属性是非虚的且只包含少量代码时，执行环境可能会用访问器的实际代码替换对访问器进行的调用。此过程称为<strong>内联 (inlining)</strong>，它使属性访问与字段访问一样高效，而且仍保留了属性的更高灵活性。</p>
<p>当属性不需要添加额外的读写逻辑时，声明属性的同时，编译器将自动为该属性创建对应的<strong>匿名字段</strong>，该字段只能被属性的<code>get</code>和<code>set</code>访问器所访问。这时属性等效于一个字段。</p>
<pre><code class="language-c#">public type PropertyName { get; set; }
</code></pre>
<p>当属性声明包含<code>static</code>修饰符时，称该属性为静态属性 (static property)；反之，该属性为实例属性 (instance property)。静态属性不与特定实例相关联，因此在静态属性的访问器内引用 <code>this</code>会导致编译时错误。静态属性需要通过类名进行访问，而实例属性需要通过实例名称进行访问。</p>
<p>属性的访问器可以是虚的。当属性声明包括 <code>virtual</code>、<code>abstract </code>或 <code>override</code>修饰符时，修饰符应用于该属性的访问器。</p>
<h4 id="索引器indexer-1"><a class="header" href="#索引器indexer-1">索引器(Indexer)</a></h4>
<p>索引器的定义方式类似属性。</p>
<pre><code class="language-c#">private string[] types = { &quot;Baseball&quot;, &quot;Basketball&quot;, &quot;Football&quot;};
public string this[int i]{
   get =&gt; types[i];
   set =&gt; types[i] = value;
}
</code></pre>
<h4 id="事件-1"><a class="header" href="#事件-1">事件</a></h4>
<p>事件 (<code>event</code>) 是一种使类或对象能够提供通知的成员。事件的声明与字段类似，不同的是，事件的声明使用<code>event</code>关键字修飾，值类型必须是<a href="CSharp.NET/CSharp%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80.html#_%E5%A7%94%E6%89%98">委托类型</a>，表示事件的处理方法。</p>
<pre><code class="language-c#">public event DelegateType SampleEvent;
</code></pre>
<p>使用<code>?.</code>运算符发起事件。</p>
<pre><code class="language-c#">SampleEvent?.Invoke(sender, event_args);
SampleEvent(sender, event_args)
</code></pre>
<p>事件参数：根据发起事件所对应的委托类型的参数<strong>数量和类型</strong>决定。</p>
<blockquote>
<p>可使用任意类型和数量的参数作为事件参数。</p>
<p><code>EventArgs</code>类是表示事件参数的基类，不包含任何数据。可从该类导出自定义类型将所有参数作为成员变量包括其中。使用单一类型作为事件处理方法的参数，便于代码自动生成。</p>
</blockquote>
<h5 id="事件处理函数event-handler-1"><a class="header" href="#事件处理函数event-handler-1">事件处理函数（event handler）</a></h5>
<p>委托类型可以进行加减操作，因此可以为事件添加一个或多个处理方法。事件处理方法签名与事件的委托类型一致。</p>
<pre><code class="language-c#">void event_handler(object sender, EventArgs e){}
sender.SampleEvent += listener.event_handler;
</code></pre>
<p>事件处理方法可以是发布事件的类（<code>sender</code>）中的成员函数，也可以是其他类的成员函数。在其他类中订阅发布者的事件必须能够获取发布者类的引用（<code>sender</code>）。</p>
<blockquote>
<p><a href="CSharp.NET/CSharp%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80.html#%E5%A7%94%E6%89%98">委托实际还封装了成员函数及其所属类型的实例</a>，因此事件发布和订阅在实例对象之间进行。</p>
</blockquote>
<p>解除订阅：使用<code>-=</code>运算符从事件委托中删除事件处理函数。</p>
<h5 id="异步事件处理-1"><a class="header" href="#异步事件处理-1">异步事件处理</a></h5>
<p>事件的发送和接收是同步的，即事件委托中所有事件处理函数被执行。为了实现异步，应该在将事件处理函数实现为<a href="CSharp.NET/CSharp%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80.html#%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B">异步方法</a>。</p>
<h4 id="运算符-11"><a class="header" href="#运算符-11">运算符</a></h4>
<p>可以定义三类运算符：一元运算符、二元运算符和转换运算符。</p>
<p>所有运算符都必须声明为<code>public static</code>。</p>
<h4 id="访问限定符-1"><a class="header" href="#访问限定符-1">访问限定符</a></h4>
<p>访问限定符用于声明类成员的访问能力。访问限定符包括以下四类：</p>
<ul>
<li><code>public</code></li>
<li><code>protected</code></li>
<li><code>internal</code></li>
<li><code>private</code></li>
</ul>
<p>使用以上访问限定符可以声明以下五类访问级别：</p>
<ul>
<li><code>public</code>：访问不受限制。</li>
<li><code>protected</code>：访问限制在本类型，或由本类派生的类型。</li>
<li><code>internal</code>：访问限制在当前程序集。</li>
<li><code>protected internal</code>：访问限制在当前程序集，或由本类派生的类型。</li>
<li><code>private</code>：访问限制于包含类型。</li>
</ul>
<h3 id="多态-1"><a class="header" href="#多态-1">多态</a></h3>
<p>类支持单一继承和多态，这些是派生类可用来扩展和专用化基类的机制。</p>
<h4 id="虚方法-1"><a class="header" href="#虚方法-1">虚方法</a></h4>
<p>使用“<code>virtual</code>”关键字修饰的方法，用于实现多态。当调用<a href="CSharp.NET/CSharp%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80.html#%E8%99%9A%E5%87%BD%E6%95%B0310">虚方法</a>时，运行时将确定调用对象是哪一个子类的实例，并调用适当的覆盖方法。</p>
<p>通过<code>override</code>关键字在子类中声明覆盖父类的虚方法。使用<code>override</code>关键字时不能同时使用<code>new</code>、<code>static</code>和<code>virtual</code>关键字修饰方法；使用<code>override</code>修饰符时，父类必须具有同名虚函数或抽象方法。（另一种覆盖父类方法的关键字是<code>new</code>，使用<code>new</code>关键字时，父类和基类中需要有同名的函数。这个过程叫做方法的隐藏。重写虚方法可以使用<code>override</code>或<code>new</code>，重写抽象方法只能用<code>override</code>。）</p>
<h4 id="抽象方法-1"><a class="header" href="#抽象方法-1">抽象方法</a></h4>
<p>用于抽象表示公共的方法，将具体的实现交给具体的类。</p>
<p>抽象 (<code>abstract</code>) 方法是没有实现的虚方法。用“<code>abstract</code>”关键字修饰的方法，只有函数原型，不能添加函数体。声明抽象方法的类必须被声明为抽象类（以“<code>abstract</code>”关键字修饰的类）。</p>
<p>在子类中，使用<code>overide</code>关键字重写父类中的抽象方法，同时该函数在父类中不能是私有成员。</p>
<p>不能用 “<code>sealed</code>”修饰符修饰抽象类，因为这两个修饰符的含义是相反的。</p>
<h4 id="方法重载-1"><a class="header" href="#方法重载-1">方法重载</a></h4>
<p>同一类中的多个方法具有相同名称，条件是这些方法具有唯一的签名（signature）。</p>
<h3 id="接口-3"><a class="header" href="#接口-3">接口</a></h3>
<p>接口 (<code>interface</code>) 定义了一个可由类和结构实现的协定，可以包含方法、属性、事件和索引器。</p>
<p>一个接口可以从多个基接口继承，而一个类或结构可以实现多个接口。</p>
<p>当类或结构实现某个特定接口时，该类或结构的实例可以隐式地转换为该接口类型。</p>
<h3 id="反射-4"><a class="header" href="#反射-4">反射</a></h3>
<blockquote>
<p>Function</p>
<p>obtain information about <em>loaded assemblies</em> and <em>the types</em> defined within them, such as <em>classes</em>, <em>interfaces</em>, and <em>value types</em>. </p>
<blockquote>
<p>Classes, Assembly, Module, ConstructorInfo, MethodInfo, FieldInfo, EventInfo, PropertyInfo, ParameterInfo, CustomAttributeData.</p>
</blockquote>
<p><em>create type instances at run time</em>, and to invoke and access them.</p>
</blockquote>
<p><code>nameof(identifier)</code>：生成变量、类型、成员的字符串表示名称。</p>
<pre><code class="language-c#">using System.Reflection;
using System.Type;
</code></pre>
<h4 id="运行时中的泛型-1"><a class="header" href="#运行时中的泛型-1">运行时中的泛型</a></h4>
<p>https://docs.microsoft.com/zh-cn/dotnet/csharp/programming-guide/generics/generics-in-the-run-time</p>
<h4 id="泛型和反射-1"><a class="header" href="#泛型和反射-1">泛型和反射</a></h4>
<p>https://docs.microsoft.com/zh-cn/dotnet/csharp/programming-guide/generics/generics-and-reflection</p>
<h4 id="特性attributes-1"><a class="header" href="#特性attributes-1">特性（Attributes）</a></h4>
<p>特性将元数据、声明性信息与代码（例如程序集、类型、方法、属性等）关联。可通过<a href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/attributes/accessing-attributes-by-using-reflection">反射</a>在程序运行时获取这些信息。</p>
<p>在代码声明前添加特性标签：</p>
<pre><code class="language-c#">[Serializable]
public class SampleClass{ 
  // Objects of this type can be serialized.
}
[System.Runtime.InteropServices.DllImport(&quot;user32.dll&quot;)]
extern static void SampleMethod();

</code></pre>
<p>https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/attributes/</p>
<h5 id="内置属性-1"><a class="header" href="#内置属性-1">内置属性</a></h5>
<pre><code class="language-c#">using System.Attribute;
[Required] string Name;               // 该属性非空
[Range(0.01, 9999.99)] decimal Price; // 数值范围
</code></pre>
<h2 id="程序结构-3"><a class="header" href="#程序结构-3">程序结构</a></h2>
<p>C#程序由一个或多个源文件（编译单元）组成，在逻辑上按命名空间进行组织。命名空间中定义类，类的定义中包含各类型成员。</p>
<h3 id="命名空间-1"><a class="header" href="#命名空间-1">命名空间</a></h3>
<p>命名空间（namespace）中定义以下内容：</p>
<ul>
<li>嵌套命名空间</li>
<li>类</li>
<li>接口</li>
<li>结构</li>
<li>枚举</li>
<li>委托</li>
</ul>
<p>定义命名空间</p>
<pre><code class="language-c#">namespace identifier {……}
</code></pre>
<p>命名空间隐式地具有公开（<code>public</code>）访问属性且不可被修改，在声明时不允许使用任何访问修饰符。它要么出现在编译单元第一行，要么作为成员出现在其他名字空间的声明中。</p>
<p>命名空间的声明空间是“开放式的”，两个具有相同的完全限定名的命名空间声明共同构成同一个声明空间，因此命名空间可以跨文件进行组织。</p>
<p>无论你是否在源代码中声明一个命名空间，编译器都会添加一个<strong>默认的命名空间</strong>。该命名空间有时称为全局命名空间，在每个文件中都出现。全局命名空间中的任何标识符在有名的命名空间中都可访问。</p>
<h4 id="引用命名空间中的内容-1"><a class="header" href="#引用命名空间中的内容-1">引用命名空间中的内容</a></h4>
<p>程序可以直接使用自身所在的命名空间内的名称。如果在程序中使用其他命名空间中的内容，可以将该命名空间引入当前程序。</p>
<pre><code class="language-c#">using Namespace;
</code></pre>
<blockquote>
<p>可使用该空间中的所有内容。</p>
</blockquote>
<p>或者通过命名空间名称索引要使用的内容</p>
<pre><code class="language-c#">space1.space2.class1
</code></pre>
<p>命名空间之间的层次结构只是一种组织上的形式：<strong>当引用父空间时，子空间对于引用程序来说是透明的，如果还要使用子空间需要另外声明引用</strong>。同时注意：如果在父空间和子空间都声明了同名的类，则同时引用两个空间，会导致引用混乱，编译器无法确定程序究竟是要使用哪一级的类。这是只能通过指明类的命名空间来进行访问。</p>
<p>定义命名空间别名：</p>
<pre><code class="language-c#">using co = Company.Proj.Nested;
</code></pre>
<p>.NET Framework的命名空间包括：<code>System</code>、<code>System.Windows.Forms</code>、<code>System.Drawing</code> ……</p>
<h4 id="partial-class-1"><a class="header" href="#partial-class-1">Partial Class</a></h4>
<p>将类、结构或接口的定义分离为多个部分到多个文件中。每个部分都必须使用<code>partial</code>关键字。每个部分必须在编译时可用，每个部分具有相同的访问权限，例如<code>public</code>、<code>private</code>等。</p>
<p>如果某个部分定义为<code>abstract</code>，则整个类被认为是<code>abstract</code>。如果某个部分定义为<code>sealed</code>，则整个类被认为是<code>sealed</code>。如果某个部分声明了基类，则整个类继承该基类（所有部分必须声明一致的基类，但是省略基类声明的部分仍然继承该基类。）。</p>
<p>每个部分可以声明不同的基类接口，且最终类型必须实现所有由每个部分声明的接口。任何类、结构、接口成员在每一个部分中都可用。最终类型是所有部分的组合。</p>
<p>以下几种情况应该将类的定义分离为多个部分：</p>
<ul>
<li>
<p>大型项目，将类分为几个文件允许多个程序员同时工作。</p>
</li>
<li>
<p>自动生成源代码的情况。</p>
</li>
</ul>
<h5 id="partial-methods-1"><a class="header" href="#partial-methods-1">Partial Methods</a></h5>
<p>局部类可以包含局部方法。类的一个部分可以包含方法的原型，可选的方法实现可以在同一个部分或其他部分。如果没有提供方法的实现，则该方法和该方法的所有调用在编译时被移除。</p>
<p>局部方法必须以partial修饰，并且返回void。</p>
<p>局部方法可以具有<code>ref</code>但是不能有<code>out</code>参数。</p>
<p>局部方法是隐式的私有方法，因此不能是抽象方法（<code>virtual</code>）。</p>
<p>局部方法不能被<code>extern</code>修饰，因为方法体的出现与否决定该方法是否被定义或实现。</p>
<p>局部方法可以具有<code>static</code>或<code>unsafe</code>修饰符。</p>
<h4 id="嵌套类型-1"><a class="header" href="#嵌套类型-1">嵌套类型</a></h4>
<p>在类或结构声明内部声明的类型称为嵌套类型 (nested type)。在命名空间内声明的类型称为非嵌套类型 (non-nested type)。</p>
<h3 id="异步编程-1"><a class="header" href="#异步编程-1">异步编程</a></h3>
<p>https://docs.microsoft.com/en-us/dotnet/csharp/async</p>
<h4 id="task-based-asynchronous-pattern-tap-1"><a class="header" href="#task-based-asynchronous-pattern-tap-1">Task-based Asynchronous Pattern (TAP)</a></h4>
<p>The <code>async</code> keyword turns a method into an <em><strong>async method</strong></em>, which allows you to use the <code>await</code> keyword in its body. The <code>await</code> keyword  ==yields control== to the caller of the method that performed <code>await</code>, and it ultimately allows a UI to be responsive or a service to be elastic.</p>
<blockquote>
<p>The compiler transforms your code into a state machine that keeps track of things like yielding execution when an <code>await</code> is reached and resuming execution when a background job has finished.</p>
</blockquote>
<p>IO密集型任务：<code>await</code> an operation that returns a <code>Task</code> or <code>Task&lt;T&gt;</code> inside of an <code>async</code> method.</p>
<blockquote>
<p>your code be &quot;waiting&quot; for something</p>
</blockquote>
<pre><code class="language-c#">public async Task&lt;int&gt; GetDotNetCountAsync(){
    var html = await client.GetStringAsync(&quot;https://dotnetfoundation.org&quot;); 
    return Regex.Matches(html, @&quot;\.NET&quot;).Count;
} // await GetDotNetCountAsync() at somewhere
public async Task&lt;string&gt; GetHtmlAsync(){
    var client = new HttpClient(); // Execution is synchronous here
    return client.GetStringAsync(&quot;https://www.dotnetfoundation.org&quot;);
}
</code></pre>
<p><img src="CSharp.NET/CSharp%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80.assets/image-20201119233012960.png" alt="image-20201119233012960" /></p>
<p>在一个方法中如果有后续计算依赖于异步方法的返回结果，应当使用<code>await</code>关键字。此时，<code>await</code>将创建并返回一个新的<code>Task&lt;T&gt;</code>对象，表示一个可能尚未完成的任务。<code>await</code>关键字之后的代码将封装到<code>Task&lt;T&gt;</code>对象中，稍后由系统调度并通过<code>Task</code>的方法和属性进行监视。此任务稍后完成时，将计算结果返回更新之前无计算结果的<code>Task&lt;T&gt;</code>对象。</p>
<blockquote>
<p>此处的返回机制类似于<code>fork</code>方法，即进程在此处分支，父进程立即返回<code>Task&lt;T&gt;</code>，子进程的代码则是<code>await</code>语句之后的内容。但是子进程不是立即启动执行，而是由系统管理。当系统收到<code>await</code>的任务执行完成时，将该任务的返回结果解封，并传递给子进程继续执行。</p>
<p>==一个方法如果使用了<code>await</code>关键字，则必须在方法声明上添加<code>async</code>修饰==；</p>
<p>一个方法如果调用了异步方法，但没有<code>await</code>获取结果，则该方法应该直接在异步方法处返回（后续代码依赖于异步方法返回的结果，否则也无需写在异步方法之后）；该方法中没有后续需要执行的代码，因此无需使用<code>await</code>创建一个新的<code>Task&lt;T&gt;</code>对象。</p>
</blockquote>
<p><strong>异步方法的起点</strong>：<code>Task&lt;T&gt;</code>的返回方式使得异步方法层层嵌套，并最终由系统调用进入内核启动真正的异步过程。例如系统与网络设备的交互，设备在收到系统指令后，准备通过网络发送数据，并向系统返回该过程的状态为挂起（<code>pending</code>），系统因此可以暂时从该任务返回执行其他任务。当请求完成且收到来自设备驱动的数据后，设备通过中断信号（interrupt）通知系统（CPU），系统的中断处理器将接收数据并向上传递到注册的任务（通过<code>system interop call</code>），这些结果将缓存在队列中直到将其解封并交给空闲线程执行任务中的剩余代码。</p>
<blockquote>
<p>异步过程实现的基本原理，仍然是并行处理模型。系统（CPU）和设备是并行运行的，两者间通过总线等方式进行通信。系统（CPU）内部内核进程和用户进程也是并行的，通过系统调用进行数据交换。</p>
<p><a href="https://docs.microsoft.com/en-us/dotnet/api/system.threading.tasks.taskcompletionsource-1.setresult#System_Threading_Tasks_TaskCompletionSource_1_SetResult__0_">TaskCompletionSource</a>. </p>
</blockquote>
<p><strong>共享线程池</strong>：异步方法在<code>await</code>之后将返回，从而释放占用的线程，可以由其他任务调用。而当异步任务完成后，系统将从线程池中分配线程以运行<code>Task&lt;T&gt;</code>对象中的剩余代码。当一个<code>Task&lt;T&gt;</code>执行完成时，将更新其上层<code>Task&lt;T&gt;</code>的状态，将其加入缓存队列，从而使得上层任务在未来某个时刻被空余线程执行。由此，层层向上经过一系列离散时间片段完成异步任务，直到顶层异步方法。==因此，异步方法真正占用线程的时间被大幅减少，从而提高系统的服务能力。==对于客户端而言，为了增加UI的响应能力，需要将耗时的计算或IO任务分配给额外线程。使用共享线程池可大幅减少手动创建专用线程的开销。对于IO任务而言，由于其并不消耗CPU资源，因此分配其单独的线程将严重浪费CPU资源。</p>
<p><strong>异步方法的终点</strong>：在<code>await</code>之后输出结果（终端、屏幕或文件等），而非再返回到上一层调用者。这意味者该方法的返回类型为<code>Task&lt;void&gt;</code>，这通常是事件处理器（event handler）。</p>
<blockquote>
<p><code>async Task&lt;void&gt;</code> <strong>should only be used for event handlers</strong>.</p>
<p>事件处理器的调用者（事件队列管理器）无需等待事件处理器执行完成并查看其结果。</p>
</blockquote>
<p>CPU密集型任务：<code>await </code>an operation that is started on a background thread with the <code>Task.Run</code> method.</p>
<blockquote>
<p>your code be performing an expensive computation</p>
<p>spawn off the work on another thread <em>with</em> <code>Task.Run</code></p>
<p><strong>concurrency and parallelism</strong>: <a href="https://docs.microsoft.com/en-us/dotnet/standard/parallel-programming/task-parallel-library-tpl">Task Parallel Library</a></p>
</blockquote>
<pre><code class="language-c#">calculateButton.Clicked += async (o, e) =&gt; {
    var damageResult = await Task.Run(() =&gt; CalculateDamageDone());
    DisplayDamage(damageResult);
}
</code></pre>
<h5 id="wait-for-multiple-tasks-to-complete-1"><a class="header" href="#wait-for-multiple-tasks-to-complete-1">Wait for multiple tasks to complete</a></h5>
<p>可以首先构造多个异步任务，再等待其执行完成。由于每个异步任务会在<code>wait</code>语句处立即返回，因此启动多个任务的延迟不会太大。待所有任务启动后，再等待最先结束的任务。</p>
<pre><code class="language-c#">var eggsTask = FryEggsAsync(2);    // =&gt; Task&lt;Egg&gt;
var baconTask = FryBaconAsync(3);
var toastTask = MakeToastWithButterAndJamAsync(2);
var eggs = await eggsTask;
var bacon = await baconTask;
var toast = await toastTask;
</code></pre>
<p>这些任务可同时被分发执行，可以首先等待预计最先完成的任务。</p>
<p><code>Task.WhenAll</code> and <code>Task.WhenAny</code></p>
<pre><code class="language-c#">public static async Task&lt;List&lt;User&gt;&gt; GetUsersAsync(List&lt;int&gt; userIds){
    var getUserTasks = new List&lt;Task&lt;User&gt;&gt;();
    foreach (int userId in userIds){
        getUserTasks.Add(GetUserAsync(userId));
    }
    return Task.WhenAll(getUserTasks);  // similar for `Task.WhenAny` 
}
</code></pre>
<blockquote>
<p><code>await Task.WhenAny</code>类似于Linux的<code>select</code>或<code>epoll</code>。</p>
</blockquote>
<h5 id="tips-1"><a class="header" href="#tips-1">Tips</a></h5>
<ul>
<li>
<p><strong>You should add &quot;Async&quot; as the suffix of every async method name you write.</strong></p>
</li>
<li>
<p><strong>Consider using</strong> <code>ValueTask</code> <strong>where possible</strong></p>
</li>
</ul>
<ol>
<li>
<p><a href="https://docs.microsoft.com/en-us/dotnet/standard/async-in-depth">Deeper Dive into Tasks for an I/O-Bound Operation</a>.</p>
</li>
<li>
<p><a href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/async/">Asynchronous programming with async and await</a></p>
</li>
<li>
<p><a href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/async/task-asynchronous-programming-model">Task asynchronous programming model</a></p>
</li>
<li>
<p><a href="https://docs.microsoft.com/en-us/dotnet/standard/asynchronous-programming-patterns/">Asynchronous programming patterns</a></p>
</li>
</ol>
<h4 id="task-and-taskt-1"><a class="header" href="#task-and-taskt-1"><code>Task</code> and <code>Task&lt;T&gt;</code></a></h4>
<p><a href="https://en.wikipedia.org/wiki/Futures_and_promises">Promise Model of Concurrency</a>.</p>
<p><code>Task</code> and <code>Task&lt;T&gt;</code> objects supported by the <code>async</code> and <code>await</code> keywords. </p>
<ul>
<li><code>Task</code> represents a single operation which does not return a value.</li>
<li><code>Task&lt;T&gt;</code> represents a single operation which returns a value of type <code>T</code>.</li>
</ul>
<p>By default, tasks execute on the current thread and ==delegate work to the Operating System==, as appropriate. Optionally, tasks can be explicitly requested to ==run on a separate thread== via the <code>Task.Run</code> API.</p>
<h5 id="构造task-1"><a class="header" href="#构造task-1">构造Task</a></h5>
<h3 id="预处理指令-1"><a class="header" href="#预处理指令-1">预处理指令</a></h3>
<h2 id="自动内存管理-1"><a class="header" href="#自动内存管理-1">自动内存管理</a></h2>
<h2 id="不安全代码-1"><a class="header" href="#不安全代码-1">不安全代码</a></h2>
<h3 id="指针-1"><a class="header" href="#指针-1">指针</a></h3>
<h2 id="附录-1"><a class="header" href="#附录-1">附录</a></h2>
<h3 id="关键字-1"><a class="header" href="#关键字-1">关键字</a></h3>
<p><code>const</code>：如果变量是<code>const</code>，则该变量也是<code>static</code>的。</p>
<p><code>using</code>：声明语句块，用于保证具有<code>Idisposable</code>接口的对象（非托管资源）的正确使用。</p>
<pre><code class="language-c#">using (declare DisposableObjects){ 
    statements; 
}
</code></pre>
<p>在语句块中，定义的对象为只读，不能修改或重新赋值。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="输入输出-4"><a class="header" href="#输入输出-4">输入输出</a></h1>
<h2 id="标准输入输出-3"><a class="header" href="#标准输入输出-3">标准输入输出</a></h2>
<p><code>System.Console</code>提供终端的标准输入输出方法。</p>
<pre><code class="language-c#">Console.Write(value);
Console.Write(string Format, args)
</code></pre>
<blockquote>
<p><code>Format</code>参考<a href="CSharp.NET/./C#%E6%95%B0%E6%8D%AE%E5%AE%B9%E5%99%A8.html#%E6%A0%BC%E5%BC%8F%E5%8C%96">字符串格式化</a>。</p>
<p><code>Console.WriteLine</code>额外输出换行。</p>
</blockquote>
<h2 id="文件系统-1"><a class="header" href="#文件系统-1">文件系统</a></h2>
<p><code>System.IO</code> 命名空间包含与文件和目录进行交互的类型、对数据流和文件进行同步和异步读取和写入。</p>
<h3 id="路径-3"><a class="header" href="#路径-3">路径</a></h3>
<blockquote>
<p><code>Path</code> 类并不关心内容是否确实存在。 路径是概念上的路径，而不是物理路径。</p>
</blockquote>
<p>分隔符：<code>Path.DirectorySeparatorChar</code>。</p>
<p>连接路径：</p>
<pre><code class="language-c#">var p = Path.Combine(&quot;stores&quot;,&quot;201&quot;)
</code></pre>
<pre><code class="language-c#">var ext = Path.GetExtension(&quot;sales.json&quot;)
</code></pre>
<h3 id="目录"><a class="header" href="#目录">目录</a></h3>
<h4 id="目录信息"><a class="header" href="#目录信息">目录信息</a></h4>
<h5 id="目录属性"><a class="header" href="#目录属性">目录属性</a></h5>
<p><code>DirecotryInfo</code></p>
<p>列出目录包含的文件夹和文件。</p>
<pre><code class="language-c#">using System.IO;
IEnumerable&lt;string&gt; dirs = Directory.EnumerateDirectories(&quot;stores&quot;);
IEnumerable&lt;string&gt; files = Directory.EnumerateFiles(&quot;stores&quot;, '*.txt', SearchOption.AllDirectories);
</code></pre>
<blockquote>
<p>接受用于指定搜索模式文件和目录名称匹配模式，以及是否递归方式遍历指定的文件夹及其所有子文件夹。</p>
<p>返回路径基于给定的路径。</p>
</blockquote>
<pre><code class="language-c#">bool tf = Directory.Exists(path)   // 判断目录是否存在
</code></pre>
<h4 id="特殊目录"><a class="header" href="#特殊目录">特殊目录</a></h4>
<h5 id="当前目录"><a class="header" href="#当前目录">当前目录</a></h5>
<pre><code class="language-c#">string curdir = Directory.GetCurrentDirectory() // 绝对路径
</code></pre>
<p><code>System.Environment.SpecialFolder</code> 枚举指定用于检索特殊系统文件夹路径的常量。</p>
<h4 id="文件属性"><a class="header" href="#文件属性">文件属性</a></h4>
<p><code>FileInfo</code></p>
<h4 id="创建文件和目录"><a class="header" href="#创建文件和目录">创建文件和目录</a></h4>
<pre><code class="language-c#">Directory.CreateDirectory(path);
</code></pre>
<h4 id="目录管理"><a class="header" href="#目录管理">目录管理</a></h4>
<pre><code>
</code></pre>
<h2 id="文件输出输出"><a class="header" href="#文件输出输出">文件输出输出</a></h2>
<p>使用静态方法读写：</p>
<pre><code class="language-c#">File.WriteAllText(path, txt);
File.AppendAllText(path, txt);
string txt = File.ReadAllText(path);
</code></pre>
<p>使用<code>File</code>类读写。</p>
<h3 id="json-3"><a class="header" href="#json-3">JSON</a></h3>
<pre><code class="language-powershell">dotnet add package Newtonsoft.Json
</code></pre>
<pre><code class="language-c#">class SalesTotal
{
  public double Total { get; set; }
}
// 反序列化构造
var data = JsonConvert.DeserializeObject&lt;SalesTotal&gt;(str_data);
</code></pre>
<h3 id="csv-1"><a class="header" href="#csv-1">CSV</a></h3>
<p><code>CsvHelper</code></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="c数据容器"><a class="header" href="#c数据容器">C#数据容器</a></h1>
<h2 id="字符串string-1"><a class="header" href="#字符串string-1">字符串(String)</a></h2>
<h5 id="构造-2"><a class="header" href="#构造-2">构造</a></h5>
<pre><code class="language-c#">string str = &quot;this is a string&quot;;  //使用字面值初始化；
str = new string(charr_array); //使用字符数组初始化；
str = new string(ch, n);  // 重复字符n次；
</code></pre>
<h3 id="查找-1"><a class="header" href="#查找-1">查找</a></h3>
<pre><code class="language-c#">tf = name.StartsWith(&quot;B&quot;)
</code></pre>
<h4 id="正则表达式-3"><a class="header" href="#正则表达式-3">正则表达式</a></h4>
<pre><code class="language-c#">Regex in System.Text.RegularExpressions
Regex.Match()
</code></pre>
<h3 id="运算"><a class="header" href="#运算">运算</a></h3>
<p><code>String</code>类有很多字符串修改方法，但是<code>String</code>对象本身是不会改变的；修改的结果由返回值返回,只能对变量进行重新复制，让它指向内存中的另一块区域。</p>
<p>要在源字符串直接做修改，则改用<a href="CSharp.NET/CSharp%E6%95%B0%E6%8D%AE%E5%AE%B9%E5%99%A8.html#StringBuilder"><code>StringBuilder</code>类</a>。</p>
<h5 id="拼接-2"><a class="header" href="#拼接-2">拼接</a></h5>
<p>使用<code>+</code>或<code>Concat</code>方法，将对象的字符串表示（<code>ToString()</code>）拼接形成一个字符串。</p>
<pre><code class="language-c#">String.Concat(obj1,obj2,...);
String.Concat({obj1,obj2,....})
</code></pre>
<p><code>+</code>运算符作用对象包含字符串时，作为拼接运算符。</p>
<h5 id="字符串内插"><a class="header" href="#字符串内插">字符串内插</a></h5>
<pre><code class="language-c#">string greeting = 'Hello', firstName = 'Bob';
string message = $&quot;{greeting} {firstName}!&quot;;
</code></pre>
<blockquote>
<p>可以同时使用逐字文本前缀符号 <code>@</code> 和字符串内插 <code>$</code> 符号。</p>
</blockquote>
<h3 id="格式化"><a class="header" href="#格式化">格式化</a></h3>
<p>使用格式声明对参数进行格式化并输出字符串。</p>
<pre><code class="language-c#">String.Format(&quot;{0}...{1}...&quot;, arg1, arg2, ...)
</code></pre>
<blockquote>
<p>支持格式化语法的类似方法包括：<code>StringBuilder.AppendFormat</code>、<code>Console.WriteLine</code>、<code>TextWriter.WriteLine</code>、<code>Debug.WriteLine</code>等。</p>
</blockquote>
<h6 id="复合格式声明"><a class="header" href="#复合格式声明">复合格式声明</a></h6>
<p>复合格式由参数索引，对齐声明和格式声明组成）。</p>
<pre><code class="language-c#">{ index[,[+-]alignment][:formatString]}
</code></pre>
<p>多个格式项可以引用同一个参数，索引顺序与参数顺序无关。</p>
<p>对齐方式：<code>alignment</code>的绝对值代表了字符串的最小长度（字符串长度超过该值，则<code>alignment</code>无效）；正值代表右对齐，负值代表左对齐，如果需要则填充空白。</p>
<p>不同类型的对象有不同的格式声明（格式声明在不同国家/语言有不同输出），其中：
标准数字格式包括：</p>
<div class="table-wrapper"><table><thead><tr><th>格式</th><th>名称</th><th>说明</th></tr></thead><tbody>
<tr><td>`C</td><td>c[n]`</td><td>货币格式</td></tr>
<tr><td>`D</td><td>d[n]`</td><td>整型数字</td></tr>
<tr><td>`E</td><td>e[n]`</td><td>指数计数法</td></tr>
<tr><td>`F</td><td>f[n]`</td><td>定点计数法</td></tr>
<tr><td>`G</td><td>g[n]`</td><td>科学计数法</td></tr>
<tr><td>`P</td><td>p[n]`</td><td>百分比</td></tr>
<tr><td>`X</td><td>x`</td><td>十六进制整型</td></tr>
</tbody></table>
</div>
<p>自定义数值格式：</p>
<p>标准日期和时间：</p>
<div class="table-wrapper"><table><thead><tr><th>格式</th><th>说明</th><th>示例</th></tr></thead><tbody>
<tr><td><code>d</code></td><td>短日期</td><td><code>6/15/2009</code></td></tr>
<tr><td><code>D</code></td><td>长日期</td><td><code>Monday, June 15, 2009</code></td></tr>
<tr><td><code>g</code></td><td>短日期时间</td><td><code>6/15/2009 1:45 PM</code></td></tr>
<tr><td><code>G</code></td><td>长日期时间</td><td><code>6/15/2009 1:45:30 PM</code></td></tr>
</tbody></table>
</div>
<p>自定义日期和时间类型：获取日期时间中的字段</p>
<div class="table-wrapper"><table><thead><tr><th>格式</th><th>说明</th><th>格式</th><th>说明</th></tr></thead><tbody>
<tr><td><code>y/yy</code></td><td>year(<code>0-99</code>/<code>00-99</code>)</td><td><code>yyyy</code></td><td>year(<code>0000-9999</code>)</td></tr>
<tr><td><code>M/MM</code></td><td>month(<code>1-12</code>/<code>01-12</code>)</td><td><code>MMM/MMMM</code></td><td>month name (short/long)</td></tr>
<tr><td><code>d/dd</code></td><td>day-of-month</td><td></td><td></td></tr>
<tr><td><code>ddd</code></td><td>day-of-week, short (<code>Mon</code>)</td><td><code>dddd</code></td><td>day-of-week, long (<code>Monday</code>)</td></tr>
<tr><td><code>h/hh</code></td><td>hour(<code>1-12</code>/<code>01~12</code>)</td><td><code>H/HH</code></td><td>hour(<code>0-23</code>/<code>01-23</code>)</td></tr>
<tr><td><code>m/mm</code></td><td>minute(<code>0-59/00-59</code>)</td><td></td><td></td></tr>
<tr><td><code>s/ss</code></td><td>second(<code>0-59</code>/<code>00-59</code>)</td><td></td><td></td></tr>
<tr><td><code>t/tt</code></td><td>AM/PM</td><td></td><td></td></tr>
<tr><td><code>g/gg</code></td><td><code>A.D.</code> or <code>B.C.</code></td><td><code>f/ff/fff/...</code></td><td><code>.x</code>/<code>.xx</code>/<code>.xxx</code>/<code>...</code> seconds</td></tr>
<tr><td><code>K</code></td><td>time zone</td><td><code>z/zz</code></td><td>timezone hour offset</td></tr>
<tr><td><code>:</code></td><td>时间分隔符</td><td><code>/</code></td><td>日期分隔符</td></tr>
</tbody></table>
</div>
<p>TimeSpan类型</p>
<p>枚举类型</p>
<ol>
<li><a href="https://docs.microsoft.com/zh-cn/dotnet/standard/base-types/standard-numeric-format-strings">标准数字格式字符串</a>。</li>
<li><a href="https://docs.microsoft.com/zh-cn/dotnet/standard/base-types/standard-date-and-time-format-strings">标准日期和时间格式字符串</a>。</li>
<li><a href="https://docs.microsoft.com/zh-cn/dotnet/standard/base-types/custom-date-and-time-format-strings">自定义日期和时间格式字符串</a>。</li>
<li><a href="https://docs.microsoft.com/zh-cn/dotnet/standard/base-types/standard-timespan-format-strings">标准 TimeSpan 格式字符串</a>。</li>
</ol>
<h5 id="比较"><a class="header" href="#比较">比较</a></h5>
<pre><code class="language-c#">bool Equals(string value, StringComparison comparisonType);
bool EndsWith(string value, comparisonType)
</code></pre>
<p><code>comparisonType</code>：比较规则包括<code>{Ordinal, OrdinalIgnoreCase }</code>。当调用字符串比较函数如<code>String.Compare</code>、<code>String.Equals</code>、<code>String.IndexOf</code>，应该总是使用带有<code>comparisonType</code>的函数指定比较规则。省略<code>comparisonType</code>，则该方法按照<code>Ordinal</code>规则（case-sensitive和culture-insensitive）进行比较。</p>
<h3 id="stringbuilder"><a class="header" href="#stringbuilder">StringBuilder</a></h3>
<pre><code class="language-c#">StringBuilder str = new StringBuilder();
str.Append(value);
</code></pre>
<h3 id="编码"><a class="header" href="#编码">编码</a></h3>
<p><code>Encoding</code></p>
<h2 id="数组-3"><a class="header" href="#数组-3">数组</a></h2>
<p>数组是用于存储多个同一类型变量的数据结构。数组是引用类型，派生于抽象基类Array类，所以数组也能当做类来使用。</p>
<h3 id="声明"><a class="header" href="#声明">声明</a></h3>
<p>声明数组：</p>
<pre><code class="language-c#">type[] arrayname;  // 1-D
type[,,,...] arrayname; // multi-dimension array
</code></pre>
<p>数组的类型由值类型<code>type</code>和“<code>[]</code>”指定的维数决定。数组元素的类型可以是基本类型也可以是引用类型（甚至可以是数组类型）。数组的维数根据“<code>[]</code>”中的“<code>,</code>”的个数确定，<code>维数=逗号个数+1</code>。</p>
<p>数组初始化时的维度应该与数组声明一致，也可以将数组的声明和初始化放到一起。</p>
<pre><code class="language-c#">type[] arrayname = new type[size]；// initialize as default
</code></pre>
<p>数组在初始化时确定其维数和长度，且不能在实例存在期间修改。</p>
<p><strong>数组的每个维度的长度或初始化列表可以省略，但两者不能同时省略</strong>：如果省略初始化列表则使用元素类型的默认值初始化数组；如果省略长度，则根据初始化列表元素的长度确定数组的长度；如果<strong>两者同时给出，则必须保证维数和长度声明与初始化列表一致</strong>。</p>
<pre><code class="language-c#">arrayname = new type[size]{initialize_list};
arrayname = new type[m,n]{{list1},{list2},...{listm}};
arrayname = new type[,]{{list1},{list2},...{listm}};
arrayname = {{list1},{list2},...{listm}};
</code></pre>
<h3 id="锯齿数组-1"><a class="header" href="#锯齿数组-1">锯齿数组</a></h3>
<p>锯齿数组（或称为交错数组）的每个元素是数组。</p>
<pre><code class="language-c#">type [,...][,...] arrayname;
</code></pre>
<p>声明中，第一个<code>[,...]</code>是锯齿数组的维度声明，第二个是锯齿数组元素的维度声明。虽然每个子数组的维数由声明确定，但是在初始化时，子数组之间各相应维度的长度可以各不相同，因此称为锯齿/交错数组。使用初始化列表赋值：</p>
<pre><code class="language-c#">int[][,] jag_array = { // 使用初始化列表
    new int[,]{{1,2,3},{2,4,1}},
    new int[,]{{2,1},{4,2}},
    new int[,]{{1,3,5},{2,1,3},{3,4,5}}
    ...
};
int[][,] jag_array = new int[M][,]{...}
</code></pre>
<p>先使用<code>new</code>初始化交替数组本身，再初始化数组的每个元素：</p>
<pre><code class="language-c#">int[][] jag_array = new int[M][];
for(int i=0; i&lt;M; ++i){ //对每个元素逐个赋值
    jag_array[i] = new int[len_i];
}
</code></pre>
<p>可以定义高维的锯齿数组：：</p>
<pre><code class="language-c#">int[,][] multi_array = {
    {new int[]{1,2,3}, new int[]{2,1}},
    {new int[]{1,3}, new int[]{2,1,3}}
};
</code></pre>
<h3 id="数组访问"><a class="header" href="#数组访问">数组访问</a></h3>
<p><strong>下标</strong></p>
<p>普通数组的访问方法是<code>array[i,j,...]</code>。</p>
<p>交错数组的访问方法是<code>array[i][j,k,...]</code>。</p>
<p><strong>迭代</strong></p>
<p>使用循环语句<code>for</code>。</p>
<pre><code class="language-c#">// 普通数组
for(int i = 0; i&lt;M; ++i){
    for(int j=0; j&lt;M; ++j){
        Console.Write(&quot;{0:G} &quot;, array2d[i,j])
    }
}
</code></pre>
<p>使用<code>foreach</code>语句，高维数组视为一维数组迭代。</p>
<pre><code class="language-c#">foreach(int x in array2d){
    Console.Write(&quot;{0:G} &quot;, x)
}
</code></pre>
<blockquote>
<p><code>foreach</code>只能读元素，而不能修改数组。</p>
</blockquote>
<h5 id="数组维数和长度"><a class="header" href="#数组维数和长度">数组维数和长度</a></h5>
<pre><code class="language-c#">array.Length;	// 数组的元素总数
array.GetLength(dim);  //数组的一个维度的长度；
</code></pre>
<h2 id="容器-1"><a class="header" href="#容器-1">容器</a></h2>
<h3 id="容器类型-1"><a class="header" href="#容器类型-1">容器类型</a></h3>
<h4 id="泛型和非泛型容器"><a class="header" href="#泛型和非泛型容器">泛型和非泛型容器</a></h4>
<p><a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/programming-guide/generics/">泛型</a>容器（<code>System.Collections.Generic</code>）用于储存同一类型的元素，<strong>具有强类型要求</strong>，从而提供更好的类型安全以及更好的性能。</p>
<p>非泛型容器（<code>System.Collections</code>）存储的元素不要求特定的类型，所有元素都当作<code>Object</code>对象。非泛型集合（如 <code>ArrayList</code>）不建议使用，并且保留用于兼容性目的。大多数非泛型版本容器都不支持应用商店应用。</p>
<div class="table-wrapper"><table><thead><tr><th>容器名</th><th>泛型</th><th>非泛型</th><th>说明</th></tr></thead><tbody>
<tr><td>列表</td><td><code>List&lt;T&gt;</code></td><td><a href="CSharp.NET/CSharp%E6%95%B0%E6%8D%AE%E5%AE%B9%E5%99%A8.html#arraylist"><code>ArrayList</code></a></td><td>容器的大小可以增加或减小。提供查找、排序和修改等等方法。</td></tr>
<tr><td>链表</td><td><code>LinkedList&lt;T&gt;</code></td><td></td><td></td></tr>
<tr><td>有序列表</td><td><code>SortedList&lt;Tk, Tv&gt;</code></td><td><code>SortedList</code></td><td>使用<code>ICompare</code>接口根据对元素进行排序。</td></tr>
<tr><td>队列</td><td><code>Queue&lt;T&gt;</code></td><td><code>Queue</code></td><td>具有先进先出（FIFO）操作规则。</td></tr>
<tr><td>栈</td><td><code>Stack&lt;T&gt;</code></td><td><code>Stack</code></td><td></td></tr>
<tr><td>映射</td><td><code>Dictionary&lt;Tk,Tv&gt;</code></td><td><code>HashTable</code></td><td>基于键值或Hash值索引元素。</td></tr>
<tr><td>有序映射</td><td><code>SortedDictionary&lt;Tk, Tv&gt;</code></td><td></td><td></td></tr>
<tr><td>集合</td><td><code>HashSet&lt;T&gt;</code></td><td></td><td></td></tr>
<tr><td>有序集合</td><td><a href="https://msdn.microsoft.com/en-us/library/dd412070(v=vs.110).aspx"><code>SortedSet&lt;T&gt;</code></a></td><td></td><td></td></tr>
</tbody></table>
</div>
<h4 id="专用容器"><a class="header" href="#专用容器">专用容器</a></h4>
<p><code>System.Collections.Specialized</code></p>
<p>包含专用的强类型的结合。例如：链表字典，位向量，字符串容器。</p>
<h4 id="并发容器"><a class="header" href="#并发容器">并发容器</a></h4>
<p><code>System.Collections.Concurrent</code></p>
<p>提供高效地线程安全的容器访问操作。当从多线程访问容器时，应该使用本空间中的对应容器类型代替<code>System.Collections.Generic</code>和<code>System.Collections</code>中的类型。</p>
<h3 id="容器公共特性"><a class="header" href="#容器公共特性">容器公共特性</a></h3>
<p>容器基于<code>ICollection</code>、<code>IList</code>和<code>IDictionary</code>接口及其泛型版本。<code>IList</code>和<code>IDictionary</code>派生自<code>ICollection</code>。</p>
<p>容器接口包括：</p>
<ul>
<li>
<p><code>ICollection&lt;T&gt;</code></p>
</li>
<li>
<p><code>IList&lt;T&gt;</code></p>
</li>
<li>
<p><code>IDictionary&lt;T&gt;</code></p>
</li>
<li>
<p><code>IComparer&lt;T&gt;</code></p>
</li>
<li>
<p><code>IEqualityComparer&lt;T&gt;</code></p>
</li>
<li>
<p><code>IEnumerator&lt;T&gt;</code></p>
</li>
<li>
<p><code>ISet&lt;T&gt;</code></p>
</li>
</ul>
<h4 id="枚举元素"><a class="header" href="#枚举元素">枚举元素</a></h4>
<p>容器类型继承<code>IEnumerable</code>/<code>IEnumerable&lt;T&gt;</code>，因此可以通过<code>foreach</code>语句进行枚举。继承自<code>IEnumerable&lt;T&gt;</code>的容器还可以通过<code>LINQ</code>进行查询。<code>LINQ</code>通常更简洁且可读性更强，提供筛选、排序以及分组能力，且能提高性能。</p>
<h4 id="复制到数组"><a class="header" href="#复制到数组">复制到数组</a></h4>
<p>通过<code>CopyTo</code>方法将元素按照枚举顺序复制到一维数组中。</p>
<h4 id="容量和计数"><a class="header" href="#容量和计数">容量和计数</a></h4>
<ul>
<li>
<p><code>Capacity</code></p>
<p>在不重新分配空间前，容器的容量。<code>Capacity</code>不应该设置为比<code>Count</code>小的值，否则引发异常（<code>ArgumentOutOfRangeException</code>）。</p>
</li>
<li>
<p><code>Count</code></p>
<p>容器包含元素的数量。</p>
</li>
</ul>
<h4 id="一致的下界"><a class="header" href="#一致的下界">一致的下界</a></h4>
<p>元素从0起索引。Array可以自定义起始索引。</p>
<h4 id="比较-1"><a class="header" href="#比较-1">比较</a></h4>
<p>Contains, IndexOf,
<code>LastIndexOf</code>以及<code>Remove</code>等方法使用等式比较。泛型容器的比较方案：如果类型T继承了<code>IEquatable\&lt;T\&gt;</code>接口，则使用接口的<code>Equals</code>函数；否则使用<code>Object.Equals</code>。</p>
<h4 id="排序顺序"><a class="header" href="#排序顺序">排序顺序</a></h4>
<p><code>BinarySearch</code>和<code>Sort</code>使用一个顺序比较器，用于比较容器的元素或与给定的值比较。</p>
<p>default
comparer：依赖参与比较的对象至少有一个实现了IComparable接口。泛型类型的比较器方案：如果T实现了IComparable&lt;T&gt;接口，则默认比较器为IComparable&lt;T&gt;.CompareTo(T)；如果T实现了IComparable接口，则默认比较器为IComparable.CompareTo(T)；如果T没有实现以上接口，则必须显示提供比较器。</p>
<h3 id="元素排序"><a class="header" href="#元素排序">元素排序</a></h3>
<ul>
<li><code>SortedList</code>/
<code>SortedList&lt;TKey, TValue&gt;</code>、<code>SortedDictionary&lt;TKey, TValue&gt;</code></li>
</ul>
<blockquote>
<p>实现<code>IDictionary</code>/``IDictionary&lt;TKey, TValue&gt;`接口，每个元素是key/value对。</p>
<p>元素根据<code>ICompare</code>/<code>ICompare&lt;T&gt;</code>接口排序。</p>
<p>每个类提供仅返回key或value的属性。</p>
</blockquote>
<ul>
<li><code>HashTable</code>/<code>Dictionary&lt;TKey,TValue&gt;</code></li>
</ul>
<blockquote>
<p>按key排序。</p>
</blockquote>
<h3 id="迭代器-2"><a class="header" href="#迭代器-2">迭代器</a></h3>
<p>迭代器用于容器的迭代访问操作。</p>
<p>使用<code>foreach</code>语句来调用迭代器。</p>
<p>访问容器的接口</p>
<h3 id="容器相关操作"><a class="header" href="#容器相关操作">容器相关操作</a></h3>
<h4 id="queue-1"><a class="header" href="#queue-1">Queue</a></h4>
<ul>
<li>Dequeue/Enqueue</li>
</ul>
<h4 id="stack"><a class="header" href="#stack">Stack</a></h4>
<ul>
<li>
<p>Push/Pop</p>
<p>Peek</p>
</li>
</ul>
<h2 id="linq"><a class="header" href="#linq">LINQ</a></h2>
<p>You can write LINQ queries in C# with SQL Server databases, XML documents, ADO.NET Datasets, and any collection of objects that <strong>supports <code>IEnumerable</code> or the generic <code>IEnumerable&lt;T&gt;</code> interface.</strong></p>
<p>All LINQ query operations consist of three distinct actions:</p>
<ol>
<li>
<p>Obtain the data source.</p>
</li>
<li>
<p>Create the query.</p>
</li>
<li>
<p>Execute the query.</p>
</li>
</ol>
<h3 id="数据源data-source"><a class="header" href="#数据源data-source">数据源(Data Source)</a></h3>
<p>LINQ数据源可以是支持<code>IEnumerable&lt;T&gt;</code>接口以及继承该接口的任何实例。支持<code>IEnumerable&lt;T&gt;</code>及其派生接口（如<code>IQueryable&lt;T&gt;</code>）的类型被称为<strong>可查询类型</strong>。</p>
<p><code>Enumerable</code>类提供一组用于查询实现<code>IEnumerable&lt;T&gt;</code>的对象的静态方法。</p>
<p>XElement</p>
<p>Northwnd</p>
<h3 id="查询"><a class="header" href="#查询">查询</a></h3>
<p>查询语法：从对象序列中查询满足条件的对象，并返回筛选结果。</p>
<pre><code class="language-c#">var seattleCustomers = from customer in customers
                       where customer.City == &quot;Seattle&quot;
			              [orderby customer.ID]
                       select customer.Name;   // or select customer
</code></pre>
<blockquote>
<p><code>from</code>指定数据源；<code>where</code>应用过滤条件；<code>select</code>语句指定返回元素的类型。</p>
</blockquote>
<pre><code class="language-c#">var localDistributors =
    from customer in customers
    join distributor in distributors on customer.City equals distributor.City
    select new { Customer = customer, Distributor = distributor.ID };
</code></pre>
<blockquote>
<p>return a new type</p>
</blockquote>
<pre><code class="language-c#">var scoreQuery = from student in students
                 from score in student.Scores
                 where score &gt; 90
                 select new { Last = student.LastName, score };
</code></pre>
<h3 id="执行查询"><a class="header" href="#执行查询">执行查询</a></h3>
<h4 id="延迟执行"><a class="header" href="#延迟执行">延迟执行</a></h4>
<p>查询变量本身只储存查询命令，当通过<code>foreach</code>语句对查询变量进行迭代时，才真正执行查询。</p>
<h4 id="强制立即执行"><a class="header" href="#强制立即执行">强制立即执行</a></h4>
<p>统计函数：<code>Count</code>、<code>Max</code>、<code>Average</code>、<code>First</code></p>
<p>强制执行：<code>ToList()</code>或<code>ToArray()</code>;</p>
<p>在查询语句之后，立即使用<code>foreach</code>语句。</p>
<h2 id="list-1"><a class="header" href="#list-1">List</a></h2>
<h3 id="list实现的接口"><a class="header" href="#list实现的接口"><code>List</code>实现的接口</a></h3>
<p><code>IndexOf</code>、<code>LastIndexOf</code>和<code>Remove</code>方法使用类型<code>T</code>的默认比较函数（<code>EqualityComparer&lt;T&gt;.Default</code>属性）判断相等。如果<code>T</code>实现了<code>System.IEquatable&lt;T&gt;</code>接口，则返回包含该接口的<code>EqualityComparer</code>，否则返回包含由<code>T</code>提供的<code>Objects.Equals</code>和<code>Objects.GetHashCode</code>的<code>EqualityComparer</code>。</p>
<p><code>Contains</code>方法使用默认的相等比较函数判断相等。如果<code>T</code>实现了<code>IEquatable&lt;T&gt;</code>接口，则调用<code>IEquatabale.Equals</code>方法，否则使用<code>Object.Equals</code>。</p>
<p><code>Sort</code>、<code>BinarySearch</code>使用类型T的默认的比较函数（<code>Comparer&lt;T&gt;.Default</code>属性）。如果<code>T</code>实现了<code>IComparable&lt;T&gt;</code>接口，则默认比较函数为<code>IComparable&lt;T&gt;.CompareTo(T)</code>；否则如果实现了<code>IComparable</code>接口，则默认比较函数是<code>IComparable.CompareTo()</code>；如果<code>T</code>没有实现比较接口，则必须显式提供比较委托。</p>
<p><code>List</code>允许引用类型取值为<code>null</code>，以及重复元素。</p>
<h4 id="arraylist"><a class="header" href="#arraylist">ArrayList</a></h4>
<p>ArrayList的容量是自动扩充的（类似于字符串，与一般数组不同）；</p>
<p>ArrayList只能是一维的；</p>
<h3 id="构造函数"><a class="header" href="#构造函数">构造函数</a></h3>
<pre><code class="language-c#">List&lt;T&gt;()		//with default capacity
List&lt;T&gt;(Int32 Capacity)
</code></pre>
<h3 id="属性-4"><a class="header" href="#属性-4">属性</a></h3>
<pre><code>T this[int index] { get; set; }
</code></pre>
<p>按序号访问指定的元素。</p>
<h3 id="方法-5"><a class="header" href="#方法-5">方法</a></h3>
<h5 id="插入-1"><a class="header" href="#插入-1">插入</a></h5>
<pre><code class="language-c#">void Add( T item );
void Insert( int index, T item )
</code></pre>
<p><code>Add</code>添加元素到列表末尾。</p>
<p><code>Insert</code>在指定序号处插入元素，指定的序号小于<code>0</code>或大于<code>Count</code>会引发异常（<code>ArgumentOutOfRangeException</code>）。</p>
<h5 id="删除"><a class="header" href="#删除">删除</a></h5>
<pre><code class="language-c#">bool Remove( T item );
int RemoveAll( Predicate&lt;T&gt; match );
void RemoveAt( int index )
void Clear();
void TrimExcess()
</code></pre>
<p><code>Remove</code>移除出现的第一个指定元素，如果成功移除返回<code>true</code>；如果指定元素不在列表中或移除失败，返回<code>false</code>。</p>
<p><code>RemoveAll</code>移除满足条件的所有元素，并返回移除元素的数量。</p>
<p><code>RemoveAt</code>移除指定位置的元素，指定的序号小于<code>0</code>或大于<code>Count</code>会引发异常（<code>ArgumentOutOfRangeException</code>）。</p>
<p><code>Clear</code>移除列表中的所有元素。</p>
<p><code>TrimExcess</code>将列表的容量缩小至元素实际数量。</p>
<h5 id="查找-2"><a class="header" href="#查找-2">查找</a></h5>
<pre><code class="language-c#">bool Contains( T item );
bool Exists( Predicate&lt;T&gt; match );
T Find( Predicate\&lt;T\&gt; match );  // FindLast
int FindIndex( Predicate\&lt;T\&gt; match ); // FindLastIndex
int IndexOf( T item );  // LastIndexOf
List&lt;T&gt; FindAll( Predicate&lt;T&gt; match );
</code></pre>
<p><code>Contains</code>判断一个元素是否包含在列表中。（This method determines equality by using
the default equality comparer, as defined by the object's
implementation of the IEquatable&lt;T&gt;.Equals method forT (the type of
values in the list).）</p>
<p><code>Exists</code>判断是否存在匹配给定条件的元素。<code>match</code>定义了查找元素的条件。列表的元素分别被传递给<code>match</code>函数，当找到匹配元素时停止操作。</p>
<p><code>Find</code>查找满足条件的元素并返回第一个元素。</p>
<p><code>FindAll</code>查找所有满足条件的元素并返回。</p>
<p><code>FindIndex</code>查找满足条件的元素并返回第一个元素序号。</p>
<p><code>IndexOf</code>查找指定的元素，并返回第一个元素的序号。</p>
<h5 id="排序-2"><a class="header" href="#排序-2">排序</a></h5>
<pre><code>void Reverse()
</code></pre>
<p>反转整个列表的元素排列顺序。</p>
<pre><code class="language-c#">void Sort()
void Sort( Comparison&lt;T&gt; comparison )
void Sort( IComparer&lt;T&gt; comparer )
</code></pre>
<p>使用<code>comparison</code>对列表排序。</p>
<p>使用<code>comparer</code>进行排序。</p>
<h2 id="dictionary"><a class="header" href="#dictionary">Dictionary</a></h2>
<pre><code>System.Collections in mscorlib
</code></pre>
<p>代表非一般性的键值对（key/value）的容器。每一个键值对储存在一个<code>DictionaryEntry</code>对象中。</p>
<p>每个键值对必须具有唯一的键名，实现类型可以决定是否允许键名为null。值可以是null且不要求唯一性。</p>
<p><code>IDictionary</code>的实现类型分为三类：只读、固定长度、可变长度。</p>
<h3 id="属性-5"><a class="header" href="#属性-5">属性</a></h3>
<p>按键名key访问元素：</p>
<pre><code>Object this[ Object key] { get; set; }
</code></pre>
<p>键名和值</p>
<pre><code class="language-c#">ICollection Keys { get; }
ICollection Values { get; }
</code></pre>
<p>值的顺序与<code>Keys</code>返回的键名的顺序对应。</p>
<p><code>DictionaryEntry</code>定义字典的键值对。</p>
<pre><code class="language-c#">Object Key { get; set; }
Object Value { get; set; }
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="net开发"><a class="header" href="#net开发">.NET开发</a></h1>
<blockquote>
<p><strong>C# 和 .NET 是截然不同的。</strong> C# 是一种编程语言语法。 作为语法的一部分，你可以引用和调用 .NET 代码库或程序集中定义的方法。 此外，还可以使用随 .NET SDK 一起安装的 C# 编译器从 C# 代码创建程序集。</p>
</blockquote>
<p><strong>应用程序框架</strong>合并了几个相关的库，以及初学者项目、文件模板、代码生成器和其他工具。 你可以使用这些资源为特定目的生成整个应用程序。 这些应用程序框架称为“应用模型”。 例如，常用的 .NET 应用程序框架可用于 Web 开发、桌面和移动开发，以及游戏开发等应用模型。</p>
<p><img src="CSharp.NET/dotnet%E5%BC%80%E5%8F%91.assets/dotnet5_platform.png" alt="img" /></p>
<h2 id="开发环境-2"><a class="header" href="#开发环境-2">开发环境</a></h2>
<p>可以选择 Visual Studio 2019 或 Visual Studio Code和.NET 软件开发工具包 (SDK)。</p>
<h3 id="net-sdk"><a class="header" href="#net-sdk">.NET SDK</a></h3>
<h5 id="net-cli"><a class="header" href="#net-cli">.NET CLI</a></h5>
<p>.NET CLI 概述：https://docs.microsoft.com/zh-cn/dotnet/core/tools/。</p>
<pre><code class="language-shell">dotnet --info    # .NET install information
</code></pre>
<p>create app</p>
<pre><code class="language-shell">dotnet new console -o myApp  # creat project with templates
</code></pre>
<p><code>-o</code>：创建指定目录以存储项目文件；</p>
<p>可创建的项目类型可通过以下命令查看。</p>
<pre><code class="language-powershell">dotnet new -l [&lt;name&gt;] 
#    Templates           Short Name      Language         Tags
# --------------------  ------------   ------------   --------------
# Console Application   console        [C#], F#, VB   Common/Console
# Class library         classlib       [C#], F#, VB   Common/Library
# ......
</code></pre>
<p>运行应用：</p>
<pre><code class="language-powershell">cd myApp
dotnet run
</code></pre>
<h5 id="nuget-包管理器"><a class="header" href="#nuget-包管理器">NuGet 包管理器</a></h5>
<p>NuGet 是适用于 .NET 的包管理器。 它使开发人员能够创建、共享和使用有用的 .NET 库。 NuGet 客户端工具可生成这些库并将其作为“包”。</p>
<p>访问https://www.nuget.org/packages/查看包的详情。</p>
<p>NuGet 文档：https://docs.microsoft.com/zh-cn/nuget/。</p>
<blockquote>
<ul>
<li>若面向.NET Core或.NET Standard，请使用<code>dotnet</code> CLI（是SDK项目格式所必需的）。</li>
<li>要面向.NET Framework（仅限非SDK样式项目），请使用<code>nuget.exe</code>CLI。</li>
</ul>
<p><em><code>NU1202: Package is not compatible with net50-windows</code></em>：<a href="https://stackoverflow.com/questions/65722395/nu1202-package-is-not-compatible-with-net50-windows">dotnet工具版本太低</a>，升级<code>dotnet</code> SDK。</p>
</blockquote>
<h5 id="配置nuget仓库"><a class="header" href="#配置nuget仓库">配置Nuget仓库</a></h5>
<p><em>Nuget官方仓库未默认配置</em>（导致无法添加包），通过以下命令配置仓库源。</p>
<pre><code class="language-powershell">dotnet nuget add source https://api.nuget.org/v3/index.json -n nuget.org
dotnet nuget list source # 查看注册的软件源
</code></pre>
<p>其他软件源相关命令：<code>enable</code>，<code>disable</code>，<code>remove</code>，<code>update</code></p>
<h5 id="向项目添加包"><a class="header" href="#向项目添加包">向项目添加包</a></h5>
<p>Visual Studio 和 Visual Studio for Mac 中有一个内置的包管理器命令行和图形用户界面。 可手动向项目文件添加包引用。 也可通过命令行接口 (CLI) 工具（如 Paket 或 .NET Core CLI）进行安装。</p>
<p>运行 <code>dotnet add package &lt;package name&gt;</code> 命令时将抓取和下载所有依赖项。安装的包在项目文件（<code>.csproj </code>）中列出。</p>
<pre><code class="language-xml">&lt;ItemGroup&gt;
  &lt;PackageReference Include=&quot;Humanizer&quot; Version=&quot;2.8.26&quot; /&gt;
&lt;/ItemGroup&gt;
</code></pre>
<p>如果需要查看项目中的包，可以输入 </p>
<pre><code class="language-powershell">dotnet list package [--include-transitive]
</code></pre>
<h5 id="net命令行工具"><a class="header" href="#net命令行工具">.NET命令行工具</a></h5>
<p>使用 <code>dotnet tool install &lt;package name&gt;</code> 命令安装工具。</p>
<blockquote>
<p>A .NET tool is a special NuGet package that contains a console application.</p>
<ul>
<li>global tool: The tool binaries are installed in a default directory that is added to the PATH environment variable.</li>
<li>global tool in a custom location</li>
<li>local tool: The .NET CLI uses manifest files to keep track of which tools are installed as local to a directory.</li>
</ul>
<p>https://docs.microsoft.com/en-us/dotnet/core/tools/global-tools</p>
</blockquote>
<p>使用 <code>dotnet new -i &lt;package name&gt;</code> 命令安装模板。</p>
<h5 id="版本控制"><a class="header" href="#版本控制">版本控制</a></h5>
<p>语义化版本控制的工作原理是确保包具有版本号，并且该版本号划分为以下部分：</p>
<ul>
<li><strong>主版本</strong>。 最左边的数字。 例如 1.0.0 中的 1。 此数字发生更改意味着代码可能出现中断性变更。 可能需要重写部分代码。</li>
<li><strong>次要版本</strong>。 中间的数字。 例如 1.2.0 中的 2。 此数字发生更改意味着添加了新功能。 你的代码仍可正常工作。 接受更新通常是安全的。</li>
<li><strong>修补程序版本</strong>。 最右边的数字。 例如 1.2.3 中的 3。 此数字发生更改意味着应用了一个更改，修复了代码中应正常工作的内容。 接受更新应是安全的。</li>
</ul>
<h6 id="查找和更新过时的包"><a class="header" href="#查找和更新过时的包">查找和更新过时的包</a></h6>
<pre><code class="language-powershell">dotnet list package --outdated [--include-prerelease]
</code></pre>
<p>运行 <code>dotnet add package &lt;package name&gt; [--prerelease]</code>，它将尝试更新到最新版本，可选择传入 <code>--version=&lt;version number/range&gt;</code>。</p>
<h3 id="生成项目"><a class="header" href="#生成项目">生成项目</a></h3>
<pre><code class="language-powershell">dotnet build
</code></pre>
<h3 id="调试运行"><a class="header" href="#调试运行">调试运行</a></h3>
<pre><code class="language-shell">dotnet App.dll &gt;App.log &amp;
</code></pre>
<blockquote>
<p>可以直接启动动态链接库文件</p>
</blockquote>
<p>调试器所具有的两个最重要的功能是：</p>
<ul>
<li>控制程序执行。 你可以暂停程序并逐步运行它，以便查看执行了哪些代码及其对程序状态的影响。</li>
<li>观察程序的状态。 例如，你可以在代码执行期间随时查看变量的值和函数参数。</li>
</ul>
<h4 id="日志记录"><a class="header" href="#日志记录">日志记录</a></h4>
<ul>
<li>
<p>传统的调试器可能难以调试长期存在的问题。 通过日志，可以对较长的时间跨度进行详细的事后剖析。 与此相反，调试器限制为只能进行实时分析。</p>
</li>
<li>
<p>多线程应用程序和分布式应用程序通常难以调试。 附加调试器往往会修改行为。 可以根据需要分析详细日志，以了解复杂的系统。</p>
</li>
<li>
<p>分布式应用程序中的问题可能是由许多组件之间的复杂交互导致的。 将调试器连接到系统的每个部分可能并不合理。</p>
</li>
<li>
<p>许多服务不应停止。 附加调试器往往会导致超时失败。</p>
</li>
<li>
<p>问题并非总是可预见的。 日志记录和跟踪旨在降低开销，以便在出现问题的情况下可以始终记录程序。</p>
</li>
<li>
<p><code>System.Console</code></p>
<ul>
<li>始终启用，并始终写入控制台。</li>
<li>适用于客户可能需要在发行版中看到的信息。</li>
<li>由于这是最简单的方法，所以常常用于临时调试。 此调试代码通常不会签入到源代码管理中。</li>
<li>在非控制台应用程序中使用 <code>System.Console.WriteLine</code> 时，应慎重考虑。</li>
</ul>
</li>
<li>
<p><code>System.Diagnostics.Trace</code></p>
<ul>
<li>仅在定义 <code>TRACE</code> 时启用。</li>
<li>写入附加侦听器，默认情况下为 DefaultTraceListener。</li>
<li>创建将在大多数生成中启用的日志时，请使用此 API。</li>
</ul>
</li>
<li>
<p><code>System.Diagnostics.Debug</code></p>
<ul>
<li>仅在定义 <code>DEBUG</code> 时才启用（处于调试模式时）。</li>
<li>写入附加调试器。</li>
<li>创建仅在调试生成中启用的日志时，请使用此 API。</li>
</ul>
</li>
</ul>
<h5 id="定义-trace-和-debug-常数"><a class="header" href="#定义-trace-和-debug-常数">定义 TRACE 和 DEBUG 常数</a></h5>
<p>在项目文件中添加<code>PropertyGroup</code>：</p>
<pre><code class="language-xml">&lt;PropertyGroup Condition=&quot;'$(Configuration)|$(Platform)'=='Debug|AnyCPU'&quot;&gt;
    &lt;DefineConstants&gt;DEBUG;TRACE&lt;/DefineConstants&gt;
&lt;/PropertyGroup&gt;
&lt;PropertyGroup Condition=&quot;'$(Configuration)|$(Platform)'=='Release|AnyCPU'&quot;&gt;
    &lt;DefineConstants&gt;TRACE&lt;/DefineConstants&gt;
&lt;/PropertyGroup&gt;
</code></pre>
<pre><code class="language-c#">Debug.Assert(n2 == 5, &quot;The return value is not 5 and it should be.&quot;);
</code></pre>
<h2 id="aspnet-core"><a class="header" href="#aspnet-core">ASP.NET Core</a></h2>
<p>RESTful API: adding, viewing, modifying, and removing;</p>
<p>HTTP action verbs : <strong>C</strong>reate, <strong>R</strong>ead, <strong>U</strong>pdate, <strong>D</strong>elete (CRUD).</p>
<p>Entity Framework (EF) Core</p>
<h3 id="概览"><a class="header" href="#概览">概览</a></h3>
<p><img src="CSharp.NET/dotnet%E5%BC%80%E5%8F%91.assets/architecture.png" alt="app overview" /></p>
<h4 id="api-specification"><a class="header" href="#api-specification">API Specification</a></h4>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">API</th><th style="text-align: left">Description</th><th style="text-align: left">Request body</th><th style="text-align: left">Response body</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>GET /api/Items</code></td><td style="text-align: left">Get all items</td><td style="text-align: left">None</td><td style="text-align: left">Array of items</td></tr>
<tr><td style="text-align: left"><code>GET /api/Items/{id}</code></td><td style="text-align: left">Get item by ID</td><td style="text-align: left">None</td><td style="text-align: left">item</td></tr>
<tr><td style="text-align: left"><code>POST /api/Items</code></td><td style="text-align: left">Add a new item</td><td style="text-align: left">To-do item</td><td style="text-align: left">item</td></tr>
<tr><td style="text-align: left"><code>PUT /api/Items/{id}</code></td><td style="text-align: left">Update existing item</td><td style="text-align: left">To-do item</td><td style="text-align: left">None</td></tr>
<tr><td style="text-align: left"><code>DELETE /api/Items/{id}</code></td><td style="text-align: left">Delete an item</td><td style="text-align: left">None</td><td style="text-align: left">None</td></tr>
</tbody></table>
</div>
<h4 id="创建项目-1"><a class="header" href="#创建项目-1">创建项目</a></h4>
<pre><code class="language-powershell">dotnet new webapi -o dotnet-webapi
cd dotnet-webapi
dotnet add package Microsoft.EntityFrameworkCore.SqlServer
dotnet add package Microsoft.EntityFrameworkCore.InMemory
dotnet dev-certs https --trust  # Trust the HTTPS deve certificate
code .
</code></pre>
<p>https://docs.microsoft.com/en-us/aspnet/core/tutorials/first-web-api?view=aspnetcore-5.0&amp;tabs=visual-studio-code</p>
<h3 id="编程模型"><a class="header" href="#编程模型">编程模型</a></h3>
<h4 id="mvc"><a class="header" href="#mvc">MVC</a></h4>
<h5 id="model"><a class="header" href="#model">Model</a></h5>
<p>Model classes can go anywhere in the project, but the <em>Models</em> folder is used by convention.</p>
<pre><code class="language-c#">
</code></pre>
<p>The <em>database context</em> is the main class that coordinates Entity Framework functionality for a data model.</p>
<pre><code class="language-c#">public class ContosoPetsContext : DbContext { /*...*/ }
</code></pre>
<h5 id="controllers-http-endpoints"><a class="header" href="#controllers-http-endpoints">Controllers (HTTP endpoints)</a></h5>
<p>自动生成代码：</p>
<ul>
<li>
<p>Marks the class with the ApiController attribute. This attribute indicates that the controller responds to web API requests.</p>
</li>
<li>
<p>Uses DI to inject the database context (<code>TodoContext</code>) into the controller. The database context is used in each of the <a href="https://wikipedia.org/wiki/Create,_read,_update_and_delete">CRUD</a> methods in the controller.</p>
</li>
</ul>
<pre><code class="language-powershell">dotnet add package Microsoft.VisualStudio.Web.CodeGeneration.Design
dotnet add package Microsoft.EntityFrameworkCore.Design
dotnet tool install -g dotnet-aspnet-codegenerator
dotnet aspnet-codegenerator controller -name TodoItemsController -async -api -m TodoItem -dc TodoContext -outDir Controllers
</code></pre>
<blockquote>
<p><code>-m TodoItem -dc TodoContext</code>：指定了创建的Controller对象关联的数据模型和数据库上下文对象。</p>
</blockquote>
<p>Routing and URL Path</p>
<pre><code class="language-c#">[Route(&quot;api/[controller]&quot;)]
[ApiController]
public class TodoItemsController : ControllerBase{}
</code></pre>
<p><a href="https://docs.microsoft.com/en-us/aspnet/core/mvc/controllers/routing?view=aspnetcore-5.0#attribute-routing-with-httpverb-attributes">Routing to controller actions in ASP.NET Core</a>.</p>
<pre><code class="language-c#">// GET: api/TodoItems/5
[HttpGet(&quot;{id}&quot;)]
public async Task&lt;ActionResult&lt;TodoItem&gt;&gt; GetTodoItem(long id){}
</code></pre>
<blockquote>
<p>When <code>GetTodoItem</code> is invoked, the value of <code>&quot;{id}&quot;</code> in the URL is provided to the method in its <code>id</code> parameter.</p>
</blockquote>
<p>返回值：The return type of the <code>GetTodoItems</code> and <code>GetTodoItem</code> methods is <a href="https://docs.microsoft.com/en-us/aspnet/core/web-api/action-return-types?view=aspnetcore-5.0#actionresultt-type">ActionResult type</a>. ASP.NET Core automatically serializes the object to <a href="https://www.json.org/">JSON</a> and writes the JSON into the body of the response message. </p>
<h6 id="post-api处理"><a class="header" href="#post-api处理">POST API处理</a></h6>
<p>从HTTP请求中读取数据。</p>
<h5 id="配置服务"><a class="header" href="#配置服务">配置服务</a></h5>
<h6 id="注册服务"><a class="header" href="#注册服务">注册服务</a></h6>
<p>Registers the custom <code>DbContext</code> class</p>
<pre><code class="language-c#">// Startup.cs
public void ConfigureServices(IServiceCollection services)
{
    services.AddDbContext&lt;ContosoPetsContext&gt;(options =&gt;
        options.UseInMemoryDatabase(&quot;ContosoPets&quot;));
    services.AddControllers();
    // code omitted for brevity
}
</code></pre>
<h3 id="测试-1"><a class="header" href="#测试-1">测试</a></h3>
<h4 id="postman"><a class="header" href="#postman">Postman</a></h4>
<p>https://www.postman.com/downloads/</p>
<h2 id="entity-framework-core"><a class="header" href="#entity-framework-core">Entity Framework Core</a></h2>
<p>The <code>Microsoft.EntityFrameworkCore.InMemory</code> package is required to use an EF Core in-memory database. </p>
<h2 id="第三方库-1"><a class="header" href="#第三方库-1">第三方库</a></h2>
<h3 id="terminalgui"><a class="header" href="#terminalgui">Terminal.GUI</a></h3>
<pre><code class="language-powershell">dotnet add package Terminal.GUI
</code></pre>
<h4 id="模块"><a class="header" href="#模块">模块</a></h4>
<h5 id="应用实例"><a class="header" href="#应用实例">应用实例</a></h5>
<pre><code class="language-c#">Application.Init();
Application.Shutdown ();
</code></pre>
<h4 id="视图"><a class="header" href="#视图">视图</a></h4>
<p>应用程序中添加的UI元素组成<strong>视图</strong>（<em>Views</em>），视图负责处理显示、接收输入事件和参与聚焦机制。</p>
<p>视图可包含任意数量的子视图（<em>Subviews</em>），<code>View.SuperView</code>是当前视图的容器。</p>
<blockquote>
<p><a href="https://gui-cs.github.io/Terminal.Gui/articles/views.html">Views provided by the Terminal.Gui library</a></p>
</blockquote>
<h5 id="toplevels"><a class="header" href="#toplevels">TopLevels</a></h5>
<p><code>Toplevel</code>视图占用整个屏幕，不含可见的UI元素，通常需要在程序中向其中添加子视图或组件（如文本标签<code>Label</code>、菜单<code>MenuBar</code>、工作窗口<code>Window</code>等）。</p>
<pre><code class="language-c#">TopLevel top = Application.Top; // 默认的视图
top.add(label);
Application.Run();  // 渲染顶层界面
</code></pre>
<blockquote>
<p>自定义其他视图：</p>
<pre><code class="language-c#">var top = new Toplevel(){ 
    X=0, Y=0, Width=Dim.Fill(), Height = Dim.Fill() 
};
Application.Run(top); 
</code></pre>
</blockquote>
<h5 id="windows-2"><a class="header" href="#windows-2">Windows</a></h5>
<p><code>Window</code>（窗口）视图扩展<code>Toplevel</code>，将视图划为标题栏和画框（<em>frame</em>），屏幕上可同时存在多个窗口。</p>
<h5 id="dialogs"><a class="header" href="#dialogs">Dialogs</a></h5>
<p><code>Dialog</code>是位于屏幕中央的一类窗口，以模态方式运行。通过<code>AddButtion</code>可在底部增加按钮。</p>
<pre><code class="language-c#">bool ok_pressed = false;
var ok = new Button(&quot;Ok&quot;){
    Clicked = () =&gt; { Application.RequestStop (); ok_pressed = true; }
};
var cancel = new Button(&quot;Cancel&quot;){
    Clicked = () =&gt; Application.RequestStop(); 
};
var dialog = new Dialog(&quot;Quit&quot;, 60, 7, ok, cancel);
Application.Run(dialog);
if (ok_pressed){
    Console.WriteLine (&quot;xxx&quot;);
}
</code></pre>
<h4 id="布局-2"><a class="header" href="#布局-2">布局</a></h4>
<p>UI元素的布局通过指定左上角位置和组件的尺寸确定。布局方案<code>View.LayoutStyle</code>包括绝对布局和动态布局。</p>
<pre><code class="language-c#">var label2 = new Label (new Rect (1, 2, 20, 1), &quot;World&quot;); // 使用Rect定义绝对尺寸
var label = new Label (&quot;Hello&quot;) {
    X = 1,               //绝对值
    Y = Pos.Center(),    //动态计算
    Width = Dim.Fill(),  //动态计算
    Height = 1           //绝对值
};
</code></pre>
<h5 id="绝对布局"><a class="header" href="#绝对布局">绝对布局</a></h5>
<p><code>View.Frame</code></p>
<h5 id="动态布局"><a class="header" href="#动态布局">动态布局</a></h5>
<p>位置计算方法：</p>
<pre><code class="language-c#">view.X = Pos.Center () - 10;  
view.Y = Pos.Percent (20);   //按比例布局
//相对边界布局
view.X = AnchorEnd(10);
//相对其他组件布局
view.X = Pos.X(super_view);
view.Y = Pos.Bottom(another_view);
</code></pre>
<p>尺寸计算方法：</p>
<pre><code class="language-c#">view.Width = Dim.Fill () - 10;
view.Height = Dim.Percent(20) - 1;
anotherView.Height = Dim.Height(view)+1;
</code></pre>
<h4 id="色彩样式"><a class="header" href="#色彩样式">色彩样式</a></h4>
<h4 id="ui组件-1"><a class="header" href="#ui组件-1">UI组件</a></h4>
<h5 id="工具栏"><a class="header" href="#工具栏">工具栏</a></h5>
<h5 id="窗口"><a class="header" href="#窗口">窗口</a></h5>
<h4 id="事件处理"><a class="header" href="#事件处理">事件处理</a></h4>
<p><a href="https://gui-cs.github.io/Terminal.Gui/articles/mainloop.html">Event Processing and the Application Main Loop (gui-cs.github.io)</a></p>
<h2 id="参考文献-7"><a class="header" href="#参考文献-7">参考文献</a></h2>
<div class="footnote-definition" id="netstd"><sup class="footnote-definition-label">1</sup>
<p><a href="https://devblogs.microsoft.com/dotnet/introducing-net-standard/">Introducing .NET Standard - .NET Blog (microsoft.com)</a>
<sup class="footnote-reference"><a href="#netstd2">2</a></sup>: <a href="https://devblogs.microsoft.com/dotnet/the-future-of-net-standard/">The future of .NET Standard - .NET Blog (microsoft.com)</a></p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="modern-c"><a class="header" href="#modern-c">Modern C++</a></h1>
<h2 id="introducing-modern-c"><a class="header" href="#introducing-modern-c">Introducing Modern C++</a></h2>
<h3 id="c标准"><a class="header" href="#c标准">C++标准</a></h3>
<ul>
<li>
<p><code>C++98</code></p>
</li>
<li>
<p><code>C++03</code></p>
</li>
<li>
<p><code>C++11</code></p>
</li>
<li>
<p><code>c++14</code></p>
</li>
<li>
<p><code>C++17</code></p>
</li>
<li>
<p><code>C++20</code></p>
<blockquote>
<p>Support in <code>gcc</code> is highly experimental, and will almost certainly change in incompatible ways in future releases.</p>
</blockquote>
</li>
</ul>
<h3 id="c特性"><a class="header" href="#c特性">C++特性</a></h3>
<h4 id="c-vs-c"><a class="header" href="#c-vs-c">C++ v.s. C</a></h4>
<div class="table-wrapper"><table><thead><tr><th>C++</th><th>C</th></tr></thead><tbody>
<tr><td></td><td><em>not</em> a <em>strict</em> subset of C++</td></tr>
<tr><td>stronger type system</td><td>weak type system</td></tr>
<tr><td>high-level abstractions</td><td>only low-level memory abstraction</td></tr>
<tr><td>powerful custom types (<code>class</code>es)</td><td>only data aggregation (<code>struct</code>)</td></tr>
<tr><td>use compiler as correctness checker</td><td>get the code to compile quickly</td></tr>
<tr><td>if it compiles, it should be correct</td><td>debugging is the real work</td></tr>
</tbody></table>
</div>
<h4 id="c-vs-java"><a class="header" href="#c-vs-java">C++ v.s. Java</a></h4>
<div class="table-wrapper"><table><thead><tr><th>C++</th><th>Java</th></tr></thead><tbody>
<tr><td>==<a href="https://akrzemi1.wordpress.com/2012/02/03/value-semantics">value semantics</a> for all types==</td><td>==value semantics only for primitives (<code>int</code>, <code>float</code>,… )==</td></tr>
<tr><td>optional reference semantics for all types</td><td>baked-in reference semantics for <code>class</code> types</td></tr>
<tr><td>full control over memory (de-)allocation; <br/>no garbage collection</td><td>garbage collector; can degrade performance</td></tr>
<tr><td>deterministic &amp; controllable object lifetime</td><td>no predictable object lifetime control</td></tr>
<tr><td>⇒ memory frugal</td><td>⇒ high memory consumption</td></tr>
<tr><td>aggressive inline can eliminate slow function calls</td><td>performance degradation due to un-devirtualizable, non-inlinable methods</td></tr>
</tbody></table>
</div>
<h4 id="c-vs-python"><a class="header" href="#c-vs-python">C++ v.s. Python</a></h4>
<div class="table-wrapper"><table><thead><tr><th>C++</th><th>Python</th></tr></thead><tbody>
<tr><td>almost always faster</td><td>almost always slower (in practice around 25-50 times)</td></tr>
<tr><td>complex syntax and tons of features can be intimidating to newcomers</td><td>simple syntax; usually easy to comprehend</td></tr>
<tr><td>statically typed</td><td>dynamically typed</td></tr>
<tr><td>many types of bugs can be caught at compile time</td><td>many types of bugs will only manifest at runtime</td></tr>
<tr><td>suited for safety-critical large-scale systems</td><td>hard to build reliable large-scale systems</td></tr>
<tr><td>even simple, small-scope tasks can quickly require an expert knowledge of various arcane corner cases &amp; quirks</td><td>tends to be more beginner-friendly and small scripts are usually quickly written</td></tr>
<tr><td>fairly small standard library but extensive ecosystem with libraries for nearly everything</td><td>==batteries included philosophy== with tons of libraries only one <code>import</code> away</td></tr>
</tbody></table>
</div>
<p>https://isocpp.org/wiki/faq</p>
<h2 id="数据类型-2"><a class="header" href="#数据类型-2">数据类型</a></h2>
<h3 id="基础数据类型"><a class="header" href="#基础数据类型">基础数据类型</a></h3>
<img src="CC++/Modern C++.assets/image-20210130230242900.png" alt="basic types" style="zoom:67%;" />
<blockquote>
<ul>
<li><code>0</code> is always <code>false</code>；everything else is <code>true</code>。</li>
</ul>
</blockquote>
<p>字符类型：<code>char</code>型（1字节），<code>wchar_t</code>型（长度与平台相关可能是2或4字节），<code>char16_t</code>（2字节）， <code>char32_t</code>（4字节）。</p>
<h4 id="字面值-4"><a class="header" href="#字面值-4">字面值</a></h4>
<p>字面值类型包括：整数常量、字符常量、浮点数常量、字符串常量。此处的常量均是指字面值常量。</p>
<h5 id="整数常量"><a class="header" href="#整数常量">整数常量</a></h5>
<p>整数常量可以声明为十进制、八进制、十六进制，有无符号，长或短整型。十进制数以非零数字开始，八进制以数字“<code>0</code>”为前导，十六进制以“<code>0x</code>”为前导。</p>
<p>后缀“<code>u</code>”或“<code>U</code>”用于声明该数值为无符号数，未添加该后缀则表示有符号数。</p>
<p>后缀“<code>L</code>”或“<code>l</code>”用于声明长整形。</p>
<p>后缀“<code>i64</code>”或“<code>ll</code>”或“<code>LL</code>”用于声明64位整形。</p>
<h5 id="浮点常量"><a class="header" href="#浮点常量">浮点常量</a></h5>
<p>浮点常量中是必须包含小数点的定点数，还可以包含指数，还可以附加后缀用于声明类型。浮点数默认类型为<code>double</code>，当添加后缀“<code>F</code>”或“<code>f</code>”表示浮点型，“<code>L</code>”或“<code>l</code>”表示<code>long double</code>（<code>long double</code>和<code>double</code>的长度都是一样的，但是类型不相同）。</p>
<p>定点数的表示方法：</p>
<pre><code class="language-c++">double x = 18.46, y = 38. ;
</code></pre>
<p>指数表示方法：</p>
<pre><code class="language-c++">double x = 18.46e0, y = 18.46E1 ;
</code></pre>
<p>指数部分可以是负数。当浮点数包含指数时，定点数部分可以不包含小数点。</p>
<p>数值范围：</p>
<pre><code class="language-c++">#include &lt;limits&gt;
std::numeric_limits&lt;double&gt;::max()     // largest positive value
std::numeric_limits&lt;double&gt;::min()     // smallest value &gt; 0
std::numeric_limits&lt;double&gt;::lowest()  // smallest negative value
std::numeric_limits&lt;double&gt;::epsilon() // smallest difference
</code></pre>
<p>一个整型类型可以转换成更宽位数的整型类型，这种转换称为整型提升。进行这种转换不改变数据的值。</p>
<h5 id="字符常量"><a class="header" href="#字符常量">字符常量</a></h5>
<p>字符常量是使用“<code>'</code>”包围的一个或多个字符。</p>
<p>如果整型使用普通字符常量或宽字符常量声明，则不足位补零；如果普通字符或宽字符用多字符常量声明，则将丢弃高位（左边的）字符。超过四个字符的字符常量声明将出错。</p>
<p>在字符声明中，具有特殊意义的字符（<code>\</code>、<code>'</code>、<code>&quot;</code>等）需要使用转义字符“<code>\</code>”消除特殊意义。转义序列有三种类型：</p>
<ul>
<li>
<p>简单类型：<code>\'  \&quot;  \?  \\ \a  \b  \f  \n  \r  \t  \v</code>；</p>
</li>
<li>
<p>八进制转义序列（转移字符之后最长三位八进制数，超过三位则第二个字符开始，或者从第一非八进制数字结束）：<code>\012</code>；</p>
</li>
<li>
<p>十六进制转义字符：转义字符后接“<code>x</code>”，其后接十六进制数字，后接数字位数无限制，只能以非十六进制数字结束。十六进制转义字符首先去除多余的高位，然后将剩余的8位数字转换为整型，再将整型转换为字符，如果整形的无符号值大于255，则转换不能完成，编译时会出错。</p>
<blockquote>
<p>转移字符之后的字符如果不是特殊字符，则结果由具体的实现决定。</p>
</blockquote>
</li>
</ul>
<p>双引号在字符常量中可以不使用转义字符。</p>
<blockquote>
<p>Microsoft Specification：通常只能是ASCII字符，包括96个字符：空格、水平制表符、垂直制表符、换行符、Formfeed和26个大小写字符、10个数字、以及下列字符：</p>
<p><code>_ { } [ ] # ( ) &lt; &gt; % : ; . ? * + - / ^ &amp; | ~ ! = , \ &quot; '</code></p>
<p>对于转义字符之后的非特殊意义字符，非特殊字符将正常显示，而转义字符不会显示；编译时会出现警告“不可识别的字符转移序列”。</p>
</blockquote>
<h5 id="字符串常量"><a class="header" href="#字符串常量">字符串常量</a></h5>
<p>一个字符串常量由0个或多个字符构成，有双引号所包围，字符串代表一个由“<code>null</code>”结尾的字符序列。字符串中可以包含所有字符常量允许使用的字符，以及使用转义字符。C++字符串包含两种类型：<code>char[]</code>，<code>wchar_t[]</code>。</p>
<pre><code class="language-c++">wchar_t w[] = L&quot;wide string&quot;; 
</code></pre>
<blockquote>
<p>声明<code>wchar_t</code>字符或字符串常量需要添加一个前缀“<code>L</code>”，类似地<code>u</code>用于<code>char16_t</code>类型字面值，<code>U</code>用于<code>char32_t</code>类型字面值。</p>
<p>通过指向常量字符串的指针修改常量字符串是不允许的，结果未知。</p>
</blockquote>
<p>以空格分隔的字符串会被自动拼接为单个字符串（也可以在行末使用“<code>\</code>”连接两行。）。</p>
<pre><code class="language-c++">const char* b = &quot;first&quot; &quot;second&quot; // ⇒ &quot;first second&quot;
</code></pre>
<p>原始字符转字面值：</p>
<pre><code class="language-c++">char const * ch_array = R&quot;(raw &quot;C&quot;-string c:\users\joe )&quot;;  // c++11
</code></pre>
<blockquote>
<p>Microsoft Specification：在一些情况下，声明的相同的字符串将被合并为一个字符串，在内存中使用同一段内存。</p>
<p>字符串的字面值最大长度为2048字节，对于<code>char</code>和<code>wchar_t</code>都一样。</p>
<p>如果定义了UNICODE，则<code>_T()</code>等效于前缀<code>L</code>。</p>
</blockquote>
<h4 id="枚举-3"><a class="header" href="#枚举-3">枚举</a></h4>
<p>限定作用域枚举，使用枚举类型名访问枚举成员。</p>
<pre><code class="language-c++">enum class day:short { mon, tue, wed, thu, fri, sat, sun };
day d = day::mon;
</code></pre>
<p>非限定作用域枚举，不同的枚举类型不能包含相同名字的成员。</p>
<pre><code class="language-c++">enum day { mon, tue, wed, thu, fri, sat, sun };
day d = mon;
</code></pre>
<p>可以为枚举指定底层整数类型（<code>char, short, long,...</code>，默认为<code>int</code>）。可以将枚举强制转换为其底层类型。</p>
<h3 id="引用"><a class="header" href="#引用">引用</a></h3>
<p>引用声明以后就是绑定到变量的别名，对引用名再赋值等效于修改绑定变量的值，因此无法再修改引用本身（赋值）使之绑定到其他变量。由于引用是变量的别名，因此通过引用总是能访问有效的变量。</p>
<pre><code class="language-c++">[const] ValueType [const] &amp; ref_name = VarName;
</code></pre>
<blockquote>
<p><code>const</code>声明符可以位于类型的前面或后面，但后者与<a href="CC++/Modern%20C++.html#%E5%B8%B8%E9%87%8F%E7%9B%B8%E5%85%B3%E6%8C%87%E9%92%88">指针类型声明</a>风格保持一致。</p>
<p>references cannot be &quot;null&quot;, i.e., they must always refer to an object</p>
</blockquote>
<pre><code class="language-c++">int  i  = 2, k  = 3;
int&amp; ri = i;    // reference to i
ri = k;         // assign new value to ri(i)
</code></pre>
<p>如果引用声明为常量，则无法通过该引用修改变量的值。</p>
<h4 id="引用的应用"><a class="header" href="#引用的应用">引用的应用</a></h4>
<ul>
<li>
<p>作为函数、“<code>[]</code>”和“<code>=</code>”操作符的返回值，满足左操作数可以被赋值的要求（L-value）。</p>
<p><strong>Dangling Reference</strong>：</p>
<blockquote>
<p>不要返回局部变量的引用；</p>
<p>引用容器元素在修改容器后可能失效；</p>
</blockquote>
</li>
<li>
<p>作为函数参数，等价于使用指针进行参数传递，而无须复制实际参数。</p>
</li>
<li>
<p>在迭代循环中使用</p>
<pre><code class="language-c++">for(std::string &amp; s : v) { cin &gt;&gt; s; } // modify vector elements
for(std::string const&amp; s : v) { cout &lt;&lt; s; } // read-only access
for(auto &amp; s : v) { cin &gt;&gt; s; }
for(auto const&amp; s : v) { cout &lt;&lt; s; }
</code></pre>
</li>
<li>
<p><a href="https://hackingcpp.com/cpp/lang/move_semantics.html">Move Semantics</a></p>
</li>
<li>
<p>Avoid Output Parameters! 难以确定参数是否发生变化，参数是否仅作为输出或还作为输入。</p>
</li>
<li>
<p><strong>Just take returned objects by value.</strong> This does not involve expensive copies for most functions and types in modern C++, especially in C++17 and above.</p>
<blockquote>
<p>使用引用绑定函数返回值将导致临时变量的生命周期变长。</p>
</blockquote>
</li>
</ul>
<h4 id="引用绑定规则"><a class="header" href="#引用绑定规则">引用绑定规则</a></h4>
<h5 id="rvalues-and-lvalues"><a class="header" href="#rvalues-and-lvalues"><em>R</em>values and <em>L</em>values</a></h5>
<p><strong>左值（Lvalues）</strong>：expressions of which we <strong>can</strong> get memory address</p>
<ul>
<li>内存中可引用的对象</li>
<li>具有名字的对象 (variables, function parameters, …)</li>
</ul>
<p><strong>右值（Rvalues）</strong>：expressions of which we <strong>can't</strong> get memory address</p>
<ul>
<li>字面值(<code>123</code>, <code>&quot;string literal&quot;</code>, …)（位于代码区）；</li>
<li>运算的零时结果；</li>
<li>函数返回的零时变量；</li>
</ul>
<p><strong>左值引用</strong>：<code>type&amp;</code>，仅能绑定到左值；<code>type const&amp;</code>可绑定到<code>const</code>左值和右值；</p>
<p><strong>右值引用</strong>：<code>type&amp;&amp;</code>，仅能绑定到右值（涉及<a href="CC++/Modern%20C++.html#%E7%B1%BB%E5%9E%8B%E6%8E%A8%E6%96%AD">类型推断</a>的除外）；</p>
<p><strong>万能引用（转发引用）</strong>：根据类型推断的结果，可能为左值或右值引用。</p>
<pre><code class="language-c++">auto&amp;&amp; ref = var;
template&lt;typename T&gt; void f(T&amp;&amp; param);
</code></pre>
<blockquote>
<p>类型推导是必要条件，被推导类型必须为<code>T&amp;&amp;</code>，其中<code>T</code>是模板类型参数。</p>
</blockquote>
<h3 id="类型语法"><a class="header" href="#类型语法">类型语法</a></h3>
<h4 id="类型别名"><a class="header" href="#类型别名">类型别名</a></h4>
<pre><code class="language-c++">using NewType = OldType;  // C++11
typedef OldType NewType;  // C++98
</code></pre>
<h4 id="类型推断"><a class="header" href="#类型推断">类型推断</a></h4>
<pre><code class="language-c++">auto variable = expression; // c++11
</code></pre>
<h4 id="类型转换-4"><a class="header" href="#类型转换-4">类型转换</a></h4>
<p><code>static_cast(v)</code>：强制类型转换，编译器允许执行（但不一定是自动执行的）的任何转换都可以完成。避免发生精度损失时的警告。类似于C语法<code>type(var)</code>。</p>
<p><code>const_cast(v)</code>：去除常量性质，是变量能够被修改。</p>
<p><code>dynamic_cast(v)</code>：运行时动态识别类型。将基类类型的指针或引用安全地转换为派生类型的指针或引用。</p>
<p><code>reinterpret_cast(v)</code>：对于编译器不允许的转换类型（如指针类型转换），可以使用<code>reinterpret_cast</code>进行强制转换而不产生编译期错误。 </p>
<p><code>std:move(T&amp;&amp;)</code>将参数强制转换为右值；</p>
<p><code>std:forward&lt;T&gt;(param)</code>：仅当实参为右值时，将形参转换为右值；</p>
<h3 id="指针-2"><a class="header" href="#指针-2">指针</a></h3>
<p>指针可以用于访问对象，且可以在运行期间改变其引用的对象（引用则不能修改）。指针的一个重要用途是函数参数传递，使用指针可以进行地址传递，则主函数和子函数可以访问同一段内存的变量。</p>
<img src="CC++/Modern C++.assets/image-20210212200114257.png" alt="image-20210212200114257" style="zoom:40%;" />
<h4 id="原始指针"><a class="header" href="#原始指针">原始指针</a></h4>
<p>指针存储内存地址的整数变量。通过取地址运算符<code>&amp;</code>获取变量地址。</p>
<pre><code class="language-c++">int a = 1;
int* ptr = &amp;a;
</code></pre>
<p>或通过<a href="CC++/Modern%20C++.html#%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D">动态内存分配</a>获取堆上创建的变量的地址。</p>
<h5 id="指针运算"><a class="header" href="#指针运算">指针运算</a></h5>
<p>指针可以进行赋值运算、算数运算、关系运算和解引用运算。</p>
<p><code>*</code>：对象引用运算符；</p>
<p><code>-&gt;</code>：对象成员引用运算符；</p>
<pre><code class="language-c++">point *p = new point{1,2};
cout &lt;&lt; p-&gt;x &lt;&lt; p-&gt;y &lt;&lt; *(p).x;
</code></pre>
<blockquote>
<p>优先使用引用，语法更加简洁。</p>
</blockquote>
<h4 id="智能指针c11"><a class="header" href="#智能指针c11">智能指针（C++11）</a></h4>
<img src="CC++/Modern C++.assets/image-20210212200441907.png" alt="image-20210212200441907" style="zoom: 40%;" />
<h5 id="unique_ptr"><a class="header" href="#unique_ptr">unique_ptr</a></h5>
<p>不能复制指针，但可以移动指针指向的对象到新的指针，原指针被置为<code>nullptr</code>。</p>
<pre><code class="language-c++">#include &lt;memory&gt;
auto p = make_unique&lt;Type&gt;(init_list);    // c++14, more safe
std::unique_ptr&lt;Type&gt; p1(new Type(args));  // c++14
auto p2 = move(p);  // 不能复制unique_ptr
</code></pre>
<blockquote>
<p>仍然使用<code>-&gt;</code>运算符访问类型的成员。</p>
</blockquote>
<h5 id="shared_ptr"><a class="header" href="#shared_ptr">shared_ptr</a></h5>
<pre><code class="language-c++">#include &lt;memory&gt;
auto p = make_shared&lt;Type&gt;(init_list);     // c++14
std::shared_ptr&lt;Type&gt; p1(new Type(args));  // c++14
auto p2 = p;
</code></pre>
<p>引用计数：当最后引用对象的指针被销毁时，对象被销毁。</p>
<p><code>weak_ptr</code>可以复制<code>shared_ptr</code>但不影响引用计数。</p>
<h3 id="数组-4"><a class="header" href="#数组-4">数组</a></h3>
<pre><code class="language-c++">type array[N];
type array[N] = {1,2,3,...};
</code></pre>
<blockquote>
<p>当初始化列表给定时，可省略数组长度参数。==数组长度？==</p>
</blockquote>
<p>动态创建数组：</p>
<pre><code class="language-c++">type* ptr_array = new type[size];
type* ptr_array = new type[size]{1,2,...};
</code></pre>
<p>多维数组：创建$M\times N\times\cdots$维数组。</p>
<pre><code class="language-c++">type array[M][N]...[];
type (*ptr)[N]... = new type[size][N]...;
</code></pre>
<p>仅有数组的最高维度是可以动态分配的，将其他维度整体看作一个整体（子数组）。</p>
<blockquote>
<p><code>K</code>维数组可以看成由<code>size</code>个维度为<code>K-1</code>的子数组构成的。分配一维数组，实际上是分配连续的<code>size</code>个基本变量；分配二维数组，实际上是连续分配<code>size</code>个一维数组，以此类推…… </p>
<p>动态创建数组时只有<code>size</code>是变量，其他参数必须是编译期确定的常量（字面值或<code>constexpr</code>）。指向数组的指针进行“加减”运算，指针加减1实际对应的内存地址偏移量为对应子数组的内存占用长度。</p>
</blockquote>
<h4 id="指针数组"><a class="header" href="#指针数组">指针数组</a></h4>
<p>即数组元素是指针类型。指针数组的声明：</p>
<pre><code class="language-c++">type* ptr_array[L1][L2]...;
type(*ptr_array[L1][L2]...)[M][N]...[P];
</code></pre>
<p>其中<code>[L1][L2]...</code>是指针数组本身的维度，而<code>type(*)[M][N]...[P]</code>代表最终指向的数据类型。如果带参数<code>[M][N]...[P]</code>，则代表指向的是数组（的维度）；如果没有该参数则为指向变量的指针（此时不省略<code>()</code>会生成警告）。</p>
<h4 id="数组索引"><a class="header" href="#数组索引">数组索引</a></h4>
<pre><code class="language-c++">array_name[index]；
*(array_name+index)；
</code></pre>
<blockquote>
<p>数组名相当于<a href="CC++/Modern%20C++.html#%E5%B8%B8%E9%87%8F%E7%9B%B8%E5%85%B3%E6%8C%87%E9%92%88">指针常量</a>。</p>
</blockquote>
<p>高维数组在内存中实际上是按照线性方式存储数据的，所以实质上等效于是一个一维数组，所以仍然可以定义一维数组指针来访问数组元素。则指向第一个元素的一维数组指针的值应该是：</p>
<pre><code class="language-c++">type *ptr =  array[M][N]...;    // 省略最后一维
type *ptr = &amp;array[M][N]...[P]; // 或直接取元素地址
</code></pre>
<h3 id="类型修饰符"><a class="header" href="#类型修饰符">类型修饰符</a></h3>
<h4 id="静态变量-2"><a class="header" href="#静态变量-2">静态变量</a></h4>
<pre><code class="language-c++">static int x = 1; // 定义静态（文件作用域）变量
extern int x;     // 引用全局（非静态）变量，不推荐使用全局变量
</code></pre>
<blockquote>
<p>可以在<a href="CC++/Modern%20C++.html#%E5%A4%B4%E6%96%87%E4%BB%B6">头文件中定义静态变量</a>，引用该头文件的源文件将分别生成独立的文件作用域静态变量。</p>
</blockquote>
<p><strong>局部静态变量</strong>：静态变量定义在非全局作用域（如函数内部）。该变量的生命周期为程序生命周期，但仅能在定义该变量的作用域中访问。==局部静态变量只会在定义位置被初始化一次==。</p>
<blockquote>
<p>全局变量构造器：在静态函数中返回静态变量的引用。</p>
</blockquote>
<h4 id="常量-2"><a class="header" href="#常量-2">常量</a></h4>
<pre><code class="language-c++">Type const variable_name = value;
const Type variable_name = value;
</code></pre>
<p>用<code>const</code>关键字可以代替<code>#define</code>宏，使用<code>const</code>关键字声明的常量在编译时可以进行类型检查，而使用<code>#define</code>宏定义的常量则不能。</p>
<h5 id="常量表达式"><a class="header" href="#常量表达式">常量表达式</a></h5>
<p>表达式的值在编译期间是确定的，其组成部分都是常量表达式。</p>
<pre><code class="language-c++">constexpr int i = 2;       // OK '2' is a literal
constexpr int cxf(int i) { return i*2; }
constexpr int j = cxf(5);  // OK, cxf is constexpr 
constexpr int k = cxf(i);  // OK, cxf and i are constexpr
</code></pre>
<blockquote>
<p><code>c++14</code>：常量表达式函数内部可以包含多条语句；</p>
</blockquote>
<h4 id="常量相关指针"><a class="header" href="#常量相关指针">常量相关指针</a></h4>
<p>常量指针：指针本身是常量，即不能更改指针本身（所存储的内存位置），但可以更改指针指向的内容。</p>
<p>指向常量的指针：指针所指的内容必须是常量，不能修改指针所指的内容，但可以修改指针本身（所存储的内存地址）。可以用于函数参数，防止函数改变通过指针传入的参数。</p>
<pre><code class="language-c++">type *const ptr;  // const pointer to variable of Type &lt;type&gt;
type const *ptr;  // pointer to const variable of Type &lt;type&gt;
</code></pre>
<blockquote>
<p><code>type const *const</code>：指针本身不能改变，指针所指的值也不允许改变。</p>
</blockquote>
<img src="CC++/Modern C++.assets/image-20210212201652844.png" alt="image-20210212201652844" style="zoom:30%;" />
<blockquote>
<p>从右到左解释类型声明。</p>
</blockquote>
<h3 id="内存模型"><a class="header" href="#内存模型">内存模型</a></h3>
<p><strong>heap</strong>: used for objects of dynamic storage duration;</p>
<blockquote>
<p>空闲内存块列表。</p>
</blockquote>
<p><strong>stack</strong>: used for objects of automatic storage duration: local variables, function parameters, etc.</p>
<blockquote>
<p>栈分配通常从高地址到低地址。</p>
</blockquote>
<img src="CC++/Modern C++.assets/vector_of_ints.svg" alt="img" style="zoom:50%;" />
<h4 id="内存占用-2"><a class="header" href="#内存占用-2">内存占用</a></h4>
<p>基本数据类型的区别主要在于内存占用量。</p>
<pre><code class="language-c++">sizeof(char)；  // 操作符： auto x = sizeof char
</code></pre>
<blockquote>
<p>Integer Size Guarantees  <a href="https://hackingcpp.com/tags/C++11">C++11</a></p>
<pre><code class="language-c++">#include &lt;cstdint&gt;
</code></pre>
<p>exact size: <code>int8_t</code>,   <code>int16_t</code>,   <code>int32_t</code>,   <code>int64_t</code>,   <code>unt8_t, …</code></p>
</blockquote>
<h4 id="动态内存分配"><a class="header" href="#动态内存分配">动态内存分配</a></h4>
<p>C++使用<code>new</code>和<code>delete</code>关键字进行动态内存管理。当使用<code>new</code>关键字为变量在堆上分配内存并返回<a href="CC++/Modern%20C++.html#%E5%8E%9F%E5%A7%8B%E6%8C%87%E9%92%88">内存地址</a>，并自动调用构造函数进行初始化。如果分配内存失败，<code>new</code>返回<code>nullptr</code>或抛出异常。</p>
<blockquote>
<p><code>nullptr</code>为指针默认值（转换为<code>false</code>，可以用于逻辑判断）。</p>
</blockquote>
<pre><code class="language-c++">type *ptr = new type(args); // type *ptr = new type{args};
type *ptr = new type[const_num]{init_list};
delete ptr;     // delete variable
delete [] ptr;  // delete array
</code></pre>
<blockquote>
<p>无法从指针类型判断其是只想单个变量或数组。</p>
</blockquote>
<p>使用<code>delete</code>关键字对值为<code>nullptr</code>的指针进行操作不会出错；但使用<code>delete</code>对不是用<code>new</code>分配的内存块（栈）的指针进行操作将会出现不可知的结果；在使用<code>delete</code>释放内存后，再使用指针将会出现未知结果或导致程序崩溃。</p>
<blockquote>
<p>In modern C++, manual allocation is actually only really necessary if you want to implement your own dynamic data structures / containers.</p>
</blockquote>
<h2 id="语法-2"><a class="header" href="#语法-2">语法</a></h2>
<h3 id="定义变量-2"><a class="header" href="#定义变量-2">定义变量</a></h3>
<pre><code class="language-c++">type varname;
</code></pre>
<p>定义可以与初始化结合。</p>
<pre><code class="language-c++">type varname = value;
type varname = {value};
type varname{value}; // C++11: narrowing conversion ⇒ compiler warning
</code></pre>
<blockquote>
<p>==基本数值类型变量在声明时不会被赋予默认值，其值是随机的。==</p>
</blockquote>
<p>聚合类型（结构体、类）的<a href="CC++/Modern%20C++.html#%E5%88%9D%E5%A7%8B%E5%8C%96">初始化</a>由<a href="CC++/Modern%20C++.html#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0">构造函数</a>执行。</p>
<pre><code class="language-c++">ClassName varname = ClassName(args);  // 调用构造函数初始化变量
ClassName varname(args);              // 简洁写法
ClassName varname = ClassName{args};  // c++11: narrow conversion
ClassName varname{args};              // 简洁写法
</code></pre>
<p><a href="CC++/Modern%20C++.html#%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D">动态分配的变量</a>返回变量的地址。</p>
<h4 id="赋值-2"><a class="header" href="#赋值-2">赋值</a></h4>
<p>赋值运算默认具有值语义，即显式复制对象的数据成员，避免在非期望情况下修改数据；</p>
<ul>
<li>
<p>避免将聚合类型变量的定义和初始化分开，否则则首先会调用默认构造函数执行初始化再随后执行赋值操作，造成额外开销。</p>
</li>
<li>
<p>==具有指针成员变量的类==应该重写赋值运算符和复制/移动构造函数，以处理动态分配对象的复制问题。否则，对已定义变量使用新构造对象赋值应注意，新构造对象仅具有临时生命周期，因此可能导致赋值后的变量中指针成员引用无效对象。</p>
<pre><code class="language-c++">LinkedList l1;        // LinkedList.header是指针成员变量
vector&lt;int&gt; v = {1, 2, 3, 4};
l1 = LinkedList(v);   // 如果没有适当的赋值拷贝，由于临时创建对象释放，l1可能包含无效指针
</code></pre>
</li>
</ul>
<h5 id="引用语义"><a class="header" href="#引用语义">引用语义</a></h5>
<p>值语义（<a href="https://akrzemi1.wordpress.com/2012/02/03/value-semantics">value semantics</a>）：<a href="CC++/Modern%20C++.html#%E5%A4%8D%E5%88%B6%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0">赋值运算默认为值传递方式</a>（包括函数输入输出参数）。</p>
<blockquote>
<p>更接近数学记法：输入参数不会被函数改变；</p>
<p>we do not run into any memory management issues. No dangling references to nonexistent objects, no expensive and unnecessary free store allocation, no memory leaks, no smart or dumb pointers. </p>
</blockquote>
<p>引用语义（<em>reference semantics</em>）</p>
<blockquote>
<p>where you want to create an object, and let it live for a significant amount of time, and want different parties to modify the object, you need to pass by reference.</p>
<p>This is the case for globals like <code>std::cout</code> that need to be accessible from different places in the code, and it always has to be this very object at this very address.</p>
</blockquote>
<p>指针：</p>
<blockquote>
<p>they are objects that store values which are addresses in memory <em>referring</em> to objects.</p>
<p>at the higher level of abstraction passing and returning pointers to and from functions is usually considered passing by reference (reference semantics), even though technically you are passing values. </p>
<p><em>the reason people often resort to allocating objects in free store (on the heap) and returning a (more or less) smart pointer to it, is that value semantics does not play well with OO techniques that require access to objects via references or pointers to enable virtual function calls.</em></p>
</blockquote>
<h3 id="运算符-12"><a class="header" href="#运算符-12">运算符</a></h3>
<h4 id="自增自减"><a class="header" href="#自增自减">自增/自减</a></h4>
<ul>
<li>prefix expressions <code>++x</code> / <code>--x</code> returns new (incremented/decremented) value；</li>
<li>postfix expression <code>x++</code> / <code>x--</code> increments/decrements value, but <em>returns old value</em>；</li>
</ul>
<h4 id="逻辑运算"><a class="header" href="#逻辑运算">逻辑运算</a></h4>
<pre><code class="language-c++">bool c = a &amp;&amp; b;   // false    logical AND
bool d = a || b;   // true     logical OR
bool e = !a;       // false    logical NOT
</code></pre>
<p><strong>Short-circuit Evaluation</strong>: The second operand of a boolean comparison is not evaluated if the result is already known after evaluating the first operand.</p>
<h4 id="移位运算"><a class="header" href="#移位运算">移位运算</a></h4>
<p>只有整数类型能进行移位操作：</p>
<pre><code class="language-c++">result = op1 &gt;&gt; op2  // 右移
result = op1 &lt;&lt; op2  // 左移
</code></pre>
<p>其中<code>op1</code>是要进行移位的整数，<code>op2</code>是要偏移的位数。<code>op1</code>的值不会改变，移位的结果作为返回值，返回结果的类型与<code>op1</code>的类型相同（准确的说，返回类型应该是长整型，赋值的过程可以强制转换）。</p>
<p>如果<code>op2=0</code>，则实际不对<code>op1</code>移位；如果<code>op2</code>为负数或达到整数类型的bit长度，则结果未定义。实际测试（Windows/Linux）可以发现，移位运算会先对<code>op2</code>进行求余处理，使移位范围不超过整数的bit长度，再进行移位。</p>
<p>左移运算是逻辑移位，即右侧空出的位补零；如果<code>op1</code>是有符号数，则右移运算是算数移位，即左边空出的位填充符号位，如果<code>op1</code>是无符号数，则右移运算是逻辑移位，即左边空出的位补0。</p>
<h3 id="控制流程"><a class="header" href="#控制流程">控制流程</a></h3>
<blockquote>
<p><strong>表达式（Expressions）</strong>: series of computations (operators + operands); may <strong>produce a result</strong>.</p>
<p><strong>Statements</strong>: sequence of expressions; do not produce a result; delimited by <code>;</code> and grouped by <code>{ }</code>.</p>
</blockquote>
<h4 id="条件分支"><a class="header" href="#条件分支">条件分支</a></h4>
<h5 id="if-else-2"><a class="header" href="#if-else-2">if-else</a></h5>
<pre><code class="language-c++">if (condition1) {
  // do this if condition1 is true
}
else {
  // otherwise do this
}
// if(statement; condition) { … }  C++17
</code></pre>
<blockquote>
<p><code>else if</code>是<code>if</code>嵌套在<code>else</code>语句块的结果。</p>
<p>三元运算符：<code>condition ? true_statement : false_statement</code>。</p>
</blockquote>
<h5 id="switch"><a class="header" href="#switch">switch</a></h5>
<pre><code class="language-c++">switch (m) {
  case 0:   // do this if m is 0
    break;
  case 1:   
  case 3:   // do this if m is 1 or 3
    break;
  default:  // do this if m is not 0, 1 or 3
}
// switch (statement; variable) { … }   C++17
</code></pre>
<h5 id="ternary-condition-operator"><a class="header" href="#ternary-condition-operator">Ternary Condition Operator</a></h5>
<pre><code class="language-c++">Result = Condition ? If-Expression : Else-Expression
</code></pre>
<h4 id="循环-5"><a class="header" href="#循环-5">循环</a></h4>
<pre><code class="language-c++">for (int i = 0; i &lt; 5; ++i) {
  cout &lt;&lt; i &lt;&lt; ' ';
}
</code></pre>
<pre><code class="language-c++">std::vector&lt;int&gt; v {1,2,3,4,5};
for(auto i = begin(v); i != end(v); ++i) { cout &lt;&lt; *i; }
for (int x : v)  { cout &lt;&lt; x &lt;&lt; '\n'; } // c++11
</code></pre>
<pre><code class="language-c++">while (j &lt; 10) {
  cout &lt;&lt; j &lt;&lt; ' ';
  ++j;
}
do { 
  cout &lt;&lt; j &lt;&lt; ' ';
  --j;
} while (j &gt; 0);
</code></pre>
<h4 id="异常-1"><a class="header" href="#异常-1">异常</a></h4>
<pre><code class="language-c++">try {...}
catch(std::invalid_argument&amp;e){
    throw;  //re-throw exception
}catch(...){
    // catch all exceptions
}

void funcname(...) noexcept {...}  // throw exception not allowed
</code></pre>
<h3 id="预处理命令"><a class="header" href="#预处理命令">预处理命令</a></h3>
<h4 id="头文件"><a class="header" href="#头文件">头文件</a></h4>
<p>头文件用于集中存放函数原型声明和类型定义。</p>
<pre><code class="language-c++">#include &lt;filename&gt;
</code></pre>
<p>按照标准方式搜索要包含的文件（将文件内容添加到当前处理的源文件中），该文件位于C++系统目录的<code>include</code>子目录下，一般要包含系统提供的标准文件时这样使用。</p>
<pre><code class="language-c++">#include &quot;filename&quot;
</code></pre>
<p>首先在当前目录下搜索要包含的文件，如果没有，再按照标准方式搜索，<em><strong>*对用户自己编辑的文件，采用这种方式*</strong></em>。</p>
<h4 id="宏"><a class="header" href="#宏">宏</a></h4>
<pre><code class="language-c++">#define	MACRO  // 定义宏
#undef MACRO   // 删除由define定义的宏
</code></pre>
<h5 id="特殊宏"><a class="header" href="#特殊宏">特殊宏</a></h5>
<pre><code class="language-c++">__LINE__;  // 行号
__FILE__;  // 文件名
__DATE__;
__TIME__;
__cplusplus;  // 值为最新支持的c++标准发布时间
</code></pre>
<h5 id="带参数的宏"><a class="header" href="#带参数的宏">带参数的宏</a></h5>
<pre><code class="language-c++">#define LOG(x) std::cout &lt;&lt; x &lt;&lt; std::endl
</code></pre>
<h4 id="条件编译指令"><a class="header" href="#条件编译指令">条件编译指令</a></h4>
<pre><code class="language-c++">#if constant_expression
	statements;
#elif constant_expression
	statements;
#else
	statements;
#endif

#ifdef identifier
    statements;
#elif defined(identfier2)
    statements;
#else
    statements;
#endif

#ifndef	identifier
    statements;
#else
    statements;
#endif
</code></pre>
<p><code>#ifdef</code>和<code>#ifndef</code>用于判断一个宏是否已经定义，这两个命令常组合起来使用，在头文件中加入以下结构，用于防止头文件的重复包含。</p>
<pre><code class="language-c++">#ifndef identifier
#define identifier
header_file_contents
#endif
</code></pre>
<blockquote>
<p><code>#pragma once</code>：保证在源文件中只会包含该头文件一次，避免类型的重复定义。</p>
</blockquote>
<p>**注意：**不要在头文件中添加定义，因为该头文件如果被包含到不同源文件，在链接阶段会产生重复符号定义。</p>
<ul>
<li>将函数声明为<code>static</code>，但没有必要为每个源文件定义功能相同的函数；</li>
<li>==将函数声明为<code>inline</code>，则编译时函数体被替换为代码块==。</li>
</ul>
<h4 id="兼容c语言"><a class="header" href="#兼容c语言">兼容C语言</a></h4>
<p>​	使C++在编译C语言函数保持对C语言的兼容，在头文件中添加以下结构。</p>
<pre><code class="language-c++">#ifdef __cplusplus
	#if __cplusplus
extern &quot;C&quot;{
    #endif
#endif
    
function-declare;
    
#ifdef __cplusplus
    #if __cplusplus
}
	#endif
#endif
</code></pre>
<h3 id="注释"><a class="header" href="#注释">注释</a></h3>
<h4 id="文档"><a class="header" href="#文档">文档</a></h4>
<h5 id="c-docstrings"><a class="header" href="#c-docstrings">C++ Docstrings</a></h5>
<pre><code class="language-c++">/**
 * Create a new Triangle object of side lengths 1, 1, and 1.
 * @brief Triangle class used for triangle manipulations.
 * @details 细节
 * @param a The Length of triangle side a.
 * @return The length of side a.
 * @see Triangle(const double a, const double b, const double c)
 * @file 文件名
 * @todo todo things
 */
</code></pre>
<pre><code class="language-c++">/**
 * @mainpage Triangle Library Documentation
 * @author 作者
 * @version 版本号
 * @date 年-月-日
 * @section intro_sec Introduction
 * Do somethings ...
 * @subsection install_dependencies Installing Dependencies
 */
</code></pre>
<h5 id="doxygen"><a class="header" href="#doxygen">doxygen</a></h5>
<p>运行<a href="CC++/../%E5%BA%94%E7%94%A8%E8%BD%AF%E4%BB%B6/%E6%96%87%E6%A1%A3%E7%94%9F%E6%88%90%E8%BD%AF%E4%BB%B6.html#doxygen"><code>doxygen</code></a>生成文档。</p>
<pre><code class="language-shell">doxygen –g Doxyfile
</code></pre>
<p><a href="https://leimao.github.io/blog/CPP-Documentation-Using-Doxygen/">Lei Mao's Log Book – C/C++ Documentation Using Doxygen</a></p>
<p><a href="https://marketplace.visualstudio.com/items?itemName=cschlosser.doxdocgen">Doxygen Documentation Generator - Visual Studio Marketplace</a></p>
<h2 id="函数-4"><a class="header" href="#函数-4">函数</a></h2>
<blockquote>
<ul>
<li>encapsulation of implementation details</li>
<li>easier reasoning about correctness and testing by breaking down problems into separate functions</li>
<li>avoids repeating code for common tasks</li>
</ul>
</blockquote>
<p>返回类型推断：在编译期间可以确定返回类型。</p>
<pre><code class="language-c++">auto foo (int i, double d) {
  …
  return i;
}
</code></pre>
<p>默认参数：</p>
<pre><code class="language-c++">double f (double a, double b = 1.5) {
    return (a * b);
}
</code></pre>
<p>函数声明（declaration）：</p>
<ul>
<li>告知编译器一个函数存在于某个源文件中。函数声明通常放置在头文件中，便于导入。</li>
<li>作为函数参数，接受声明类型的函数对象<code>int cmp(int &amp;, int &amp;)</code>；</li>
</ul>
<h3 id="参数传递-2"><a class="header" href="#参数传递-2">参数传递</a></h3>
<h4 id="传入参数"><a class="header" href="#传入参数">传入参数</a></h4>
<img src="CC++/Modern C++.assets/pass_parameters_args.png" alt="pass parameters" style="zoom: 45%;" />
<blockquote>
<p>Read from cheaply copyable object (all fundamental types) ⇒ <strong>pass by value</strong>;</p>
<p>Read from object with larger (&gt; 64bit) memory footprint ⇒ pass by <code>type const &amp;</code>;</p>
<p>Write to function-external object ⇒ pass by <code>type &amp;</code>.</p>
</blockquote>
<h5 id="可变参数列表"><a class="header" href="#可变参数列表">可变参数列表</a></h5>
<p>可变参数函数（如<code>printf</code>）的最后一个参数以“<code>...</code>”代替。</p>
<pre><code class="language-c++">return_type func_name (param,...){...} 
</code></pre>
<p>使用在“<code>stdarg.h</code>”中定义的类型（<code>va_list</code>指针类型）和宏（<code>va_start</code>、<code>va_arg</code>、<code>va_end</code>和<code>va_copy</code>）访问参数列表。</p>
<ul>
<li>
<p><em><code>va_start</code>：返回参数列表存储区的指针。使用可变参数列表必须至少提供一个占位的固定参数，这个参数可以不被函数使用。这样<code>va_start</code>才可以定位到参数列表的首地址。</em></p>
<pre><code class="language-c++">va_list ptr_args = va_start(param, param1);
for(;ptr_args!=nullptr; ++ptr_args){
   var_name = va_arg(ptr_args, type);
}
</code></pre>
</li>
<li>
<p><em><code>va_arg</code>：返回一个参数。</em></p>
</li>
<li>
<p><em><code>va_end</code>：将参数列表指针设为<code>nullptr</code>，等效标记为end。</em></p>
</li>
<li>
<p><em><code>va_copy</code>： 将参数列表指针，赋值给另一个指针。</em></p>
</li>
</ul>
<p>参数列表并没有显式的结束标识，因此在传递参数时，需要使用固定参数指定可变参数个数，或者使用特殊参数值标识参数列表结束。</p>
<h5 id="传递数组作为参数"><a class="header" href="#传递数组作为参数">传递数组作为参数</a></h5>
<p>通过以上两种指针的定义及赋值，可以得知数组指针是有类型的，即数组指针的类型为：指明数组低维度长度的指针型变量，表示为：</p>
<pre><code class="language-c++">type (*ptr_name)[N]...;
</code></pre>
<p>数组指针类型用于定义数组对象或==传递数组参数==。</p>
<p>数组也可通过引用类型传递，但必须显式指定数组长度，传递的参数必须与声明长度相同（否则产生编译错误）。</p>
<pre><code class="language-c++">void print_array_ref(int (&amp;array)[5]);
</code></pre>
<p>由于长度固定，难以通用。因此<a href="CC++/Modern%20C++.html#%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92">传递数组参数</a>通常还是通过指针或容器对象（如<code>std::vector</code>和<code>std::array</code>）。</p>
<h5 id="传递函数作为参数"><a class="header" href="#传递函数作为参数">传递函数作为参数</a></h5>
<p><strong>函数指针</strong>：函数是特殊类型的对象，<strong>函数名是该对象的地址</strong>。可定义该函数类型的指针以引用该函数，并作为参数传递：</p>
<pre><code class="language-c++">return_type (*ptr_func)(arg_types,...);  // 定义函数类型时不需要形参名
ptr_func(arg_list);  // =&gt; (*ptr_func)(arg_list);
</code></pre>
<blockquote>
<p>函数指针<a href="https://www.cprogramming.com/tutorial/function-pointers.html">可自动解引用</a>，因此可以不添加<code>*</code>运算符。</p>
</blockquote>
<p>为了在定义函数参数时简化语法，可以预先定义函数类型：</p>
<pre><code class="language-c++">typedef return_type (* FunctionType)(arg_types);
using FunctionType = return_type (*)(arg_types); // [c++11]
call_func(FunctionType call_func);               // 传递函数参数
</code></pre>
<p><strong>函数对象</strong>：</p>
<pre><code class="language-c++">std::function&lt;return_type (arg_types)&gt; func_obj; // [c++11]
using func_type = std::function&lt;return_type (arg_types)&gt;;
</code></pre>
<h4 id="返回值-2"><a class="header" href="#返回值-2">返回值</a></h4>
<img src="CC++/Modern C++.assets/pass_parameters_return.png" alt="pass parameters" style="zoom: 40%;" />
<blockquote>
<p>返回多值：</p>
<ul>
<li>
<p>==使用结构体来构造多返回值结构==。</p>
</li>
<li>
<p>使用<code>tuple</code>和自动展开；</p>
<pre><code class="language-c++">std::make_pair(); // return tuple
</code></pre>
</li>
<li>
<p>使用数组<code>std::array</code>或向量<code>std::vector</code>（类型相同）；</p>
</li>
<li>
<p>==使用引用或指针类型输入参数作为输出参数==（可能产生歧义）。</p>
</li>
</ul>
</blockquote>
<h4 id="可选参数"><a class="header" href="#可选参数">可选参数</a></h4>
<pre><code class="language-c++">optional&lt;int&gt; x;
if (x) {}  // x若未经初始化，则判断条件为false；代替传统使用空指针判断值是否可用。
</code></pre>
<h3 id="函数重载"><a class="header" href="#函数重载">函数重载</a></h3>
<blockquote>
<p>functions with the same name but different <strong>parameter lists</strong>.</p>
</blockquote>
<p>如果一组函数具有相同的名称，但具有不同的输入参数模式（参数类型，参数个数，参数顺序），则这些参数可以同时存在于同一命名空间。重载（overload）就是在编译时通过传入参数的类型，来选择相应的函数。</p>
<p>不能通过访问权限、返回类型、抛出的异常进行重载。</p>
<blockquote>
<p>对于继承来说，如果某一方法在父类中是访问权限是<code>private</code>，那么就不能在子类对其进行重载，如果定义的话，也只是定义了一个新方法，而不会达到重载的效果。</p>
</blockquote>
<h4 id="运算符重载-2"><a class="header" href="#运算符重载-2">运算符重载</a></h4>
<p>运算符重载是对已有运算符赋予多重含义，使同一个运算符作用于不同类型的数据时导致不同的行为。<strong>运算符重载的实质是函数重载。</strong></p>
<p>运算符可重载为独立函数或类的<a href="CC++/Modern%20C++.html#%E6%88%90%E5%91%98%E8%BF%90%E7%AE%97%E7%AC%A6">成员函数</a>。运算符声明可能需要在相应操作数类定义中<a href="CC++/Modern%20C++.html#Friends">使用<code>friend</code>声明</a>以访问操作数的非公开成员。</p>
<pre><code class="language-c++">[friend] type operator op (params) { /*statements*/ } 
</code></pre>
<blockquote>
<p><code>op =&gt; +,-,*,/,[],++,--,... </code></p>
</blockquote>
<p>重载为成员函数时：</p>
<ul>
<li>对于单目运算符，则不需要参数；对于“++”和“--”，为了区分前置运算符和后置运算符，当重载为后置运算符是，增加一个整形参数，但该参数只用于区分，没有其它用途。</li>
<li>对于双目运算符，还需要将另一个操作数作为参数传入函数；</li>
</ul>
<h5 id="输出运算符"><a class="header" href="#输出运算符">输出运算符</a></h5>
<pre><code class="language-c++">ostream&amp; operator &lt;&lt; (ostream&amp; os, type T) 
{ os &lt;&lt; T.x &lt;&lt; T.y; return os; }
</code></pre>
<h5 id="比较运算符-2"><a class="header" href="#比较运算符-2">比较运算符</a></h5>
<p>C++使用值语义，因此比较运算符<code>==,!=</code>是比较对象的值。编译器不会自动为自定义类型生成比较运算符，需要自定义。</p>
<pre><code class="language-c++">bool operator==(T1 const&amp;, T2 const&amp;)const=default; // c++20
</code></pre>
<blockquote>
<p><code>=default</code>：自动生成默认比较运算符（递归比较所有成员变量），无需给出函数原型；</p>
<p>不用重载<code>!=</code>运算符，编译器会自动根据<code>==</code>的定义生成<code>!=</code>运算符的定义。</p>
<p><code>c++20</code>：compiler rewrites a call <code>a == b</code> as <code>b == a</code> if necessary。</p>
</blockquote>
<p><strong>双目运算符的交换问题</strong>：双目运算符的运算数类型如果不同，需要声明不同的操作符重载，以满足定义的交换律。</p>
<h3 id="优化"><a class="header" href="#优化">优化</a></h3>
<p><strong>Return Value Optimization (RVO)</strong>：在返回语句中构造对象时，将不会为返回值创建临时对象。</p>
<pre><code class="language-c++">Type create_object(){
  // ...
  return Type(...)  // Performing RVO
}
Type a = create_object();  
</code></pre>
<blockquote>
<p>由于类型在Stack上占用的空间在编译期间是确定的，因此编译器预先为返回值<code>a</code>在Stack上分配空间（==相当于调用一个空的默认构造函数==）。通过修改函数原型以及函数行为，将该空间地址通过指针传递给调用函数，在返回语句构造对象时使用传入地址指定的空间，而非重新在Stack上分配一段内存空间。当函数执行完成时，将上述预分配空间的地址绑定到返回值。整个过程仅执行一次对象构造，而为执行优化时，将执行一次构造函数和两次复制构造函数（从局部对象到临时对象，从临时对象到返回值，临时对象实际也是在调用对象前通过指针传入函数）。</p>
<p><a href="https://en.wikipedia.org/wiki/Copy_elision#Return_value_optimization">Copy elision - Wikipedia</a>。</p>
</blockquote>
<p><strong>Named Return Value Optimization (NRVO)</strong>：在返回语句中返回局部对象，将不会为返回值创建临时对象。</p>
<blockquote>
<p>类似地，NRVO则是在要返回的局部变量在构造时，使用上层传入的Stack空间。</p>
</blockquote>
<p><strong>内联（inlining）</strong>：Calls to small/short functions are replaced with the code of the function.</p>
<blockquote>
<p><em>Inlining is a lot harder or sometimes impossible in many other languages like Java, C#, etc. with <strong>always-on polymorphism</strong> which means that all/most function/method calls can only be resolved at runtime.</em></p>
</blockquote>
<h3 id="主函数"><a class="header" href="#主函数">主函数</a></h3>
<pre><code class="language-c++">#include &lt;iostream&gt;
int main (int argc, char* argv[]) {
  for(int i = 0; i &lt; argc; ++i) {
    std::cout &lt;&lt; argv[i] &lt;&lt; '\n';
  }
} // return 0 by default only for main function
</code></pre>
<blockquote>
<ul>
<li>names <code>argc</code> and <code>argv</code> are only a convention</li>
<li><code>argv[0]</code> contains the program call</li>
</ul>
</blockquote>
<h3 id="匿名函数"><a class="header" href="#匿名函数">匿名函数</a></h3>
<h4 id="lambda-class"><a class="header" href="#lambda-class">lambda class</a></h4>
<p>编译器自动生成的<a href="CC++/Modern%20C++.html#%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1">函数对象</a>，用于需要提供函数作为参数的位置。</p>
<pre><code class="language-c++">[](P const&amp; x, P const&amp; y){ return x.c &lt; y.c; }
[](auto x){ ... }         // c++14
[](auto const &amp; x){ ... }
[](auto &amp;x){ ... }
</code></pre>
<blockquote>
<p>输入参数为空则可以省略<code>()</code>。</p>
</blockquote>
<h5 id="closure"><a class="header" href="#closure">closure</a></h5>
<p>instance of lambda class。</p>
<p>保存外部作用域的变量：</p>
<pre><code class="language-c++">[=](...){...}     // captures all by value
[&amp;](...){...}     // captures all by reference
[=x,&amp;y](...){...} // captures x by value and y by reference
[= ,&amp;y](...){...} // captures all by value except y by reference
</code></pre>
<p>保存闭包：闭包类型由编译器确定，因此使用<code>auto</code>表示结果。</p>
<pre><code class="language-c++">auto f = [...](...){...}
</code></pre>
<h2 id="聚合类型"><a class="header" href="#聚合类型">聚合类型</a></h2>
<p>将多个基本类型变量组合成一个聚合类型，相当于一个简单类型，成员变量根据声明顺序在内存中连续存储。</p>
<p>聚合类型是对逻辑上相关的函数和数据的封装，是对问题的抽象描述。提供成员访问限制，自定义初始化、解构、复制和赋值，成员函数；<a href="https://hackingcpp.com/cpp/lang/custom_type_basics.html">保证类行为的不变性、清晰性和正确性</a>。</p>
<h5 id="结构体-2"><a class="header" href="#结构体-2">结构体</a></h5>
<pre><code class="language-c++">struct point {
  int x;  // ← &quot;member variable&quot;
  int y; 
};
point p1 = {10, 5};
point p2 {5, 10};    // c++11
</code></pre>
<blockquote>
<ul>
<li>semantic data grouping: <code>point</code>, <code>date</code>, …</li>
<li>avoids many function parameters and thus, confusion</li>
<li>can return multiple values from function with one dedicated type instead of multiple non-const reference output parameters</li>
</ul>
</blockquote>
<h5 id="类-5"><a class="header" href="#类-5">类</a></h5>
<pre><code class="language-c++">class ClassName: public classA,…, protected classB,…, private classC,… 
{
    public：				//外部接口
    	//构造函数
        ClassName()=default;
        [explicit]ClassName(args1, arg2,...){ /*initialization;*/}
        virtual ~ClassName()；//(虚)析构函数	
        //数据成员；
        using value_type = std::uint64_t;  //类型接口
        //函数成员；
        type func_name(params){}
    private：
    protected：//保护成员
};
</code></pre>
<blockquote>
<p>在C++中，<code>class</code>和<code>struct</code>关键字都可用于定义类，不同之处在于两者的默认访问权限不同（<code>class</code>是<code>private</code>，<code>struct</code>是<code>public</code>）。</p>
<p><em>Do not use leading underscores or double underscores in names of types, variables, functions, private data members</em>.</p>
</blockquote>
<p><strong>继承语法</strong>：访问修饰符指明基类成员的访问方式，如果不显式给出，则默认为私有继承。</p>
<p><strong>组合类</strong>：一个类的成员不仅包含基本数据类型，还包含其它<strong>类的对象</strong>。</p>
<h3 id="成员变量"><a class="header" href="#成员变量">成员变量</a></h3>
<h5 id="常量成员变量"><a class="header" href="#常量成员变量">常量成员变量</a></h5>
<p>==如果对象被声明成常量，那么限定只能调用对象的常成员函数以防止对象被修改。==</p>
<p>一般常量必须在声明时进行初始化，在C++的类中，常数据成员的初始化，在构造函数的初始化列表中完成，<em>而不能在声明时初始化</em>（C++11支持<a href="CC++/Modern%20C++.html#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%99%A8">声明时初始化</a>），或在构造函数的函数体中进行初始化。</p>
<h5 id="静态成员变量"><a class="header" href="#静态成员变量">静态成员变量</a></h5>
<p>如果某个属性为整个类所共有，不属于任何一个具体对象，则采用<code>static</code>关键字声明为静态成员变量。静态成员在每个类中只有一个实例，实现同一类的不同对象之间的数据共享。</p>
<p>类内部只是静态成员的声明，静态成员（包括常量）需要在程序的全局作用域的某个位置对其进行定义和初始化。</p>
<blockquote>
<p>由于类的静态成员变量在头文件中声明，其作用域为全局作用域而非文件作用域。因此需要将初始化放在某个源文件中，而不能放在头文件中；否则当头文件被多个源文件引用时，会分别执行多次定义产生符号冲突。</p>
</blockquote>
<pre><code class="language-c++">type class_name::static_var = value;
</code></pre>
<p><em>整数静态常量比较特别，可以在声明时进行初始化。</em></p>
<h3 id="资源管理"><a class="header" href="#资源管理">资源管理</a></h3>
<h4 id="构造函数-1"><a class="header" href="#构造函数-1">构造函数</a></h4>
<p>构造函数的函数名与类名相同，且没有返回值，被声明为公有函数。如果类中没有声明构造函数，或给出了无参构造函数的声明但没有给出实现，则编译器会自动生成一个默认的构造函数，不做任何事情；如果用户自定义了构造函数，则不会再自动生成默认构造函数，如果没有另外声明无参构造函数，则必须在声明对象时，提供必要的参数完成初始化。</p>
<blockquote>
<p>尽可能避免书写特殊成员函数，除非需要资源分配。使用<a href="CC++/Modern%20C++.html#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%99%A8">成员初始化器</a>可以执行默认初始化，使用智能指针、容器等可以尽量减少人工管理内存分配，从而避免自定义析构函数。</p>
</blockquote>
<h5 id="初始化列表构造函数"><a class="header" href="#初始化列表构造函数">初始化列表构造函数</a></h5>
<p>初始化列表<code>initializer_list</code>是一种特殊可迭代容器，用于序列类型的初始化。</p>
<pre><code class="language-c++">#include &lt;initializer_list&gt; // c++11
ClassA{ ClassA(std::initializer_list&lt;int&gt; li){...} }
ClassA a {1,3,4,5};   // {}调用初始化列表构造函数，而()调用其他构造函数
</code></pre>
<h5 id="复制构造函数"><a class="header" href="#复制构造函数">复制构造函数</a></h5>
<p><strong>复制构造函数</strong>是一种特殊的构造函数，具有一般构造函数的所有特性，其<strong>形参是本类对象的引用</strong>，其作用是使用一个已经存在的对象，去初始化一个同类型的新对象。如果没有在类中定义复制构造函数，则编译器会生成<strong>默认的复制构造函数</strong>，其功能是：<strong>把参数对象的每个数据成员的复制到新建立的对象中</strong>（如果声明了复制构造函数，则复制功能由复制构造函数完成，类将不会自动复制相应的变量）。</p>
<pre><code class="language-c++">ClassName(const ClassName &amp; obj);        //复制构造函数
ClassName(const ClassName &amp; obj)=delete; //禁用复制构造函数
</code></pre>
<p><strong>浅拷贝</strong>：C++默认是<a href="CC++/Modern%20C++.html#%E5%BC%95%E7%94%A8%E8%AF%AD%E4%B9%89">值语义</a>，因此进行赋值运算时，会复制类的所有成员，但使用原始指针引用的对象不会被复制（弱引用关系，不属于该类的成员）。==自定义复制构造函数和赋值运算符可以定义是否为指针引用的对象创建副本==。</p>
<pre><code class="language-c++">Object(const Object&amp; other){ // 默认复制类的成员
	memcpy(this, &amp;other,  sizeof(Object))   
}
</code></pre>
<p>复制构造函数的调用情况：</p>
<ol>
<li>
<p>当用类的一个对象去初始化该类的另一个对象。</p>
</li>
<li>
<p>如果函数的形参是类的对象，调用函数时，用实参初始化形参。</p>
</li>
<li>
<p>如果函数的返回值是类的对象，函数执行完返回时，为了完成从子函数到主函数的值传递，创建一个临时对象，初始化该对象。</p>
</li>
</ol>
<p><strong>如果类不包含动态分配的资源，则一般使用默认的构造函数就足够了</strong>。
一般情况，每个对象所拥有的资源应该是相互独立的，这样一个对象的操作才不会影响到另一个对象。
但是使用默认复制构造函数，只能完成成员变量即相关资源的标识符的复制，而不能自动完成动态资源的分配。
这时候就需要程序定义复制构造函数，来完成动态分配资源的分配和值的复制。</p>
<p>“<code>=</code>”操作符的意义在于使用一个对象向另一个同类型对象赋值，这和初始化时使用一个对象对同类型对象进行初始化的原理基本相同。
“<code>=</code>”操作符的处理==可能还需要先释放对象已分配的资源==，再申请新的资源。
如果没有定义“<code>=</code>”操作符，则会自动生成一个与默认复制构造函数具有相同功能的操作符定义，因此，默认的“<code>=</code>”操作符并不能完成具有动态资源的对象的复制。
<strong>通常，定义了复制构造函数也就意味着需要定义“<code>=</code>”操作符</strong>。</p>
<pre><code class="language-c++">ClassName&amp; ClassName::operator = (ClassName const&amp;);
</code></pre>
<p>https://en.cppreference.com/w/cpp/language/copy_constructor</p>
<h5 id="移动语义"><a class="header" href="#移动语义">移动语义</a></h5>
<p>将对象在堆上的空间与新对象进行交换（新对象可能并未分配堆空间）。</p>
<pre><code class="language-c++">std::swap(a,b);
</code></pre>
<h6 id="移动构造函数和移动赋值函数"><a class="header" href="#移动构造函数和移动赋值函数">移动构造函数和移动赋值函数</a></h6>
<pre><code class="language-c++">ClassName(const ClassName &amp;&amp; obj); //移动构造函数
ClassName&amp; ClassName::operator = (ClassName const&amp;&amp;); //移动赋值运算符
</code></pre>
<p>https://hackingcpp.com/cpp/lang/move_semantics.html</p>
<h4 id="初始化-1"><a class="header" href="#初始化-1">初始化</a></h4>
<blockquote>
<p><u>R</u>esource <u>A</u>cquisition <u>I</u>s <u>I</u>nitialization (RAII)</p>
<ul>
<li>acquire some resource (memory, file handle, connection, …) when object is constructed</li>
<li>release/clean up resource when object is destroyed (de-allocate memory, close connection, …)</li>
</ul>
</blockquote>
<p>对象所占据的内存空间只是用于存放数据成员，函数成员不在每个对象中存储副本。但是如果该类包含<a href="CC++/Modern%20C++.html#%E8%99%9A%E5%87%BD%E6%95%B0">虚函数</a>，则虚函数地址存放在虚函数表中，将占用内存空间。</p>
<h5 id="成员初始化列表"><a class="header" href="#成员初始化列表">成员初始化列表</a></h5>
<p>通过构造函数的初始化列表对成员变量进行初始化（构造）。==初始值可以来自构造函数的参数。====初始化列表也可以调用本类的其他构造函数代替单独变量初始化。==</p>
<pre><code class="language-c++">class Foo {
   int i_;     // 1st
   double x_;  // 2nd
public:    
   Foo(): i_{10}, x_{3.14} { }  // same order: i_ , x_
   Foo(int i, double x): i_(i), x_(x) {}
};
</code></pre>
<blockquote>
<p>成员初始化列表：使用<code>()</code>或<code>{}</code>（C++11: narrowing conversion）传递参数。</p>
</blockquote>
<p>初始化列表应首先给出父类的初始化声明，再给出当前类中成员变量的初始值（初始化顺序与成员的声明顺序保持一致）。构造函数执行的次序：</p>
<ol>
<li>
<p>调用父类的构造函数初始化父类成员，顺序与继承声明一致（从左到右）；</p>
</li>
<li>
<p>初始化基本类型或调用成员的构造函数，调用顺序与内嵌对象在类中声明的次序一致；</p>
<blockquote>
<p>当未在初始化列表给出成员的初始化声明，则会调用该类型的默认构造函数（此时该类型需要具有默认构造函数）。而如果在构造函数体内对该成员通过赋值进行初始化，则会重复执行构造，造成性能开销。==因此应该优先使用成员初始化列表。==</p>
</blockquote>
</li>
<li>
<p>执行构造函数体的内容。</p>
</li>
</ol>
<h5 id="隐式类型转换"><a class="header" href="#隐式类型转换">隐式类型转换</a></h5>
<p>只有一个参数的构造函数，其调用形式与强制类型转换的语法相同，因此，等效于同时重载了由指定类型到当前类型的<a href="CC++/Modern%20C++.html#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E8%BF%90%E7%AE%97%E7%AC%A6">（隐式）类型转换运算符</a>。</p>
<pre><code class="language-c++">type y;
ClassName x = y; // =&gt; 隐式转换：className x = ClassName(y);
</code></pre>
<blockquote>
<p>当构造函数被<code>explicit</code>关键字修饰时，则不会同时重载该运算符，因此上述代码不会进行隐式转换，从而赋值语句类型不兼容。</p>
</blockquote>
<h5 id="初始化器"><a class="header" href="#初始化器">初始化器</a></h5>
<p>C++11支持在声明成员变量时给出默认初始值。</p>
<pre><code class="language-c++">class Foo {
  int i_ = 10;
  double x_ = 3.14;
};
</code></pre>
<h4 id="析构函数"><a class="header" href="#析构函数">析构函数</a></h4>
<p><strong>析构函数</strong>与构造函数的作用基本相反，用来完成对象被删除前的一些清理工作，在对象的生命期即将结束时被自动调用。和构造函数不同的是，析构函数不接受任何参数，但可以是<strong>虚函数</strong>。声明虚析构函数必须给出实现（参考虚函数）。</p>
<p>析构函数调用顺序由类的继承关系决定，与构造函数的调用顺序相反：即类本身的析构函数，类成员对象的析构函数，基类的析构函数。由于析构函数是自动调用的，因此无需显示调用父类析构函数。</p>
<h3 id="成员函数"><a class="header" href="#成员函数">成员函数</a></h3>
<p>成员函数可以在类的声明之外单独定义（使用作用域限定符），在类声明中仅给出声明。</p>
<pre><code class="language-c++">type ClassName::func_name(params){}
</code></pre>
<blockquote>
<p>代码量较小的函数应该尽量放置于类定义中，以方便“内联”优化。</p>
</blockquote>
<blockquote>
<p><a href="https://hackingcpp.com/cpp/lang/custom_type_basics.html">How to</a> implement a feature / add new functionality?</p>
<ul>
<li>only need to access public data (e.g. via member functions) ⇒ implement as free standing function</li>
<li>need to access private data ⇒ implement as member function</li>
</ul>
<p>==use &quot;action&quot; functions instead of just &quot;setters&quot;==：usually models problems better; more fine-grained control; better code readability / expression of intent</p>
</blockquote>
<p>在成员函数中访问成员变量/函数：</p>
<h5 id="this指针"><a class="header" href="#this指针"><code>this</code>指针</a></h5>
<p>非静态成员函数的参数隐含了当前实例的指针<code>this</code>。</p>
<p>如果在<code>Class</code>的成员函数中没有可见的同名局部作用域标识符，那么在该函数内可以直接访问成员<code>Member</code>。反之，非静态成员需要通过<code>this</code>指针进行访问<code>this-&gt;Member</code>。</p>
<blockquote>
<p>也可以使用作用域限定符<code>::</code>访问类成员，通常作用域限定符用于<a href="CC++/Modern%20C++.html#%E8%AE%BF%E9%97%AE%E9%9D%99%E6%80%81%E6%88%90%E5%91%98">访问静态成员</a>，而实例成员通过<code>this</code>指针访问。</p>
</blockquote>
<p>此外，<code>this</code>指针还可以用于在类内部调用需要该类指针的函数。</p>
<h4 id="成员运算符-2"><a class="header" href="#成员运算符-2">成员运算符</a></h4>
<p>当运算符的第一个参数是自定义类型，可将该运算符定义/重载为自定义类的成员。</p>
<blockquote>
<p>当第一个参数不是自定义类类型，则<a href="CC++/Modern%20C++.html#%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD">重载为独立运算符</a>。也可将独立运算符在类内部以<code>friends</code>修饰以确保其能访问类的内部数据。</p>
</blockquote>
<h5 id="类型转换运算符"><a class="header" href="#类型转换运算符">类型转换运算符</a></h5>
<p>类型转换函数用于自动==将类对象转换成其他兼容类型的对象==，从而实现类似基本数据类型隐式转换的功能。类型转换函数通过重载“<code>(...)</code>”操作符实现：</p>
<pre><code class="language-c++">public operator type();   // 定义方法将当前类型转换为type
</code></pre>
<p>该函数原型比较特别，没有返回值，也不需要提供参数。但是函数结束前必须返回<code>type</code>类型的值。</p>
<blockquote>
<p><em>指针转换运算符是为了方便对自定义模板类的指针进行强制类型转换而重载的，因为系统不能直接把自定义类的指针强制转换成基本类型的指针。指针转换运算符的重载函数比较特殊，它没有返回值（连void也没有）。</em></p>
</blockquote>
<h5 id="函数对象-1"><a class="header" href="#函数对象-1">函数对象</a></h5>
<p>重载<code>()</code>运算符的类。 ==函数对象可以通过私有变量保存内部状态==。</p>
<pre><code class="language-c++">public type operator (args); // 注意函数原型与类型转换运算符的区别
obj(args);                   // 调用()重载的函数。
</code></pre>
<h5 id="成员引用运算符"><a class="header" href="#成员引用运算符">成员引用运算符*</a></h5>
<p>当一个类封装另一个类对象或指针时（例如智能指针），如果要透明访问被封装类的成员，可以重载<code>-&gt;</code>运算符（普通版本以及常量版本）：</p>
<pre><code class="language-c++">InternalObject* operator-&gt;(){ return prt_obj;}
ExternalObject* m = new ExternalObject();
m-&gt;some_interal_member;
</code></pre>
<h5 id="和运算符"><a class="header" href="#和运算符">“<code>=</code>”和“<code>[]</code>”运算符</a></h5>
<p>这两种运算符的适用场合，有可能作为表达式的左值出现，如</p>
<pre><code class="language-c++">A[5]=2;
(a=b)++;  
</code></pre>
<p>作为左值的量都必须是变量，否则无法进行赋值或自加等操作，这就要求在重载“<code>=</code>”和“<code>[]</code>”运算符时返回变量；由于<strong>函数的返回值是一个右值</strong>（<a href="CC++/Modern%20C++.html#Rvalues-and-Lvalues">临时变量</a>），所以不满足要求。</p>
<p>所以<strong>在重载这两个操作符时，返回值应该是引用类型</strong>。当然，<strong>由于局部变量在函数结束时就消失了，所以不能返回局部变量的引用，否则对引用的操作将出现错误。</strong></p>
<p>“<code>=</code>”返回左操组数（上面例子中a）的引用；</p>
<p>“<code>[]</code>”返回左操作数（上面例子的A）的索引对应项的引用。只能重载一维数组下标操作符（如何重载多维下标http://blog.sina.com.cn/s/blog_66ec4d660100mxq5.html）。</p>
<h4 id="静态成员函数"><a class="header" href="#静态成员函数">静态成员函数</a></h4>
<pre><code class="language-c++">static type static_function_declare();
class_name::static_function();   // 调用静态成员函数
</code></pre>
<p>静态成员函数只能访问类的静态成员函数/变量。</p>
<h4 id="常量成员函数"><a class="header" href="#常量成员函数">常量成员函数</a></h4>
<pre><code class="language-c++">type member_function_declare() const;
</code></pre>
<blockquote>
<p><code>const</code>可以用于修饰函数的返回值，表示对函数的返回值不可以做修改。</p>
</blockquote>
<p>使用<code>const</code>关键字修饰成员函数，意味着成员函数具有“只读”属性，而不能修改对象（<strong>实例成员变量</strong>）或者调用任何非常成员函数。</p>
<blockquote>
<p>使用<code>mutable</code>修饰的成员是例外，可以被<code>const</code>方法修改。</p>
</blockquote>
<p><code>const</code>可以用于成员函数的重载（在声明和定义处都需要使用<code>const</code>修饰），当对象被声明成常量时，则该实例只能访问使用<code>const</code>成员函数，因为只有这样才能保证类的成员变量不会被修改。</p>
<blockquote>
<p>对于一般对象，则常函数成员和非常函数成员都可以被调用。</p>
<p>当对象是变量时，优先调用同名非常成员函数（当没有声明非常成员函数时，调用同名常成员函数）。</p>
</blockquote>
<p><code>const</code>-qualify all non-modifying member functions。</p>
<h5 id="访问静态成员"><a class="header" href="#访问静态成员">访问静态成员</a></h5>
<p>静态成员不与类的实例绑定，需要通过作用域限定符和类名进行访问。</p>
<pre><code class="language-c++">ClassName::StaticMember;
ClassName::StaticMemberFunction(args);
</code></pre>
<h3 id="访问限制"><a class="header" href="#访问限制">访问限制</a></h3>
<p>在类内部，所有的数据成员的为其成员函数所共享；通过静态数据成员，实现同一类的不同对象之间的数据共享。</p>
<p><strong>访问关系是针对于类而言的，并不是针对类的实例</strong>。即对象的成员函数可以访问同一类型对象的所有成员变量。</p>
<blockquote>
<p>访问控制的主要作用是限定代码的组织方式，对程序运行没有影响；实际上可以通过操纵指针绕过访问控制限制。</p>
</blockquote>
<img src="CC++/Modern C++.assets/access_control.png" style="zoom: 67%;" />
<h4 id="friends"><a class="header" href="#friends">Friends</a></h4>
<pre><code class="language-c++">class A{…… friend class B; …… }  // friend class
class A{…… type function(args); …… } // friend function
</code></pre>
<p><strong>友元函数</strong>是在类中用关键字<code>friend</code>修饰的非成员函数，可以是普通函数也可以是其他类的成员函数，虽然它不是本类的成员函数，但是可以访问本类的私有和保护成员。</p>
<p>**友元关系是不能传递的：**A是B的友元，B是C的友元，如果没有声明，A和C是没有友元关系的；</p>
<p>**友元关系是单向的：**A是B的友元，如果没有声明，则B不是A的友元；</p>
<p>**友元关系是不被继承的：**如果A是B的友元，但A的派生类，如果没有声明，则不是B的友元。</p>
<h3 id="自定义类型"><a class="header" href="#自定义类型">自定义类型</a></h3>
<p>https://hackingcpp.com/cpp/design/arithmetic_types.html</p>
<p>https://hackingcpp.com/cpp/design/node_based_data_structures.html</p>
<h2 id="程序结构-4"><a class="header" href="#程序结构-4">程序结构</a></h2>
<h3 id="命名空间-2"><a class="header" href="#命名空间-2">命名空间</a></h3>
<p><a href="https://en.cppreference.com/w/cpp/language/namespace">Namespaces - cppreference.com</a></p>
<ul>
<li>避免命名冲突；</li>
<li>将内容分为不同的部分。</li>
</ul>
<blockquote>
<p>命名空间仅用于防止命名冲突，不具有访问控制作用（访问控制修饰符修饰命名空间无效）。</p>
</blockquote>
<h5 id="定义"><a class="header" href="#定义">定义</a></h5>
<pre><code class="language-c++">namespace my{
    class vector {...};
    namespace time{...}
}
</code></pre>
<p>一个文件中可以定义多个命名空间；同时，一个命名空间也可以出现在多个文件中。</p>
<p>命名空间可嵌套定义。</p>
<h5 id="引入命名空间"><a class="header" href="#引入命名空间">引入命名空间</a></h5>
<pre><code class="language-c++">my::vector v1;
using my::vector;  // 单独引入命名空间中的定义
vector v2;
using my;   // 引入命名空间中的所有定义
namespace mt = my::time;  // 定义命名空间别名简化书写
</code></pre>
<blockquote>
<p>避免在头文件中引入命名空间：引入命名空间会导入其中所有的声明到头文件中。该头文件再被其他文件引用时，可能造成命名冲突。</p>
</blockquote>
<h3 id="标识符作用域"><a class="header" href="#标识符作用域">标识符作用域</a></h3>
<ol>
<li>
<p>局部作用域：在代码块中声明的标识符，其作用域从声明处开始，一直到块结束的大括号为止。**具有局部作用域的变量也称为局部变量。**函数体、控制语句块，空语句块等都是局部作用域。</p>
</li>
<li>
<p>类作用域：类<code>Class</code>的成员<code>Member</code>具有类作用域，其范围为类的定义。</p>
</li>
<li>
<p>文件作用域：<strong>具有文件作用域的标识符其作用域开始于声明点，结束于文件尾。具有文件作用域的变量也称为全局变量。</strong></p>
<p>命名空间将文件作用域进行了逻辑划分；</p>
</li>
</ol>
<h4 id="可见性-2"><a class="header" href="#可见性-2">可见性</a></h4>
<p>程序运行到某一点在，能够引用到的标识符就是该处可见的标识符。作用域可见性的规则：</p>
<ol>
<li>标识符声明在前，引用在后；</li>
<li>在同一作用域中不能定义同名标识符；</li>
<li>在没有互相包含关系的不同作用域中定义的同名标识符，互不影响；</li>
<li>如果在两个或多个具有包含关系的作用域中声明了同名标识符，则外层标识符在内层不可见。</li>
</ol>
<h4 id="作用域限定符"><a class="header" href="#作用域限定符">作用域限定符</a></h4>
<p>用于在默认规则不可见的位置访问某些标识符。</p>
<ul>
<li>访问命名空间中的成员（例如<code>std::cout</code>）；</li>
<li>在类定义外部，定义函原型和初始化静态变量；</li>
<li>访问静态成员；</li>
<li>在类内部，识别多继承的同名成员；</li>
</ul>
<p><em>对于静态成员</em>，则通过作用域分辨符<code>::</code>进行访问：<code>ClassName::M</code>。</p>
<p><em>多继承的父类成员可见性</em>。</p>
<h4 id="前向声明"><a class="header" href="#前向声明">前向声明</a></h4>
<p>​    两个类不能相互引用作为其定义的一部分，因为这样无法确定任何一个类的类型。但是两个类可以相互引用其指针作为定义的一部分。</p>
<p>​    如果出现以上相互引用的情况下，一般地，应该互相包含其头文件，但这样又会造成头文件内容无法确定。为了解决这一问题，C++引入了前向声明，即==在定义类之前对类名进行声明==，则无需包含该类定义所在的头文件，即可定义该类的指针。</p>
<pre><code class="language-c++">class c_a;
class c_b{
	c_a *p_a;
}
</code></pre>
<h2 id="多态-2"><a class="header" href="#多态-2">多态</a></h2>
<h3 id="继承-2"><a class="header" href="#继承-2">继承</a></h3>
<p><strong>类的继承，是新类从已有类那里得到已有的特性。同时，从已有类产生新类的过程就是派生</strong>。由原有类产生新类时，新类便包含了原有类的特性，同时也可以加入自己所有的新特性。</p>
<p>从对象的数据存储来看，组合类和派生的作用一样：如果把派生类的父类的实例都添加到一个新类的定义中，则派生类的这个新类有相同的数据成员，只是组织形式不同。但是组合类只能利用现有类提供的功能并在新类中定义新功能，而派生类在此基础上可以提供多态行为，即子类可以通过虚函数覆盖父类的同名函数。反之，如果不需要更改父类行为，使用组合类更简洁。</p>
<h4 id="构造析构函数"><a class="header" href="#构造析构函数">构造/析构函数</a></h4>
<p>根据构造函数调用规则，应该在子类的初始化列表中调用父类构造函数。</p>
<h4 id="虚继承"><a class="header" href="#虚继承">虚继承</a></h4>
<h3 id="成员函数重载"><a class="header" href="#成员函数重载">成员函数重载</a></h3>
<p>运算符重载</p>
<h3 id="覆盖"><a class="header" href="#覆盖">覆盖</a></h3>
<p>具有相同函数原型（即相同的函数名与输入参数列表）的函数不满足重载的条件，不能存在于同一命名空间。但具有相同原型的函数可存在于父类（接口）与子类（实现）中。子类（实现）提供的具有相同原型的函数是对父类（接口）的相应函数进行重定义，以替换原有的功能，这种方式称为覆盖（override）。</p>
<h5 id="隐藏"><a class="header" href="#隐藏">隐藏</a></h5>
<p>当子类中定义与父类同名函数时，将无法直接访问父类的同名函数（即使非重载形式）。此时需要使用父类指针（在类外部）或作用域限定符（类内部）访问父类函数。</p>
<blockquote>
<p>多继承情况下，如果继承多个父类的同名函数，也会导致父类同名函数的隐藏。</p>
</blockquote>
<h4 id="虚函数"><a class="header" href="#虚函数">虚函数</a></h4>
<p>对于从同一父类派生出的不同类的对象，如果使用==父类的指针==统一进行管理与访问，可以明显的简化程序。但使用父类指针引用子类对象只能访问到父类中定义的成员，而不能访问子类中的成员。<strong>如果需要使用父类的指针访问子类中的成员函数，就需要首先在父类中将该函数声明为虚函数（<strong>不能通过父类指针访问子类数据成员</strong>）</strong>。</p>
<p><strong>虚函数是动态绑定的基础，虚函数必须是非静态的成员函数</strong>，虚函数经过派生后，在类族中就可以实现运行过程中的多态。虚函数的声明语法：</p>
<pre><code class="language-c++">virtual type function_name(arg_list);   // in parent class
type function_name（arg_list）override {statements} // in child class
</code></pre>
<blockquote>
<p>[1] C++ 虚函数表解析. http://blog.csdn.net/haoel/article/details/1948051/。</p>
</blockquote>
<p>虚函数的修饰符只能出现在类中函数声明处，而不能在函数实现处。在子类中不需要显式地给出虚函数的声明，当子类的成员函数满足重载条件时就会自动确定为虚函数。被覆盖的父类函数，任然可以通过作用域标识符来访问。</p>
<h5 id="虚函数的适用条件"><a class="header" href="#虚函数的适用条件">虚函数的适用条件</a></h5>
<p><strong>当子类需要修改父类的行为时，就应该将父类的相应函数声明为虚函数</strong>。而父类中声明的非虚函数，通常代表那些不希望被子类改变的功能，也是不能实现多态的。因此一般不要重写继承而来的非虚函数（虽然语法没有限制）。</p>
<p>在重写继承来的虚函数时，<strong>不能改变函数的默认形参值</strong>，因为：虽然虚函数是动态绑定的，但是默认形参值是静态绑定的。</p>
<p>虚函数必须给出实现，否则应该声明为<a href="CC++/Modern%20C++.html#%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0">纯虚函数</a>。</p>
<h5 id="虚析构函数"><a class="header" href="#虚析构函数">虚析构函数</a></h5>
<p>使用父类指针访问子类对象完成后，如果子类对象是动态分配的，这时存在的一个问题是：能否直接<code>delete</code>父类指针，完成子类对象的删除。在动态分配内存时，系统会记录下所分配的内存的首地址和分配长度，因此在执行删除操作时，无论指针指向的是父类对象还是子类对象，都能够正确的释放对象所占用的内存。</p>
<p>但是如果动态创建的对象中还有指向动态分配的内存空间的指针成员，则这样的删除就是不完全的，因为这些指针成员指向的动态分配的内存空间并不能得到释放（如同深拷贝与浅拷贝的原理一样，在构造函数中，浅拷贝只会复制指针，而不会另外增加一份指针指向的内容，这时需要深拷贝手动完成内容的赋值）。</p>
<p>动态空间的释放显然应该由析构函数来完成，其中父类的构造函数释放父类对象动态申请的内存空间，子类的构造函数释放子类对象动态申请的内存空间。当使用父类指针来实现多态时，由于通过父类指针只能直接访问父类成员，析构函数也是一样，这种情况下访问不到子类的析构函数（对象通过<code>delete</code>销毁获声明周期结束时，只会调用父类的构造函数），则不能完成子类动态分配空间的释放，因此要将父类的析构函数声明为虚函数。</p>
<h3 id="抽象类-2"><a class="header" href="#抽象类-2">抽象类</a></h3>
<p>抽象类用于抽象和设计接口。一个抽象类无法实例化，只能通过继承将抽象类改写为非抽象类，然后再实例化。可以定义抽象类的指针和引用，通过指针和引用，就可以访问子类的对象，实现多态性。</p>
<h4 id="纯虚函数"><a class="header" href="#纯虚函数">纯虚函数</a></h4>
<p>抽象类是带有纯虚函数的类。抽象方法、接口。</p>
<pre><code class="language-c++">virtual tpye function_name(args...) = 0;
</code></pre>
<p>抽象类派生出新类后，如果子类中给出了所有纯虚函数的函数实现，这个子类就不再是抽象类，而可以实例化；反之，如果子类中没有完全给出所有纯虚函数的实现，那么这个子类就仍然是抽象类。</p>
<h2 id="模板"><a class="header" href="#模板">模板</a></h2>
<p>模板定义语法</p>
<pre><code class="language-c++">template &lt;typename T,..., args&gt; declaration;  
</code></pre>
<p>其中，<code>declaration</code>可以表示函数或类的声明语法。模板参数包括：</p>
<ol>
<li>
<p><strong>类型参数</strong>，使用类型定义关键字（<code>class</code>或<code>typename</code>）或者嵌套定义的类模板类型（<code>template &lt;typename T,...&gt;ClassName</code>）；</p>
</li>
<li>
<p><strong>非类型参数</strong>，参数类型可以是整数，枚举，指针，引用或指向成员的指针，且==在编译时可以确定为常量==（类似于数组长度）。</p>
</li>
</ol>
<blockquote>
<p>模板参数可设置默认值。</p>
</blockquote>
<p><strong>编译器根据模板生成实际代码</strong>：定义模板并不定义实际类型或函数，只有在使用模板并传递相应的参数时，编译器才真正添加一个类型或函数。</p>
<p><a href="CC++/../CSharp.NET/CSharp%E6%95%B0%E6%8D%AE%E5%AE%B9%E5%99%A8.html#%E6%B3%9B%E5%9E%8B%E5%92%8C%E9%9D%9E%E6%B3%9B%E5%9E%8B%E5%AE%B9%E5%99%A8">泛型</a>：<a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/programming-guide/generics/differences-between-cpp-templates-and-csharp-generics">C++ 模板和 C# 泛型之间的区别</a>。</p>
<h3 id="函数模板"><a class="header" href="#函数模板">函数模板</a></h3>
<p>函数模板的声明语法：</p>
<pre><code class="language-c++">template &lt;typename T1, typename T2,...&gt;
T2 function_name(T param,...){statements}  
</code></pre>
<p>类型参数用来指定函数模板的参数类型和返回值类型，以及声明函数中的变量类型等。</p>
<h5 id="实例化"><a class="header" href="#实例化">实例化</a></h5>
<pre><code class="language-c++">fucntion_name&lt;T&gt;(args);   // 可省略类型参数，当类型可由参数推导出
</code></pre>
<h3 id="类模板"><a class="header" href="#类模板">类模板</a></h3>
<p>使用类模板使用户可以为类声明一种模式，使得类中的某些数据成员，某些成员函数的参数、返回值能取任意类型（包括系统预定义的和用户自定义的）。类模板的定义语法：</p>
<pre><code class="language-c++">template &lt;typename T1, typename T2, ..., int n,...&gt;  
class ClassName{member_declaration}  
</code></pre>
<p>在类模板内部定义成员的方法与普通类成员的定义语法一样，可能用到模板参数表中定义的类型或数值参数。模板类成员可以是静态或非静态，数据或函数成员。</p>
<blockquote>
<p>如果要在类模板定义范围以外定义其成员函数，则必须指定其所属的模板类，且模板类要指定相应的模板参数，即采用以下定义形式</p>
<pre><code class="language-c++">template &lt; class T1,class T2, ..., int  n,...&gt;
T2 ClassName&lt;T1,T2,...,n...&gt;::functionname(arg_list){statements}  
</code></pre>
<p>静态数据成员的定义方法也类似。</p>
</blockquote>
<p>类模板的成员函数也可作为函数模板来定义，即增加额外的模板参数，其声明和定义语法如下所示。</p>
<pre><code class="language-c++">template &lt;typename A1,...&gt;
class ClassName(args_list){
   template&lt;typename T1,...&gt; 
   T1 function_identifer(A1 param1, ...){statements}
}  
</code></pre>
<p>==（在类中的声明形式与一般函数一致），而不能如普通类一样，将成员函数的实现放到源文件中（否则或出现链接错误，LINK2019/2001）==。</p>
<h4 id="类模板实例化"><a class="header" href="#类模板实例化">类模板实例化</a></h4>
<p>使用一个模板类建立对象时，应该按以下形式声明：</p>
<pre><code class="language-c++">ClassTemplate&lt;T1,T2,...,n,...&gt;obj1;  
</code></pre>
<h3 id="完美转发"><a class="header" href="#完美转发">完美转发</a></h3>
<div style="break-before: page; page-break-before: always;"></div><h1 id="modern-c-1"><a class="header" href="#modern-c-1">Modern C++</a></h1>
<h2 id="introducing-modern-c-1"><a class="header" href="#introducing-modern-c-1">Introducing Modern C++</a></h2>
<h3 id="c标准-1"><a class="header" href="#c标准-1">C++标准</a></h3>
<ul>
<li>
<p><code>C++98</code></p>
</li>
<li>
<p><code>C++03</code></p>
</li>
<li>
<p><code>C++11</code></p>
</li>
<li>
<p><code>c++14</code></p>
</li>
<li>
<p><code>C++17</code></p>
</li>
<li>
<p><code>C++20</code></p>
<blockquote>
<p>Support in <code>gcc</code> is highly experimental, and will almost certainly change in incompatible ways in future releases.</p>
</blockquote>
</li>
</ul>
<h3 id="c特性-1"><a class="header" href="#c特性-1">C++特性</a></h3>
<h4 id="c-vs-c-1"><a class="header" href="#c-vs-c-1">C++ v.s. C</a></h4>
<div class="table-wrapper"><table><thead><tr><th>C++</th><th>C</th></tr></thead><tbody>
<tr><td></td><td><em>not</em> a <em>strict</em> subset of C++</td></tr>
<tr><td>stronger type system</td><td>weak type system</td></tr>
<tr><td>high-level abstractions</td><td>only low-level memory abstraction</td></tr>
<tr><td>powerful custom types (<code>class</code>es)</td><td>only data aggregation (<code>struct</code>)</td></tr>
<tr><td>use compiler as correctness checker</td><td>get the code to compile quickly</td></tr>
<tr><td>if it compiles, it should be correct</td><td>debugging is the real work</td></tr>
</tbody></table>
</div>
<h4 id="c-vs-java-1"><a class="header" href="#c-vs-java-1">C++ v.s. Java</a></h4>
<div class="table-wrapper"><table><thead><tr><th>C++</th><th>Java</th></tr></thead><tbody>
<tr><td>==<a href="https://akrzemi1.wordpress.com/2012/02/03/value-semantics">value semantics</a> for all types==</td><td>==value semantics only for primitives (<code>int</code>, <code>float</code>,… )==</td></tr>
<tr><td>optional reference semantics for all types</td><td>baked-in reference semantics for <code>class</code> types</td></tr>
<tr><td>full control over memory (de-)allocation; <br/>no garbage collection</td><td>garbage collector; can degrade performance</td></tr>
<tr><td>deterministic &amp; controllable object lifetime</td><td>no predictable object lifetime control</td></tr>
<tr><td>⇒ memory frugal</td><td>⇒ high memory consumption</td></tr>
<tr><td>aggressive inline can eliminate slow function calls</td><td>performance degradation due to un-devirtualizable, non-inlinable methods</td></tr>
</tbody></table>
</div>
<h4 id="c-vs-python-1"><a class="header" href="#c-vs-python-1">C++ v.s. Python</a></h4>
<div class="table-wrapper"><table><thead><tr><th>C++</th><th>Python</th></tr></thead><tbody>
<tr><td>almost always faster</td><td>almost always slower (in practice around 25-50 times)</td></tr>
<tr><td>complex syntax and tons of features can be intimidating to newcomers</td><td>simple syntax; usually easy to comprehend</td></tr>
<tr><td>statically typed</td><td>dynamically typed</td></tr>
<tr><td>many types of bugs can be caught at compile time</td><td>many types of bugs will only manifest at runtime</td></tr>
<tr><td>suited for safety-critical large-scale systems</td><td>hard to build reliable large-scale systems</td></tr>
<tr><td>even simple, small-scope tasks can quickly require an expert knowledge of various arcane corner cases &amp; quirks</td><td>tends to be more beginner-friendly and small scripts are usually quickly written</td></tr>
<tr><td>fairly small standard library but extensive ecosystem with libraries for nearly everything</td><td>==batteries included philosophy== with tons of libraries only one <code>import</code> away</td></tr>
</tbody></table>
</div>
<p>https://isocpp.org/wiki/faq</p>
<h2 id="数据类型-3"><a class="header" href="#数据类型-3">数据类型</a></h2>
<h3 id="基础数据类型-1"><a class="header" href="#基础数据类型-1">基础数据类型</a></h3>
<img src="CC++/Modern C++.assets/image-20210130230242900.png" alt="basic types" style="zoom:67%;" />
<blockquote>
<ul>
<li><code>0</code> is always <code>false</code>；everything else is <code>true</code>。</li>
</ul>
</blockquote>
<p>字符类型：<code>char</code>型（1字节），<code>wchar_t</code>型（长度与平台相关可能是2或4字节），<code>char16_t</code>（2字节）， <code>char32_t</code>（4字节）。</p>
<h4 id="字面值-5"><a class="header" href="#字面值-5">字面值</a></h4>
<p>字面值类型包括：整数常量、字符常量、浮点数常量、字符串常量。此处的常量均是指字面值常量。</p>
<h5 id="整数常量-1"><a class="header" href="#整数常量-1">整数常量</a></h5>
<p>整数常量可以声明为十进制、八进制、十六进制，有无符号，长或短整型。十进制数以非零数字开始，八进制以数字“<code>0</code>”为前导，十六进制以“<code>0x</code>”为前导。</p>
<p>后缀“<code>u</code>”或“<code>U</code>”用于声明该数值为无符号数，未添加该后缀则表示有符号数。</p>
<p>后缀“<code>L</code>”或“<code>l</code>”用于声明长整形。</p>
<p>后缀“<code>i64</code>”或“<code>ll</code>”或“<code>LL</code>”用于声明64位整形。</p>
<h5 id="浮点常量-1"><a class="header" href="#浮点常量-1">浮点常量</a></h5>
<p>浮点常量中是必须包含小数点的定点数，还可以包含指数，还可以附加后缀用于声明类型。浮点数默认类型为<code>double</code>，当添加后缀“<code>F</code>”或“<code>f</code>”表示浮点型，“<code>L</code>”或“<code>l</code>”表示<code>long double</code>（<code>long double</code>和<code>double</code>的长度都是一样的，但是类型不相同）。</p>
<p>定点数的表示方法：</p>
<pre><code class="language-c++">double x = 18.46, y = 38. ;
</code></pre>
<p>指数表示方法：</p>
<pre><code class="language-c++">double x = 18.46e0, y = 18.46E1 ;
</code></pre>
<p>指数部分可以是负数。当浮点数包含指数时，定点数部分可以不包含小数点。</p>
<p>数值范围：</p>
<pre><code class="language-c++">#include &lt;limits&gt;
std::numeric_limits&lt;double&gt;::max()     // largest positive value
std::numeric_limits&lt;double&gt;::min()     // smallest value &gt; 0
std::numeric_limits&lt;double&gt;::lowest()  // smallest negative value
std::numeric_limits&lt;double&gt;::epsilon() // smallest difference
</code></pre>
<p>一个整型类型可以转换成更宽位数的整型类型，这种转换称为整型提升。进行这种转换不改变数据的值。</p>
<h5 id="字符常量-1"><a class="header" href="#字符常量-1">字符常量</a></h5>
<p>字符常量是使用“<code>'</code>”包围的一个或多个字符。</p>
<p>如果整型使用普通字符常量或宽字符常量声明，则不足位补零；如果普通字符或宽字符用多字符常量声明，则将丢弃高位（左边的）字符。超过四个字符的字符常量声明将出错。</p>
<p>在字符声明中，具有特殊意义的字符（<code>\</code>、<code>'</code>、<code>&quot;</code>等）需要使用转义字符“<code>\</code>”消除特殊意义。转义序列有三种类型：</p>
<ul>
<li>
<p>简单类型：<code>\'  \&quot;  \?  \\ \a  \b  \f  \n  \r  \t  \v</code>；</p>
</li>
<li>
<p>八进制转义序列（转移字符之后最长三位八进制数，超过三位则第二个字符开始，或者从第一非八进制数字结束）：<code>\012</code>；</p>
</li>
<li>
<p>十六进制转义字符：转义字符后接“<code>x</code>”，其后接十六进制数字，后接数字位数无限制，只能以非十六进制数字结束。十六进制转义字符首先去除多余的高位，然后将剩余的8位数字转换为整型，再将整型转换为字符，如果整形的无符号值大于255，则转换不能完成，编译时会出错。</p>
<blockquote>
<p>转移字符之后的字符如果不是特殊字符，则结果由具体的实现决定。</p>
</blockquote>
</li>
</ul>
<p>双引号在字符常量中可以不使用转义字符。</p>
<blockquote>
<p>Microsoft Specification：通常只能是ASCII字符，包括96个字符：空格、水平制表符、垂直制表符、换行符、Formfeed和26个大小写字符、10个数字、以及下列字符：</p>
<p><code>_ { } [ ] # ( ) &lt; &gt; % : ; . ? * + - / ^ &amp; | ~ ! = , \ &quot; '</code></p>
<p>对于转义字符之后的非特殊意义字符，非特殊字符将正常显示，而转义字符不会显示；编译时会出现警告“不可识别的字符转移序列”。</p>
</blockquote>
<h5 id="字符串常量-1"><a class="header" href="#字符串常量-1">字符串常量</a></h5>
<p>一个字符串常量由0个或多个字符构成，有双引号所包围，字符串代表一个由“<code>null</code>”结尾的字符序列。字符串中可以包含所有字符常量允许使用的字符，以及使用转义字符。C++字符串包含两种类型：<code>char[]</code>，<code>wchar_t[]</code>。</p>
<pre><code class="language-c++">wchar_t w[] = L&quot;wide string&quot;; 
</code></pre>
<blockquote>
<p>声明<code>wchar_t</code>字符或字符串常量需要添加一个前缀“<code>L</code>”，类似地<code>u</code>用于<code>char16_t</code>类型字面值，<code>U</code>用于<code>char32_t</code>类型字面值。</p>
<p>通过指向常量字符串的指针修改常量字符串是不允许的，结果未知。</p>
</blockquote>
<p>以空格分隔的字符串会被自动拼接为单个字符串（也可以在行末使用“<code>\</code>”连接两行。）。</p>
<pre><code class="language-c++">const char* b = &quot;first&quot; &quot;second&quot; // ⇒ &quot;first second&quot;
</code></pre>
<p>原始字符转字面值：</p>
<pre><code class="language-c++">char const * ch_array = R&quot;(raw &quot;C&quot;-string c:\users\joe )&quot;;  // c++11
</code></pre>
<blockquote>
<p>Microsoft Specification：在一些情况下，声明的相同的字符串将被合并为一个字符串，在内存中使用同一段内存。</p>
<p>字符串的字面值最大长度为2048字节，对于<code>char</code>和<code>wchar_t</code>都一样。</p>
<p>如果定义了UNICODE，则<code>_T()</code>等效于前缀<code>L</code>。</p>
</blockquote>
<h4 id="枚举-4"><a class="header" href="#枚举-4">枚举</a></h4>
<p>限定作用域枚举，使用枚举类型名访问枚举成员。</p>
<pre><code class="language-c++">enum class day:short { mon, tue, wed, thu, fri, sat, sun };
day d = day::mon;
</code></pre>
<p>非限定作用域枚举，不同的枚举类型不能包含相同名字的成员。</p>
<pre><code class="language-c++">enum day { mon, tue, wed, thu, fri, sat, sun };
day d = mon;
</code></pre>
<p>可以为枚举指定底层整数类型（<code>char, short, long,...</code>，默认为<code>int</code>）。可以将枚举强制转换为其底层类型。</p>
<h3 id="引用-1"><a class="header" href="#引用-1">引用</a></h3>
<p>引用声明以后就是绑定到变量的别名，对引用名再赋值等效于修改绑定变量的值，因此无法再修改引用本身（赋值）使之绑定到其他变量。由于引用是变量的别名，因此通过引用总是能访问有效的变量。</p>
<pre><code class="language-c++">[const] ValueType [const] &amp; ref_name = VarName;
</code></pre>
<blockquote>
<p><code>const</code>声明符可以位于类型的前面或后面，但后者与<a href="CC++/Modern%20C++.html#%E5%B8%B8%E9%87%8F%E7%9B%B8%E5%85%B3%E6%8C%87%E9%92%88">指针类型声明</a>风格保持一致。</p>
<p>references cannot be &quot;null&quot;, i.e., they must always refer to an object</p>
</blockquote>
<pre><code class="language-c++">int  i  = 2, k  = 3;
int&amp; ri = i;    // reference to i
ri = k;         // assign new value to ri(i)
</code></pre>
<p>如果引用声明为常量，则无法通过该引用修改变量的值。</p>
<h4 id="引用的应用-1"><a class="header" href="#引用的应用-1">引用的应用</a></h4>
<ul>
<li>
<p>作为函数、“<code>[]</code>”和“<code>=</code>”操作符的返回值，满足左操作数可以被赋值的要求（L-value）。</p>
<p><strong>Dangling Reference</strong>：</p>
<blockquote>
<p>不要返回局部变量的引用；</p>
<p>引用容器元素在修改容器后可能失效；</p>
</blockquote>
</li>
<li>
<p>作为函数参数，等价于使用指针进行参数传递，而无须复制实际参数。</p>
</li>
<li>
<p>在迭代循环中使用</p>
<pre><code class="language-c++">for(std::string &amp; s : v) { cin &gt;&gt; s; } // modify vector elements
for(std::string const&amp; s : v) { cout &lt;&lt; s; } // read-only access
for(auto &amp; s : v) { cin &gt;&gt; s; }
for(auto const&amp; s : v) { cout &lt;&lt; s; }
</code></pre>
</li>
<li>
<p><a href="https://hackingcpp.com/cpp/lang/move_semantics.html">Move Semantics</a></p>
</li>
<li>
<p>Avoid Output Parameters! 难以确定参数是否发生变化，参数是否仅作为输出或还作为输入。</p>
</li>
<li>
<p><strong>Just take returned objects by value.</strong> This does not involve expensive copies for most functions and types in modern C++, especially in C++17 and above.</p>
<blockquote>
<p>使用引用绑定函数返回值将导致临时变量的生命周期变长。</p>
</blockquote>
</li>
</ul>
<h4 id="引用绑定规则-1"><a class="header" href="#引用绑定规则-1">引用绑定规则</a></h4>
<h5 id="rvalues-and-lvalues-1"><a class="header" href="#rvalues-and-lvalues-1"><em>R</em>values and <em>L</em>values</a></h5>
<p><strong>左值（Lvalues）</strong>：expressions of which we <strong>can</strong> get memory address</p>
<ul>
<li>内存中可引用的对象</li>
<li>具有名字的对象 (variables, function parameters, …)</li>
</ul>
<p><strong>右值（Rvalues）</strong>：expressions of which we <strong>can't</strong> get memory address</p>
<ul>
<li>字面值(<code>123</code>, <code>&quot;string literal&quot;</code>, …)（位于代码区）；</li>
<li>运算的零时结果；</li>
<li>函数返回的零时变量；</li>
</ul>
<p><strong>左值引用</strong>：<code>type&amp;</code>，仅能绑定到左值；<code>type const&amp;</code>可绑定到<code>const</code>左值和右值；</p>
<p><strong>右值引用</strong>：<code>type&amp;&amp;</code>，仅能绑定到右值（涉及<a href="CC++/Modern%20C++.html#%E7%B1%BB%E5%9E%8B%E6%8E%A8%E6%96%AD">类型推断</a>的除外）；</p>
<p><strong>万能引用（转发引用）</strong>：根据类型推断的结果，可能为左值或右值引用。</p>
<pre><code class="language-c++">auto&amp;&amp; ref = var;
template&lt;typename T&gt; void f(T&amp;&amp; param);
</code></pre>
<blockquote>
<p>类型推导是必要条件，被推导类型必须为<code>T&amp;&amp;</code>，其中<code>T</code>是模板类型参数。</p>
</blockquote>
<h3 id="类型语法-1"><a class="header" href="#类型语法-1">类型语法</a></h3>
<h4 id="类型别名-1"><a class="header" href="#类型别名-1">类型别名</a></h4>
<pre><code class="language-c++">using NewType = OldType;  // C++11
typedef OldType NewType;  // C++98
</code></pre>
<h4 id="类型推断-1"><a class="header" href="#类型推断-1">类型推断</a></h4>
<pre><code class="language-c++">auto variable = expression; // c++11
</code></pre>
<h4 id="类型转换-5"><a class="header" href="#类型转换-5">类型转换</a></h4>
<p><code>static_cast(v)</code>：强制类型转换，编译器允许执行（但不一定是自动执行的）的任何转换都可以完成。避免发生精度损失时的警告。类似于C语法<code>type(var)</code>。</p>
<p><code>const_cast(v)</code>：去除常量性质，是变量能够被修改。</p>
<p><code>dynamic_cast(v)</code>：运行时动态识别类型。将基类类型的指针或引用安全地转换为派生类型的指针或引用。</p>
<p><code>reinterpret_cast(v)</code>：对于编译器不允许的转换类型（如指针类型转换），可以使用<code>reinterpret_cast</code>进行强制转换而不产生编译期错误。 </p>
<p><code>std:move(T&amp;&amp;)</code>将参数强制转换为右值；</p>
<p><code>std:forward&lt;T&gt;(param)</code>：仅当实参为右值时，将形参转换为右值；</p>
<h3 id="指针-3"><a class="header" href="#指针-3">指针</a></h3>
<p>指针可以用于访问对象，且可以在运行期间改变其引用的对象（引用则不能修改）。指针的一个重要用途是函数参数传递，使用指针可以进行地址传递，则主函数和子函数可以访问同一段内存的变量。</p>
<img src="CC++/Modern C++.assets/image-20210212200114257.png" alt="image-20210212200114257" style="zoom:40%;" />
<h4 id="原始指针-1"><a class="header" href="#原始指针-1">原始指针</a></h4>
<p>指针存储内存地址的整数变量。通过取地址运算符<code>&amp;</code>获取变量地址。</p>
<pre><code class="language-c++">int a = 1;
int* ptr = &amp;a;
</code></pre>
<p>或通过<a href="CC++/Modern%20C++.html#%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D">动态内存分配</a>获取堆上创建的变量的地址。</p>
<h5 id="指针运算-1"><a class="header" href="#指针运算-1">指针运算</a></h5>
<p>指针可以进行赋值运算、算数运算、关系运算和解引用运算。</p>
<p><code>*</code>：对象引用运算符；</p>
<p><code>-&gt;</code>：对象成员引用运算符；</p>
<pre><code class="language-c++">point *p = new point{1,2};
cout &lt;&lt; p-&gt;x &lt;&lt; p-&gt;y &lt;&lt; *(p).x;
</code></pre>
<blockquote>
<p>优先使用引用，语法更加简洁。</p>
</blockquote>
<h4 id="智能指针c11-1"><a class="header" href="#智能指针c11-1">智能指针（C++11）</a></h4>
<img src="CC++/Modern C++.assets/image-20210212200441907.png" alt="image-20210212200441907" style="zoom: 40%;" />
<h5 id="unique_ptr-1"><a class="header" href="#unique_ptr-1">unique_ptr</a></h5>
<p>不能复制指针，但可以移动指针指向的对象到新的指针，原指针被置为<code>nullptr</code>。</p>
<pre><code class="language-c++">#include &lt;memory&gt;
auto p = make_unique&lt;Type&gt;(init_list);    // c++14, more safe
std::unique_ptr&lt;Type&gt; p1(new Type(args));  // c++14
auto p2 = move(p);  // 不能复制unique_ptr
</code></pre>
<blockquote>
<p>仍然使用<code>-&gt;</code>运算符访问类型的成员。</p>
</blockquote>
<h5 id="shared_ptr-1"><a class="header" href="#shared_ptr-1">shared_ptr</a></h5>
<pre><code class="language-c++">#include &lt;memory&gt;
auto p = make_shared&lt;Type&gt;(init_list);     // c++14
std::shared_ptr&lt;Type&gt; p1(new Type(args));  // c++14
auto p2 = p;
</code></pre>
<p>引用计数：当最后引用对象的指针被销毁时，对象被销毁。</p>
<p><code>weak_ptr</code>可以复制<code>shared_ptr</code>但不影响引用计数。</p>
<h3 id="数组-5"><a class="header" href="#数组-5">数组</a></h3>
<pre><code class="language-c++">type array[N];
type array[N] = {1,2,3,...};
</code></pre>
<blockquote>
<p>当初始化列表给定时，可省略数组长度参数。==数组长度？==</p>
</blockquote>
<p>动态创建数组：</p>
<pre><code class="language-c++">type* ptr_array = new type[size];
type* ptr_array = new type[size]{1,2,...};
</code></pre>
<p>多维数组：创建$M\times N\times\cdots$维数组。</p>
<pre><code class="language-c++">type array[M][N]...[];
type (*ptr)[N]... = new type[size][N]...;
</code></pre>
<p>仅有数组的最高维度是可以动态分配的，将其他维度整体看作一个整体（子数组）。</p>
<blockquote>
<p><code>K</code>维数组可以看成由<code>size</code>个维度为<code>K-1</code>的子数组构成的。分配一维数组，实际上是分配连续的<code>size</code>个基本变量；分配二维数组，实际上是连续分配<code>size</code>个一维数组，以此类推…… </p>
<p>动态创建数组时只有<code>size</code>是变量，其他参数必须是编译期确定的常量（字面值或<code>constexpr</code>）。指向数组的指针进行“加减”运算，指针加减1实际对应的内存地址偏移量为对应子数组的内存占用长度。</p>
</blockquote>
<h4 id="指针数组-1"><a class="header" href="#指针数组-1">指针数组</a></h4>
<p>即数组元素是指针类型。指针数组的声明：</p>
<pre><code class="language-c++">type* ptr_array[L1][L2]...;
type(*ptr_array[L1][L2]...)[M][N]...[P];
</code></pre>
<p>其中<code>[L1][L2]...</code>是指针数组本身的维度，而<code>type(*)[M][N]...[P]</code>代表最终指向的数据类型。如果带参数<code>[M][N]...[P]</code>，则代表指向的是数组（的维度）；如果没有该参数则为指向变量的指针（此时不省略<code>()</code>会生成警告）。</p>
<h4 id="数组索引-1"><a class="header" href="#数组索引-1">数组索引</a></h4>
<pre><code class="language-c++">array_name[index]；
*(array_name+index)；
</code></pre>
<blockquote>
<p>数组名相当于<a href="CC++/Modern%20C++.html#%E5%B8%B8%E9%87%8F%E7%9B%B8%E5%85%B3%E6%8C%87%E9%92%88">指针常量</a>。</p>
</blockquote>
<p>高维数组在内存中实际上是按照线性方式存储数据的，所以实质上等效于是一个一维数组，所以仍然可以定义一维数组指针来访问数组元素。则指向第一个元素的一维数组指针的值应该是：</p>
<pre><code class="language-c++">type *ptr =  array[M][N]...;    // 省略最后一维
type *ptr = &amp;array[M][N]...[P]; // 或直接取元素地址
</code></pre>
<h3 id="类型修饰符-1"><a class="header" href="#类型修饰符-1">类型修饰符</a></h3>
<h4 id="静态变量-3"><a class="header" href="#静态变量-3">静态变量</a></h4>
<pre><code class="language-c++">static int x = 1; // 定义静态（文件作用域）变量
extern int x;     // 引用全局（非静态）变量，不推荐使用全局变量
</code></pre>
<blockquote>
<p>可以在<a href="CC++/Modern%20C++.html#%E5%A4%B4%E6%96%87%E4%BB%B6">头文件中定义静态变量</a>，引用该头文件的源文件将分别生成独立的文件作用域静态变量。</p>
</blockquote>
<p><strong>局部静态变量</strong>：静态变量定义在非全局作用域（如函数内部）。该变量的生命周期为程序生命周期，但仅能在定义该变量的作用域中访问。==局部静态变量只会在定义位置被初始化一次==。</p>
<blockquote>
<p>全局变量构造器：在静态函数中返回静态变量的引用。</p>
</blockquote>
<h4 id="常量-3"><a class="header" href="#常量-3">常量</a></h4>
<pre><code class="language-c++">Type const variable_name = value;
const Type variable_name = value;
</code></pre>
<p>用<code>const</code>关键字可以代替<code>#define</code>宏，使用<code>const</code>关键字声明的常量在编译时可以进行类型检查，而使用<code>#define</code>宏定义的常量则不能。</p>
<h5 id="常量表达式-1"><a class="header" href="#常量表达式-1">常量表达式</a></h5>
<p>表达式的值在编译期间是确定的，其组成部分都是常量表达式。</p>
<pre><code class="language-c++">constexpr int i = 2;       // OK '2' is a literal
constexpr int cxf(int i) { return i*2; }
constexpr int j = cxf(5);  // OK, cxf is constexpr 
constexpr int k = cxf(i);  // OK, cxf and i are constexpr
</code></pre>
<blockquote>
<p><code>c++14</code>：常量表达式函数内部可以包含多条语句；</p>
</blockquote>
<h4 id="常量相关指针-1"><a class="header" href="#常量相关指针-1">常量相关指针</a></h4>
<p>常量指针：指针本身是常量，即不能更改指针本身（所存储的内存位置），但可以更改指针指向的内容。</p>
<p>指向常量的指针：指针所指的内容必须是常量，不能修改指针所指的内容，但可以修改指针本身（所存储的内存地址）。可以用于函数参数，防止函数改变通过指针传入的参数。</p>
<pre><code class="language-c++">type *const ptr;  // const pointer to variable of Type &lt;type&gt;
type const *ptr;  // pointer to const variable of Type &lt;type&gt;
</code></pre>
<blockquote>
<p><code>type const *const</code>：指针本身不能改变，指针所指的值也不允许改变。</p>
</blockquote>
<img src="CC++/Modern C++.assets/image-20210212201652844.png" alt="image-20210212201652844" style="zoom:30%;" />
<blockquote>
<p>从右到左解释类型声明。</p>
</blockquote>
<h3 id="内存模型-1"><a class="header" href="#内存模型-1">内存模型</a></h3>
<p><strong>heap</strong>: used for objects of dynamic storage duration;</p>
<blockquote>
<p>空闲内存块列表。</p>
</blockquote>
<p><strong>stack</strong>: used for objects of automatic storage duration: local variables, function parameters, etc.</p>
<blockquote>
<p>栈分配通常从高地址到低地址。</p>
</blockquote>
<img src="CC++/Modern C++.assets/vector_of_ints.svg" alt="img" style="zoom:50%;" />
<h4 id="内存占用-3"><a class="header" href="#内存占用-3">内存占用</a></h4>
<p>基本数据类型的区别主要在于内存占用量。</p>
<pre><code class="language-c++">sizeof(char)；  // 操作符： auto x = sizeof char
</code></pre>
<blockquote>
<p>Integer Size Guarantees  <a href="https://hackingcpp.com/tags/C++11">C++11</a></p>
<pre><code class="language-c++">#include &lt;cstdint&gt;
</code></pre>
<p>exact size: <code>int8_t</code>,   <code>int16_t</code>,   <code>int32_t</code>,   <code>int64_t</code>,   <code>unt8_t, …</code></p>
</blockquote>
<h4 id="动态内存分配-1"><a class="header" href="#动态内存分配-1">动态内存分配</a></h4>
<p>C++使用<code>new</code>和<code>delete</code>关键字进行动态内存管理。当使用<code>new</code>关键字为变量在堆上分配内存并返回<a href="CC++/Modern%20C++.html#%E5%8E%9F%E5%A7%8B%E6%8C%87%E9%92%88">内存地址</a>，并自动调用构造函数进行初始化。如果分配内存失败，<code>new</code>返回<code>nullptr</code>或抛出异常。</p>
<blockquote>
<p><code>nullptr</code>为指针默认值（转换为<code>false</code>，可以用于逻辑判断）。</p>
</blockquote>
<pre><code class="language-c++">type *ptr = new type(args); // type *ptr = new type{args};
type *ptr = new type[const_num]{init_list};
delete ptr;     // delete variable
delete [] ptr;  // delete array
</code></pre>
<blockquote>
<p>无法从指针类型判断其是只想单个变量或数组。</p>
</blockquote>
<p>使用<code>delete</code>关键字对值为<code>nullptr</code>的指针进行操作不会出错；但使用<code>delete</code>对不是用<code>new</code>分配的内存块（栈）的指针进行操作将会出现不可知的结果；在使用<code>delete</code>释放内存后，再使用指针将会出现未知结果或导致程序崩溃。</p>
<blockquote>
<p>In modern C++, manual allocation is actually only really necessary if you want to implement your own dynamic data structures / containers.</p>
</blockquote>
<h2 id="语法-3"><a class="header" href="#语法-3">语法</a></h2>
<h3 id="定义变量-3"><a class="header" href="#定义变量-3">定义变量</a></h3>
<pre><code class="language-c++">type varname;
</code></pre>
<p>定义可以与初始化结合。</p>
<pre><code class="language-c++">type varname = value;
type varname = {value};
type varname{value}; // C++11: narrowing conversion ⇒ compiler warning
</code></pre>
<blockquote>
<p>==基本数值类型变量在声明时不会被赋予默认值，其值是随机的。==</p>
</blockquote>
<p>聚合类型（结构体、类）的<a href="CC++/Modern%20C++.html#%E5%88%9D%E5%A7%8B%E5%8C%96">初始化</a>由<a href="CC++/Modern%20C++.html#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0">构造函数</a>执行。</p>
<pre><code class="language-c++">ClassName varname = ClassName(args);  // 调用构造函数初始化变量
ClassName varname(args);              // 简洁写法
ClassName varname = ClassName{args};  // c++11: narrow conversion
ClassName varname{args};              // 简洁写法
</code></pre>
<p><a href="CC++/Modern%20C++.html#%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D">动态分配的变量</a>返回变量的地址。</p>
<h4 id="赋值-3"><a class="header" href="#赋值-3">赋值</a></h4>
<p>赋值运算默认具有值语义，即显式复制对象的数据成员，避免在非期望情况下修改数据；</p>
<ul>
<li>
<p>避免将聚合类型变量的定义和初始化分开，否则则首先会调用默认构造函数执行初始化再随后执行赋值操作，造成额外开销。</p>
</li>
<li>
<p>==具有指针成员变量的类==应该重写赋值运算符和复制/移动构造函数，以处理动态分配对象的复制问题。否则，对已定义变量使用新构造对象赋值应注意，新构造对象仅具有临时生命周期，因此可能导致赋值后的变量中指针成员引用无效对象。</p>
<pre><code class="language-c++">LinkedList l1;        // LinkedList.header是指针成员变量
vector&lt;int&gt; v = {1, 2, 3, 4};
l1 = LinkedList(v);   // 如果没有适当的赋值拷贝，由于临时创建对象释放，l1可能包含无效指针
</code></pre>
</li>
</ul>
<h5 id="引用语义-1"><a class="header" href="#引用语义-1">引用语义</a></h5>
<p>值语义（<a href="https://akrzemi1.wordpress.com/2012/02/03/value-semantics">value semantics</a>）：<a href="CC++/Modern%20C++.html#%E5%A4%8D%E5%88%B6%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0">赋值运算默认为值传递方式</a>（包括函数输入输出参数）。</p>
<blockquote>
<p>更接近数学记法：输入参数不会被函数改变；</p>
<p>we do not run into any memory management issues. No dangling references to nonexistent objects, no expensive and unnecessary free store allocation, no memory leaks, no smart or dumb pointers. </p>
</blockquote>
<p>引用语义（<em>reference semantics</em>）</p>
<blockquote>
<p>where you want to create an object, and let it live for a significant amount of time, and want different parties to modify the object, you need to pass by reference.</p>
<p>This is the case for globals like <code>std::cout</code> that need to be accessible from different places in the code, and it always has to be this very object at this very address.</p>
</blockquote>
<p>指针：</p>
<blockquote>
<p>they are objects that store values which are addresses in memory <em>referring</em> to objects.</p>
<p>at the higher level of abstraction passing and returning pointers to and from functions is usually considered passing by reference (reference semantics), even though technically you are passing values. </p>
<p><em>the reason people often resort to allocating objects in free store (on the heap) and returning a (more or less) smart pointer to it, is that value semantics does not play well with OO techniques that require access to objects via references or pointers to enable virtual function calls.</em></p>
</blockquote>
<h3 id="运算符-13"><a class="header" href="#运算符-13">运算符</a></h3>
<h4 id="自增自减-1"><a class="header" href="#自增自减-1">自增/自减</a></h4>
<ul>
<li>prefix expressions <code>++x</code> / <code>--x</code> returns new (incremented/decremented) value；</li>
<li>postfix expression <code>x++</code> / <code>x--</code> increments/decrements value, but <em>returns old value</em>；</li>
</ul>
<h4 id="逻辑运算-1"><a class="header" href="#逻辑运算-1">逻辑运算</a></h4>
<pre><code class="language-c++">bool c = a &amp;&amp; b;   // false    logical AND
bool d = a || b;   // true     logical OR
bool e = !a;       // false    logical NOT
</code></pre>
<p><strong>Short-circuit Evaluation</strong>: The second operand of a boolean comparison is not evaluated if the result is already known after evaluating the first operand.</p>
<h4 id="移位运算-1"><a class="header" href="#移位运算-1">移位运算</a></h4>
<p>只有整数类型能进行移位操作：</p>
<pre><code class="language-c++">result = op1 &gt;&gt; op2  // 右移
result = op1 &lt;&lt; op2  // 左移
</code></pre>
<p>其中<code>op1</code>是要进行移位的整数，<code>op2</code>是要偏移的位数。<code>op1</code>的值不会改变，移位的结果作为返回值，返回结果的类型与<code>op1</code>的类型相同（准确的说，返回类型应该是长整型，赋值的过程可以强制转换）。</p>
<p>如果<code>op2=0</code>，则实际不对<code>op1</code>移位；如果<code>op2</code>为负数或达到整数类型的bit长度，则结果未定义。实际测试（Windows/Linux）可以发现，移位运算会先对<code>op2</code>进行求余处理，使移位范围不超过整数的bit长度，再进行移位。</p>
<p>左移运算是逻辑移位，即右侧空出的位补零；如果<code>op1</code>是有符号数，则右移运算是算数移位，即左边空出的位填充符号位，如果<code>op1</code>是无符号数，则右移运算是逻辑移位，即左边空出的位补0。</p>
<h3 id="控制流程-1"><a class="header" href="#控制流程-1">控制流程</a></h3>
<blockquote>
<p><strong>表达式（Expressions）</strong>: series of computations (operators + operands); may <strong>produce a result</strong>.</p>
<p><strong>Statements</strong>: sequence of expressions; do not produce a result; delimited by <code>;</code> and grouped by <code>{ }</code>.</p>
</blockquote>
<h4 id="条件分支-1"><a class="header" href="#条件分支-1">条件分支</a></h4>
<h5 id="if-else-3"><a class="header" href="#if-else-3">if-else</a></h5>
<pre><code class="language-c++">if (condition1) {
  // do this if condition1 is true
}
else {
  // otherwise do this
}
// if(statement; condition) { … }  C++17
</code></pre>
<blockquote>
<p><code>else if</code>是<code>if</code>嵌套在<code>else</code>语句块的结果。</p>
<p>三元运算符：<code>condition ? true_statement : false_statement</code>。</p>
</blockquote>
<h5 id="switch-1"><a class="header" href="#switch-1">switch</a></h5>
<pre><code class="language-c++">switch (m) {
  case 0:   // do this if m is 0
    break;
  case 1:   
  case 3:   // do this if m is 1 or 3
    break;
  default:  // do this if m is not 0, 1 or 3
}
// switch (statement; variable) { … }   C++17
</code></pre>
<h5 id="ternary-condition-operator-1"><a class="header" href="#ternary-condition-operator-1">Ternary Condition Operator</a></h5>
<pre><code class="language-c++">Result = Condition ? If-Expression : Else-Expression
</code></pre>
<h4 id="循环-6"><a class="header" href="#循环-6">循环</a></h4>
<pre><code class="language-c++">for (int i = 0; i &lt; 5; ++i) {
  cout &lt;&lt; i &lt;&lt; ' ';
}
</code></pre>
<pre><code class="language-c++">std::vector&lt;int&gt; v {1,2,3,4,5};
for(auto i = begin(v); i != end(v); ++i) { cout &lt;&lt; *i; }
for (int x : v)  { cout &lt;&lt; x &lt;&lt; '\n'; } // c++11
</code></pre>
<pre><code class="language-c++">while (j &lt; 10) {
  cout &lt;&lt; j &lt;&lt; ' ';
  ++j;
}
do { 
  cout &lt;&lt; j &lt;&lt; ' ';
  --j;
} while (j &gt; 0);
</code></pre>
<h4 id="异常-2"><a class="header" href="#异常-2">异常</a></h4>
<pre><code class="language-c++">try {...}
catch(std::invalid_argument&amp;e){
    throw;  //re-throw exception
}catch(...){
    // catch all exceptions
}

void funcname(...) noexcept {...}  // throw exception not allowed
</code></pre>
<h3 id="预处理命令-1"><a class="header" href="#预处理命令-1">预处理命令</a></h3>
<h4 id="头文件-1"><a class="header" href="#头文件-1">头文件</a></h4>
<p>头文件用于集中存放函数原型声明和类型定义。</p>
<pre><code class="language-c++">#include &lt;filename&gt;
</code></pre>
<p>按照标准方式搜索要包含的文件（将文件内容添加到当前处理的源文件中），该文件位于C++系统目录的<code>include</code>子目录下，一般要包含系统提供的标准文件时这样使用。</p>
<pre><code class="language-c++">#include &quot;filename&quot;
</code></pre>
<p>首先在当前目录下搜索要包含的文件，如果没有，再按照标准方式搜索，<em><strong>*对用户自己编辑的文件，采用这种方式*</strong></em>。</p>
<h4 id="宏-1"><a class="header" href="#宏-1">宏</a></h4>
<pre><code class="language-c++">#define	MACRO  // 定义宏
#undef MACRO   // 删除由define定义的宏
</code></pre>
<h5 id="特殊宏-1"><a class="header" href="#特殊宏-1">特殊宏</a></h5>
<pre><code class="language-c++">__LINE__;  // 行号
__FILE__;  // 文件名
__DATE__;
__TIME__;
__cplusplus;  // 值为最新支持的c++标准发布时间
</code></pre>
<h5 id="带参数的宏-1"><a class="header" href="#带参数的宏-1">带参数的宏</a></h5>
<pre><code class="language-c++">#define LOG(x) std::cout &lt;&lt; x &lt;&lt; std::endl
</code></pre>
<h4 id="条件编译指令-1"><a class="header" href="#条件编译指令-1">条件编译指令</a></h4>
<pre><code class="language-c++">#if constant_expression
	statements;
#elif constant_expression
	statements;
#else
	statements;
#endif

#ifdef identifier
    statements;
#elif defined(identfier2)
    statements;
#else
    statements;
#endif

#ifndef	identifier
    statements;
#else
    statements;
#endif
</code></pre>
<p><code>#ifdef</code>和<code>#ifndef</code>用于判断一个宏是否已经定义，这两个命令常组合起来使用，在头文件中加入以下结构，用于防止头文件的重复包含。</p>
<pre><code class="language-c++">#ifndef identifier
#define identifier
header_file_contents
#endif
</code></pre>
<blockquote>
<p><code>#pragma once</code>：保证在源文件中只会包含该头文件一次，避免类型的重复定义。</p>
</blockquote>
<p>**注意：**不要在头文件中添加定义，因为该头文件如果被包含到不同源文件，在链接阶段会产生重复符号定义。</p>
<ul>
<li>将函数声明为<code>static</code>，但没有必要为每个源文件定义功能相同的函数；</li>
<li>==将函数声明为<code>inline</code>，则编译时函数体被替换为代码块==。</li>
</ul>
<h4 id="兼容c语言-1"><a class="header" href="#兼容c语言-1">兼容C语言</a></h4>
<p>​	使C++在编译C语言函数保持对C语言的兼容，在头文件中添加以下结构。</p>
<pre><code class="language-c++">#ifdef __cplusplus
	#if __cplusplus
extern &quot;C&quot;{
    #endif
#endif
    
function-declare;
    
#ifdef __cplusplus
    #if __cplusplus
}
	#endif
#endif
</code></pre>
<h3 id="注释-1"><a class="header" href="#注释-1">注释</a></h3>
<h4 id="文档-1"><a class="header" href="#文档-1">文档</a></h4>
<h5 id="c-docstrings-1"><a class="header" href="#c-docstrings-1">C++ Docstrings</a></h5>
<pre><code class="language-c++">/**
 * Create a new Triangle object of side lengths 1, 1, and 1.
 * @brief Triangle class used for triangle manipulations.
 * @details 细节
 * @param a The Length of triangle side a.
 * @return The length of side a.
 * @see Triangle(const double a, const double b, const double c)
 * @file 文件名
 * @todo todo things
 */
</code></pre>
<pre><code class="language-c++">/**
 * @mainpage Triangle Library Documentation
 * @author 作者
 * @version 版本号
 * @date 年-月-日
 * @section intro_sec Introduction
 * Do somethings ...
 * @subsection install_dependencies Installing Dependencies
 */
</code></pre>
<h5 id="doxygen-1"><a class="header" href="#doxygen-1">doxygen</a></h5>
<p>运行<a href="CC++/../%E5%BA%94%E7%94%A8%E8%BD%AF%E4%BB%B6/%E6%96%87%E6%A1%A3%E7%94%9F%E6%88%90%E8%BD%AF%E4%BB%B6.html#doxygen"><code>doxygen</code></a>生成文档。</p>
<pre><code class="language-shell">doxygen –g Doxyfile
</code></pre>
<p><a href="https://leimao.github.io/blog/CPP-Documentation-Using-Doxygen/">Lei Mao's Log Book – C/C++ Documentation Using Doxygen</a></p>
<p><a href="https://marketplace.visualstudio.com/items?itemName=cschlosser.doxdocgen">Doxygen Documentation Generator - Visual Studio Marketplace</a></p>
<h2 id="函数-5"><a class="header" href="#函数-5">函数</a></h2>
<blockquote>
<ul>
<li>encapsulation of implementation details</li>
<li>easier reasoning about correctness and testing by breaking down problems into separate functions</li>
<li>avoids repeating code for common tasks</li>
</ul>
</blockquote>
<p>返回类型推断：在编译期间可以确定返回类型。</p>
<pre><code class="language-c++">auto foo (int i, double d) {
  …
  return i;
}
</code></pre>
<p>默认参数：</p>
<pre><code class="language-c++">double f (double a, double b = 1.5) {
    return (a * b);
}
</code></pre>
<p>函数声明（declaration）：</p>
<ul>
<li>告知编译器一个函数存在于某个源文件中。函数声明通常放置在头文件中，便于导入。</li>
<li>作为函数参数，接受声明类型的函数对象<code>int cmp(int &amp;, int &amp;)</code>；</li>
</ul>
<h3 id="参数传递-3"><a class="header" href="#参数传递-3">参数传递</a></h3>
<h4 id="传入参数-1"><a class="header" href="#传入参数-1">传入参数</a></h4>
<img src="CC++/Modern C++.assets/pass_parameters_args.png" alt="pass parameters" style="zoom: 45%;" />
<blockquote>
<p>Read from cheaply copyable object (all fundamental types) ⇒ <strong>pass by value</strong>;</p>
<p>Read from object with larger (&gt; 64bit) memory footprint ⇒ pass by <code>type const &amp;</code>;</p>
<p>Write to function-external object ⇒ pass by <code>type &amp;</code>.</p>
</blockquote>
<h5 id="可变参数列表-1"><a class="header" href="#可变参数列表-1">可变参数列表</a></h5>
<p>可变参数函数（如<code>printf</code>）的最后一个参数以“<code>...</code>”代替。</p>
<pre><code class="language-c++">return_type func_name (param,...){...} 
</code></pre>
<p>使用在“<code>stdarg.h</code>”中定义的类型（<code>va_list</code>指针类型）和宏（<code>va_start</code>、<code>va_arg</code>、<code>va_end</code>和<code>va_copy</code>）访问参数列表。</p>
<ul>
<li>
<p><em><code>va_start</code>：返回参数列表存储区的指针。使用可变参数列表必须至少提供一个占位的固定参数，这个参数可以不被函数使用。这样<code>va_start</code>才可以定位到参数列表的首地址。</em></p>
<pre><code class="language-c++">va_list ptr_args = va_start(param, param1);
for(;ptr_args!=nullptr; ++ptr_args){
   var_name = va_arg(ptr_args, type);
}
</code></pre>
</li>
<li>
<p><em><code>va_arg</code>：返回一个参数。</em></p>
</li>
<li>
<p><em><code>va_end</code>：将参数列表指针设为<code>nullptr</code>，等效标记为end。</em></p>
</li>
<li>
<p><em><code>va_copy</code>： 将参数列表指针，赋值给另一个指针。</em></p>
</li>
</ul>
<p>参数列表并没有显式的结束标识，因此在传递参数时，需要使用固定参数指定可变参数个数，或者使用特殊参数值标识参数列表结束。</p>
<h5 id="传递数组作为参数-1"><a class="header" href="#传递数组作为参数-1">传递数组作为参数</a></h5>
<p>通过以上两种指针的定义及赋值，可以得知数组指针是有类型的，即数组指针的类型为：指明数组低维度长度的指针型变量，表示为：</p>
<pre><code class="language-c++">type (*ptr_name)[N]...;
</code></pre>
<p>数组指针类型用于定义数组对象或==传递数组参数==。</p>
<p>数组也可通过引用类型传递，但必须显式指定数组长度，传递的参数必须与声明长度相同（否则产生编译错误）。</p>
<pre><code class="language-c++">void print_array_ref(int (&amp;array)[5]);
</code></pre>
<p>由于长度固定，难以通用。因此<a href="CC++/Modern%20C++.html#%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92">传递数组参数</a>通常还是通过指针或容器对象（如<code>std::vector</code>和<code>std::array</code>）。</p>
<h5 id="传递函数作为参数-1"><a class="header" href="#传递函数作为参数-1">传递函数作为参数</a></h5>
<p><strong>函数指针</strong>：函数是特殊类型的对象，<strong>函数名是该对象的地址</strong>。可定义该函数类型的指针以引用该函数，并作为参数传递：</p>
<pre><code class="language-c++">return_type (*ptr_func)(arg_types,...);  // 定义函数类型时不需要形参名
ptr_func(arg_list);  // =&gt; (*ptr_func)(arg_list);
</code></pre>
<blockquote>
<p>函数指针<a href="https://www.cprogramming.com/tutorial/function-pointers.html">可自动解引用</a>，因此可以不添加<code>*</code>运算符。</p>
</blockquote>
<p>为了在定义函数参数时简化语法，可以预先定义函数类型：</p>
<pre><code class="language-c++">typedef return_type (* FunctionType)(arg_types);
using FunctionType = return_type (*)(arg_types); // [c++11]
call_func(FunctionType call_func);               // 传递函数参数
</code></pre>
<p><strong>函数对象</strong>：</p>
<pre><code class="language-c++">std::function&lt;return_type (arg_types)&gt; func_obj; // [c++11]
using func_type = std::function&lt;return_type (arg_types)&gt;;
</code></pre>
<h4 id="返回值-3"><a class="header" href="#返回值-3">返回值</a></h4>
<img src="CC++/Modern C++.assets/pass_parameters_return.png" alt="pass parameters" style="zoom: 40%;" />
<blockquote>
<p>返回多值：</p>
<ul>
<li>
<p>==使用结构体来构造多返回值结构==。</p>
</li>
<li>
<p>使用<code>tuple</code>和自动展开；</p>
<pre><code class="language-c++">std::make_pair(); // return tuple
</code></pre>
</li>
<li>
<p>使用数组<code>std::array</code>或向量<code>std::vector</code>（类型相同）；</p>
</li>
<li>
<p>==使用引用或指针类型输入参数作为输出参数==（可能产生歧义）。</p>
</li>
</ul>
</blockquote>
<h4 id="可选参数-1"><a class="header" href="#可选参数-1">可选参数</a></h4>
<pre><code class="language-c++">optional&lt;int&gt; x;
if (x) {}  // x若未经初始化，则判断条件为false；代替传统使用空指针判断值是否可用。
</code></pre>
<h3 id="函数重载-1"><a class="header" href="#函数重载-1">函数重载</a></h3>
<blockquote>
<p>functions with the same name but different <strong>parameter lists</strong>.</p>
</blockquote>
<p>如果一组函数具有相同的名称，但具有不同的输入参数模式（参数类型，参数个数，参数顺序），则这些参数可以同时存在于同一命名空间。重载（overload）就是在编译时通过传入参数的类型，来选择相应的函数。</p>
<p>不能通过访问权限、返回类型、抛出的异常进行重载。</p>
<blockquote>
<p>对于继承来说，如果某一方法在父类中是访问权限是<code>private</code>，那么就不能在子类对其进行重载，如果定义的话，也只是定义了一个新方法，而不会达到重载的效果。</p>
</blockquote>
<h4 id="运算符重载-3"><a class="header" href="#运算符重载-3">运算符重载</a></h4>
<p>运算符重载是对已有运算符赋予多重含义，使同一个运算符作用于不同类型的数据时导致不同的行为。<strong>运算符重载的实质是函数重载。</strong></p>
<p>运算符可重载为独立函数或类的<a href="CC++/Modern%20C++.html#%E6%88%90%E5%91%98%E8%BF%90%E7%AE%97%E7%AC%A6">成员函数</a>。运算符声明可能需要在相应操作数类定义中<a href="CC++/Modern%20C++.html#Friends">使用<code>friend</code>声明</a>以访问操作数的非公开成员。</p>
<pre><code class="language-c++">[friend] type operator op (params) { /*statements*/ } 
</code></pre>
<blockquote>
<p><code>op =&gt; +,-,*,/,[],++,--,... </code></p>
</blockquote>
<p>重载为成员函数时：</p>
<ul>
<li>对于单目运算符，则不需要参数；对于“++”和“--”，为了区分前置运算符和后置运算符，当重载为后置运算符是，增加一个整形参数，但该参数只用于区分，没有其它用途。</li>
<li>对于双目运算符，还需要将另一个操作数作为参数传入函数；</li>
</ul>
<h5 id="输出运算符-1"><a class="header" href="#输出运算符-1">输出运算符</a></h5>
<pre><code class="language-c++">ostream&amp; operator &lt;&lt; (ostream&amp; os, type T) 
{ os &lt;&lt; T.x &lt;&lt; T.y; return os; }
</code></pre>
<h5 id="比较运算符-3"><a class="header" href="#比较运算符-3">比较运算符</a></h5>
<p>C++使用值语义，因此比较运算符<code>==,!=</code>是比较对象的值。编译器不会自动为自定义类型生成比较运算符，需要自定义。</p>
<pre><code class="language-c++">bool operator==(T1 const&amp;, T2 const&amp;)const=default; // c++20
</code></pre>
<blockquote>
<p><code>=default</code>：自动生成默认比较运算符（递归比较所有成员变量），无需给出函数原型；</p>
<p>不用重载<code>!=</code>运算符，编译器会自动根据<code>==</code>的定义生成<code>!=</code>运算符的定义。</p>
<p><code>c++20</code>：compiler rewrites a call <code>a == b</code> as <code>b == a</code> if necessary。</p>
</blockquote>
<p><strong>双目运算符的交换问题</strong>：双目运算符的运算数类型如果不同，需要声明不同的操作符重载，以满足定义的交换律。</p>
<h3 id="优化-1"><a class="header" href="#优化-1">优化</a></h3>
<p><strong>Return Value Optimization (RVO)</strong>：在返回语句中构造对象时，将不会为返回值创建临时对象。</p>
<pre><code class="language-c++">Type create_object(){
  // ...
  return Type(...)  // Performing RVO
}
Type a = create_object();  
</code></pre>
<blockquote>
<p>由于类型在Stack上占用的空间在编译期间是确定的，因此编译器预先为返回值<code>a</code>在Stack上分配空间（==相当于调用一个空的默认构造函数==）。通过修改函数原型以及函数行为，将该空间地址通过指针传递给调用函数，在返回语句构造对象时使用传入地址指定的空间，而非重新在Stack上分配一段内存空间。当函数执行完成时，将上述预分配空间的地址绑定到返回值。整个过程仅执行一次对象构造，而为执行优化时，将执行一次构造函数和两次复制构造函数（从局部对象到临时对象，从临时对象到返回值，临时对象实际也是在调用对象前通过指针传入函数）。</p>
<p><a href="https://en.wikipedia.org/wiki/Copy_elision#Return_value_optimization">Copy elision - Wikipedia</a>。</p>
</blockquote>
<p><strong>Named Return Value Optimization (NRVO)</strong>：在返回语句中返回局部对象，将不会为返回值创建临时对象。</p>
<blockquote>
<p>类似地，NRVO则是在要返回的局部变量在构造时，使用上层传入的Stack空间。</p>
</blockquote>
<p><strong>内联（inlining）</strong>：Calls to small/short functions are replaced with the code of the function.</p>
<blockquote>
<p><em>Inlining is a lot harder or sometimes impossible in many other languages like Java, C#, etc. with <strong>always-on polymorphism</strong> which means that all/most function/method calls can only be resolved at runtime.</em></p>
</blockquote>
<h3 id="主函数-1"><a class="header" href="#主函数-1">主函数</a></h3>
<pre><code class="language-c++">#include &lt;iostream&gt;
int main (int argc, char* argv[]) {
  for(int i = 0; i &lt; argc; ++i) {
    std::cout &lt;&lt; argv[i] &lt;&lt; '\n';
  }
} // return 0 by default only for main function
</code></pre>
<blockquote>
<ul>
<li>names <code>argc</code> and <code>argv</code> are only a convention</li>
<li><code>argv[0]</code> contains the program call</li>
</ul>
</blockquote>
<h3 id="匿名函数-1"><a class="header" href="#匿名函数-1">匿名函数</a></h3>
<h4 id="lambda-class-1"><a class="header" href="#lambda-class-1">lambda class</a></h4>
<p>编译器自动生成的<a href="CC++/Modern%20C++.html#%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1">函数对象</a>，用于需要提供函数作为参数的位置。</p>
<pre><code class="language-c++">[](P const&amp; x, P const&amp; y){ return x.c &lt; y.c; }
[](auto x){ ... }         // c++14
[](auto const &amp; x){ ... }
[](auto &amp;x){ ... }
</code></pre>
<blockquote>
<p>输入参数为空则可以省略<code>()</code>。</p>
</blockquote>
<h5 id="closure-1"><a class="header" href="#closure-1">closure</a></h5>
<p>instance of lambda class。</p>
<p>保存外部作用域的变量：</p>
<pre><code class="language-c++">[=](...){...}     // captures all by value
[&amp;](...){...}     // captures all by reference
[=x,&amp;y](...){...} // captures x by value and y by reference
[= ,&amp;y](...){...} // captures all by value except y by reference
</code></pre>
<p>保存闭包：闭包类型由编译器确定，因此使用<code>auto</code>表示结果。</p>
<pre><code class="language-c++">auto f = [...](...){...}
</code></pre>
<h2 id="聚合类型-1"><a class="header" href="#聚合类型-1">聚合类型</a></h2>
<p>将多个基本类型变量组合成一个聚合类型，相当于一个简单类型，成员变量根据声明顺序在内存中连续存储。</p>
<p>聚合类型是对逻辑上相关的函数和数据的封装，是对问题的抽象描述。提供成员访问限制，自定义初始化、解构、复制和赋值，成员函数；<a href="https://hackingcpp.com/cpp/lang/custom_type_basics.html">保证类行为的不变性、清晰性和正确性</a>。</p>
<h5 id="结构体-3"><a class="header" href="#结构体-3">结构体</a></h5>
<pre><code class="language-c++">struct point {
  int x;  // ← &quot;member variable&quot;
  int y; 
};
point p1 = {10, 5};
point p2 {5, 10};    // c++11
</code></pre>
<blockquote>
<ul>
<li>semantic data grouping: <code>point</code>, <code>date</code>, …</li>
<li>avoids many function parameters and thus, confusion</li>
<li>can return multiple values from function with one dedicated type instead of multiple non-const reference output parameters</li>
</ul>
</blockquote>
<h5 id="类-6"><a class="header" href="#类-6">类</a></h5>
<pre><code class="language-c++">class ClassName: public classA,…, protected classB,…, private classC,… 
{
    public：				//外部接口
    	//构造函数
        ClassName()=default;
        [explicit]ClassName(args1, arg2,...){ /*initialization;*/}
        virtual ~ClassName()；//(虚)析构函数	
        //数据成员；
        using value_type = std::uint64_t;  //类型接口
        //函数成员；
        type func_name(params){}
    private：
    protected：//保护成员
};
</code></pre>
<blockquote>
<p>在C++中，<code>class</code>和<code>struct</code>关键字都可用于定义类，不同之处在于两者的默认访问权限不同（<code>class</code>是<code>private</code>，<code>struct</code>是<code>public</code>）。</p>
<p><em>Do not use leading underscores or double underscores in names of types, variables, functions, private data members</em>.</p>
</blockquote>
<p><strong>继承语法</strong>：访问修饰符指明基类成员的访问方式，如果不显式给出，则默认为私有继承。</p>
<p><strong>组合类</strong>：一个类的成员不仅包含基本数据类型，还包含其它<strong>类的对象</strong>。</p>
<h3 id="成员变量-1"><a class="header" href="#成员变量-1">成员变量</a></h3>
<h5 id="常量成员变量-1"><a class="header" href="#常量成员变量-1">常量成员变量</a></h5>
<p>==如果对象被声明成常量，那么限定只能调用对象的常成员函数以防止对象被修改。==</p>
<p>一般常量必须在声明时进行初始化，在C++的类中，常数据成员的初始化，在构造函数的初始化列表中完成，<em>而不能在声明时初始化</em>（C++11支持<a href="CC++/Modern%20C++.html#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%99%A8">声明时初始化</a>），或在构造函数的函数体中进行初始化。</p>
<h5 id="静态成员变量-1"><a class="header" href="#静态成员变量-1">静态成员变量</a></h5>
<p>如果某个属性为整个类所共有，不属于任何一个具体对象，则采用<code>static</code>关键字声明为静态成员变量。静态成员在每个类中只有一个实例，实现同一类的不同对象之间的数据共享。</p>
<p>类内部只是静态成员的声明，静态成员（包括常量）需要在程序的全局作用域的某个位置对其进行定义和初始化。</p>
<blockquote>
<p>由于类的静态成员变量在头文件中声明，其作用域为全局作用域而非文件作用域。因此需要将初始化放在某个源文件中，而不能放在头文件中；否则当头文件被多个源文件引用时，会分别执行多次定义产生符号冲突。</p>
</blockquote>
<pre><code class="language-c++">type class_name::static_var = value;
</code></pre>
<p><em>整数静态常量比较特别，可以在声明时进行初始化。</em></p>
<h3 id="资源管理-1"><a class="header" href="#资源管理-1">资源管理</a></h3>
<h4 id="构造函数-2"><a class="header" href="#构造函数-2">构造函数</a></h4>
<p>构造函数的函数名与类名相同，且没有返回值，被声明为公有函数。如果类中没有声明构造函数，或给出了无参构造函数的声明但没有给出实现，则编译器会自动生成一个默认的构造函数，不做任何事情；如果用户自定义了构造函数，则不会再自动生成默认构造函数，如果没有另外声明无参构造函数，则必须在声明对象时，提供必要的参数完成初始化。</p>
<blockquote>
<p>尽可能避免书写特殊成员函数，除非需要资源分配。使用<a href="CC++/Modern%20C++.html#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%99%A8">成员初始化器</a>可以执行默认初始化，使用智能指针、容器等可以尽量减少人工管理内存分配，从而避免自定义析构函数。</p>
</blockquote>
<h5 id="初始化列表构造函数-1"><a class="header" href="#初始化列表构造函数-1">初始化列表构造函数</a></h5>
<p>初始化列表<code>initializer_list</code>是一种特殊可迭代容器，用于序列类型的初始化。</p>
<pre><code class="language-c++">#include &lt;initializer_list&gt; // c++11
ClassA{ ClassA(std::initializer_list&lt;int&gt; li){...} }
ClassA a {1,3,4,5};   // {}调用初始化列表构造函数，而()调用其他构造函数
</code></pre>
<h5 id="复制构造函数-1"><a class="header" href="#复制构造函数-1">复制构造函数</a></h5>
<p><strong>复制构造函数</strong>是一种特殊的构造函数，具有一般构造函数的所有特性，其<strong>形参是本类对象的引用</strong>，其作用是使用一个已经存在的对象，去初始化一个同类型的新对象。如果没有在类中定义复制构造函数，则编译器会生成<strong>默认的复制构造函数</strong>，其功能是：<strong>把参数对象的每个数据成员的复制到新建立的对象中</strong>（如果声明了复制构造函数，则复制功能由复制构造函数完成，类将不会自动复制相应的变量）。</p>
<pre><code class="language-c++">ClassName(const ClassName &amp; obj);        //复制构造函数
ClassName(const ClassName &amp; obj)=delete; //禁用复制构造函数
</code></pre>
<p><strong>浅拷贝</strong>：C++默认是<a href="CC++/Modern%20C++.html#%E5%BC%95%E7%94%A8%E8%AF%AD%E4%B9%89">值语义</a>，因此进行赋值运算时，会复制类的所有成员，但使用原始指针引用的对象不会被复制（弱引用关系，不属于该类的成员）。==自定义复制构造函数和赋值运算符可以定义是否为指针引用的对象创建副本==。</p>
<pre><code class="language-c++">Object(const Object&amp; other){ // 默认复制类的成员
	memcpy(this, &amp;other,  sizeof(Object))   
}
</code></pre>
<p>复制构造函数的调用情况：</p>
<ol>
<li>
<p>当用类的一个对象去初始化该类的另一个对象。</p>
</li>
<li>
<p>如果函数的形参是类的对象，调用函数时，用实参初始化形参。</p>
</li>
<li>
<p>如果函数的返回值是类的对象，函数执行完返回时，为了完成从子函数到主函数的值传递，创建一个临时对象，初始化该对象。</p>
</li>
</ol>
<p><strong>如果类不包含动态分配的资源，则一般使用默认的构造函数就足够了</strong>。
一般情况，每个对象所拥有的资源应该是相互独立的，这样一个对象的操作才不会影响到另一个对象。
但是使用默认复制构造函数，只能完成成员变量即相关资源的标识符的复制，而不能自动完成动态资源的分配。
这时候就需要程序定义复制构造函数，来完成动态分配资源的分配和值的复制。</p>
<p>“<code>=</code>”操作符的意义在于使用一个对象向另一个同类型对象赋值，这和初始化时使用一个对象对同类型对象进行初始化的原理基本相同。
“<code>=</code>”操作符的处理==可能还需要先释放对象已分配的资源==，再申请新的资源。
如果没有定义“<code>=</code>”操作符，则会自动生成一个与默认复制构造函数具有相同功能的操作符定义，因此，默认的“<code>=</code>”操作符并不能完成具有动态资源的对象的复制。
<strong>通常，定义了复制构造函数也就意味着需要定义“<code>=</code>”操作符</strong>。</p>
<pre><code class="language-c++">ClassName&amp; ClassName::operator = (ClassName const&amp;);
</code></pre>
<p>https://en.cppreference.com/w/cpp/language/copy_constructor</p>
<h5 id="移动语义-1"><a class="header" href="#移动语义-1">移动语义</a></h5>
<p>将对象在堆上的空间与新对象进行交换（新对象可能并未分配堆空间）。</p>
<pre><code class="language-c++">std::swap(a,b);
</code></pre>
<h6 id="移动构造函数和移动赋值函数-1"><a class="header" href="#移动构造函数和移动赋值函数-1">移动构造函数和移动赋值函数</a></h6>
<pre><code class="language-c++">ClassName(const ClassName &amp;&amp; obj); //移动构造函数
ClassName&amp; ClassName::operator = (ClassName const&amp;&amp;); //移动赋值运算符
</code></pre>
<p>https://hackingcpp.com/cpp/lang/move_semantics.html</p>
<h4 id="初始化-2"><a class="header" href="#初始化-2">初始化</a></h4>
<blockquote>
<p><u>R</u>esource <u>A</u>cquisition <u>I</u>s <u>I</u>nitialization (RAII)</p>
<ul>
<li>acquire some resource (memory, file handle, connection, …) when object is constructed</li>
<li>release/clean up resource when object is destroyed (de-allocate memory, close connection, …)</li>
</ul>
</blockquote>
<p>对象所占据的内存空间只是用于存放数据成员，函数成员不在每个对象中存储副本。但是如果该类包含<a href="CC++/Modern%20C++.html#%E8%99%9A%E5%87%BD%E6%95%B0">虚函数</a>，则虚函数地址存放在虚函数表中，将占用内存空间。</p>
<h5 id="成员初始化列表-1"><a class="header" href="#成员初始化列表-1">成员初始化列表</a></h5>
<p>通过构造函数的初始化列表对成员变量进行初始化（构造）。==初始值可以来自构造函数的参数。====初始化列表也可以调用本类的其他构造函数代替单独变量初始化。==</p>
<pre><code class="language-c++">class Foo {
   int i_;     // 1st
   double x_;  // 2nd
public:    
   Foo(): i_{10}, x_{3.14} { }  // same order: i_ , x_
   Foo(int i, double x): i_(i), x_(x) {}
};
</code></pre>
<blockquote>
<p>成员初始化列表：使用<code>()</code>或<code>{}</code>（C++11: narrowing conversion）传递参数。</p>
</blockquote>
<p>初始化列表应首先给出父类的初始化声明，再给出当前类中成员变量的初始值（初始化顺序与成员的声明顺序保持一致）。构造函数执行的次序：</p>
<ol>
<li>
<p>调用父类的构造函数初始化父类成员，顺序与继承声明一致（从左到右）；</p>
</li>
<li>
<p>初始化基本类型或调用成员的构造函数，调用顺序与内嵌对象在类中声明的次序一致；</p>
<blockquote>
<p>当未在初始化列表给出成员的初始化声明，则会调用该类型的默认构造函数（此时该类型需要具有默认构造函数）。而如果在构造函数体内对该成员通过赋值进行初始化，则会重复执行构造，造成性能开销。==因此应该优先使用成员初始化列表。==</p>
</blockquote>
</li>
<li>
<p>执行构造函数体的内容。</p>
</li>
</ol>
<h5 id="隐式类型转换-1"><a class="header" href="#隐式类型转换-1">隐式类型转换</a></h5>
<p>只有一个参数的构造函数，其调用形式与强制类型转换的语法相同，因此，等效于同时重载了由指定类型到当前类型的<a href="CC++/Modern%20C++.html#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E8%BF%90%E7%AE%97%E7%AC%A6">（隐式）类型转换运算符</a>。</p>
<pre><code class="language-c++">type y;
ClassName x = y; // =&gt; 隐式转换：className x = ClassName(y);
</code></pre>
<blockquote>
<p>当构造函数被<code>explicit</code>关键字修饰时，则不会同时重载该运算符，因此上述代码不会进行隐式转换，从而赋值语句类型不兼容。</p>
</blockquote>
<h5 id="初始化器-1"><a class="header" href="#初始化器-1">初始化器</a></h5>
<p>C++11支持在声明成员变量时给出默认初始值。</p>
<pre><code class="language-c++">class Foo {
  int i_ = 10;
  double x_ = 3.14;
};
</code></pre>
<h4 id="析构函数-1"><a class="header" href="#析构函数-1">析构函数</a></h4>
<p><strong>析构函数</strong>与构造函数的作用基本相反，用来完成对象被删除前的一些清理工作，在对象的生命期即将结束时被自动调用。和构造函数不同的是，析构函数不接受任何参数，但可以是<strong>虚函数</strong>。声明虚析构函数必须给出实现（参考虚函数）。</p>
<p>析构函数调用顺序由类的继承关系决定，与构造函数的调用顺序相反：即类本身的析构函数，类成员对象的析构函数，基类的析构函数。由于析构函数是自动调用的，因此无需显示调用父类析构函数。</p>
<h3 id="成员函数-1"><a class="header" href="#成员函数-1">成员函数</a></h3>
<p>成员函数可以在类的声明之外单独定义（使用作用域限定符），在类声明中仅给出声明。</p>
<pre><code class="language-c++">type ClassName::func_name(params){}
</code></pre>
<blockquote>
<p>代码量较小的函数应该尽量放置于类定义中，以方便“内联”优化。</p>
</blockquote>
<blockquote>
<p><a href="https://hackingcpp.com/cpp/lang/custom_type_basics.html">How to</a> implement a feature / add new functionality?</p>
<ul>
<li>only need to access public data (e.g. via member functions) ⇒ implement as free standing function</li>
<li>need to access private data ⇒ implement as member function</li>
</ul>
<p>==use &quot;action&quot; functions instead of just &quot;setters&quot;==：usually models problems better; more fine-grained control; better code readability / expression of intent</p>
</blockquote>
<p>在成员函数中访问成员变量/函数：</p>
<h5 id="this指针-1"><a class="header" href="#this指针-1"><code>this</code>指针</a></h5>
<p>非静态成员函数的参数隐含了当前实例的指针<code>this</code>。</p>
<p>如果在<code>Class</code>的成员函数中没有可见的同名局部作用域标识符，那么在该函数内可以直接访问成员<code>Member</code>。反之，非静态成员需要通过<code>this</code>指针进行访问<code>this-&gt;Member</code>。</p>
<blockquote>
<p>也可以使用作用域限定符<code>::</code>访问类成员，通常作用域限定符用于<a href="CC++/Modern%20C++.html#%E8%AE%BF%E9%97%AE%E9%9D%99%E6%80%81%E6%88%90%E5%91%98">访问静态成员</a>，而实例成员通过<code>this</code>指针访问。</p>
</blockquote>
<p>此外，<code>this</code>指针还可以用于在类内部调用需要该类指针的函数。</p>
<h4 id="成员运算符-3"><a class="header" href="#成员运算符-3">成员运算符</a></h4>
<p>当运算符的第一个参数是自定义类型，可将该运算符定义/重载为自定义类的成员。</p>
<blockquote>
<p>当第一个参数不是自定义类类型，则<a href="CC++/Modern%20C++.html#%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD">重载为独立运算符</a>。也可将独立运算符在类内部以<code>friends</code>修饰以确保其能访问类的内部数据。</p>
</blockquote>
<h5 id="类型转换运算符-1"><a class="header" href="#类型转换运算符-1">类型转换运算符</a></h5>
<p>类型转换函数用于自动==将类对象转换成其他兼容类型的对象==，从而实现类似基本数据类型隐式转换的功能。类型转换函数通过重载“<code>(...)</code>”操作符实现：</p>
<pre><code class="language-c++">public operator type();   // 定义方法将当前类型转换为type
</code></pre>
<p>该函数原型比较特别，没有返回值，也不需要提供参数。但是函数结束前必须返回<code>type</code>类型的值。</p>
<blockquote>
<p><em>指针转换运算符是为了方便对自定义模板类的指针进行强制类型转换而重载的，因为系统不能直接把自定义类的指针强制转换成基本类型的指针。指针转换运算符的重载函数比较特殊，它没有返回值（连void也没有）。</em></p>
</blockquote>
<h5 id="函数对象-2"><a class="header" href="#函数对象-2">函数对象</a></h5>
<p>重载<code>()</code>运算符的类。 ==函数对象可以通过私有变量保存内部状态==。</p>
<pre><code class="language-c++">public type operator (args); // 注意函数原型与类型转换运算符的区别
obj(args);                   // 调用()重载的函数。
</code></pre>
<h5 id="成员引用运算符-1"><a class="header" href="#成员引用运算符-1">成员引用运算符*</a></h5>
<p>当一个类封装另一个类对象或指针时（例如智能指针），如果要透明访问被封装类的成员，可以重载<code>-&gt;</code>运算符（普通版本以及常量版本）：</p>
<pre><code class="language-c++">InternalObject* operator-&gt;(){ return prt_obj;}
ExternalObject* m = new ExternalObject();
m-&gt;some_interal_member;
</code></pre>
<h5 id="和运算符-1"><a class="header" href="#和运算符-1">“<code>=</code>”和“<code>[]</code>”运算符</a></h5>
<p>这两种运算符的适用场合，有可能作为表达式的左值出现，如</p>
<pre><code class="language-c++">A[5]=2;
(a=b)++;  
</code></pre>
<p>作为左值的量都必须是变量，否则无法进行赋值或自加等操作，这就要求在重载“<code>=</code>”和“<code>[]</code>”运算符时返回变量；由于<strong>函数的返回值是一个右值</strong>（<a href="CC++/Modern%20C++.html#Rvalues-and-Lvalues">临时变量</a>），所以不满足要求。</p>
<p>所以<strong>在重载这两个操作符时，返回值应该是引用类型</strong>。当然，<strong>由于局部变量在函数结束时就消失了，所以不能返回局部变量的引用，否则对引用的操作将出现错误。</strong></p>
<p>“<code>=</code>”返回左操组数（上面例子中a）的引用；</p>
<p>“<code>[]</code>”返回左操作数（上面例子的A）的索引对应项的引用。只能重载一维数组下标操作符（如何重载多维下标http://blog.sina.com.cn/s/blog_66ec4d660100mxq5.html）。</p>
<h4 id="静态成员函数-1"><a class="header" href="#静态成员函数-1">静态成员函数</a></h4>
<pre><code class="language-c++">static type static_function_declare();
class_name::static_function();   // 调用静态成员函数
</code></pre>
<p>静态成员函数只能访问类的静态成员函数/变量。</p>
<h4 id="常量成员函数-1"><a class="header" href="#常量成员函数-1">常量成员函数</a></h4>
<pre><code class="language-c++">type member_function_declare() const;
</code></pre>
<blockquote>
<p><code>const</code>可以用于修饰函数的返回值，表示对函数的返回值不可以做修改。</p>
</blockquote>
<p>使用<code>const</code>关键字修饰成员函数，意味着成员函数具有“只读”属性，而不能修改对象（<strong>实例成员变量</strong>）或者调用任何非常成员函数。</p>
<blockquote>
<p>使用<code>mutable</code>修饰的成员是例外，可以被<code>const</code>方法修改。</p>
</blockquote>
<p><code>const</code>可以用于成员函数的重载（在声明和定义处都需要使用<code>const</code>修饰），当对象被声明成常量时，则该实例只能访问使用<code>const</code>成员函数，因为只有这样才能保证类的成员变量不会被修改。</p>
<blockquote>
<p>对于一般对象，则常函数成员和非常函数成员都可以被调用。</p>
<p>当对象是变量时，优先调用同名非常成员函数（当没有声明非常成员函数时，调用同名常成员函数）。</p>
</blockquote>
<p><code>const</code>-qualify all non-modifying member functions。</p>
<h5 id="访问静态成员-1"><a class="header" href="#访问静态成员-1">访问静态成员</a></h5>
<p>静态成员不与类的实例绑定，需要通过作用域限定符和类名进行访问。</p>
<pre><code class="language-c++">ClassName::StaticMember;
ClassName::StaticMemberFunction(args);
</code></pre>
<h3 id="访问限制-1"><a class="header" href="#访问限制-1">访问限制</a></h3>
<p>在类内部，所有的数据成员的为其成员函数所共享；通过静态数据成员，实现同一类的不同对象之间的数据共享。</p>
<p><strong>访问关系是针对于类而言的，并不是针对类的实例</strong>。即对象的成员函数可以访问同一类型对象的所有成员变量。</p>
<blockquote>
<p>访问控制的主要作用是限定代码的组织方式，对程序运行没有影响；实际上可以通过操纵指针绕过访问控制限制。</p>
</blockquote>
<img src="CC++/Modern C++.assets/access_control.png" style="zoom: 67%;" />
<h4 id="friends-1"><a class="header" href="#friends-1">Friends</a></h4>
<pre><code class="language-c++">class A{…… friend class B; …… }  // friend class
class A{…… type function(args); …… } // friend function
</code></pre>
<p><strong>友元函数</strong>是在类中用关键字<code>friend</code>修饰的非成员函数，可以是普通函数也可以是其他类的成员函数，虽然它不是本类的成员函数，但是可以访问本类的私有和保护成员。</p>
<p>**友元关系是不能传递的：**A是B的友元，B是C的友元，如果没有声明，A和C是没有友元关系的；</p>
<p>**友元关系是单向的：**A是B的友元，如果没有声明，则B不是A的友元；</p>
<p>**友元关系是不被继承的：**如果A是B的友元，但A的派生类，如果没有声明，则不是B的友元。</p>
<h3 id="自定义类型-1"><a class="header" href="#自定义类型-1">自定义类型</a></h3>
<p>https://hackingcpp.com/cpp/design/arithmetic_types.html</p>
<p>https://hackingcpp.com/cpp/design/node_based_data_structures.html</p>
<h2 id="程序结构-5"><a class="header" href="#程序结构-5">程序结构</a></h2>
<h3 id="命名空间-3"><a class="header" href="#命名空间-3">命名空间</a></h3>
<p><a href="https://en.cppreference.com/w/cpp/language/namespace">Namespaces - cppreference.com</a></p>
<ul>
<li>避免命名冲突；</li>
<li>将内容分为不同的部分。</li>
</ul>
<blockquote>
<p>命名空间仅用于防止命名冲突，不具有访问控制作用（访问控制修饰符修饰命名空间无效）。</p>
</blockquote>
<h5 id="定义-1"><a class="header" href="#定义-1">定义</a></h5>
<pre><code class="language-c++">namespace my{
    class vector {...};
    namespace time{...}
}
</code></pre>
<p>一个文件中可以定义多个命名空间；同时，一个命名空间也可以出现在多个文件中。</p>
<p>命名空间可嵌套定义。</p>
<h5 id="引入命名空间-1"><a class="header" href="#引入命名空间-1">引入命名空间</a></h5>
<pre><code class="language-c++">my::vector v1;
using my::vector;  // 单独引入命名空间中的定义
vector v2;
using my;   // 引入命名空间中的所有定义
namespace mt = my::time;  // 定义命名空间别名简化书写
</code></pre>
<blockquote>
<p>避免在头文件中引入命名空间：引入命名空间会导入其中所有的声明到头文件中。该头文件再被其他文件引用时，可能造成命名冲突。</p>
</blockquote>
<h3 id="标识符作用域-1"><a class="header" href="#标识符作用域-1">标识符作用域</a></h3>
<ol>
<li>
<p>局部作用域：在代码块中声明的标识符，其作用域从声明处开始，一直到块结束的大括号为止。**具有局部作用域的变量也称为局部变量。**函数体、控制语句块，空语句块等都是局部作用域。</p>
</li>
<li>
<p>类作用域：类<code>Class</code>的成员<code>Member</code>具有类作用域，其范围为类的定义。</p>
</li>
<li>
<p>文件作用域：<strong>具有文件作用域的标识符其作用域开始于声明点，结束于文件尾。具有文件作用域的变量也称为全局变量。</strong></p>
<p>命名空间将文件作用域进行了逻辑划分；</p>
</li>
</ol>
<h4 id="可见性-3"><a class="header" href="#可见性-3">可见性</a></h4>
<p>程序运行到某一点在，能够引用到的标识符就是该处可见的标识符。作用域可见性的规则：</p>
<ol>
<li>标识符声明在前，引用在后；</li>
<li>在同一作用域中不能定义同名标识符；</li>
<li>在没有互相包含关系的不同作用域中定义的同名标识符，互不影响；</li>
<li>如果在两个或多个具有包含关系的作用域中声明了同名标识符，则外层标识符在内层不可见。</li>
</ol>
<h4 id="作用域限定符-1"><a class="header" href="#作用域限定符-1">作用域限定符</a></h4>
<p>用于在默认规则不可见的位置访问某些标识符。</p>
<ul>
<li>访问命名空间中的成员（例如<code>std::cout</code>）；</li>
<li>在类定义外部，定义函原型和初始化静态变量；</li>
<li>访问静态成员；</li>
<li>在类内部，识别多继承的同名成员；</li>
</ul>
<p><em>对于静态成员</em>，则通过作用域分辨符<code>::</code>进行访问：<code>ClassName::M</code>。</p>
<p><em>多继承的父类成员可见性</em>。</p>
<h4 id="前向声明-1"><a class="header" href="#前向声明-1">前向声明</a></h4>
<p>​    两个类不能相互引用作为其定义的一部分，因为这样无法确定任何一个类的类型。但是两个类可以相互引用其指针作为定义的一部分。</p>
<p>​    如果出现以上相互引用的情况下，一般地，应该互相包含其头文件，但这样又会造成头文件内容无法确定。为了解决这一问题，C++引入了前向声明，即==在定义类之前对类名进行声明==，则无需包含该类定义所在的头文件，即可定义该类的指针。</p>
<pre><code class="language-c++">class c_a;
class c_b{
	c_a *p_a;
}
</code></pre>
<h2 id="多态-3"><a class="header" href="#多态-3">多态</a></h2>
<h3 id="继承-3"><a class="header" href="#继承-3">继承</a></h3>
<p><strong>类的继承，是新类从已有类那里得到已有的特性。同时，从已有类产生新类的过程就是派生</strong>。由原有类产生新类时，新类便包含了原有类的特性，同时也可以加入自己所有的新特性。</p>
<p>从对象的数据存储来看，组合类和派生的作用一样：如果把派生类的父类的实例都添加到一个新类的定义中，则派生类的这个新类有相同的数据成员，只是组织形式不同。但是组合类只能利用现有类提供的功能并在新类中定义新功能，而派生类在此基础上可以提供多态行为，即子类可以通过虚函数覆盖父类的同名函数。反之，如果不需要更改父类行为，使用组合类更简洁。</p>
<h4 id="构造析构函数-1"><a class="header" href="#构造析构函数-1">构造/析构函数</a></h4>
<p>根据构造函数调用规则，应该在子类的初始化列表中调用父类构造函数。</p>
<h4 id="虚继承-1"><a class="header" href="#虚继承-1">虚继承</a></h4>
<h3 id="成员函数重载-1"><a class="header" href="#成员函数重载-1">成员函数重载</a></h3>
<p>运算符重载</p>
<h3 id="覆盖-1"><a class="header" href="#覆盖-1">覆盖</a></h3>
<p>具有相同函数原型（即相同的函数名与输入参数列表）的函数不满足重载的条件，不能存在于同一命名空间。但具有相同原型的函数可存在于父类（接口）与子类（实现）中。子类（实现）提供的具有相同原型的函数是对父类（接口）的相应函数进行重定义，以替换原有的功能，这种方式称为覆盖（override）。</p>
<h5 id="隐藏-1"><a class="header" href="#隐藏-1">隐藏</a></h5>
<p>当子类中定义与父类同名函数时，将无法直接访问父类的同名函数（即使非重载形式）。此时需要使用父类指针（在类外部）或作用域限定符（类内部）访问父类函数。</p>
<blockquote>
<p>多继承情况下，如果继承多个父类的同名函数，也会导致父类同名函数的隐藏。</p>
</blockquote>
<h4 id="虚函数-1"><a class="header" href="#虚函数-1">虚函数</a></h4>
<p>对于从同一父类派生出的不同类的对象，如果使用==父类的指针==统一进行管理与访问，可以明显的简化程序。但使用父类指针引用子类对象只能访问到父类中定义的成员，而不能访问子类中的成员。<strong>如果需要使用父类的指针访问子类中的成员函数，就需要首先在父类中将该函数声明为虚函数（<strong>不能通过父类指针访问子类数据成员</strong>）</strong>。</p>
<p><strong>虚函数是动态绑定的基础，虚函数必须是非静态的成员函数</strong>，虚函数经过派生后，在类族中就可以实现运行过程中的多态。虚函数的声明语法：</p>
<pre><code class="language-c++">virtual type function_name(arg_list);   // in parent class
type function_name（arg_list）override {statements} // in child class
</code></pre>
<blockquote>
<p>[1] C++ 虚函数表解析. http://blog.csdn.net/haoel/article/details/1948051/。</p>
</blockquote>
<p>虚函数的修饰符只能出现在类中函数声明处，而不能在函数实现处。在子类中不需要显式地给出虚函数的声明，当子类的成员函数满足重载条件时就会自动确定为虚函数。被覆盖的父类函数，任然可以通过作用域标识符来访问。</p>
<h5 id="虚函数的适用条件-1"><a class="header" href="#虚函数的适用条件-1">虚函数的适用条件</a></h5>
<p><strong>当子类需要修改父类的行为时，就应该将父类的相应函数声明为虚函数</strong>。而父类中声明的非虚函数，通常代表那些不希望被子类改变的功能，也是不能实现多态的。因此一般不要重写继承而来的非虚函数（虽然语法没有限制）。</p>
<p>在重写继承来的虚函数时，<strong>不能改变函数的默认形参值</strong>，因为：虽然虚函数是动态绑定的，但是默认形参值是静态绑定的。</p>
<p>虚函数必须给出实现，否则应该声明为<a href="CC++/Modern%20C++.html#%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0">纯虚函数</a>。</p>
<h5 id="虚析构函数-1"><a class="header" href="#虚析构函数-1">虚析构函数</a></h5>
<p>使用父类指针访问子类对象完成后，如果子类对象是动态分配的，这时存在的一个问题是：能否直接<code>delete</code>父类指针，完成子类对象的删除。在动态分配内存时，系统会记录下所分配的内存的首地址和分配长度，因此在执行删除操作时，无论指针指向的是父类对象还是子类对象，都能够正确的释放对象所占用的内存。</p>
<p>但是如果动态创建的对象中还有指向动态分配的内存空间的指针成员，则这样的删除就是不完全的，因为这些指针成员指向的动态分配的内存空间并不能得到释放（如同深拷贝与浅拷贝的原理一样，在构造函数中，浅拷贝只会复制指针，而不会另外增加一份指针指向的内容，这时需要深拷贝手动完成内容的赋值）。</p>
<p>动态空间的释放显然应该由析构函数来完成，其中父类的构造函数释放父类对象动态申请的内存空间，子类的构造函数释放子类对象动态申请的内存空间。当使用父类指针来实现多态时，由于通过父类指针只能直接访问父类成员，析构函数也是一样，这种情况下访问不到子类的析构函数（对象通过<code>delete</code>销毁获声明周期结束时，只会调用父类的构造函数），则不能完成子类动态分配空间的释放，因此要将父类的析构函数声明为虚函数。</p>
<h3 id="抽象类-3"><a class="header" href="#抽象类-3">抽象类</a></h3>
<p>抽象类用于抽象和设计接口。一个抽象类无法实例化，只能通过继承将抽象类改写为非抽象类，然后再实例化。可以定义抽象类的指针和引用，通过指针和引用，就可以访问子类的对象，实现多态性。</p>
<h4 id="纯虚函数-1"><a class="header" href="#纯虚函数-1">纯虚函数</a></h4>
<p>抽象类是带有纯虚函数的类。抽象方法、接口。</p>
<pre><code class="language-c++">virtual tpye function_name(args...) = 0;
</code></pre>
<p>抽象类派生出新类后，如果子类中给出了所有纯虚函数的函数实现，这个子类就不再是抽象类，而可以实例化；反之，如果子类中没有完全给出所有纯虚函数的实现，那么这个子类就仍然是抽象类。</p>
<h2 id="模板-1"><a class="header" href="#模板-1">模板</a></h2>
<p>模板定义语法</p>
<pre><code class="language-c++">template &lt;typename T,..., args&gt; declaration;  
</code></pre>
<p>其中，<code>declaration</code>可以表示函数或类的声明语法。模板参数包括：</p>
<ol>
<li>
<p><strong>类型参数</strong>，使用类型定义关键字（<code>class</code>或<code>typename</code>）或者嵌套定义的类模板类型（<code>template &lt;typename T,...&gt;ClassName</code>）；</p>
</li>
<li>
<p><strong>非类型参数</strong>，参数类型可以是整数，枚举，指针，引用或指向成员的指针，且==在编译时可以确定为常量==（类似于数组长度）。</p>
</li>
</ol>
<blockquote>
<p>模板参数可设置默认值。</p>
</blockquote>
<p><strong>编译器根据模板生成实际代码</strong>：定义模板并不定义实际类型或函数，只有在使用模板并传递相应的参数时，编译器才真正添加一个类型或函数。</p>
<p><a href="CC++/../CSharp.NET/CSharp%E6%95%B0%E6%8D%AE%E5%AE%B9%E5%99%A8.html#%E6%B3%9B%E5%9E%8B%E5%92%8C%E9%9D%9E%E6%B3%9B%E5%9E%8B%E5%AE%B9%E5%99%A8">泛型</a>：<a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/programming-guide/generics/differences-between-cpp-templates-and-csharp-generics">C++ 模板和 C# 泛型之间的区别</a>。</p>
<h3 id="函数模板-1"><a class="header" href="#函数模板-1">函数模板</a></h3>
<p>函数模板的声明语法：</p>
<pre><code class="language-c++">template &lt;typename T1, typename T2,...&gt;
T2 function_name(T param,...){statements}  
</code></pre>
<p>类型参数用来指定函数模板的参数类型和返回值类型，以及声明函数中的变量类型等。</p>
<h5 id="实例化-1"><a class="header" href="#实例化-1">实例化</a></h5>
<pre><code class="language-c++">fucntion_name&lt;T&gt;(args);   // 可省略类型参数，当类型可由参数推导出
</code></pre>
<h3 id="类模板-1"><a class="header" href="#类模板-1">类模板</a></h3>
<p>使用类模板使用户可以为类声明一种模式，使得类中的某些数据成员，某些成员函数的参数、返回值能取任意类型（包括系统预定义的和用户自定义的）。类模板的定义语法：</p>
<pre><code class="language-c++">template &lt;typename T1, typename T2, ..., int n,...&gt;  
class ClassName{member_declaration}  
</code></pre>
<p>在类模板内部定义成员的方法与普通类成员的定义语法一样，可能用到模板参数表中定义的类型或数值参数。模板类成员可以是静态或非静态，数据或函数成员。</p>
<blockquote>
<p>如果要在类模板定义范围以外定义其成员函数，则必须指定其所属的模板类，且模板类要指定相应的模板参数，即采用以下定义形式</p>
<pre><code class="language-c++">template &lt; class T1,class T2, ..., int  n,...&gt;
T2 ClassName&lt;T1,T2,...,n...&gt;::functionname(arg_list){statements}  
</code></pre>
<p>静态数据成员的定义方法也类似。</p>
</blockquote>
<p>类模板的成员函数也可作为函数模板来定义，即增加额外的模板参数，其声明和定义语法如下所示。</p>
<pre><code class="language-c++">template &lt;typename A1,...&gt;
class ClassName(args_list){
   template&lt;typename T1,...&gt; 
   T1 function_identifer(A1 param1, ...){statements}
}  
</code></pre>
<p>==（在类中的声明形式与一般函数一致），而不能如普通类一样，将成员函数的实现放到源文件中（否则或出现链接错误，LINK2019/2001）==。</p>
<h4 id="类模板实例化-1"><a class="header" href="#类模板实例化-1">类模板实例化</a></h4>
<p>使用一个模板类建立对象时，应该按以下形式声明：</p>
<pre><code class="language-c++">ClassTemplate&lt;T1,T2,...,n,...&gt;obj1;  
</code></pre>
<h3 id="完美转发-1"><a class="header" href="#完美转发-1">完美转发</a></h3>
<div style="break-before: page; page-break-before: always;"></div><h1 id="开发环境-3"><a class="header" href="#开发环境-3">开发环境</a></h1>
<h2 id="编辑器"><a class="header" href="#编辑器">编辑器</a></h2>
<p><a href="https://code.visualstudio.com/">Visual Studio <em>Code</em></a> </p>
<p>VIM </p>
<h2 id="编译-3"><a class="header" href="#编译-3">编译</a></h2>
<p><img src="CC++/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83.assets/compile_single_file.png" alt="img" /></p>
<h3 id="编译器"><a class="header" href="#编译器">编译器</a></h3>
<h5 id="gccg"><a class="header" href="#gccg">gcc/g++</a></h5>
<pre><code class="language-shell">sudo apt-get install -y g++
sudo apt-get install -y build-essential
</code></pre>
<pre><code class="language-shell">g++ -std=c++17 -Wall -Wextra -Wpedantic input.cpp -o output
</code></pre>
<p><code>-g</code>：compile for debugging; avoid optimization level <code>-O1,-O2,-O3</code>, use <code>-O0, -Og</code> instead.</p>
<p><code>-D MACRO</code>： 定义宏；</p>
<p><code>-I path</code>：添加搜索路径；</p>
<p><code>-l lib</code>：添加外部库；</p>
<p><code>-L path</code>：外部库目录；</p>
<blockquote>
<p>The use of <code>gcc</code> does not add the C++ library.  <code>g++</code> is a program that calls <code>gcc</code> and automatically specifies linking against the C++ library.</p>
<p><a href="https://www.cnblogs.com/samewang/p/4774180.html">GCC的gcc和g++区别</a>。</p>
</blockquote>
<h5 id="clangclang"><a class="header" href="#clangclang">clang/clang++</a></h5>
<pre><code class="language-shell">sudo apt-get install -y clang
sudo apt-get install -y build-essential
</code></pre>
<p>在规模较大的项目中，往往需要多个源程序文件，每个源程序文件称为一个<strong>编译单元。一个类的声明必须出现在所有使用该类的编译单元中。</strong></p>
<h3 id="链接"><a class="header" href="#链接">链接</a></h3>
<p>跨目标文件查找符号（变量、函数）并进行关联。</p>
<p>默认的程序入口函数为<code>main</code>，可通过连接器选项指定。</p>
<blockquote>
<p><code>static</code>声明的函数只会在当前文件作用域被调用，因此当此函数未在该文件中被调用时，链接器不会尝试去链接该函数内部调用的其他函数。</p>
</blockquote>
<h4 id="静态链接"><a class="header" href="#静态链接">静态链接</a></h4>
<h5 id="外部库的路径"><a class="header" href="#外部库的路径">外部库的路径</a></h5>
<p>包含目录<code>$INCLUDE</code>：头文件的搜索路径；</p>
<p>库目录<code>$LIB</code>：库文件的搜索路径；</p>
<blockquote>
<p><a href="CC++/C++%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83.html#VC++%E9%A1%B9%E7%9B%AE%E5%B1%9E%E6%80%A7%E9%85%8D%E7%BD%AE">Visual Studio</a>: 在<code>c++</code>项目属性中配置Visual C++目录。</p>
</blockquote>
<h5 id="链接到外部库"><a class="header" href="#链接到外部库">链接到外部库</a></h5>
<p>为连接器指定库文件。</p>
<blockquote>
<p>Visual Studio：在<code>c++</code>项目属性中配置“连接器/附加依赖项”，在给定库目录路径后，只需给出文件名即可。在同一解决方案下的库，可使用“添加/引用”的方式导入依赖库。</p>
</blockquote>
<p>静态链接可以执行链接优化。</p>
<h4 id="动态链接"><a class="header" href="#动态链接">动态链接</a></h4>
<p><code>xxxdll.lib</code></p>
<p>将<code>xxx.dll</code>文件放置在可执行文件所在目录（或设置库目录）。</p>
<h3 id="工具链-1"><a class="header" href="#工具链-1">工具链</a></h3>
<h4 id="make-1"><a class="header" href="#make-1">make</a></h4>
<p>先声明最后的输出文件（可执行文件）的构建命令，然后分别声明依赖文件的构建命令。<code>make</code>根据依赖关系决定是否继续查找后续目标，然后反向执行命令。</p>
<pre><code class="language-makefile">prog: main.o dbl.o
	g++ main.o dbl.o -o prog
main.o : main.cpp
	g++ -c main.cpp
dbl.o : dbl.cpp
	g++ -c dbl.cpp  # tab for indentation
clean:
	rm -rf *.o prog
install:
   install prog /usr/local/bin/
</code></pre>
<blockquote>
<p>仅编译更新过的源文件、目标文件。</p>
<p><a href="https://makefiletutorial.com/">Makefile Tutorial By Example</a></p>
</blockquote>
<h5 id="设置编译器选项cflags"><a class="header" href="#设置编译器选项cflags">设置编译器选项（CFLAGS）</a></h5>
<pre><code class="language-sh"> ./configure CFLAGS='-g -O2 -w' CXXFLAGS='-g -O2 -w'
 make CFLAGS='-g -O2 -w' CXXFLAGS='-g -O2 -w'
</code></pre>
<h5 id="编译项目"><a class="header" href="#编译项目">编译项目</a></h5>
<pre><code class="language-shell">make &amp; make install # building project and install the software
make clean			# cleaning the building output
make uninstall		# uninstall the software from the configured location
</code></pre>
<h4 id="cmake"><a class="header" href="#cmake">cmake</a></h4>
<p>https://cliutils.gitlab.io/modern-cmake。</p>
<pre><code class="language-shell">sudo apt install cmake
</code></pre>
<p>https://https//github.com/lefticus/cpp_starter_project。</p>
<pre><code class="language-cmake"># Makefile
camke_minimum_required(VERSION 3.5)
project (HelloWorld)
set (CMAKE_CXX_FLAGS &quot;$CMAKE_CXX_FLAGS -Wall -Werror -std=c++11&quot;)
set (source_dir &quot;$PROJECT_SOURCE_DIR/src/&quot;)
file (GLOB source_files &quot;$source_dir/*.cpp&quot;)
add_executable (HelloWorld $(source_files))
</code></pre>
<pre><code class="language-shell">Cmake -G &quot;Codelite - Unix Makefiles&quot; -DCMKAE_BUILD_TYPE=Debug
</code></pre>
<h4 id="msbuild"><a class="header" href="#msbuild">MSBuild</a></h4>
<h4 id="build2"><a class="header" href="#build2">build2</a></h4>
<h4 id="qmake"><a class="header" href="#qmake">QMake</a></h4>
<h2 id="ide"><a class="header" href="#ide">IDE</a></h2>
<h3 id="visual-studio-1"><a class="header" href="#visual-studio-1">Visual Studio</a></h3>
<ul>
<li>
<p><a href="https://visualstudio.microsoft.com/free-developer-offers">Visual Studio Free Community Edition</a></p>
<blockquote>
<p>VisualAssist</p>
</blockquote>
<h5 id="vc项目属性配置"><a class="header" href="#vc项目属性配置">VC++项目属性配置</a></h5>
<p>目录配置：使用宏（<code>例如$(SolutionDir)</code>）配置输出目录。</p>
<p>配置类型：可执行文件（<code>.exe</code>）、静态库（<code>.lib</code>）、动态库（<code>.dll</code>）……。</p>
<p>语言标准：</p>
<p>C++/CLI属性</p>
</li>
<li>
<p><a href="https://www.qt.io/qt-features-libraries-apis-tools-and-ide/#ide">Qt Creator</a> </p>
</li>
<li>
<p><a href="https://codelite.org/">CodeLite</a></p>
<blockquote>
<h5 id="code-completion"><a class="header" href="#code-completion">Code Completion</a></h5>
<ul>
<li><strong>C++</strong> code completion: powerful and amazingly fast code completion based on our in-house parser (supports C++11 auto keyword, templates, inheritance etc)</li>
<li><strong>clang</strong> based code completion for <strong>C++</strong> projects - based on the CLANG/LLVM project - this feature provides a compiler level code completion</li>
<li>Parse and display doxygen comments in the code completion box (as a separated floating window)</li>
</ul>
<h5 id="compilers"><a class="header" href="#compilers">Compilers</a></h5>
<ul>
<li>Generic support for compilers with built-in support for GCC/clang/VC++</li>
<li>Display errors as code annotations or as tooltip in the editor window</li>
<li>Errors are clickable via the <strong>Build</strong> tab</li>
</ul>
<h5 id="lldb-support"><a class="header" href="#lldb-support">LLDB Support</a></h5>
<h5 id="gdb-support"><a class="header" href="#gdb-support">GDB Support</a></h5>
<ul>
<li>Watches table - add persistent watches with a single click</li>
<li>Quick Watch - right click on a variable to expand it</li>
<li>Locals tree - automatically displays the current stack variables (also displays *this if available)</li>
<li>Threads view - contains a list of currently-running threads; switch between them with a single click</li>
<li>Breakpoint management - disable, enable, conditional, temporary</li>
<li>Automatic <strong>tree</strong> like tooltips</li>
<li>Memory view</li>
<li>Tree View tooltips (auto de-references pointers)</li>
<li>Allow modifying tooltips</li>
</ul>
<h5 id="refactoring"><a class="header" href="#refactoring">Refactoring</a></h5>
<ul>
<li>Rename symbol, local symbol</li>
<li>Rename file (will also change all <code>#include</code> in the code)</li>
<li>Generate setters / getters</li>
<li>Implement inherited virtual functions</li>
<li>Implement inherited pure-virtual functions</li>
<li>Easily change function signature to match its header / implementation counterpart</li>
<li>Move functions implementation to another source file</li>
<li>Implement all unimplemented methods</li>
<li>Implement method</li>
</ul>
<h5 id="source-control-plugins"><a class="header" href="#source-control-plugins">Source Control Plugins</a></h5>
</blockquote>
</li>
</ul>
<h2 id="标准库-1"><a class="header" href="#标准库-1">标准库</a></h2>
<p>标准模板库（STL）。</p>
<p>Microsoft 基础类 (MFC) 通过 Win32 提供面向 C++ 对象的包装，以便实现本机桌面应用程序的快速开发。 活动模板库 (ATL, ActiveX Template Library) 是一个包装库，它简化了 COM 开发，广泛用于创建 ActiveX 控件。</p>
<h2 id="工具集"><a class="header" href="#工具集">工具集</a></h2>
<p>命令行工具：</p>
<div class="table-wrapper"><table><thead><tr><th>工具</th><th>命令</th><th>说明</th></tr></thead><tbody>
<tr><td><code>hexdump</code></td><td><code>hexdump -C file</code></td><td>查看文件的十六进制编码</td></tr>
<tr><td><code>readelf</code></td><td><code>readelf -aW file</code></td><td>查看ELF二进制文件结构</td></tr>
<tr><td></td><td></td><td></td></tr>
</tbody></table>
</div>
<h3 id="red-hat-developer-toolset"><a class="header" href="#red-hat-developer-toolset">Red Hat Developer Toolset</a></h3>
<blockquote>
<p><em><a href="https://access.redhat.com/documentation/en-us/red_hat_developer_toolset/10/html/user_guide/chap-red_hat_developer_toolset">Red Hat Developer Toolset does not replace the default system tools</a>.</em></p>
<p>Enable Red Hat Developer Toolset by using Red Hat Subscription Management.</p>
</blockquote>
<pre><code class="language-shell">yum install devtoolset-10 # all development, debugging, and performance monitoring tools
# devtoolset-10-toolchain
# devtoolset-10-perftools
</code></pre>
<p>使用指定的工具</p>
<pre><code class="language-shell">scl enable devtoolset-10 'gcc -o output_file source_file...'
scl enable devtoolset-10 'bash' # 使开发工具集中的执行程序成为默认
</code></pre>
<p><a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/8/html-single/developing_c_and_cpp_applications_in_rhel_8">Developing C and C++ applications in RHEL 8 Red Hat Enterprise Linux 8 | Red Hat Customer Portal</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="c容器"><a class="header" href="#c容器">C++容器</a></h1>
<h2 id="概述"><a class="header" href="#概述">概述</a></h2>
<p>标准容器都是模板类型，可以指定自定义的数据类型。</p>
<p>容器分为三类：序列容器、关联容器、容器适配器。</p>
<p><strong>序列容器</strong>保持元素添加的顺序，允许指定插入元素的位置。序列容器类型包括，<code>vector</code>、<code>list</code>和<code>deque</code>（双端队列）。<code>string</code>类具有与序列容器相同的基本操作。</p>
<p><strong>关联容器</strong>的元素以预先给定的顺序插入，例如排序顺序，分为两个子类：<code>map</code>(dictionary)和<code>set</code>。<code>map</code>(dictionary)由key/value组成，其中key用于排序。<code>set</code>中的元素按升序排列。</p>
<p>容器适配器包括：<code>stack</code>，<code>queue</code>，<code>priority_queue</code>。容器适配器不支持迭代，不能用于STL算法。</p>
<h3 id="迭代器-3"><a class="header" href="#迭代器-3">迭代器</a></h3>
<p>标准库为每一种标准容器定义了<strong>迭代器类型</strong><code>container&lt;type&gt;::iterator</code>（常量迭代器类型<code>container&lt;type&gt;::const_iterator</code>）。</p>
<pre><code class="language-c++">container.begin();     // → @first_element
container.end();       // → @one_behind_last_element
std::begin(container); // → @first_element
std::end(container);   // → @one_behind_last_element
</code></pre>
<blockquote>
<p>使用<code>@pos</code>代表迭代器。</p>
</blockquote>
<p><code>rbegin()</code>，<code>rend()</code>用于反向迭代。</p>
<p><code>const_iterator</code>类型只能用于读取容器内元素，但不能改变其值，返回迭代器的函数以<code>c</code>开头，与<code>iterator</code>类型的返回函数对应。</p>
<h4 id="迭代器运算"><a class="header" href="#迭代器运算">迭代器运算</a></h4>
<pre><code class="language-c++">vector&lt;int&gt; v {1,2,3,4,5,6,7}
auto i = begin(v);   // 获取迭代器
auto e = end(v);
cout &lt;&lt; *i;    // 访问容器元素
++i;   // =&gt; pos=std::next(pos);     // move to end() by 1 element
--i;   // =&gt; pos=std::prev(pos);     // move to begin() by 1 element
i+=2;  // =&gt; pos=std::next(pos,2);   // move forward
i-=3;  // =&gt; pos=std::next(pos, -3); // move backward
</code></pre>
<blockquote>
<p><code>end()</code>返回的迭代器不指向任何元素。迭代器的移动运算结果只有在<code>begin()</code>到<code>end()</code>之间才是有效的。</p>
</blockquote>
<p>同指针一样，可以<strong>使用解引用操作符（<code>*, -&gt;</code>）来访问容器中的元素</strong>。</p>
<p>用<code>==</code>或<code>!=</code>运算符来比较两个迭代器，如果两个迭代器对象指向同一个元素，则它们相等，否则就不相等。</p>
<h4 id="迭代区间"><a class="header" href="#迭代区间">迭代区间</a></h4>
<p>容器的部分操作支持以迭代区间作为参数。</p>
<pre><code class="language-c++">vector&lt;int&gt; v (begin(u)+i, begin(u)+j);   // [i,j)
w.assign(begin(u)+i, end(u)+j);
</code></pre>
<h3 id="容器初始化类型推断-c17"><a class="header" href="#容器初始化类型推断-c17">容器初始化类型推断 <code>C++17</code></a></h3>
<pre><code class="language-c++">std::vector v {1, 2, 3, 4};   // std::vector&lt;int&gt;
</code></pre>
<h3 id="容器属性"><a class="header" href="#容器属性">容器属性</a></h3>
<p><code>size</code>，获取容器的长度（元素数量）；<code>empty</code>，判断容器是否为空。</p>
<pre><code class="language-c++">size_type n = v.size();
bool tf = v.empty();   // [c++17] std::empty(container)
</code></pre>
<h3 id="容器方法"><a class="header" href="#容器方法">容器方法</a></h3>
<h5 id="赋值-4"><a class="header" href="#赋值-4">赋值</a></h5>
<p><code>assign</code>，为容器重新赋值；“<code>=</code>”操作符。</p>
<pre><code class="language-c++">v.assign(@First, @Last); 
</code></pre>
<h5 id="比较-2"><a class="header" href="#比较-2">比较</a></h5>
<p>同类型容器间比较，对于<code>==</code>，元素数量相同且对应值相等返回<code>true</code>。其他运算符包括<code>!=</code>，<code>&lt;</code>，<code>&gt;</code>，<code>&gt;=</code>，<code>&lt;=</code>。</p>
<pre><code class="language-c++">bool values_same = s1 == s2;  // true
</code></pre>
<h5 id="删除-1"><a class="header" href="#删除-1">删除</a></h5>
<pre><code class="language-c++">c.erase(@pos)        // → @behind_deleted
c.erase(@begin,@end) // → @behind_last_deleted
</code></pre>
<p><code>clear</code>，删除容器中的所有元素，等价于调用<code>erase(begin(),end())</code>。</p>
<pre><code class="language-c++">void clear( );  
</code></pre>
<h5 id="遍历访问"><a class="header" href="#遍历访问">遍历访问</a></h5>
<p>适用于所有序列容器和关联容器。</p>
<pre><code class="language-c++">for(type variable : container){}// no out-of-bounds access possible
</code></pre>
<blockquote>
<p>迭代变量声明：</p>
<ul>
<li><code>type variable</code>：read-only, type cheap to copy；</li>
<li><code>type const &amp; variable</code>：read-only, type expensive to copy；</li>
<li><code>type &amp; variable</code>：modify values；</li>
<li><code>auto</code>：支持自动类型推导。</li>
</ul>
</blockquote>
<pre><code class="language-c++">range::for_each(v, func);       // c++20: no out-of-bounds access possible
range::for_each(@begin, @end, func); 
range::for_each_n(@begin, n, func);  // c++17: only for n elements
</code></pre>
<p>在循环中使用迭代器。</p>
<h6 id="反向遍历"><a class="header" href="#反向遍历">反向遍历</a></h6>
<pre><code class="language-c++">for(type variable : container | std::views::reverse){} // c++20
#include &lt;ranges&gt;  // std::ranges::for_each
namespace ranges = std::ranges;        // alias
namespace views = std::ranges::views;  // alias
ranges::for_each(views::reverse(v), [](auto x){ cout &lt;&lt; x; }); 
</code></pre>
<blockquote>
<p>works for all bidirectional containers.</p>
</blockquote>
<p>使用反向迭代器<code>rbegin(), rend()</code>。</p>
<h2 id="简单容器-1"><a class="header" href="#简单容器-1">简单容器</a></h2>
<pre><code class="language-c++">#include &lt;utility&gt;
pair&lt;int, double&gt; p {4, 2.0};
tuple&lt;int, double, vector&lt;int&gt;&gt; t = {4,2.0, vector&lt;int&gt;{1,2,3}} //c++11
</code></pre>
<blockquote>
<p><code>c++17</code>支持类型自动推导。</p>
<pre><code class="language-c++">std::tie(i,j,k) = func_return_tuple();  // 展开返回参数
auto [i,j,k] = func_return_tuple_or_struct();  //c++17
</code></pre>
</blockquote>
<h2 id="序列容器"><a class="header" href="#序列容器">序列容器</a></h2>
<h5 id="array"><a class="header" href="#array">array</a></h5>
<p><img src="CC++/hackingcpp/sequence_containers_array.png" alt="" /></p>
<p><code>array</code>类型不支持更改容器的容量。</p>
<pre><code class="language-c++">#include &lt;array&gt;
std::array&lt;int,6&gt; a {4,8,15,16,23,42}; // array长度必须在编译期间确定（常量）
</code></pre>
<h3 id="序列容器支持的操作"><a class="header" href="#序列容器支持的操作">序列容器支持的操作</a></h3>
<h5 id="赋值-5"><a class="header" href="#赋值-5">赋值</a></h5>
<pre><code class="language-c++">v.assign(count, value);
</code></pre>
<h5 id="属性-6"><a class="header" href="#属性-6">属性</a></h5>
<p><code>max_size</code>，在不断分配内存情况下，允许存储的元素最大数量；。</p>
<pre><code class="language-c++">size_type n = v.max_size();  
</code></pre>
<p><code>resize</code>：更改容器的长度，如果没有指定初始值，新增加的值被设为默认初始值。</p>
<pre><code class="language-c++">v.resize(size_type n);  
v.resize(size_type n, value);  
</code></pre>
<blockquote>
<p>将容器长度设置为0等价于<code>v.clear()</code>。</p>
</blockquote>
<h5 id="访问"><a class="header" href="#访问">访问</a></h5>
<p>返回容器中最后一个/第一个元素。</p>
<pre><code class="language-c++">[const_]reference back( ) [const];
[const_]reference front( ) [const];  
</code></pre>
<p>如果容器为空，则返回结果不确定。如果将返回值赋值给常量引用，则返回值不能被修改，如果赋值给普通引用，则返回值可以修改。</p>
<h5 id="插入-2"><a class="header" href="#插入-2">插入</a></h5>
<p><code>insert</code>，<code>emplace</code>*，在迭代器指定位置插入单个，多个值或连续的一列值；</p>
<pre><code class="language-c++">v.insert(@pos, value);         // return 
v.insert(@pos, T&amp;&amp;value); 
v.insert(@pos, count, value);
v.insert(@pos, @first, @Last);
v.insert(@pos, list);
v.emplace(@pos, Args&amp;&amp;...args); //[c++11]
</code></pre>
<p>返回插入的首个元素的迭代器，如果未插入任何元素，返回<code>@pos</code>。<code>emplace</code>直接用参数构造的对象插入容器（<a href="https://hackingcpp.com/cpp/lang/perfect_forwarding.html">完美转发</a>）。</p>
<blockquote>
<ul>
<li>引用容器的位置参数<code>@pos</code>从普通迭代器变为常量迭代器<code>c++11</code>；</li>
<li>插入容器的值支持移动语义<code>c++11</code>；</li>
<li>返回值类型从迭代器变为常量迭代器<code>c++20</code>。</li>
</ul>
</blockquote>
<p><code>push_back</code>，<code>emplace_back</code>，在容器末端插入元素；</p>
<pre><code class="language-c++">void push_back(value);
void emplace_back(Args&amp;&amp;...args);  
</code></pre>
<blockquote>
<p><code>emplace_back</code>提供可变参数列表适配构造函数，当参数是容器元素引用时，调用移动构造函数，和其他容器的调用方法一致。</p>
</blockquote>
<h5 id="删除-2"><a class="header" href="#删除-2">删除</a></h5>
<p><code>pop_back</code>，从容器末端删除一个元素；</p>
<pre><code class="language-c++">void pop_back( );  
</code></pre>
<p>其他操作：交换，释放额外存储空间，保留最小存储空间。</p>
<h4 id="序列容器的特殊操作"><a class="header" href="#序列容器的特殊操作">序列容器的特殊操作</a></h4>
<h5 id="随机访问"><a class="header" href="#随机访问">随机访问</a></h5>
<p><code>vector</code>和<code>deque</code>支持随机访问，因此可以使用<code>at()</code>、操作符“<code>[]</code>”返回指定位置的元素，如果索引值大于容器的大小，则<code>at</code>抛出异常，而运算符“<code>[]</code>”的返回值是不确定的。如果将返回值赋值给常量引用，则返回值不能被修改，如果赋值给普通引用，则返回值可以修改。</p>
<pre><code class="language-c++">[const_]reference at(size_type _Pos) [const];
[const_]reference operator[](size_type _Pos)  [const];  
</code></pre>
<p>利用随机访问特性，可以使用序号遍历容器元素。</p>
<pre><code class="language-c++">for (int i = 0; i &lt; v.size(); ++i){cout &lt;&lt; v[i];}
</code></pre>
<h5 id="插入和删除"><a class="header" href="#插入和删除">插入和删除</a></h5>
<p><code>push_front，pop_front，emplace_front</code>，由于<code>list</code>支持在任意位置快速插入/删除元素，<code>deque</code>支持在首尾快速插入，因此这两个插入函数为<code>list</code>和<code>deque</code>提供更高效的插入方式。</p>
<h3 id="vector"><a class="header" href="#vector">vector</a></h3>
<p><img src="CC++/hackingcpp/sequence_containers_vector.png" alt="" /></p>
<p><code>vector</code>是序列容器（Array/List），元素按照线性方式存储，允许快速地随机访问。<code>vector</code>不提供查找功能。</p>
<pre><code class="language-c++">#include &lt;vector&gt;
using namespace std;
template &lt;
   		class Type, 					//元素数据类型
   		class Allocator = allocator&lt;Type&gt; 
&gt; class vector;
vector&lt;int&gt; v {2, 7, 9}; 
</code></pre>
<p>在<code>vector</code>末端进行插入和删除只需花费常数时间，在中间插入或删除需要线性时间。</p>
<blockquote>
<p><code>dequeue</code>容器优先用于在队列的首尾插入以及随机访问，<code>list</code>容器优先用于在任意位置插入或删除。</p>
</blockquote>
<p>当<code>vector</code>中的元素数目达到其容量时，<code>vector</code>就会重新分配存储空间，插入和删除也会造成元素存储地址的改变，这种情况下==先前创建的迭代器可能会失效==。</p>
<h4 id="构造函数-3"><a class="header" href="#构造函数-3">构造函数</a></h4>
<pre><code class="language-c++">vector&lt;int&gt; v2;     // vector(); =&gt; vector&lt;int&gt; v2{};  空向量
vector&lt;int&gt; v2(v1); // vector(const vector&amp; v);   拷贝构造函数
</code></pre>
<blockquote>
<p><strong>Copies Are Always <em>Deep</em>!</strong> Most types in the C++ standard library and ecosystem are <em>regular</em>.</p>
</blockquote>
<pre><code class="language-c++">vector&lt;int&gt; v2(5);    // explicit vector(count);   
vector&lt;int&gt; v2(5,2);  // vector(count, value); 
</code></pre>
<p>创建一个空的<code>vector</code>或创建大小为<code>count</code>的向量，指定<code>vector</code>的元素，如果没有指定元素的值，则元素值为类型的默认值。</p>
<pre><code class="language-c++">vector&lt;int&gt; v2 (@start, @end);  // vector(@First, @Last);
</code></pre>
<p>用指定的<code>vector</code>的一段来初始化新的<code>vector</code>。<code>First</code>是指向被拷贝段的第一个元素的迭代器，<code>Last</code>指向被拷贝元素后的一个元素。</p>
<h4 id="成员函数-2"><a class="header" href="#成员函数-2">成员函数</a></h4>
<pre><code class="language-c++">int n = v.capacity();
</code></pre>
<p>在目前不增加分配内存时，容器可储存的最大元素数量。</p>
<p>预留容量：与构造函数初始化指定数量的元素不同，预留的容量未被使用，而是用于后续添加的元素。</p>
<pre><code class="language-c++">v.reserve(new_capacity);
</code></pre>
<blockquote>
<p>缩小容量：</p>
<pre><code class="language-c++">shrink_to_fit 
v = vector&lt;int&gt;(v); // C++11-20
</code></pre>
</blockquote>
<h3 id="deque"><a class="header" href="#deque">deque</a></h3>
<p><img src="CC++/hackingcpp/sequence_containers_deque.png" alt="" /></p>
<p><code>deque</code>类（<u>D</u>ouble <u>E</u>nded <u>Q</u>ueue）以线性方式组织数据元素，与<code>vector</code>一样允许快速的随机访问以及高效地在末端插入和删除元素。但与<code>vector</code>不一样的，<code>deque</code>也支持==高效地在首端插入和删除元素==。</p>
<pre><code class="language-c++">#include &lt;deque&gt;
using namespace std;
template &lt;
   		class Type, 
   		class Allocator=allocator&lt;Type&gt; 
&gt; class deque
</code></pre>
<p>当成员函数需要插入或删除元素时，<code>deque</code>将会重新分配内存：</p>
<blockquote>
<ul>
<li>如果向空容器中插入元素，或将元素移除后容器为空，则先前返回的begin()或end()迭代器都会变成无效的。</li>
<li>如果在首端插入一个元素，则指向元素的所有迭代器（并非引用）将变成无效的。</li>
<li>如果在末端插入一个元素，则指向元素的所有迭代器（并非引用）将编程无效的。</li>
<li>如果<code>deque</code>容器首端的元素被移除，则只有被移除元素的引用和指针变为无效。</li>
<li>如果<code>deque</code>容器末端的元素被移除，则只有被移除元素的引用和指针变为无效。</li>
<li>其他情况，插入或删除将会导致所有迭代器和指针都变为无效的。</li>
</ul>
</blockquote>
<h4 id="构造函数-4"><a class="header" href="#构造函数-4">构造函数</a></h4>
<pre><code class="language-c++">deque();                // 空的deque容器
explicit deque(count);  // 大小为count的deque容器(默认值)
deque(count, value);    // 大小为count值为value的deque容器
deque(const deque&amp; d);  // 拷贝构造
deque(@first, @last);
</code></pre>
<h4 id="成员函数-3"><a class="header" href="#成员函数-3">成员函数</a></h4>
<p>在容器前端插入/删除元素：</p>
<pre><code class="language-c++">d.push_front(2);
d.pop_front();
</code></pre>
<h3 id="list-2"><a class="header" href="#list-2">list</a></h3>
<p><img src="CC++/hackingcpp/sequence_containers_list.png" alt="" /></p>
<p><code>list</code>使用双向链表存储，支持高效的插入和删除。</p>
<pre><code class="language-c++">#include &lt;list&gt;
using namespace std;
template&lt;class Type, class Allocator=allocator&lt;Type&gt;&gt; class list
</code></pre>
<h4 id="构造函数-5"><a class="header" href="#构造函数-5">构造函数</a></h4>
<pre><code class="language-c++">list();               // 创建空列表
explicit list(count); // 创建大小为count的列表
list(count, value);   // 创建的元素都被初始化为value。
list(const list&amp; li); // 使用已有列表创建新的列表
list(@first, @last);
</code></pre>
<h4 id="成员函数-4"><a class="header" href="#成员函数-4">成员函数</a></h4>
<h5 id="删除-3"><a class="header" href="#删除-3">删除</a></h5>
<p>删除所有匹配值对应的元素或满足条件的元素。</p>
<pre><code class="language-c++">li.remove(value);
template&lt;class UnaryPredicate&gt; // [](int n){return n&gt;10;}
    void remove_if(UnaryPredicate pred);
</code></pre>
<blockquote>
<p><code>C++20</code>：返回移除的元素数量。</p>
</blockquote>
<p>删除重复或满足条件的<strong>连续</strong>元素。</p>
<pre><code class="language-c++">li.unique();
template&lt;class BinaryPredicate&gt; void unique(BinaryPredicate _Pred);
</code></pre>
<blockquote>
<p><code>unique</code>假设列表经过了排序，所以重复元素都可以被检测到，而不连续的重复元素不能被检测到。</p>
<p>在<code>&lt;functional&gt;</code>和<code>&lt;xfunctional&gt;</code>中定义了部分比较条件，也可以自己定义比较条件。</p>
</blockquote>
<h5 id="排序-3"><a class="header" href="#排序-3">排序</a></h5>
<pre><code class="language-c++">li.sort();  // 默认升序
template&lt;class Compare&gt; void sort(Compare comp);
</code></pre>
<blockquote>
<p><code>comp</code>：比较函数对象。可以是一个返回<code>bool</code>值的二元比较函数，或者是一个重载了“<code>()</code>”运算符作为比较函数。</p>
<pre><code class="language-c++">class compare{
    public: bool operator()(left, right)const{
        return left.val&gt;_Right.val;
    }
};
</code></pre>
</blockquote>
<p>将队列反向排列：</p>
<pre><code class="language-c++">void reverse();
</code></pre>
<h5 id="合并操作"><a class="header" href="#合并操作">合并操作</a></h5>
<p>从一个列表将元素转移到另一个列表（移除另一个列表中的元素）。</p>
<pre><code class="language-c++">li.splice(@where, list&amp; other); //移动所有元素，other!=*this
li.splice(@where, list&amp; other, @first); //仅移动迭代器指向的元素
li.splice(@where, list&amp; other, @first, @last); //移动一个区间的元素(@where不应该位于区间内)
</code></pre>
<p>将转移的元素插入到<code>@where</code>引用的元素之前。</p>
<blockquote>
<p>不会复制或移动任何元素，仅修改内部指针；迭代器不会失效，但指向当前容器中的元素。</p>
<p>The behavior is undefined if: <code>get_allocator() != other.get_allocator()</code>.</p>
<p><code>C++11</code>列表参数支持移动语义（<code>list &amp;&amp;other</code>）</p>
</blockquote>
<p><code>merge</code>合并两个有序列表。</p>
<pre><code class="language-c++">li.merge(list&amp; other); 
template&lt;class Compare&gt;
    void merge(list&amp; other, Compare comp); 
</code></pre>
<p>合并规则：根据比较规则<code>comp</code>（默认为<code>&lt;</code>运算符，即升序），取出两个队列队首较小的元素放入新的队列（实际上不需要改变<code>*this</code>，而是将<code>other</code>的元素插入到<code>*this</code>中）。</p>
<p><code>merge</code>适用于已经排序的列表（<code>li.sort()</code>）的合并，合并后的结果仍然有序；反之，元素排列结果不确定（根据合并规则与实际值有关）。</p>
<h3 id="forward_list"><a class="header" href="#forward_list">forward_list</a></h3>
<p>单向链表（只能前向遍历）。</p>
<p><img src="CC++/hackingcpp/sequence_containers_forward_list.png" alt="" /></p>
<blockquote>
<p>somewhat cumbersome interface due to forward-only links</p>
<ul>
<li>no: <code>size()</code>, <code>back()</code>, <code>push_back()</code>, <code>pop_back()</code>, <code>insert()</code></li>
<li>instead: <code>insert_after()</code>, <code>splice_after()</code>, <code>before_begin()</code></li>
</ul>
</blockquote>
<h3 id="string"><a class="header" href="#string">string</a></h3>
<p>字符串动态数组，基本元素为<code>char</code>的<code>basic_string</code>具体类（类似于<code>vector&lt;char&gt;</code>）。<code>wstring</code>是基本元素为<code>wchar_t</code>的<code>basic_string</code>具体类。</p>
<pre><code class="language-c++">#include &lt;string&gt;
using namespace std;
typedef basic_string
         &lt;char,char_traits&lt;char&gt;,allocator&lt;char&gt;&gt; string;
typedef basic_string
         &lt;wchar_t,char_traits&lt;wchar_t&gt;,allocator&lt;wchar_t&gt;&gt; wstring;
</code></pre>
<h4 id="初始化-3"><a class="header" href="#初始化-3">初始化</a></h4>
<p>使用[字符串数组](Modern C++.md#字符串常量)初始化：没有指定字符数的函数则表示用整个字符串来初始化<code>string</code>。</p>
<pre><code class="language-c++">string s0;          // string();  empty string
string s1 = &quot;xyz&quot;;  // string(char const* ptr_cstr);
string(char const* ptr_cstr, count);
</code></pre>
<p>使用字符初始化。</p>
<pre><code class="language-c++">string(size_type count, char ch);
</code></pre>
<p>使用<code>string</code>类型字面值（后缀<code>s</code>）初始化：</p>
<pre><code class="language-c++">using namespace std::string_literals;
string s2 = &quot;std string literal&quot;s;   // string类型字面值[c++14]
string(str, @first, count);
string(@first, @last);
string s = R&quot;(raw &quot;std&quot;-string c:\users\moe )&quot;s;  // raw string literal[C++14]
</code></pre>
<h4 id="访问-1"><a class="header" href="#访问-1">访问</a></h4>
<p>除了<code>size()</code>之外，还有<code>length()</code>函数可返回<code>string</code>的元素总数（底层字符串的字节长度<code>size=length</code>）。</p>
<pre><code class="language-c++">char ch = str[index];
</code></pre>
<h5 id="底层数据"><a class="header" href="#底层数据">底层数据</a></h5>
<p>C-style字符串可以通过<code>string</code>的构造函数自动转换为<code>string</code>，但是<code>string</code>不能自动转换为C-style的字符串，需要使用以下函数。</p>
<pre><code class="language-c++">const char *c_str( ) const;	
const char *data( ) const;	
</code></pre>
<p>由于返回的是常量指针，所以不能通过返回的指针修改字符串。</p>
<p>返回指向<code>string</code>的字符内容的C-style字符串常量指针，当调用<code>string</code>的非<code>const</code>函数时，会导致指针变为无效。<code>string</code>的数据不会以“<code>\0</code>”结尾，“<code>\0</code>”在<code>string</code>对象中只是一个普通字符，但是返回的C-style字符串是以“<code>\0</code>”结尾的。</p>
<p><strong>复制字符串的内容</strong>：拷贝字符到字符数组，返回实际拷贝的字符数，不会在拷贝结果后面自动添加<code>null</code>字符，所以在拷贝前最好将源数组先初始化为全0。</p>
<pre><code class="language-c++">size_type copy(char* _Ptr, size_type _Count, size_type _Off = 0) const;
size_type _Copy_s(value_type *_Dest, size_type _Dest_size, 
                  size_type _Count, size_type _Off = 0) const;
</code></pre>
<h4 id="查找-3"><a class="header" href="#查找-3">查找</a></h4>
<p><code>find</code>：指向查找指定字符或字符串，返回首个符合条件的子串的首字符位置，如果没找到则返回<code>string::npos</code>(<code>=-1</code>)。</p>
<pre><code class="language-c++">s.find(&quot;r&quot;);
s.rfind(&quot;r&quot;);
</code></pre>
<p><code>find_first_of</code>：寻找首个属于制指定字符串的字符，找到返回其索引，否则返回<code>npos</code>。</p>
<p><code>find_first_not_of</code>：返回首个不属于指定子串的字符的位置，没找到则返回<code>npos</code>。</p>
<p><code>find_last_not_of</code>：寻找最后一个不在字串中的字符。</p>
<p><code>find_last_of</code>：寻找最后一个在字串中的字符。</p>
<p>查找子串：</p>
<pre><code class="language-c++">s.substr(idx, len)
</code></pre>
<h4 id="修改-1"><a class="header" href="#修改-1">修改</a></h4>
<p>==直接在目标字符串上作修改==。</p>
<h5 id="拼接-3"><a class="header" href="#拼接-3">拼接</a></h5>
<p>运算符<code>+</code>、<code>+=</code>：将字符、C-style字符串或<code>string</code>的部分或全部内容追加到目标字符串，返回目标字符串的引用。</p>
<pre><code class="language-c++">string&amp; append(const char* ptr);
string&amp; append(const char* ptr, count);
string&amp; append(other);
string&amp; append(other, offset, count);
string&amp; append(count, char ch);
string&amp; append(&amp;First, &amp;Last);
string&amp; append(@First, @Last);
</code></pre>
<blockquote>
<p>参数意义参考构造函数。</p>
<p>这里的迭代器或指针“<code>_Last</code>”是指要插入的最后一个元素的后一个位置，如果是整个插入一个<code>string</code>，则<code>_Last=string.end()</code>，如果插入整个C-style字符串，则<code>_Last=&amp;cstring[strlen(cstring)]</code>。</p>
</blockquote>
<h5 id="插入-3"><a class="header" href="#插入-3">插入</a></h5>
<p>在指定位置插入内容。</p>
<pre><code class="language-c++">str.insert(int idx, &quot;new content&quot;);
str.insert(@pos, &amp;first, &amp;last);
str.insert(@pos, @first, @last);
</code></pre>
<h5 id="删除-4"><a class="header" href="#删除-4">删除</a></h5>
<p><code>erase</code>（参考容器方法）：从字符串的指定位置删除一个元素或一部分元素。</p>
<pre><code class="language-c++">s.erase(index, count)
</code></pre>
<h5 id="替换-1"><a class="header" href="#替换-1">替换</a></h5>
<pre><code class="language-c++">s.replace(idx, len, &quot;contents&quot;)
</code></pre>
<h5 id="转换为数值"><a class="header" href="#转换为数值">转换为数值</a></h5>
<pre><code class="language-c++">#include &lt;string&gt; C++11
int    stoi (s);
long   stol (s);
float  stof (s);
double stod (s);
</code></pre>
<h3 id="序列类型视图"><a class="header" href="#序列类型视图">序列类型视图</a></h3>
<p>试图不负责资源的管理，仅是资源的一种表示方式。</p>
<ul>
<li>视图主要用于函数参数（轻量级复制），易于获取序列类型的子序列，总是引用有效内存，且使用<code>view</code>的对象不会破坏对象所有者的内存。</li>
<li>避免返回视图，容易产生无效视图，且不清楚该视图引用的是什么对象/内存。</li>
</ul>
<h4 id="string_view"><a class="header" href="#string_view">string_view</a></h4>
<p>==只读==访问：常量引用（<code>C++98/11/14</code>）；视图（<code>c++17/20</code>）；</p>
<pre><code class="language-c++">#include &lt;string_view&gt;  //c++17
std::string_view sv1 { str };
std::string_view sv2 {@pos, count}; //从@pos起连续count个字符
std::string_view sv3 {@start, @end};
</code></pre>
<blockquote>
<p>注意避免<code>string_view</code>比其初始化的字符串生命周期更长（例如在其初始化列表中构造的字符串对象）；</p>
</blockquote>
<h4 id="span"><a class="header" href="#span">span</a></h4>
<p>连续的内存区块（如<code>vector</code>，<code>array</code>）。</p>
<pre><code class="language-c++">span&lt;type&gt; s {v}; // c++20
span&lt;type const&gt; s {v};  // read-only access
span&lt;type&gt; s {@pos, count}; //从@pos起连续count个元素
span&lt;type&gt; s {@start, @end};
</code></pre>
<blockquote>
<p>支持自动类型推导，可省略模板类型。</p>
</blockquote>
<pre><code class="language-c++">tf = s.empty();
int n = s.size();
x = s[i];   //indexed access
s.begin(), s.end();  // iterator access
</code></pre>
<p>内存数据比较：</p>
<pre><code class="language-c++">bool memory_same = s1.data() == s2.data();  // false
</code></pre>
<blockquote>
<p>容器元素比较<code>s1==s2</code>。</p>
</blockquote>
<h5 id="subspan"><a class="header" href="#subspan">subspan</a></h5>
<pre><code class="language-c++">auto first3elements = s.first(3);
auto last3elements  = s.last(3);
auto subs = s.subspan(offset, count);
std::span&lt;std::byte const&gt; b = s.as_bytes();
std::span&lt;std::byte&gt; wb = s.as_writable_bytes();
</code></pre>
<h3 id="其他容器"><a class="header" href="#其他容器">其他容器</a></h3>
<h4 id="queue类"><a class="header" href="#queue类">queue类</a></h4>
<p>为底层的容器类型提供访问限制，元素只能从末端插入，从首端移除（FIFO），元素可以从queue的两端查看。</p>
<pre><code class="language-c++">template &lt;       
	class Type,           //元素类型       
	class Container = deque&lt;Type&gt; //容器类型  
 &gt; class queue  
</code></pre>
<p>合适的底层容器包括deque和list或其他支持front, back, push_back, and pop_front操作的线性容器。容器的元素类型必须与第一个参数一致。底层容器被封装在容器适配器中，容器适配器只提供了有限的线性容器成员函数。</p>
<h4 id="stack类"><a class="header" href="#stack类">stack类</a></h4>
<p>为底层的容器类型提供访问限制，使的只能对底层容器进行栈操作（后进先出，LIFO）。</p>
<pre><code class="language-c++">template &lt;class  Type, class Container=deque&lt;Type&gt; &gt; class stack;  
</code></pre>
<p>合适的底层容器包括deque、list和vector或其他支持back, push_back, and pop_back操作的线性容器。底层容器被封装在容器适配器中，容器适配器只提供了有限的线性容器成员函数。</p>
<h4 id="priority_queue类"><a class="header" href="#priority_queue类">priority_queue类</a></h4>
<p>为底层的容器类型提供访问限制，使底层容器具有priority queue的性质。容器中的元素是按值的性质排序的，即具有某种优先级。该类只支持在顶端插入、删除或查看元素。</p>
<pre><code class="language-c++">template &lt;
   class Type, 
   class Container=vector&lt;Type&gt;, 
   class Compare=less&lt;typename Container::value_type&gt;
&gt; class priority_queue  
</code></pre>
<h2 id="关联容器"><a class="header" href="#关联容器">关联容器</a></h2>
<p>关联容器分为集合（set）和映射（map），每种类型包括有序和无序两种类型。</p>
<p>有序关联容器的数据结构是平衡二叉树（<em>balanced binary tree</em>）。</p>
<img src="CC++/hackingcpp/map_layout.svg" style="zoom: 55%;" />
<p>无序关联容器的数据结构是哈希表（<em>hash table</em>，默认使用<code>std::hash&lt;Key&gt;</code>计算哈希值）。</p>
<img src="CC++/hackingcpp/unordered_map_layout.svg" style="zoom:55%;" />
<p>节点之间通过指针链接，集合类型节点（<code>container::node_type</code>）仅包含<code>key</code>，映射类型的每个节点包含<code>key</code>和<code>value</code>（<code>std::pair</code>）。</p>
<pre><code class="language-c++">#include &lt;set&gt;   // #include &lt;unordered_set&gt;
#include &lt;map&gt;   // #include &lt;unordered_map&gt;
</code></pre>
<h3 id="关联类型构造"><a class="header" href="#关联类型构造">关联类型构造</a></h3>
<h5 id="空容器"><a class="header" href="#空容器">空容器</a></h5>
<pre><code class="language-c++">std::set&lt;int&gt; s1;   // =&gt; std::set&lt;int&gt; s2 {};
std::map&lt;int&gt; m1;   // =&gt; std::map&lt;int&gt; m2 {};
</code></pre>
<h5 id="从数据构造集合"><a class="header" href="#从数据构造集合">从数据构造集合</a></h5>
<pre><code class="language-c++">std::set&lt;int&gt; s2 {3,2,1,4,5}; 
std::set&lt;int&gt; s {s1};          // set(other)
std::set&lt;int&gt; s (s1);          // set(other)
std::set&lt;int&gt; s (@start,@end); // set(@start, @end)
</code></pre>
<blockquote>
<p><code>c++17</code>支持自动类型推导。</p>
</blockquote>
<h3 id="关联类型支持的操作"><a class="header" href="#关联类型支持的操作">关联类型支持的操作</a></h3>
<h5 id="查找-4"><a class="header" href="#查找-4">查找</a></h5>
<pre><code class="language-c++">pos = s.find(7);      // return end() if not found
tf = s.contains(7);   // c++20
</code></pre>
<h5 id="删除-5"><a class="header" href="#删除-5">删除</a></h5>
<pre><code class="language-c++">s.erase(key);
</code></pre>
<h5 id="移动节点"><a class="header" href="#移动节点">移动节点</a></h5>
<pre><code class="language-c++">node = m.extract(key);       //→ node
node = m.extract(@position); //→ node
node.key() = &quot;new key&quot;;      // change key
m.insert(node);             // transfer node
</code></pre>
<h5 id="合并"><a class="header" href="#合并">合并</a></h5>
<pre><code class="language-c++">s.merge(t);      // 将t的元素转移至s中，t成为空容器。
</code></pre>
<h3 id="集合类型操作"><a class="header" href="#集合类型操作">集合类型操作</a></h3>
<h5 id="迭代-3"><a class="header" href="#迭代-3">迭代</a></h5>
<p>迭代器：<code>begin(s)</code>、<code>end(s)</code>、<code>rbegin(s)</code>、<code>rend(s)</code>。</p>
<pre><code class="language-c++">pair = s.insert(const Type&amp; value);  //return std::pair&lt;iterator, bool&gt;
pair = s.insert(Type&amp;&amp; value);  
it = s.insert(@hint, const value_type&amp; value ); 
s.insert(@first, @last);
s.insert(ilist);
</code></pre>
<blockquote>
<p>插入值位置<code>hint</code>从普通迭代器变为常量迭代器<code>c++11</code>；</p>
</blockquote>
<pre><code class="language-c++">pair = s.emplace(Args&amp;&amp;... args);
s.emplace_hint(@hint, Args&amp;&amp;... args)
</code></pre>
<p><code>set.emplace(args)</code>：使用参数直接构造集合元素并加入集合，避免不必要的复制操作。</p>
<h3 id="映射类型操作"><a class="header" href="#映射类型操作">映射类型操作</a></h3>
<h5 id="迭代-4"><a class="header" href="#迭代-4">迭代</a></h5>
<pre><code class="language-c++">for(auto const&amp; keyValuePair : myMap) {/*...*/}
for(auto const&amp; [key,value] : myMap) {/*...*/}   // c++17
</code></pre>
<p>迭代器：<code>begin(m)</code>、<code>end(m)</code>、<code>rbegin(m)</code>、<code>rend(m)</code>。</p>
<h5 id="插入-4"><a class="header" href="#插入-4">插入</a></h5>
<pre><code class="language-c++">pair = m.insert({key, value});   // return pair&lt;@pos,insert_success&gt;    
pair = m.insert(@hint, {key,value});
m.insert(@kv_pairs_begin,@kv_pairs_end);  
pair = m.emplace(key, value);            // c++11
pair = m.emplace_hint(@hint,key,value);  // c++11
pair = m.try_emplace(key,Arg1,Arg2,...); // c++17
m[key] = value;    // insert key if not found
m.at(key) = value; // throws out_of_range if key not found
m.insert_or_assign(key,value); // c++17
</code></pre>
<blockquote>
<p><code>emplace</code>使用参数直接构造要插入的节点，<code>try_emplace</code>使用参数列表直接构造要插入的节点的值<code>value</code>。</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="输入输出-5"><a class="header" href="#输入输出-5">输入输出</a></h1>
<h2 id="标准输入输出-4"><a class="header" href="#标准输入输出-4">标准输入输出</a></h2>
<p>c语言使用<code>printf</code>和<code>wprintf</code>作为标准输出函数；</p>
<pre><code class="language-c++">int wprintf(const wchar_t *format, ...);
</code></pre>
<p>用<code>wprintf()</code>时，要用<code>%ls</code>表示<code>wchar_t</code>的字符串，用<code>%s</code>表示<code>char</code>的字符串； Windows 的实现用<code>%ls</code>、<code>%s</code>都可以正确输出<code>wchar_t</code>字符串。</p>
<p>C++使用<code>cout</code>和<code>wcout</code>作为标准输出函数；
在输出Unicode编码的宽字符时，使用带前缀“<code>w</code>”的函数；在使用之前需要设置程序的区域，即调用<code>setlocale</code>函数（C语言），或使用<code>locale</code>类和流对象的<code>imbue</code>(C++)。</p>
<pre><code class="language-c++">char * setlocale ( int category, const char * locale );
</code></pre>
<p>在Linux下，可以使用 <code>locale -a</code> 命令查看系统中所有已配置的 locale。用不带选项的 <code>locale</code>命令查看当前 Shell 中活动的 <code>locale</code>。用<code>locale -m</code> 命令查看locale系统支持的所有可用的字符集编码。</p>
<p>Linux下<code>wcout</code>可以输出<code>char</code>型字符串和<code>wchar_t</code>型字符串。运行环境的locale设置要和程序中<code>setlocale()</code>设定的locale一致，比如：终端的活动字符集、环境变量（一般用<code>LANG</code>），要设置为<code>*.UTF-8</code>，才能显示<code>setlocale(LC_ALL, &quot;zh_CN.UTF-8&quot;) </code>设定的<code>wchar_t</code>的中文字符。</p>
<p>不要混用char和 wchar_t 版本的流操作函数，否则会导致这些函数运行异常。</p>
<p>fscanf
在Linux下，只能正常读取UTF-8（ASCII）编码的文本，不能对其他编码格式进行自动解码。
如果是其他编码，则需要以字节方式读入，手动转换为UTF-8编码，才能正常使用。</p>
<div class="table-wrapper"><table><thead><tr><th>I/O Streams</th><th>IO desc</th><th>Details</th><th>Operators</th></tr></thead><tbody>
<tr><td><code>std::cin</code></td><td><code>stdin</code></td><td>reads from buffer.</td><td><code>cin &gt;&gt; var</code></td></tr>
<tr><td><code>std::cout</code></td><td><code>stdout</code></td><td>output to console when buffer full.</td><td><code>cout &lt;&lt; var</code></td></tr>
<tr><td><code>std::clog</code></td><td><code>stderr</code></td><td>output to console when buffer full.</td><td><code>clog &lt;&lt; var</code></td></tr>
<tr><td><code>std::cerr</code></td><td><code>stderr</code></td><td>immediately writes to console.</td><td><code>cerr &lt;&lt; var</code></td></tr>
</tbody></table>
</div>
<pre><code class="language-c++">using namespace std;
getline(cin, s);      // read entire line
getline(cin, s, ch);  // read until next character ch
</code></pre>
<h2 id="数据流"><a class="header" href="#数据流">数据流</a></h2>
<p>C++输入输出通过输入输出流类来完成，在头文件“<code>iostream</code>”中定义了这些类的基类：</p>
<p>•    <code>istream</code>：从流中读取数数据。</p>
<p>•    <code>ostream</code>：写入数据到流中。</p>
<p>•    <code>iostream</code>：对流进行读和写操作，继承自<code>istream</code>和<code>ostream</code>。</p>
<img src="CC++/输入输出.assets/std_istream.png" alt="std iostream" style="zoom: 75%;" />
<p>所有输入输出流类，还有其宽字符版本，以支持国际化。宽字符版本在普通版本前增加“<code>w</code>”前缀。所有类型均由<code>basic_xxxstream</code>通过模板参数（<code>charT, traits</code>）实例化（类似于<code>string</code>类型）。</p>
<blockquote>
<p><code>std::cin</code>是<code>istream</code>类型对象；<code>std::cout</code>是<code>ostream</code>类型对象</p>
</blockquote>
<h3 id="格式化-1"><a class="header" href="#格式化-1">格式化</a></h3>
<p>所有设置函数未接收参数时，返回当前的设置。</p>
<h5 id="标识"><a class="header" href="#标识">标识</a></h5>
<pre><code class="language-c++">old_flags = cout.flags(ios::right|ios::hex); // set all flags
old_flags = cout.setf(flags, mask);  //only set specified flags
void unsetf(fmtflags mask);   // clear specified flags
</code></pre>
<p><code>flags()</code>设置流的所有标识（未给出的清空），而<code>setf</code>仅设置给出的标识（未给出的不变）。</p>
<p>标识为两种：1) 独立标识；2) 选择性标识：一组包括多个标识，但同时只能设置一个。<code>mask</code>用于设置选择性标识，用以清空非当前设置的同组其他标识。</p>
<blockquote>
<p>标识定义在<code>ios</code>类中，类型为<code>fmtflags</code>（<code>bitmask</code>）。</p>
</blockquote>
<h6 id="独立标识"><a class="header" href="#独立标识">独立标识</a></h6>
<div class="table-wrapper"><table><thead><tr><th>独立标识</th><th>说明</th></tr></thead><tbody>
<tr><td><code>boolalpha</code></td><td>以字符串格式读写bool值 (<code>true</code> and <code>false</code>)</td></tr>
<tr><td><code>showbase</code></td><td>输出前缀（<code>0x,o</code>）</td></tr>
<tr><td><code>showpoint</code></td><td>浮点数总是输出小数点</td></tr>
<tr><td><code>showpos</code></td><td>整数输出<code>+</code>号</td></tr>
<tr><td><code>skipws</code></td><td>跳过输入内容前面的空白</td></tr>
<tr><td><code>unitbuf</code></td><td>flush output after each inserting operation.</td></tr>
<tr><td><code>uppercase</code></td><td>替换未大写字母 in certain insertion operations.</td></tr>
</tbody></table>
</div>
<h6 id="选择性标识"><a class="header" href="#选择性标识">选择性标识</a></h6>
<div class="table-wrapper"><table><thead><tr><th>选择性标识位</th><th>掩码</th><th>说明</th></tr></thead><tbody>
<tr><td><code>left</code>, <code>right</code> or <code>internal</code></td><td><code>adjustfield</code></td><td>对齐方式</td></tr>
<tr><td><code>dec</code>, <code>oct </code>or <code>hex</code></td><td><code>basefield</code></td><td>计数进制</td></tr>
<tr><td><code>scientific</code> or <code>fixed</code></td><td><code>floatfield</code></td><td>浮点数表示法</td></tr>
</tbody></table>
</div>
<p>使用操作符格式化：</p>
<pre><code class="language-c++">cout &lt;&lt; fixed;
cout &lt;&lt; scientific;
cout &lt;&lt; boolalpha;   // booleans as string
</code></pre>
<h5 id="宽度"><a class="header" href="#宽度">宽度</a></h5>
<pre><code class="language-c++">ios.width(int n);   // cout &lt;&lt; std::setw() #include &lt;iomanip&gt;
ios.fill(char ch);  // 填充字符
</code></pre>
<p>显示数据的最小宽度，数据内容少于该宽度将填充字符，填充字符位置更具对齐方式决定（<code>adjustfield</code>）。</p>
<h5 id="精度"><a class="header" href="#精度">精度</a></h5>
<p>精度的具体定义取决于使用定点法或科学计数法。</p>
<pre><code class="language-c++">ios.precision(int n)  // cout &lt;&lt; std::setprecision(n)
</code></pre>
<h5 id="locale"><a class="header" href="#locale">locale</a></h5>
<pre><code class="language-c++">locale loc = ios.getloc()
</code></pre>
<h3 id="状态"><a class="header" href="#状态">状态</a></h3>
<pre><code class="language-c++">iostate s = ios.rdstate();   // 返回内部错误状态标识
bool tf = ios.good();// goodbit: True if no errors
bool tf = ios.eof(); // eofbit:
bool tf = ios.fail();// failbit|badbit: IO逻辑错误（在输入模式下执行输出，识别内容失败）
bool tf = ios.bad(); // badbit: IO操作读写错误
</code></pre>
<p><code>badbit</code>：标志着系统级的故障，如无法恢复的读写错误。如果出现了这类错误，则该流通常就不能再继续使用了。</p>
<p><code>failbit</code>：出现的是可恢复的错误，如在希望获得数值型数据时输入了字符，此时则设置 <code>failbit </code>标志，这种导致设置 <code>failbit</code>的问题通常是可以修正的。</p>
<p><code>eofbit</code>：遇到文件结束符时设置。</p>
<blockquote>
<p>当流出现错误时，缓存中的错误内容不会自动被丢弃，再该流上继续执行操作还会产生错误。</p>
</blockquote>
<pre><code class="language-c++">cin.clear(state=goodbit)  // 重置状态
cin.ignore(numeric_limits&lt;streamsize&gt;::max(), '\n'); // 清除缓存
</code></pre>
<p>设置异常触发：根据设置的状态触发异常。</p>
<pre><code class="language-c++">ios.exceptions(iostate except);
</code></pre>
<h3 id="读写操作符"><a class="header" href="#读写操作符">读写操作符</a></h3>
<p>“<code>&lt;&lt;</code>”操作符（<code>print()</code>）：将数据格式化输出到输出流。</p>
<p>“<code>&gt;&gt;</code>”操作符：从输入流扫描并格式化读入数据。</p>
<h5 id="重载运算符"><a class="header" href="#重载运算符">重载运算符</a></h5>
<pre><code class="language-c++">std::ostream&amp; operator &lt;&lt; (std::ostream&amp; os, point const&amp; p) {
  return os &lt;&lt; '(' &lt;&lt; p.x &lt;&lt; ',' &lt;&lt; p.y &lt;&lt; ')';
}
std::istream&amp; operator &gt;&gt; (std::istream&amp; is, point&amp; p) {
  return is &gt;&gt; p.x &gt;&gt; p.y;
}
</code></pre>
<p>https://hackingcpp.com/cpp/std/istream_recover_from_errors.html</p>
<h3 id="读写方法"><a class="header" href="#读写方法">读写方法</a></h3>
<pre><code class="language-c++">std::getline(istream&amp;, string&amp;, stopat='\n')
</code></pre>
<pre><code class="language-c++">std::istream.ignore(n, c)  // skip n chars, or until char 'c'.
</code></pre>
<h3 id="流式字符串读写"><a class="header" href="#流式字符串读写">流式字符串读写</a></h3>
<p><code>ostringstream</code>，<code>istringstream</code>。</p>
<h3 id="流式文件读写"><a class="header" href="#流式文件读写">流式文件读写</a></h3>
<p>用于普通文件读写的输入输出流类在头文件“<code>fstream</code>”中声明，包含以下类型：</p>
<pre><code class="language-c++">#include &lt;fstream&gt;
using namespace std;
ifstream; // 继承`istream`，用于读文件。
ofstream; // 继承`ostream`，用于写文件。
fstream;  // 继承`iostream`，用于读写文件。
</code></pre>
<p><code>fstream</code>中声明的类除了继承下来的行为外，还定义了两个新操作——<code>open</code>和<code>close</code>，以及形参为要打开的文件名的构造函数。</p>
<pre><code class="language-c++">std::ofstream os {&quot;squares.txt&quot;, ios::in};  // ios::binary 
os.open(&quot;squares.txt&quot;);     
os.good();    
os.close();     // file can be automatically closed
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="标准函数库"><a class="header" href="#标准函数库">标准函数库</a></h1>
<h2 id="数组-6"><a class="header" href="#数组-6">数组</a></h2>
<h5 id="拷贝数据"><a class="header" href="#拷贝数据">拷贝数据</a></h5>
<pre><code class="language-c++">void *memcpy(void *dest, const void *src, size_t count); // =&gt; wmemcpy
</code></pre>
<p><code>memcpy</code>从<code>src</code>拷贝<code>count</code>字节数据到<code>dest</code>；<code>wmemcpy</code>则拷贝<code>count</code>个宽字符的数据。如果源和目的区域有重叠，则该函数的行为未定义。</p>
<p>注意：应该保证目的缓存应该大于或等于源缓存。</p>
<pre><code class="language-c++">void *memmove(void *dest,const void *src, size_t count); 
// =&gt; wmemmove、memmove_s、wmemmove_s
</code></pre>
<p>从<code>src</code>到<code>dest</code>拷贝<code>count</code>字节（<code>memmove</code>）或字符（<code>wmemmove</code>）。如果源和目的区域有重叠，则该函数能保证覆盖区域的数据被覆盖之前被正确拷贝。</p>
<blockquote>
<p>注意：应该保证目的缓存应该大于或等于源缓存。</p>
</blockquote>
<h5 id="设置数据"><a class="header" href="#设置数据">设置数据</a></h5>
<p>memset</p>
<h5 id="比较-3"><a class="header" href="#比较-3">比较</a></h5>
<p>memcmp</p>
<h2 id="c字符串"><a class="header" href="#c字符串">C字符串</a></h2>
<p><code>char</code>型字符串==存储变长字符编码==（Linux平台为<code>UTF-8</code>，Windows平台为<code>GBK</code>），以单字节“<code>null</code>”结尾；<code>wchar_t</code>存储定长字符编码（<code>UTF-16</code>），以两个“<code>null</code>”结尾。</p>
<blockquote>
<p><code>wchar_t</code>字符串的处理函数以<code>wcs</code>开头，对应<code>char</code>字符串以<code>str</code>开头的函数。</p>
</blockquote>
<pre><code class="language-c++">char str[5] = {'T', 'h', 'i', 's', 0};  // string as array
</code></pre>
<p>当使用字符串字面值初始化时，对应的字符串是不能修改的，因此将其声明为常量。</p>
<pre><code class="language-c++">const char str[] = &quot;this is a string&quot;;
const char* ptr = &quot;this is a string&quot;;
</code></pre>
<h3 id="属性-7"><a class="header" href="#属性-7">属性</a></h3>
<pre><code class="language-c++">size_t strlen(const char *s);	  // =&gt; wcslen
</code></pre>
<p>计算字符串长度，遇到'<code>\0</code>'结束，==长度以字节计数==；如果是中文，则一般一个中文字符占3字节。</p>
<h3 id="拼接-4"><a class="header" href="#拼接-4">拼接</a></h3>
<pre><code class="language-c++">char *strcat(char *dest, const char *src);
char *strncat(char *dest, const char *src, size_t n);
</code></pre>
<p>将字符串<code>src</code>连接到<code>dest</code>的尾部。从<code>dest</code>的<code>\0</code>开始。<code>strncat</code>与<code>strcat</code>的区别在：<code>strncat</code>最多使用<code>src</code>的<code>n</code>个字节；如果<code>src</code>的长度大于或等于<code>n</code>，则<code>strncat</code>的<code>src</code>字符串不需要是<code>null</code>结尾。</p>
<blockquote>
<p><code>strlen()</code>和<code>strcat()</code>是两个比较耗时的操作。在程序中应该少使用。</p>
</blockquote>
<h3 id="比较-4"><a class="header" href="#比较-4">比较</a></h3>
<pre><code class="language-c++">int strcmp(const *s1,const *s2);
int strncmp(const char *s1, const char *s2, size_t n);
int strcasecmp(const char *s1, const char *s2);
int strncasecmp(const char *s1, const char *s2, size_t n);
</code></pre>
<p>比较<code>s1</code>和<code>s2</code>。<code>strncmp</code>只比较最多<code>n</code>个字符。<code>strcasecmp</code>忽略大小写。</p>
<ul>
<li><code>s1 = s2</code>的时候返回值 =0；</li>
<li><code>s1 &lt; s2</code>的时候返回至 &lt;0；</li>
<li><code>s1 &gt; s2</code>的时候返回值 &gt;0；</li>
</ul>
<h3 id="查找-5"><a class="header" href="#查找-5">查找</a></h3>
<pre><code class="language-c++">char *strchr(const char *s, char c);
char *strrchr(const char *s, int c);
char *strchrnul(const char *s, int c);
</code></pre>
<p><code>strchr</code>返回<code>s</code>中首次出现<code>c</code>的位置的指针，<code>strrchr</code>返回最后出现<code>c</code>的位置的指针。如果<code>s</code>中不存在<code>c</code>则返回<code>NULL</code>。
<code>strchrnul</code>与<code>strchr</code>类似，只是在找不到<code>c</code>的时候，返回字符串的<code>null</code>位置指针，而不是<code>NULL</code>。</p>
<pre><code class="language-c++">char *strstr(const char *haystack, const char *needle);
char *strcasestr(const char *haystack, const char *needle);
</code></pre>
<p>返回<code>haystack</code>中<code>needle</code>字符串首次出现的位置的指针（不比较结束符<code>null</code>）。若果没找到则返回<code>NULL</code>。<code>strcasestr</code>在查找时忽略字符串的大小写。</p>
<h3 id="复制"><a class="header" href="#复制">复制</a></h3>
<pre><code class="language-c++">char *strcpy(char *dest, const char *src);    // =&gt; wcscpy，wcscpy_s
char *strncpy(char *dest, const char *src, size_t n);  // =&gt; wcscat，wcscat_s
</code></pre>
<p>拷贝<code>src</code>指向的字符串到<code>dest</code>指向的缓冲区。<code>strncpy</code>则最多拷贝<code>n</code>个字符，如果前<code>n</code>个字符没有以<code>null</code>结束，则目标字符串也不会以<code>null</code>结束。</p>
<h3 id="类型转换-6"><a class="header" href="#类型转换-6">类型转换</a></h3>
<pre><code class="language-c++">#include &lt;cstdlib&gt;
int atoi(const char *nptr);
long atol(const char *nptr);
long long atoll(const char *nptr);
</code></pre>
<p>将字符串转换成<code>int</code>，<code>long</code>和<code>long long</code>型整数。<code>atoi()</code>会扫描参数<code>nptr</code>字符串，跳过前面的空格，直到遇上数字或者正负号才开始装换，而再遇到非数字或者字符串结束时停止转换。<code>atoi</code>不会检测错误。</p>
<pre><code class="language-c++">double atof(const char *nptr);
</code></pre>
<p>将字符串转换为浮点数。<code>atof</code>不会检测错误。</p>
<pre><code class="language-c++">long int strtol(const char *nptr, char **endptr, int base);
long long int strtoll(const char *nptr, char **endptr, int base);
</code></pre>
<p><code>strtol</code>根据<code>base</code>的值就将<code>nptr</code>指向的字符串转换为整数。<code>base</code>的取值范围为<code>2~36</code>，或为<code>0</code>。	字符串可以在开头包含任意数量的空格，空格之后可以包含“<code>+</code>”或“<code>-</code>”。如果<code>base = 0</code>，若字符串包含前缀“<code>0x</code>”，字符串字符串将按照16进制解析；若字符串包含前缀“0”，字符串字符串将按照8进制解析；其他情况则按10进制解析。解析停止于首个非法字符。</p>
<p>如果<code>endptr</code>不是<code>NULL</code>，则<code>strtol</code>将把首个非法字符的地址存储在<code>*endptr</code>中。如果<code>nptr</code>中没有数字，则<code>*endptr=nptr</code>并返回0，如果<code>nptr!=NULL</code>且<code>*endnptr=NULL</code>，则全部是合法字符。</p>
<p><code>strtoll</code>与<code>strtol</code>类似，只是返回值的类型为<code>long long int</code>。如果发生下溢出，则<code>strtol</code>返回<code>LONG_MIN</code>；如果发生上溢出，则<code>strtol</code>返回<code>LONG_MAX</code>。两种情况下，<code>errno</code>被设置为<code>ERANGE</code>。<code>strtoll</code>也是类似，只是返回值为<code>LLONG_MIN</code>和<code>LLONG_MAX</code>。</p>
<pre><code class="language-c++">unsigned long int strtoul(const char *nptr, char **endptr, int base);
unsigned long long int strtoull(const char *nptr, char **endptr, int base);
</code></pre>
<p><code>strtoul</code>根据<code>base</code>的值将<code>nptr</code>指向的字符串转换为无符号整数，转换规则与<code>strtol</code>类似。</p>
<pre><code class="language-c++">double strtod(const char *nptr, char **endptr);
float strtof(const char *nptr, char **endptr);
long double strtold(const char *nptr, char **endptr);
</code></pre>
<p>将<code>nptr</code>指向的字符串转换为浮点数。</p>
<h3 id="格式化-2"><a class="header" href="#格式化-2">格式化</a></h3>
<pre><code class="language-c++">int sprintf(char *buf, char *format,arg_list);
int snprintf(char *restrict buf, size_t n, const char *restrict format,...);
</code></pre>
<p><code>sprintf()</code>是一个功能强大的函数。跟<code>printf(char *format,arg_list)</code>的功能类似。不过，<code>printf()</code>是将格式化的字符输出到屏幕，而<code>sprintf()</code>则是将格式化的字符放入到<code>buf</code>中。这个函数对操作缓冲区<code>buf</code>,并对其内容加以格式带来了极大的方便。</p>
<p><code>snprintf()</code>最多从源串<code>format</code>中拷贝<code>n-1</code>个字符到目标串<code>buf</code>中，然后再在后面加一个'<code>\0'</code>.如果目标串的大小为<code>n</code>的话，将不会溢出。<code>snprintf()</code>如果成功则返回存入数组的字符数，若错误则返回负值。</p>
<pre><code class="language-c++">int sscanf(string str, string fmt, mixed var1, mixed var2 ... );
int scanf(const char *format [,argument]... );　　
</code></pre>
<p>从一个字符串中读进与指定格式相符的数据。<code>sscanf</code>与<code>scanf</code>类似，都是用于输入的，只是后者以屏幕(<code>stdin</code>)为输入源，前者以固定字符串为输入源。其中，<code>format</code>可以是一个或多个</p>
<p><code>{%[*][width][{h|l|I64|L}]type|' '|'\t'|'\n'|非%符号}</code></p>
<h5 id="格式化输入"><a class="header" href="#格式化输入">格式化输入</a></h5>
<pre><code class="language-c++">char buf[512];
sscanf(&quot;123456 &quot;, &quot;%s&quot;, buf);
sscanf(&quot;123456 &quot;, &quot;%4s&quot;, buf);  // 取最大长度为4字节的字符串
</code></pre>
<p>正则匹配：<code>sscanf</code>的<code>%[]</code>类似于一个正则表达式，但却没有正则表达式强大，所以如果对于比较复杂的字符串处理，建议使用正则表达式。</p>
<pre><code class="language-c++">sscanf(&quot;123456 abcdedf&quot;, &quot;%[^ ]&quot;, buf); // 取遇到空格为止字符串
sscanf(&quot;123456abcdedfBCDEF&quot;, &quot;%[1-9a-z]&quot;, buf); //仅包含指定字符集的字符串
sscanf(&quot;123456abcdedfBCDEF&quot;, &quot;%[^A-Z]&quot;, buf);
</code></pre>
<p>给定一个字符串<code>iios/12DDWDFF@122</code>，获取 <code>/</code> 和 <code>@</code> 之间的字符串，先将 &quot;<code>iios/</code>&quot;过滤掉，再将非<code>'@'</code>的一串内容送到<code>buf</code>中</p>
<pre><code class="language-c++">sscanf(&quot;iios/12DDWDFF@122&quot;, &quot;%*[^/]/%[^@]&quot;, buf);
sscanf(“hello, world”, &quot;%*s%s&quot;, buf);
</code></pre>
<p><code>%*s</code>表示第一个匹配到的<code>%s</code>被过滤掉，即<code>'hello'</code>被过滤了；如果没有空格则结果为NULL。</p>
<h3 id="其他方法"><a class="header" href="#其他方法">其他方法</a></h3>
<pre><code class="language-c">strace       strcspn      strings      strdup       strip        strpbrk 
strdupa      strtok       strtouq      strerror     strtok_r     strverscmp
strerror_r   strsep       strxfrm      strchrnul    strfmon      strsignal    
strfry       strspn       strcoll      strndup      string       strndupa       
</code></pre>
<h2 id="时间-1"><a class="header" href="#时间-1">时间</a></h2>
<h5 id="时间格式化"><a class="header" href="#时间格式化">时间格式化</a></h5>
<pre><code class="language-c++">size_t strftime(
   char *strDest,
   size_t maxsize,
   const char *format,
   const struct tm *timeptr
);
</code></pre>
<p><code>format</code>用于声明<a href="CC++/../Linux/Linux%E9%85%8D%E7%BD%AE%E5%92%8C%E7%AE%A1%E7%90%86#%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4">格式化字符串</a>。</p>
<h5 id="时间字符串解析"><a class="header" href="#时间字符串解析">时间字符串解析</a></h5>
<pre><code class="language-c++">strptime
</code></pre>
<h2 id="系统调用"><a class="header" href="#系统调用">系统调用</a></h2>
<h3 id="文件系统-2"><a class="header" href="#文件系统-2">文件系统</a></h3>
<pre><code class="language-c">#include &lt;stdio.h&gt;
int rename( const char *oldfname, const char *newfname ); // 更改文件名
</code></pre>
<h3 id="系统接口-2"><a class="header" href="#系统接口-2">系统接口</a></h3>
<p><code>system</code>解释执行一条命令。函数将命令传递给命令环境（Shell），如果输入命令为空，则<code>system</code>函数检查命令环境是否存在。在使用<code>system</code>函数前，必须显式调用刷新流（调用<code>fflush</code>或<code>_flushall</code>）或者关闭流。</p>
<pre><code class="language-c">#include &lt;stdlib.h&gt;
int system(const char *command );
int _wsystem(const wchar_t *command);
</code></pre>
<blockquote>
<p><code>_wsystem</code>是宽字符版本的<code>system</code>函数。<code>_tsystem</code>则根据程序中是否定义了<code>_UNICODE</code>来确定使用的函数。</p>
<p>如果输入命令为空，而命令解释器为找到，则返回0并且将<code>errno</code>设为``ENOENT<code>，否则返回一个非零值；如果输入命令不为空，而命令解释器可以找到，则函数返回值就是命令解释器返回的值。如果返回-1，表明发生了错误，</code>errno`设置为以下值：</p>
<ul>
<li><code>E2BIG</code> </li>
<li><code>ENOENT</code>      未能找到解释器</li>
<li><code>ENOEXEC</code>     解释器的格式无效，不能执行</li>
<li><code>ENOMEM</code>          内存不足。</li>
</ul>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="数学函数-1"><a class="header" href="#数学函数-1">数学函数</a></h1>
<h2 id="基本数值计算"><a class="header" href="#基本数值计算">基本数值计算</a></h2>
<pre><code class="language-c++">#include &lt;cmath&gt;
double sqrt(double x)          // √x square root
double pow(double a, double b) // a^b power
double abs(double x)	       // |x| absolute value
double sin(double x)           // sin(x) sine
double cos(double x)           // cos(x) cosine
double exp(double x)           // ex exponential
double log(double x)           // log(x) logarithm
double floor(double x)         // ⌊x⌋ next smaller integer
double ceil(double x)          // ⌈x⌉ next larger integer
double fmod(double x, double y)// remainder of x/y
</code></pre>
<h2 id="随机数-1"><a class="header" href="#随机数-1">随机数</a></h2>
<h3 id="随机数生成器"><a class="header" href="#随机数生成器">随机数生成器</a></h3>
<p>随机数生成器：<code>分布+发生器</code>。</p>
<pre><code class="language-c++">#include &lt;random&gt;
auto urng = std:mt19937{}; // Mersenne Twister
urng.seed(1001);
auto dist = std:uniform_int_distribution&lt;int&gt;{1,6};
int x = dist(urng);  // 生成随机数
dist = std:uniform_real_distribution&lt;float&gt;{1.0,6.0};
</code></pre>
<blockquote>
<h3 id="rand-srand-rand_r"><a class="header" href="#rand-srand-rand_r">rand, srand, rand_r</a></h3>
<pre><code class="language-c">#include &lt;stdlib.h&gt;
int rand(void);
void srand(unsigned int seed);
int rand_r(unsigned int * seedp);
</code></pre>
<p><code>rand()</code>返回一个[0,<code>RAND_MAX</code>]之间的伪随机数。<code>RAND_MAX</code>的值可能是平台相关的，在Linux下<code>RAND_MAX=0x7FFFFFFF</code>，Windows下<code>RAND_MAX=0x7FFF</code>。<code>srand()</code>用于设置rand()产生随机数的种子。如果没有调用srand()函数，则默认的随机数种子为1。因为<code>rand()</code>使用隐藏的state来连续产生随机数，因此每次调用<code>rand()</code>获得的结果都是不相同，除非调用<code>srand()</code>重置了随机数种子，而<code>rand()</code>也不是线程安全的，同一进程的多个线程应该是共享同一个随机数state的。</p>
<p><code>rand_r()</code>使用独立的变量（<code>seedp</code>指向的变量）存储随机数的状态。因此可以并发调用<code>rand_r()</code>，而互不影响各自序列的生成。但由于<code>seedp</code>所指变量只能提供很小的状态数，因此产生的序列的随机性可能较差。（<code>drand48_r</code>）</p>
<blockquote>
<p><code>rand()</code>使用的状态和<code>rand_r()</code>使用的状态是无关的。</p>
</blockquote>
<h3 id="random-srandominitstatesetstate"><a class="header" href="#random-srandominitstatesetstate">random, srandom,initstate,setstate</a></h3>
<pre><code class="language-c">#include &lt;stdlib.h&gt;
long int random(void);
void srandom(unsigned int seed);
char *initstate(unsigned int seed, char *state, size_t n);
char *setstate(char *state);
</code></pre>
<p><code>random()</code>产生[0,<code>RAND_MAX</code>]之间的随机数，<code>random()</code>使用的随机数发生器的周期非常长。<code>srandom()</code>用于设置<code>random()</code>产生随机数的种子。相同的种子将产生相同的随机数（序列），默认的随机数种子是<code>1</code>。</p>
<p><code>initstate()</code>用于初始化<code>random()</code>函数用于保存状态的空间。<code>state</code>是保存状态的数组的首地址，<code>n</code>则表示数组的长度，<code>n</code>越大，则保存的状态越复杂，产生的序列随机性也越好，<code>n</code>的取值至少应该为8，少于8字节的空间会导致函数调用错误，当前“最优的”取值包括8、32、64、128和256，其他值将会被缩小为之前述的几个值。<code>setstate()</code>用于改变<code>random()</code>所使用的保存状态的空间，<code>state</code>必须是经过<code>initstate()</code>初始化过的，或先前调用<code>setstate()</code>的返回值。如果调用成功，则<code>initstate()</code>和<code>setstate()</code>都返回先前使用的存储状态的空间的指针。如果失败，<code>setstate()</code>函数返回NULL。</p>
<p>为了保证产生的结果互不影响，<code>random()</code>同样是不能用于多线程的。</p>
<h3 id="reentrant-random-generator"><a class="header" href="#reentrant-random-generator">reentrant random generator</a></h3>
<pre><code class="language-c">#include &lt;stdio.h&gt;
int random_r(struct random_data * buf, int32_t *result);
int srandom_r(unsigned int seed, struct random_data * buf);
int initstate_r(unsigned int seed, char * statebuf,
size_t statelen, struct random_data * buf);
int setstate_r(char * statebuf, struct random_data * buf);
</code></pre>
<p>这些函数是适合于多线程程序使用的可再入的函数，可在多个线程中产生相同的随机序列。这些函数与1.2的区别在于，使用指定的<code>buf</code>存储随机数发生器的状态，而非存储在原来的一个全局变量中。</p>
<p><code>random_r()</code>将生成的随机数通过参数result返回。所有函数在成功执行后返回0，否则返回-1。</p>
<blockquote>
<p><em>this functions are nonstandard glib extensions</em></p>
</blockquote>
</blockquote>
<h2 id="算法"><a class="header" href="#算法">算法</a></h2>
<h5 id="cs-standard-algorithms-are"><a class="header" href="#cs-standard-algorithms-are">C++'s Standard Algorithms are</a></h5>
<ul>
<li><strong>operating on (iterator) ranges</strong> of elements and implemented as free-standing functions: allows algorithms to be implemented independent from container types (<strong>generic</strong>).</li>
<li>functions as parameters: many are <strong>customizable</strong> with function(object)s / lambdas</li>
<li><strong>well-tested</strong> and <strong>efficient</strong></li>
</ul>
<pre><code class="language-c++">#include &lt;algorithm&gt;
#include &lt;memory&gt;
</code></pre>
<p>Non-Modifying Queries</p>
<ul>
<li>
<p>finding elements / existence queries</p>
<pre><code class="language-c++">using namespace std;
tf = all_of(@begin, @end, tf_func_check);
tf = any_of(@begin, @end, tf_func_check);
tf = none_of(@begin, @end, tf_func_check);
</code></pre>
<blockquote>
<p>==<code>c++20</code>在<code>ranges</code>中封装了支持容器作为参数的同名函数，下同。==</p>
<pre><code class="language-c++">tf = ranges::all_of(container, check);
</code></pre>
</blockquote>
<pre><code class="language-c++">tf = count(@begin, @end, value);
tf = count_if(@begin, @end, tf_func_check);
</code></pre>
<pre><code class="language-c++">@pos = find(@begin, @end, value); // return end() if not find
@pos = find_if(@begin, @end, tf_check); // return end() if not find
</code></pre>
<blockquote>
<p><code>find_if_not()</code>。</p>
</blockquote>
<p>从备选集合中查找元素：</p>
<pre><code class="language-c++">@pos = find_first_of(@sbegin, @send, @wbegin, @wend);
@pos = find_first_of(container, candidates);  // c++20，下同
</code></pre>
<p>查找子序列：</p>
<pre><code class="language-c++">@pos = search(@sbegin, @send, @wbegin, @wend);   // find 1st occurance
@pos = find_end(@sbegin, @send, @wbegin, @wend); // find last occurance
</code></pre>
<p>查找连续出现元素：</p>
<pre><code class="language-c++">@pos = adjacent_find(@begin, @end, cmp=&lt;);
@pos = search_n(@begin, @end, n, tf_func_equal);  // 连续出现n个相同元素
</code></pre>
</li>
<li>
<p>minimum / maximum</p>
<pre><code class="language-c++">using namespace std;
x = min(a,b, cmp=&lt;);          // same for max,minmax
x = min({x1,x2,...}, cmp=&lt;);  // C++11
@min = min_element(@first, @last, cmp=&lt;);// also max_element, minmax_element
</code></pre>
<blockquote>
<p><code>minmax</code>：返回包括最小值和最大值的元组（<code>pair</code>）。<code>minmax_element</code>返回对应迭代器组成的元组。</p>
</blockquote>
</li>
<li>
<p>comparing ranges of elements</p>
<pre><code class="language-c++">tf = equal(@begin1, @end1, @begin2, @end2, tf_func_equal);
pair = mismatch(@begin1, @end1, @begin2, @end2, tf_func_equal);
</code></pre>
<blockquote>
<p><code>mismatch</code>返回两个序列中不匹配位置的迭代器组成的元组。</p>
</blockquote>
</li>
<li>
<p>binary search of sorted ranges</p>
</li>
</ul>
<p>Modifying Operations</p>
<ul>
<li>
<p>copying / moving elements</p>
<p><code>copy</code>：目标必须具有足够空间容纳源数据。</p>
<pre><code class="language-c++">@cp_end = copy(@begin, @end, @tgt_begin);   // .resize(n)
@cp_end = copy_n(@begin, n, @tgt_begin);
@cp_first = copy_backward(@begin, @end, @tgt_end); // 向目标容器中反向复制 
@cp_end = copy_if(@begin, @end, @tgt_begin, tf_func_check);
</code></pre>
<blockquote>
<p><code>ranges::copy(src, begin(tgt))</code>。</p>
</blockquote>
<pre><code class="language-c++">reverse(@begin, @end);
@cp_end = reverse_copy(@begin, @end, @tgt_begin);  // 将源数据反向复制到目标容器
</code></pre>
<p>移位：</p>
<img src="CC++/hackingcpp/shift_left_thumb.svg" style="zoom:50%;" align="left"/>
<img src="CC++/hackingcpp/shift_right_thumb.svg" style="zoom:50%;" align="left" />
<blockquote>
<p>移位后原位置上的元素值不改变。</p>
</blockquote>
<p>循环移位：将开始区间移至末尾。</p>
<img src="CC++/hackingcpp/rotate_thumb.svg" style="zoom: 45%;" align="left" />
<blockquote>
<pre><code class="language-c++">rotate_copy(@begin, @new_first, @end, @target); 
</code></pre>
</blockquote>
<p>随机采样：</p>
<pre><code class="language-c++">#include &lt;random&gt;
auto rgen = std::mt19937{}; // 32 bit mersenne twister engine
sample(@begin, @end, @tgt, n, rgen);
</code></pre>
<p>随机打乱：</p>
<pre><code class="language-c++">shuffle(@begin, @end, random_engine);
</code></pre>
<p>排列：</p>
<pre><code class="language-c++">next_permutation(begin(v),end(v));
prev_permutation(begin(v),end(v));
is_permutation(begin(v1), end(v1), begin(v2));  // c++11
</code></pre>
<p>排序：</p>
<pre><code class="language-c++">sort(@begin, @end, cmp=&lt;);
stable_sort(@begin, @end, cmp=&lt;);
tf = is_sorted(@begin, @end, cmp=&lt;);
</code></pre>
<p>分割：根据条件将区间元素分为两个部分。分割后区间前半部分<code>tf_func=true</code>，后半部分<code>tf_func=false</code>。</p>
<pre><code class="language-c++">@true_end = partition(@begin, @end, tf_func);
partition_copy(@begin, @end, @out1, @out2, tf_func);
@true_end = stable_partition(@begin, @end, tf_func);
tf = is_partitioned(@begin, @end, tf_func);
@true_end = partition_point(@begin, @end, tf_func);
</code></pre>
</li>
<li>
<p>replacing / transforming elements</p>
<pre><code class="language-c++">fill(@begin, @end, value);
fill_n(@begin, n, value);
</code></pre>
<pre><code class="language-c++">auto generator = [i=0]() mutable { i += 2; return i; };
generate(@begin, @end, generator);
generate_n(@begin, n, generator);
#include &lt;numeric&gt;
iota(@begin, @end, value);  // 使用递增数列填充区间，起始值为value
</code></pre>
<img src="CC++/hackingcpp/transform_thumb.svg" style="zoom:45%;" align="left"/>
<pre><code class="language-c++">replace(@begin, @end, old_value, new_value);
replace_if(@begin, @end, f_condition, new_value);
</code></pre>
<blockquote>
<p><code>replace_copy</code>， <code>replace_copy_if</code>。</p>
</blockquote>
<pre><code class="language-c++">remove(@begin, @end, value);
remove_if(@begin, @end, f_condition);
</code></pre>
<blockquote>
<p><code>remove_copy</code>， <code>remove_copy_if</code>。</p>
</blockquote>
<pre><code class="language-c++">@new_end = unique(@begin, @end);
</code></pre>
<blockquote>
<p>仅清除连续的重复值，并将后续值向前移动，不会重新分配内存。可以在移除前首先对数据排序，以保证最终结果唯一。（<code>unique_copy</code>）</p>
</blockquote>
</li>
<li>
<p>removing elements</p>
<pre><code class="language-c++">erase(container, value);  // c++20
erase(container, f_condition);  // c++20
</code></pre>
</li>
<li>
<p>union/intersection/etc. of sorted ranges</p>
</li>
</ul>
<pre><code class="language-c++">#include &lt;iterator&gt;
n = distance(@first, @last);
</code></pre>
<h3 id="数值计算"><a class="header" href="#数值计算">数值计算</a></h3>
<pre><code class="language-c++">#include &lt;numeric&gt;
</code></pre>
<h5 id="序列构造"><a class="header" href="#序列构造">序列构造</a></h5>
<pre><code class="language-c++">iota(@begin, @end, Type start_value=1);  // iota stants for greek letter ι
</code></pre>
<h5 id="map-reduce"><a class="header" href="#map-reduce">map-reduce</a></h5>
<pre><code class="language-c++">reduce(begin(v), end(v));    
reduce(begin(v), end(v), w0); 
reduce(begin(v), end(v), w0, func); // 默认运算为+
</code></pre>
<blockquote>
<p>未提供初始值<code>w0</code>时，将区间的第一个值作为初始值。</p>
</blockquote>
<img src="CC++/hackingcpp/transform_reduce2_thumb.svg" style="zoom:50%;" align="left"/>
<img src="CC++/hackingcpp/transform_reduce1_thumb.svg" style="zoom:50%;" align="left"/>
<h5 id="差分-1"><a class="header" href="#差分-1">差分</a></h5>
<pre><code class="language-c++">adjacent_difference(@begin, @end, @out, diff_func=-); //C++17: custom operator
inclusive_scan(@begin, @end, @out, operator=+);
</code></pre>
<blockquote>
<p><code>inclusive_scan</code>, <code>transform_inclusive_scan</code>：输入的第一个元素为输出结果的第一个元素（<code>c++17</code>）。</p>
<p><code>exclusive_scan</code>, <code>transform_exclusive_scan</code>：输出第一个元素为0，最后一个输入元素不会参与运算。</p>
</blockquote>
<h3 id="有序序列"><a class="header" href="#有序序列">有序序列</a></h3>
<p>查找有序序列：</p>
<pre><code class="language-c++">tf = binary_search(@begin, @end, value, comp=&lt;);
</code></pre>
<blockquote>
<p><code>@pos=lower_bound</code>(<code>upper_bound</code>)：查找不小（大）于指定值的第一个元素；</p>
<p><code>&lt;@start,@end&gt;=equal_range()</code>：查找等于指定值的子序列；</p>
<p><code>tf=includes(...)</code>：查找子序列；</p>
</blockquote>
<p>合并有序序列：</p>
<pre><code class="language-c++">merge(@begin1, @end1, @begin2, @end2, @out);
</code></pre>
<img src="CC++/hackingcpp/inplace_merge_thumb.svg" style="zoom:45%;" align="left"/>
<h3 id="集合运算-1"><a class="header" href="#集合运算-1">集合运算</a></h3>
<pre><code class="language-c++">@end=set_union(@begin1, @end1, @begin2, @end2, @out, compare=&lt;);
</code></pre>
<blockquote>
<p><code>set_intersection</code>、<code>set_difference</code>（在s1中而不在s2中）、<code>set_symmtric_difference</code>（仅在s1或s2中）。</p>
</blockquote>
<h3 id="函数对象-3"><a class="header" href="#函数对象-3">函数对象</a></h3>
<h4 id="比较运算-1"><a class="header" href="#比较运算-1">比较运算</a></h4>
<h6 id="include-functional"><a class="header" href="#include-functional"><code>#include &lt;functional&gt;</code></a></h6>
<ul>
<li>
<p><code>std::equal_to</code></p>
</li>
<li>
<p><code>std::not_equal_to</code></p>
</li>
<li>
<p><code>std::greater</code></p>
</li>
<li>
<p><code>std::less</code></p>
</li>
<li>
<p><code>std::greater_equal</code></p>
</li>
<li>
<p><code>std::less_equal</code></p>
</li>
<li>
<p><a href="https://hackingcpp.com/tags/c++11.html">C++11</a>  must specify operand type explicitly: <code>std::greater&lt;Type&gt;{}</code></p>
</li>
<li>
<p><a href="https://hackingcpp.com/tags/c++14.html">C++14</a>  no need for specifying operand type: <code>std::greater&lt;&gt;{}</code></p>
</li>
</ul>
<h4 id="算术运算"><a class="header" href="#算术运算">算术运算</a></h4>
<ul>
<li><code>std::plus</code></li>
<li><code>std::minus</code></li>
<li><code>std::multiplies</code></li>
<li><code>std::divides</code></li>
<li><code>std::modulus</code></li>
<li><code>std::negate</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="javascript"><a class="header" href="#javascript">JavaScript</a></h1>
<blockquote>
<p><em>... for the 6th major edition of the standard, published in June 2015. Since then a yearly edition has been published. For example, the <a href="https://www.ecma-international.org/publications-and-standards/standards/ecma-262/">13th edition</a> was published in June 2022<sup class="footnote-reference"><a href="#intro-js">1</a></sup>.</em></p>
<p><em>Unlike most programming languages, the JavaScript language has ==no concept of input or output==. It is designed to run as a scripting language in a ==host environment==, and it is up to the host environment to provide mechanisms for communicating with the outside world.</em> <em>The most common host environment is the ==browser==, but JavaScript interpreters can also be found in other places, including Adobe Acrobat/Photoshop, SVG images, server-side environments such as <a href="https://nodejs.org/">==Node.js==</a>, NoSQL databases like <a href="https://couchdb.apache.org/">Apache CouchDB</a>, desktop environments like <a href="https://www.gnome.org/">GNOME</a> , and others.</em></p>
<p>JavaScript is a multi-paradigm, dynamic language with types and operators, standard built-in objects, and methods. Its syntax is based on the Java and C languages.</p>
<img src="JavaScript/JavaScript.assets/cake.png" alt="img" style="zoom: 60%;float: right" />
***HTML**, **CSS**, and **JavaScript** are **front-end** (or **client-side**) languages, which means they are run by the browser to produce a website front-end that your users can use[^web-basic]. There are **back-end** (or **server-side**) languages, running on the server to get some data out of a database and generate some HTML to contain the data, before the result is then sent to the browser to be displayed. Example server-side languages include **ASP.NET**, **Python**, **PHP**, and **NodeJS**.* 
<p><a href="https://developer.mozilla.org/en-US/docs/Learn/JavaScript/First_steps">JavaScript First Steps - Learn web development | MDN (mozilla.org)</a></p>
<p><a href="https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Building_blocks">JavaScript building blocks - Learn web development | MDN (mozilla.org)</a></p>
<p><a href="https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/Basics">JavaScript object basics - Learn web development | MDN (mozilla.org)</a></p>
</blockquote>
<h2 id="变量-6"><a class="header" href="#变量-6">变量</a></h2>
<h3 id="变量类型"><a class="header" href="#变量类型">变量类型</a></h3>
<ul>
<li>
<p>Number：双精度64位浮点数/整数（整数也按浮点数处理）；</p>
<pre><code class="language-javascript">parseInt('123', 10)  // 将字符串转换为整数
parseInt('123.45')   // 将字符串转换为浮点数
</code></pre>
<p><code>NaN</code>、<code>Infinity</code>和<code>-Infinity</code></p>
<pre><code class="language-javascript">Number.isNaN(NaN)
isFinite(1 / 0); // false
</code></pre>
</li>
<li>
<p>BigInt</p>
</li>
<li>
<p>String：UTF-16编码。</p>
<pre><code class="language-javascript">'hello'.length;  // 字符串长度(编码单位*)
</code></pre>
<blockquote>
<p><code>*</code>：一个字符由一个或两个UTF-16编码单位组成，一个编码单位占用2字节。</p>
</blockquote>
</li>
<li>
<p>Boolean</p>
</li>
<li>
<p>Function</p>
</li>
<li>
<p>Object</p>
<ul>
<li><code>Function</code></li>
<li><code>Array</code></li>
<li><code>Date</code></li>
<li><code>RegExp</code></li>
<li><code>Math</code>：提供数学计算方法和常量。</li>
<li><code>Error</code></li>
</ul>
</li>
<li>
<p>Symbol (ES2015)</p>
</li>
<li>
<p><code>undefined</code>和<code>null</code>：<code>null</code>表示故意设置的空值，<code>undefined</code>表示变量未初始化。</p>
</li>
<li>
<p><code>boolean</code>：表示<code>true</code>或<code>false</code>。<code>false</code>、<code>0</code>、空字符串(<code>&quot;&quot;</code>)、<code>NaN</code>、<code>null</code>和<code>undefined</code> 都可转换为<code>false</code>；其他值则转换为<code>true</code>。<code>if</code>等语句块的判断条件可执行自动转换。</p>
<pre><code class="language-javascript">Boolean(1)  // true
</code></pre>
<p><code>boolean</code>类型支持<code>&amp;&amp;</code>、<code>||</code>和<code>!</code>逻辑运算。</p>
</li>
</ul>
<h4 id="变量声明-3"><a class="header" href="#变量声明-3">变量声明</a></h4>
<pre><code class="language-javascript">let a = 1;       // block-scope variable
const c = 3.14   // block-scope constant
var b = &quot;hello&quot;; // function-scope variable
</code></pre>
<p>变量类型由初始化的值决定，如果未赋值，其类型为<code>undefined</code>。</p>
<h3 id="运算符-14"><a class="header" href="#运算符-14">运算符</a></h3>
<h5 id="数值运算符"><a class="header" href="#数值运算符">数值运算符</a></h5>
<p><code>+</code>, <code>-</code>, <code>*</code>, <code>/</code> and <code>%</code> 。</p>
<p><code>+</code>可用于字符串拼接。</p>
<h5 id="赋值运算符-1"><a class="header" href="#赋值运算符-1">赋值运算符</a></h5>
<p><code>=</code>、<code>+=</code>、……、<code>++</code>、<code>--</code>（可前缀/后缀）</p>
<h5 id="比较运算符-4"><a class="header" href="#比较运算符-4">比较运算符</a></h5>
<p><code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code> and <code>&gt;=</code>.</p>
<p><code>==</code>进行比较时会对不同类型尝试强制转换；<code>===</code>，<code>!==</code>则直接比较。</p>
<p>没有<code>!=</code>运算符，使用逻辑<code>!</code>转换比较结果。</p>
<h5 id="逻辑运算符-2"><a class="header" href="#逻辑运算符-2">逻辑运算符</a></h5>
<p><code>&amp;&amp;</code>和<code>||</code>支持<strong>短路</strong>。</p>
<h3 id="字符串-5"><a class="header" href="#字符串-5">字符串</a></h3>
<p><code>str[i]//.charAt(5);</code></p>
<p><code>.indexOf/lastIndexOf(substr)</code></p>
<p><code>.slice(i[,j]);</code></p>
<p><code>.length</code></p>
<p><code>toUpperCase()</code> and <code>toLowerCase()</code></p>
<p><code>.split(&quot; &quot;);</code></p>
<p><code>.trim();</code></p>
<p><code>.replace(&quot;How&quot;, &quot;Where&quot;);</code></p>
<p><code>.replace(/javascript/gi, &quot;JavaScript&quot;)</code>：正则表达式替换；</p>
<h5 id="字符串插值"><a class="header" href="#字符串插值">字符串插值</a></h5>
<pre><code class="language-javascript">const poem = &quot;The Wide Ocean&quot;, author = &quot;Pablo Neruda&quot;;
const favePoem = `My favorite poem is ${poem} by ${author}.`; //支持换行, 支持包含引号
</code></pre>
<h5 id="引号转义"><a class="header" href="#引号转义">引号转义</a></h5>
<p>交替使用<code>''</code>和<code>&quot;&quot;</code>；</p>
<p>使用<code>\'</code>或<code>\&quot;</code>进行转义；</p>
<p>使用<code>&quot;``&quot;</code>。</p>
<h3 id="对象类型"><a class="header" href="#对象类型">对象类型</a></h3>
<h4 id="构造对象实例"><a class="header" href="#构造对象实例">构造对象实例</a></h4>
<p>JavaScript对象可以看作<code>name-value</code>组成的集合，类似于Python字典、C/C++散列表或Java<code>HashMap</code>等。</p>
<p>构造空对象：</p>
<pre><code class="language-javascript">const obj = new Object();
const obj = {};  // prefered JSON format*
</code></pre>
<blockquote>
<p><code>*</code>：<strong>JSON</strong> - <em>JavaScript Object Notation</em>。</p>
</blockquote>
<p>构造包含属性和方法的对象。</p>
<pre><code class="language-javascript">const obj = {
  name: 'Carrot',
  details: { color: 'orange', size: 12 },
  var,                           //*
  func_name(){/*...*/}           //定义函数
  func_name: function(){/*...*/} //使用匿名函数语法
};
</code></pre>
<blockquote>
<p><code>*</code>：简写，使用变量名和变量的值。</p>
</blockquote>
<p>使用函数定义构造对象（函数对象）。函数既是对象类型也作为对象的构造函数。</p>
<pre><code class="language-javascript">function Person(name, age) {
  this.name = name;
  this.age = age;
  this.fullName = function(){/**/}
} 
</code></pre>
<h5 id="使用对象原型构造对象"><a class="header" href="#使用对象原型构造对象">使用对象原型构造对象</a></h5>
<p>上述使用函数构造对象的方法在实例化对象时会重复定义函数成员，使用对象原型<code>ClassName.prototype</code>定义所有实例共享的函数对象与静态成员。</p>
<pre><code class="language-javascript">Person.prototype.fullName = function() {/*...*/}; 
const you = new Person('You', 24);
</code></pre>
<p><code>new</code>创建一个空对象，并将其赋值给<code>Person</code>函数的<code>this</code>。未使用<code>new</code>，则<code>this</code>表示的是全局变量空间。</p>
<h4 id="访问属性"><a class="header" href="#访问属性">访问属性</a></h4>
<pre><code class="language-javascript">obj.details.color
obj['details']['color']
</code></pre>
<p>对象内部可使用<code>this</code>引用当前对象的属性。</p>
<h4 id="数组-7"><a class="header" href="#数组-7">数组</a></h4>
<p>数组是一类特殊的JavaScript对象。</p>
<pre><code class="language-javascript">const a = new Array();
a[0] = 'dog'; a[1] = 'cat'; a[2] = 'hen'; //*
a.push(item); // 追加元素
a.length;     // -&gt; 3
const a = ['dog', 'cat', 'hen'];
</code></pre>
<blockquote>
<p><code>*</code>：数组可动态扩展，对应下标未赋值的元素的值为<code>undefined</code>（类似于Shell脚本）。</p>
</blockquote>
<h5 id="数组迭代"><a class="header" href="#数组迭代">数组迭代</a></h5>
<ol>
<li>
<p>使用<a href="JavaScript/JavaScript.html#%E5%BE%AA%E7%8E%AF">循环</a>进行迭代。</p>
</li>
<li>
<p>使用<code>forEach</code>方法进行迭代。</p>
<pre><code class="language-javascript">array.forEach(iter_func)
</code></pre>
</li>
</ol>
<h5 id="数组方法"><a class="header" href="#数组方法">数组方法</a></h5>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array">Array - JavaScript | MDN (mozilla.org)</a></p>
<h2 id="语法-4"><a class="header" href="#语法-4">语法</a></h2>
<p>换行：</p>
<p>注释：单行<code>// coments</code>；多行<code>/*comments*/</code>。</p>
<h3 id="流程控制-7"><a class="header" href="#流程控制-7">流程控制</a></h3>
<h5 id="条件选择"><a class="header" href="#条件选择">条件选择</a></h5>
<pre><code class="language-javascript">if (name === 'puppies') {}
else if (name === 'kittens') {}
else {} // 与C语言结构相同
</code></pre>
<pre><code class="language-javascript">switch (action) {
  case 'draw':
    break; // 如果不添加break, 则会继续执行后续分支
  case 'eat';
    break;
  default:
    doNothing();
} // 比较总是使用&quot;===&quot;
</code></pre>
<h5 id="循环-7"><a class="header" href="#循环-7">循环</a></h5>
<pre><code class="language-javascript">while (n &gt; 0) {}
do {
  input = get_input();
} while (!(input === 'exit'));
</code></pre>
<pre><code class="language-javascript">for (let i = 0; i &lt; 5; ++i){}
for (const v of array) {}     // 迭代数组元素
for (const prop in object) {} // 迭代对象属性
</code></pre>
<h3 id="函数-6"><a class="header" href="#函数-6">函数</a></h3>
<pre><code class="language-javascript">function add(x, y,...args) {
  const total = x + y;
  return total;  // 如果未指定返回值, 返回undefined
}
</code></pre>
<h4 id="参数列表"><a class="header" href="#参数列表">参数列表</a></h4>
<p>函数参数列表仅具有声明意义，实际调用时可传入少于或多于声明的参数个数。缺少的参数将被视为<code>undefined</code>，多余的参数被忽略</p>
<h5 id="变长参数列表"><a class="header" href="#变长参数列表">变长参数列表</a></h5>
<ol>
<li>使用<code>...args</code>捕获所有未声明的传入参数。</li>
<li>可在函数内部，通过<code>arguments</code>访问传入的所有参数。</li>
<li>参数展开：调用时<code>func(...args)</code>。</li>
</ol>
<h4 id="函数对象-4"><a class="header" href="#函数对象-4">函数对象</a></h4>
<p>函数也是一类特殊对象，可用于变量赋值或参数传递赋值。</p>
<h5 id="匿名函数-2"><a class="header" href="#匿名函数-2">匿名函数</a></h5>
<pre><code class="language-javascript">let avg = function(){};
</code></pre>
<h5 id="closures"><a class="header" href="#closures"><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/A_re-introduction_to_JavaScript#closures">closures</a></a></h5>
<blockquote>
<p><em>Whenever JavaScript executes a function, a '<strong>scope</strong>' object is created to hold the local variables created within that function.</em></p>
<p><em>A <strong>closure</strong> is the combination of a function and the scope object in which it was created.</em> </p>
</blockquote>
<h4 id="嵌套函数"><a class="header" href="#嵌套函数">嵌套函数</a></h4>
<p>可访问其上级函数作用域中的变量。</p>
<h3 id="异步"><a class="header" href="#异步">异步</a></h3>
<p>✨<a href="https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Asynchronous/Introducing">Introducing asynchronous JavaScript - Learn web development | MDN (mozilla.org)</a></p>
<h2 id="标准库-2"><a class="header" href="#标准库-2">标准库</a></h2>
<h3 id="输入输出-6"><a class="header" href="#输入输出-6">输入输出</a></h3>
<p><code>console</code>是封装控制台的对象，可向控制台（浏览器控制台/Node.js终端）输出日志：</p>
<pre><code class="language-javascript">console.log(obj)  // trace/debug/info/warn/error
</code></pre>
<blockquote>
<p><code>log</code>系列函数可直接输出对象。</p>
</blockquote>
<h3 id="时间日期-1"><a class="header" href="#时间日期-1">时间日期</a></h3>
<pre><code class="language-javascript">Date();
</code></pre>
<h2 id="浏览器应用"><a class="header" href="#浏览器应用">浏览器应用</a></h2>
<p>HTML文件中通过<code>&lt;script&gt;</code>标签引用JavaScript脚本（可位于<code>&lt;head&gt;</code>或<code>&lt;body&gt;</code>，相对HTML文件路径），默认情况下脚本执行顺序与引用顺序一致。脚本执行环境由浏览器解释器构建，通过运行环境中的<code>document</code>对象（<code>Document</code>）对HTML页面进行修改（页面元素内容、CSS等）。</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;
      &lt;meta charset=&quot;UTF-8&quot; /&gt;
      &lt;title&gt;JavaScript Tutorial&lt;/title&gt;
      &lt;script src=&quot;scripts/main.js&quot; defer&gt;&lt;/script&gt; &lt;!--*--&gt;
      &lt;script&gt;/*inline script*/&lt;/script&gt;
  &lt;/head&gt;

  &lt;body&gt;
    &lt;h1&gt;&lt;/h1&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<blockquote>
<p><code>*</code>：<code>defer</code>在HTML文档解析完成后再执行脚本程序（按出现顺序执行），<code>async</code>：异步获取脚本内容而不阻塞页面加载，当脚本下载完后会立即开始执行（仅用于独立执行的脚本）。</p>
<p><img src="JavaScript/JavaScript.assets/async-defer.jpg" alt="img" /></p>
<p>对于与页面内容紧密相关的脚本，可将其置于对应的HTML元素之后。</p>
<p>使用独立的脚本文件的优点：1）分离HTML和Javascript代码，使两者更易于书写、理解和维护；2）独立的脚本文件可在本地缓存，从而加快页面的加载速度。</p>
</blockquote>
<pre><code class="language-javascript">const myHeading = document.querySelector('h1'); //*
myHeading.textContent = 'Hello world!';
</code></pre>
<blockquote>
<p><code>*</code>：<em>Returns the first element that is a descendant of node that matches selectors.</em></p>
</blockquote>
<p>JavaScript的作用：</p>
<ul>
<li>动态更新HTML和CSS文件；</li>
<li>处理用户交互。</li>
</ul>
<p>✨<a href="https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Client-side_web_APIs/Introduction">Introduction to web APIs - Learn web development | MDN (mozilla.org)</a></p>
<h3 id="事件处理-1"><a class="header" href="#事件处理-1">事件处理</a></h3>
<pre><code class="language-javascript">document.querySelector('html')  // 获取页面对象
    .addEventListener(          // 为对象增加事件处理方法
        'click',
        function () {
            alert('Ouch! Stop poking me!');
        }
    );
</code></pre>
<h3 id="交互组件"><a class="header" href="#交互组件">交互组件</a></h3>
<pre><code class="language-javascript">alert(msg);
let value = prompt(msg);
</code></pre>
<h3 id="存储"><a class="header" href="#存储">存储</a></h3>
<h4 id="localstorage-api"><a class="header" href="#localstorage-api"><code>localStorage</code> API</a></h4>
<pre><code class="language-javascript">localStorage.setItem('name', 'gary');
const stored_name = localStorage.getItem('name');
</code></pre>
<h3 id="优化-2"><a class="header" href="#优化-2">优化</a></h3>
<p><code>program.min.js</code>是<code>program.js</code>优化后的文件，减少网络传输以加快网页加载：将长变量转换为短名。</p>
<p><strong>just-in-time compiling</strong>：</p>
<blockquote>
<p><em>The JavaScript source code gets compiled into a faster, binary format while the script is being used, so that it can be run as quickly as possible.</em></p>
</blockquote>
<h2 id="nodejs"><a class="header" href="#nodejs">Node.js</a></h2>
<h3 id="nodejs项目"><a class="header" href="#nodejs项目">Node.js项目</a></h3>
<h4 id="模块-1"><a class="header" href="#模块-1">模块</a></h4>
<p>在Node.js中，一般将代码合理拆分到不同的文件中，每一个文件就是一个模块，而文件路径就是模块名。在编写每个模块时，</p>
<ul>
<li>
<p><code>require</code><strong>函数</strong>用于加载和使用模块（执行模块代码并返回导出内容，一个模块中的代码仅在模块第一次被使用时执行一次）。另外，可以<code>require</code>加载一个JSON文件。</p>
<pre><code class="language-javascript">let data = require('./data/two-nodes.json')
console.log(data);
</code></pre>
</li>
<li>
<p><code>exports</code><strong>对象</strong>用于保存当前模块要导出的公有对象。通过<code>require</code>函数引用的就是模块的<code>exports</code>对象。</p>
<pre><code class="language-javascript">exports.hello = function () {
    console.log('Hello World!');
};
</code></pre>
</li>
<li>
<p><code>module</code>对象可以访问到当前模块包括<code>exports</code>在内的信息，主要用途是替换当前模块的<code>exports</code>对象。</p>
</li>
</ul>
<blockquote>
<p><code>***</code>：<code>import</code>的用法。</p>
<pre><code class="language-javascript">import defaultExport from &quot;module-name&quot;;
import * as name from &quot;module-name&quot;;
import { export } from &quot;module-name&quot;;
import { export as alias } from &quot;module-name&quot;;
</code></pre>
</blockquote>
<h5 id="模块路径解析规则"><a class="header" href="#模块路径解析规则">模块路径解析规则</a></h5>
<p>通过文件路径：模块名可使用相对路径（<code>./</code>开头）或绝对路径（以<code>/</code>或<code>X:</code>开头）；</p>
<p>通过搜索路径：模块名按搜索路径下的层级索引（类似于<code>foo/bar</code>），搜索顺序：</p>
<ul>
<li>内置模块</li>
<li><code>node_modules</code>目录</li>
<li><code>$NODE_PATH</code></li>
</ul>
<p>模块名中的<code>.js</code>扩展名可以省略。</p>
<h5 id="主模块"><a class="header" href="#主模块">主模块</a></h5>
<p>通过命令行参数传递给NodeJS以启动程序的模块被称为主模块。主模块通过引用程序的其它模块完成工作。</p>
<h5 id="入口程序"><a class="header" href="#入口程序">入口程序</a></h5>
<pre><code class="language-javascript">function main(argv) {
    copy(argv[2], argv[3]);  //argv[0]是node路径, argv[1]是主模块文件路径。
}
main(process.argv);
</code></pre>
<blockquote>
<p><code>process</code>是Node.js执行环境中的全局变量。</p>
</blockquote>
<h4 id="包-1"><a class="header" href="#包-1">包</a></h4>
<p>把由多个子模块组成的大模块称做<code>包</code>，并把所有子模块放在同一个目录里。其中一个模块作为入口模块，其导出对象将引用其他模块的导出对象，作为整个包的导出对象。当入口模块的文件名是<code>index.js</code>，加载模块时可以使用模块所在目录的路径代替模块文件路径。</p>
<p>可通过包目录下的<code>package.json</code>修改默认的入口模块名和位置。</p>
<pre><code class="language-json">{
  &quot;name&quot;: &quot;cat&quot;,
  &quot;main&quot;: &quot;./lib/main.js&quot;
}
</code></pre>
<h4 id="工程目录"><a class="header" href="#工程目录">工程目录</a></h4>
<pre><code class="language-shell">- /home/user/workspace/node-echo/   # 工程目录
    - bin/                          # 存放命令行相关代码
        node-echo
    + doc/                          # 存放文档
    - lib/                          # 存放API相关代码
        echo.js
    - node_modules/                 # 存放三方包
        + argv/
    + tests/                        # 存放测试用例
    package.json                    # 元数据文件
    README.md                       # 说明文件
</code></pre>
<h4 id="执行nodejs程序"><a class="header" href="#执行nodejs程序">执行Node.js程序</a></h4>
<p>启动Node.js程序：</p>
<ul>
<li>
<p>直接在命令行通过<code>node</code>解释执行脚本；</p>
<pre><code class="language-shell">node src/index.js
</code></pre>
</li>
<li>
<p>在Linux系统下，通过脚本首行<code>#! /usr/bin/env node</code>指定当前脚本的解释器，并为该脚本添加可执行权限；</p>
</li>
<li>
<p>在Windows系统下，通过一个cmd或PowerShell脚本封装<code>node</code>命令；</p>
<pre><code class="language-powershell">@node &quot;./node-echo.js&quot; %*
</code></pre>
</li>
</ul>
<h3 id="输入输出-7"><a class="header" href="#输入输出-7">输入输出</a></h3>
<h4 id="标准输入输出-5"><a class="header" href="#标准输入输出-5">标准输入输出</a></h4>
<p><code>process.stdin</code>、<code>process.stdout</code>和<code>process.stderr</code>。</p>
<pre><code class="language-javascript">process.stdout.write(util.format.apply(util, arguments) + '\n');
</code></pre>
<h4 id="文件读写-2"><a class="header" href="#文件读写-2">文件读写</a></h4>
<pre><code class="language-javascript">var fs = require('fs')
function copy(src, dst) {
    fs.writeFileSync(dst, fs.readFileSync(src));
}
</code></pre>
<h5 id="异步读写"><a class="header" href="#异步读写">异步读写</a></h5>
<p>通过回调函数处理数据或错误。</p>
<pre><code class="language-javascript">fs.readFile(pathname, function (err, data) {
    if (err) {
        // Deal with error.
    } else { 
        // Deal with data.
    }
});
</code></pre>
<blockquote>
<p>命名约定：默认为异步方法，带<code>Sync</code>的方法为同步方法。</p>
</blockquote>
<h5 id="流式读写"><a class="header" href="#流式读写">流式读写</a></h5>
<pre><code class="language-javascript">function copy(src, dst) {
    fs.createReadStream(src).pipe(fs.createWriteStream(dst));
}
</code></pre>
<p><code>Stream</code>基于事件机制工作。</p>
<pre><code class="language-javascript">var rs = fs.createReadStream(pathname);
rs.on('data', function (chunk) { 
    rs.puase();
    doSomething(chunk, function(){rs.resume()}); 
});
rs.on('end', function () { cleanUp(); });
</code></pre>
<h5 id="buffer"><a class="header" href="#buffer">Buffer</a></h5>
<p>http://nodejs.org/api/buffer.html</p>
<h5 id="文本编码"><a class="header" href="#文本编码">文本编码</a></h5>
<p><code>iconv-lite</code>转码。</p>
<h4 id="文件系统-3"><a class="header" href="#文件系统-3">文件系统</a></h4>
<h5 id="路径操作"><a class="header" href="#路径操作">路径操作</a></h5>
<p>http://nodejs.org/api/path.html</p>
<pre><code class="language-javascript">path.normalize(pathname)
path.join(name1, name2)
path.extname('foo/bar.js'); // =&gt; &quot;.js&quot;
</code></pre>
<h5 id="访问目录信息"><a class="header" href="#访问目录信息">访问目录信息</a></h5>
<pre><code class="language-javascript">fs.readdirSync(pathname)
fs.statSync(pathname)
</code></pre>
<h3 id="网络操作"><a class="header" href="#网络操作">网络操作</a></h3>
<h4 id="http服务"><a class="header" href="#http服务">http服务</a></h4>
<pre><code class="language-javascript">var http = require('http');
http_server = http.createServer(http_handler);
http_server.listen(8124);
</code></pre>
<pre><code class="language-javascript">let http_handler = function (request, response) {
    /*接收请求数据*/
    var body[];
    request.on('data', function (chunk) {
        body.push(chunk);
        // response.write(chunk); // 将请求数据原样返回
    });
    request.on('end', function () {
        body = Buffer.concat(body);
        console.log(body.toString());
        // response.end();
    });
	/*发送响应*/ 
    response.writeHead(200, { 'Content-Type': 'text-plain' });
    response.end('Hello World\n');
}
</code></pre>
<blockquote>
<p><code>request</code>是一个对象，可以访问<code>request.url</code>。</p>
</blockquote>
<h5 id="http客户端-1"><a class="header" href="#http客户端-1">http客户端</a></h5>
<pre><code class="language-javascript">var options = {
        hostname: 'www.example.com',
        port: 80,
        path: '/upload',
        method: 'POST',
        headers: {
            'Content-Type': 'application/x-www-form-urlencoded'
        }
    };
var request = http.request(options, function (response) {});
request.write('Hello World');
request.end();
// =&gt; http.get('http://www.example.com/', function (response) {});
</code></pre>
<h5 id="https"><a class="header" href="#https">https</a></h5>
<p>http://nodejs.org/api/https.html</p>
<h5 id="url"><a class="header" href="#url">URL</a></h5>
<pre><code class="language-javascript">url.parse('http://user:pass@host.com:8080/p/a/t/h?query=string#hash');
// 返回数据：
{ protocol: 'http:',
  auth: 'user:pass',
  host: 'host.com:8080',
  port: '8080',
  hostname: 'host.com',
  hash: '#hash',
  search: '?query=string',
  query: 'query=string',
  pathname: '/p/a/t/h',
  path: '/p/a/t/h?query=string',
  href: 'http://user:pass@host.com:8080/p/a/t/h?query=string#hash' 
}
</code></pre>
<p>请求参数</p>
<p>http://nodejs.org/api/querystring.html</p>
<h3 id="进程管理"><a class="header" href="#进程管理">进程管理</a></h3>
<p><code>process</code>对象用于管理控制当前进程。</p>
<h4 id="创建进程-2"><a class="header" href="#创建进程-2">创建进程</a></h4>
<pre><code class="language-javascript">var child = child_process.spawn('node', [ 'xxx.js' ], 
                                stdio:[0,1,2,'ipc']);
// 获取子进程的输出
child.stdout.on('data', function (data) {
    console.log('stdout: ' + data);
});
child.stderr.on('data', function (data) {
    console.log('stderr: ' + data);
});
child.on('close', function (code) {
    console.log('child process exited with code ' + code);
});
</code></pre>
<h5 id="同步调用"><a class="header" href="#同步调用">同步调用</a></h5>
<pre><code class="language-javascript">var child_process = require('child_process');
var util = require('util');

function copy(source, target, callback) {
    child_process.exec(
        util.format('cp -r %s/* %s', source, target), callback);
}
</code></pre>
<h5 id="cluster"><a class="header" href="#cluster">cluster</a></h5>
<p><code>cluster</code>模块是对<code>child_process</code>模块的进一步封装，用于解决单进程服务无法充分利用多核CPU的问题。使用该模块可以让每个核上运行一个工作进程，并统一通过主进程监听端口和分发请求。</p>
<h5 id="降低进程权限"><a class="header" href="#降低进程权限">降低进程权限</a></h5>
<pre><code class="language-javascript">http.createServer(callback).listen(80, function () {
    var env = process.env,
        uid = parseInt(env['SUDO_UID'] || process.getuid(), 10),
        gid = parseInt(env['SUDO_GID'] || process.getgid(), 10);

    process.setgid(gid);
    process.setuid(uid);
});
</code></pre>
<h5 id="退出进程"><a class="header" href="#退出进程">退出进程</a></h5>
<pre><code class="language-javascript">try {
    // ...
} catch (err) {
    // ...
    process.exit(1);
}
</code></pre>
<h4 id="进程间通信-1"><a class="header" href="#进程间通信-1">进程间通信</a></h4>
<h5 id="信号-1"><a class="header" href="#信号-1">信号</a></h5>
<pre><code class="language-javascript">child.kill('SIGTERM')
</code></pre>
<h5 id="ipc"><a class="header" href="#ipc">IPC</a></h5>
<pre><code class="language-javascript">/* parent.js: 收发数据 */
child.on('message', function (msg) {
    console.log(msg);
});
child.send({ hello: 'hello' });

/* child.js: 接收数据 */
process.on('message', function (msg) {
    msg.hello = msg.hello.toUpperCase();
    process.send(msg);
});
</code></pre>
<p>数据格式为序列化JSON文本。</p>
<h4 id="守护进程-1"><a class="header" href="#守护进程-1">守护进程</a></h4>
<h3 id="异步编程-2"><a class="header" href="#异步编程-2">异步编程</a></h3>
<p>异步方式下，函数执行结果不是通过返回值，而是通过回调函数的参数传递。</p>
<p>JS自身提供的异常捕获和处理机制<code>try..catch..</code>，只能用于同步执行的代码。由于异步函数会打断代码执行路径，异步函数执行过程中以及执行之后产生的异常抛出到执行路径被打断的位置过程中，如果没有遇到<code>try</code>语句，就作为一个全局异常抛出。</p>
<h5 id="使用域简化异步代码的异常处理"><a class="header" href="#使用域简化异步代码的异常处理">使用域简化异步代码的异常处理</a></h5>
<p>在域（就是运行环境）中，如果一个异常没有被捕获，将作为一个全局异常被抛出。Node.js通过<code>process</code>对象提供了捕获全局异常的方法。</p>
<pre><code class="language-javascript">process.on('uncaughtException', function (err) {
    console.log('Error: %s', err.message);
});
</code></pre>
<p>创建子域以尽早捕获异常。</p>
<pre><code class="language-javascript">http.createServer(function (request, response) {
    var d = domain.create();
    d.on('error', function () {/*error handler*/ });
    d.run(function () {
        asyncMethod(request, function (data) {/*processing*/});
    });
});
</code></pre>
<blockquote>
<p>使用<code>uncaughtException</code>或<code>domain</code>捕获异常，代码执行路径里涉及到了C/C++部分的代码时，如果不能确定是否会导致内存泄漏等问题，最好在处理完异常后重启程序比较妥当。而使用<code>try</code>语句捕获异常时一般捕获到的都是JS本身的异常，不用担心上诉问题。</p>
</blockquote>
<p>http://nodejs.org/api/domain.html</p>
<h2 id="参考资料-1"><a class="header" href="#参考资料-1">参考资料</a></h2>
<div class="footnote-definition" id="brief-js"><sup class="footnote-definition-label">2</sup>
<p><a href="https://www.typescriptlang.org/docs/handbook/typescript-from-scratch.html#what-is-javascript-a-brief-history">What is JavaScript? A Brief History</a>
<sup class="footnote-reference"><a href="#intro-js">1</a></sup>: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/A_re-introduction_to_JavaScript">A re-introduction to JavaScript (JS tutorial) - JavaScript | MDN (mozilla.org)</a>
<sup class="footnote-reference"><a href="#webwork">3</a></sup>:<a href="https://developer.mozilla.org/en-US/docs/Learn/Getting_started_with_the_web/How_the_Web_works">How the web works - Learn web development | MDN (mozilla.org)</a>
<sup class="footnote-reference"><a href="#web-basic">4</a></sup>: <a href="https://developer.mozilla.org/en-US/docs/Learn/Getting_started_with_the_web/The_web_and_web_standards">The web and web standards - Learn web development | MDN (mozilla.org)</a>
<sup class="footnote-reference"><a href="#jsdoc">5</a></sup>: <a href="https://devdocs.io/javascript/">JavaScript documentation — DevDocs</a>
<sup class="footnote-reference"><a href="#awesome">6</a></sup>: <a href="https://github.com/micromata/awesome-javascript-learning">micromata/awesome-javascript-learning: A tiny list limited to the best JavaScript Learning Resources (github.com)</a></p>
</div>
<div class="footnote-definition" id="7day-nodejs"><sup class="footnote-definition-label">7</sup>
<p><a href="http://nqdeng.github.io/7-days-nodejs/#1">七天学会NodeJS (nqdeng.github.io)</a></p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="typescript"><a class="header" href="#typescript">TypeScript</a></h1>
<blockquote>
<p><em>A Typed Superset of JavaScript.</em></p>
</blockquote>
<ul>
<li>TypeScript is a language that is a <em>superset</em> of JavaScript: JS syntax is therefore legal TS.</li>
<li>TypeScript is a <em>typed</em> superset, meaning that it adds rules about how different kinds of values can be used.</li>
<li>TypeScript <strong>never</strong> changes the runtime behavior of JavaScript code, even if TypeScript thinks that the code has type errors.</li>
</ul>
<h2 id="对象类型声明"><a class="header" href="#对象类型声明">对象类型声明</a></h2>
<p>JavaScript的变量具有类型，但使用前无需声明。TypeScript增加了类型声明，从而支持静态类型检查。</p>
<h3 id="基础类型"><a class="header" href="#基础类型">基础类型</a></h3>
<p><code>string</code>, <code>number</code>, and <code>boolean</code></p>
<pre><code class="language-typescript">let myName: string = &quot;Alice&quot;;
</code></pre>
<p><code>bigint</code> <code>[ES2020]</code></p>
<p><code>null</code> and <code>undefined</code> with  <code>strictNullChecks</code> on：必须处理变量为<code>null</code>或<code>undefined</code>的情形。</p>
<h5 id="non-null-assertion-operator"><a class="header" href="#non-null-assertion-operator">Non-null Assertion Operator</a></h5>
<pre><code class="language-ts">function liveDangerously(x?: number | null) {
    console.log(x!.toFixed());  // ! add assertion for null/undefined
}
</code></pre>
<h3 id="数组-8"><a class="header" href="#数组-8">数组</a></h3>
<p><code>string[]</code>, <code>number[]</code>, <code>boolean[]</code> or <code>Array&lt;number&gt;</code></p>
<h3 id="any"><a class="header" href="#any"><code>any</code></a></h3>
<p>表示任意类型，避免类型检查错误。任何无法自动推测的对象会被视为<code>any</code>类型导致跳过类型检查，在项目配置中设置<code>noImplicitAny</code>将无法推测的类型视为错误。</p>
<h3 id="对象类型-1"><a class="header" href="#对象类型-1">对象类型</a></h3>
<pre><code class="language-typescript">let pt: {x: number; y: number} = {x:3, y:7};
let name: {first: string; last?: string};
name.last !== undefined    // check optional property existence
</code></pre>
<h3 id="函数-7"><a class="header" href="#函数-7">函数</a></h3>
<pre><code class="language-typescript">// Parameter type annotation
function greet(name: string): number {
    console.log(&quot;Hello, &quot; + name.toUpperCase() + &quot;!!&quot;);
    return 0;
}
</code></pre>
<p>匿名函数参数类型可根据其调用==上下文推断==，因此无需声明其参数类型。</p>
<h4 id="函数类型变量声明"><a class="header" href="#函数类型变量声明">函数类型变量声明</a></h4>
<p>函数也是一种变量类型，因此可以用于类型声明。</p>
<pre><code class="language-typescript">function func(fn: (a: string)=&gt;void)
type GreetFunction = (a: string) =&gt; void; // 为函数类型定义别名*
</code></pre>
<blockquote>
<p><code>*</code>：函数类型声明中必须同时给出参数名和参数类型名；如果省略参数名，则会将参数类型名视为参数名，而将对应的参数类型视为<code>Any</code>。</p>
</blockquote>
<h5 id="带属性的函数类型"><a class="header" href="#带属性的函数类型"><strong>带属性</strong>的函数类型</a></h5>
<pre><code class="language-typescript">type DescribableFunction = {
  description: string;        // 属性
  (someArg: number): boolean; // 函数原型
};
</code></pre>
<h5 id="构造函数类型"><a class="header" href="#构造函数类型">构造函数类型</a></h5>
<p>使用此类声明的函数函数类型标识<code>new</code>方法调用以<a href="JavaScript/JavaScript.html#%E4%BD%BF%E7%94%A8%E5%AF%B9%E8%B1%A1%E5%8E%9F%E5%9E%8B%E6%9E%84%E9%80%A0%E5%AF%B9%E8%B1%A1">创建某类对象</a>。构造函数类型可与普通调用方法并列声明（根据参数类型决定调用对象）。</p>
<pre><code class="language-typescript">type SomeConstructor = {
  new (s: string): SomeObject;
};
interface CallOrConstruct {
  new (s: string): Date;
  (n?: number): number;
}
</code></pre>
<h4 id="函数泛型参数声明"><a class="header" href="#函数泛型参数声明">函数泛型参数声明</a></h4>
<pre><code class="language-typescript">function firstElement&lt;Type&gt;(arr: Type[]): Type | undefined {}
function map&lt;Input, Output&gt;(arr: Input[], func: (arg: Input) =&gt; Output): Output[] {}
</code></pre>
<h5 id="泛型类型限制"><a class="header" href="#泛型类型限制">泛型类型限制</a></h5>
<p>限制类型应具有的接口（包含的属性）。</p>
<pre><code class="language-typescript">function longest&lt;Type extends { length: number }&gt;(a: Type, b: Type) {}
</code></pre>
<h3 id="联合类型-2"><a class="header" href="#联合类型-2">联合类型</a></h3>
<pre><code class="language-typescript">let id: number | string;
function print(obj: number|string){/*...*/}
</code></pre>
<p>其他判断条件：<code>Array.isArray(x)</code></p>
<h4 id="字面值枚举"><a class="header" href="#字面值枚举">字面值枚举</a></h4>
<pre><code class="language-ts">let alignment: &quot;left&quot; | &quot;right&quot; | &quot;center&quot; = &quot;center&quot;;
</code></pre>
<p>字面值可以和其他类型组合成联合类型。</p>
<h4 id="类型限制narrowing"><a class="header" href="#类型限制narrowing">类型限制（Narrowing）</a></h4>
<p>联合类型默认仅能调用类型的公共方法，可通过类型判断<code>typeof</code>在分支中调用类型特有的方法。</p>
<pre><code class="language-typescript">if (typeof id === &quot;string&quot;) { // [type guard]
    // In this branch, id is of type 'string'
    console.log(id.toUpperCase());
} else {
    // Here, id is of type 'number' 
    console.log(id);
}
</code></pre>
<p><code>typeof</code>支持返回以下类型：<code>&quot;string&quot;</code>、<code>&quot;number&quot;</code>、<code>&quot;bigint&quot;</code>、<code>&quot;boolean&quot;</code>、<code>&quot;symbol&quot;</code>、<code>&quot;undefined&quot;</code>、<code>&quot;object&quot;</code>、<code>&quot;function&quot;</code>。</p>
<p><a href="https://www.typescriptlang.org/docs/handbook/2/narrowing.html">TypeScript: Documentation - Narrowing (typescriptlang.org)</a></p>
<h3 id="类型别名-2"><a class="header" href="#类型别名-2">类型别名</a></h3>
<pre><code class="language-typescript">type Point = {
    x: number;
    y: number;
};
let pt: Point = {x:3, y:7};
type ID = number | string;
let id: ID = 1001;
</code></pre>
<h3 id="接口-4"><a class="header" href="#接口-4">接口</a></h3>
<p>接口类似于类型别名，但支持继承语法(类型别名也可以不同语法实现)，并可以动态添加属性（类型别名不支持）。</p>
<pre><code class="language-javascript">interface Animal {
  name: string
}  
interface Animal {
  weight: number   // Animal: {name, weight}
}  
interface Bear extends Animal {
  honey: boolean
}
</code></pre>
<h3 id="类型断言"><a class="header" href="#类型断言">类型断言</a></h3>
<p>根据代码运行的实际情况，将对象显式转换为已知的类型。</p>
<pre><code class="language-ts">const myCanvas = document.getElementById(&quot;main_canvas&quot;) as HTMLCanvasElement;  
const myCanvas = &lt;HTMLCanvasElement&gt;document.getElementById(&quot;main_canvas&quot;); 
</code></pre>
<p>仅允许具有继承关系的类型进行相互转换。对于未知关系的类型，确实需要转换的情况，可先转换为<code>any</code>或<code>unknown</code>，再转换为目标类型。</p>
<pre><code class="language-ts">const a = (expr as any) as T;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="开发环境-4"><a class="header" href="#开发环境-4">开发环境</a></h1>
<h2 id="web开发环境"><a class="header" href="#web开发环境">Web开发环境</a></h2>
<h3 id="客户侧开发工具"><a class="header" href="#客户侧开发工具">客户侧开发工具</a></h3>
<p>✨<a href="https://developer.mozilla.org/en-US/docs/Learn/Tools_and_testing/Understanding_client-side_tools">Understanding client-side web development tools - Learn web development | MDN (mozilla.org)</a></p>
<h3 id="客户侧框架"><a class="header" href="#客户侧框架">客户侧框架</a></h3>
<p>✨<a href="https://developer.mozilla.org/en-US/docs/Learn/Tools_and_testing/Client-side_JavaScript_frameworks/Introduction">Introduction to client-side frameworks - Learn web development | MDN (mozilla.org)</a></p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Framework</th><th style="text-align: left">Browser support</th><th style="text-align: left">Preferred DSL</th><th style="text-align: left">Supported DSLs</th></tr></thead><tbody>
<tr><td style="text-align: left">Angular</td><td style="text-align: left">IE9+</td><td style="text-align: left">TypeScript</td><td style="text-align: left">HTML-based; TypeScript</td></tr>
<tr><td style="text-align: left">React</td><td style="text-align: left">Modern (IE9+ with Polyfills)</td><td style="text-align: left">JSX</td><td style="text-align: left">JSX; TypeScript</td></tr>
<tr><td style="text-align: left">Vue</td><td style="text-align: left">IE9+</td><td style="text-align: left">HTML-based</td><td style="text-align: left">HTML-based, JSX, Pug</td></tr>
<tr><td style="text-align: left">Ember</td><td style="text-align: left">Modern (IE9+ in Ember version 2.18)</td><td style="text-align: left">Handlebars</td><td style="text-align: left">Handlebars, TypeScript</td></tr>
</tbody></table>
</div>
<h3 id="服务侧框架"><a class="header" href="#服务侧框架">服务侧框架</a></h3>
<p><a href="https://developer.mozilla.org/en-US/docs/Learn/Server-side">Server-side website programming - Learn web development | MDN (mozilla.org)</a></p>
<p>✨<a href="https://developer.mozilla.org/en-US/docs/Learn/Server-side/Express_Nodejs/Introduction">Express/Node introduction - Learn web development | MDN (mozilla.org)</a></p>
<h2 id="nodejs-1"><a class="header" href="#nodejs-1">Node.js</a></h2>
<h3 id="安装nodejs"><a class="header" href="#安装nodejs">安装Node.js</a></h3>
<blockquote>
<p>Node.js® 是一个基于 <a href="https://v8.dev/">Chrome V8引擎</a> 的 JavaScript 运行时环境。</p>
<p><em>The runtime is intended for running directly on a computer or server OS. As such, the environment omits browser-specific JavaScript APIs and adds support for more traditional OS APIs including HTTP and file system libraries.</em>
✨<a href="https://github.com/maxogden/art-of-node">maxogden/art-of-node: a short introduction to node.js (github.com)</a></p>
</blockquote>
<h5 id="linux-1"><a class="header" href="#linux-1">Linux</a></h5>
<pre><code class="language-sh"># Using Ubuntu
curl -fsSL https://deb.nodesource.com/setup_lts.x | sudo -E bash -
apt-get install -y nodejs
# CentOS/Fedora
curl -fsSL https://rpm.nodesource.com/setup_lts.x | bash -
yum install -y nodejs
yum install gcc-c++ make # to compile&amp;install native addons from npm*
</code></pre>
<blockquote>
<p><code>*</code>：或者执行<code>yum groupinstall 'Development Tools'</code>。</p>
<p>Latest LTS Version: <strong>16.17.0</strong> (includes <code>npm</code> 8.15)。</p>
<p>Linux版本：https://github.com/nodesource/distributions/blob/master/README.md。</p>
<p>Windows版本：https://nodejs.org/en/download/。</p>
</blockquote>
<h5 id="windows-3"><a class="header" href="#windows-3">Windows</a></h5>
<pre><code class="language-powershell">winget install OpenJS.NodeJS.LTS  # v16 *
</code></pre>
<blockquote>
<p><code>winget</code>安装包无法自动安装Python和C++编译工具，需要从<a href="https://nodejs.org/en/download/">官网下载安装包</a>并修改安装。</p>
<p><em>MSBUILD : error MSB4132: 无法识别工具版本“2.0”。可用的工具版本为 &quot;4.0&quot;。</em></p>
</blockquote>
<h3 id="包管理器"><a class="header" href="#包管理器">包管理器</a></h3>
<h4 id="npm"><a class="header" href="#npm">NPM</a></h4>
<p>NPM (Node package manager)包含在Node.js中。</p>
<pre><code class="language-shell">npm -l             # display usage info for all commands
npm &lt;command&gt; -h   # quick help on &lt;command&gt;
npm help &lt;command&gt; # show help in browser
</code></pre>
<h5 id="初始化项目"><a class="header" href="#初始化项目">初始化项目</a></h5>
<p>为项目创建配置文件<code>package.json</code>（交互式）：</p>
<pre><code class="language-shell">cd progdir &amp;&amp; npm {init|create}   # create&lt;-&gt;init
# package name: (test-api)
# version: (1.0.0)
# description: coding a fun API using Express, a NodeJS minimalist web framework.
# entry point: (index.js)
# test command:
# git repository:
# keywords: express, api, nodejs
# author: Gary Wang
# license: (ISC)
mkdir src &amp;&amp; touch src/index.js
</code></pre>
<p>配置文件内容包括：项目基本信息、执行脚本、依赖库声明。</p>
<pre><code class="language-json">{
    &quot;name&quot;: &quot;node-echo&quot;,     
    &quot;main&quot;: &quot;./lib/echo.js&quot;, // 包的主模块
    &quot;dependencies&quot;: {
        &quot;argv&quot;: &quot;0.0.2&quot;      // 依赖库名称和版本
    }
}
</code></pre>
<h5 id="包管理"><a class="header" href="#包管理">包管理</a></h5>
<blockquote>
<p>也可在<a href="https://www.npmjs.com/">npm (npmjs.com)</a>搜索包。</p>
</blockquote>
<p>安装/更新依赖库：</p>
<pre><code class="language-shell">npm install       # 安装当前项目所需依赖(package.json)
           --location=global,user,project #*
           --global
npm install &lt;foo&gt; &lt;bar@version&gt; # 安装指定模块**
            --save # 将安装的模块加入package.json
npm update        # 更新满足条件的依赖库并更新(package-lock.json)
npm run &lt;script&gt;  # 运行package.json中定义的脚本
npm start|restart|stop --if-present   # =&gt; npm run start 
</code></pre>
<blockquote>
<p>相应脚本需要在配置文件中定义，<code>--if-present</code>仅在相应命令存在的情况下执行而不产生错误。</p>
<p><code>*</code>：安装位置：</p>
<ul>
<li><code>global</code>：<code>~\AppData\Roaming\npm\node_modules</code>（<code>Windows</code>）或<code>/usr/local/nodejs/lib/node_modules/</code>（Linux）；</li>
<li><code>user</code>：<code>~\node_modules</code>；</li>
<li><code>project</code>：<code>PROJECT_HOME\node_modules</code>；</li>
</ul>
<p><code>**</code>：如果当前目录下没有项目配置文件（<code>package.json</code>），执行命令时会自动生成包含所安装包的配置文件。</p>
</blockquote>
<h5 id="仓库镜像配置"><a class="header" href="#仓库镜像配置">仓库镜像配置</a></h5>
<p>默认仓库为<code>https://registry.npmjs.org/</code>，可修改为国内镜像源（阿里云：<code>https://registry.npmmirror.com</code>）</p>
<pre><code class="language-shell">npm config set registry https://registry.npmmirror.com
npm config get registry
</code></pre>
<h5 id="包管理-1"><a class="header" href="#包管理-1">包管理</a></h5>
<p>Java Script包采用<a href="https://docs.npmjs.com/about-semantic-versioning">语义化版本控制</a>，以在项目中使用依赖包时保证良好的兼容性。项目使用的依赖包声明方式：</p>
<ul>
<li>仅允许<code>patch</code>版本升级：<code>1.0, 1.0.x, ~1.0.4</code>；</li>
<li>允许<code>minor</code>和<code>patch</code>版本升级：<code>1, 1.x, ^1.0.4</code>；</li>
<li>允许<code>major</code>版本升级：<code>*, x</code>。</li>
<li>版本范围：<code>&gt;2.1</code>，<code>1.0.0 - 1.2.0</code>（可使用<code>&gt;,&lt;,&gt;=,&lt;=,=</code>或<code>-</code>表示范围）。</li>
<li>组合：<code>^2 &lt;2.2 || &gt;2.3</code>。</li>
</ul>
<h5 id="安装全局工具"><a class="header" href="#安装全局工具">安装全局工具</a></h5>
<pre><code class="language-shell">npm install --global,-g &lt;module-name&gt;
</code></pre>
<h4 id="yarn"><a class="header" href="#yarn">yarn</a></h4>
<pre><code class="language-shell">curl -sL https://dl.yarnpkg.com/rpm/yarn.repo | sudo tee /etc/yum.repos.d/yarn.repo
yum install yarn
</code></pre>
<pre><code class="language-shell">NODE_ENV=prodution yarn start --production
</code></pre>
<h4 id="pnpm"><a class="header" href="#pnpm">pnpm</a></h4>
<h4 id="模块编译"><a class="header" href="#模块编译">模块编译</a></h4>
<p><code>node-gyp</code>：<code>MSBuild.exe failed with exit code: 1</code>，<a href="https://stackoverflow.com/a/66801369/6571140">解决方法</a>：</p>
<pre><code class="language-shell">npm install --ignore-scripts
npm rebuild node-sass --force --ignore-scripts
</code></pre>
<h3 id="node运行环境管理"><a class="header" href="#node运行环境管理">Node运行环境管理</a></h3>
<pre><code class="language-shell">nvm version                   # 查看nvm版本
nvm arch                      # 查看node运行的系统架构
nvm current                   # 当前激活的node版本
nvm list [available]          # 列出已安装/可安装版本
nvm install &lt;version&gt; [32|64] # 安装指定版本node*
nvm use [version] [32|64]     # 切换版本(全局生效)**
nvm uninstall &lt;version&gt;       # 必须指定具体版本
</code></pre>
<blockquote>
<p><code>*</code>：具体版本号、<code>lts</code>或<code>latest</code>；</p>
<p><code>**</code>：需要管理员权限创建符号链接。</p>
</blockquote>
<h5 id="下载镜像"><a class="header" href="#下载镜像">下载镜像</a></h5>
<pre><code class="language-shell">nvm proxy [URL]
nvm node_mirror [URL] # -&gt; 下载node地址：https://nodejs.org/dist/
nvm npm_mirror [URL]  # -&gt; 下载NPM地址：https://github.com/npm/cli/archive/
nvm root [PATH]       # -&gt; 环境安装目录：~\AppData\Roaming\nvm
</code></pre>
<h3 id="node交互式环境"><a class="header" href="#node交互式环境">Node交互式环境</a></h3>
<p>在终端执行<code>node</code>进入交互命令行。</p>
<pre><code class="language-javascript">console.log('hello world!')
</code></pre>
<h3 id="nodejs库"><a class="header" href="#nodejs库">Node.js库</a></h3>
<h4 id="http服务-1"><a class="header" href="#http服务-1">HTTP服务</a></h4>
<pre><code class="language-javascript">const http = require(&quot;http&quot;);
const hostname = &quot;127.0.0.1&quot;, port = 5000;
const server = http.createServer(function (req, res) {
    res.writeHead(200, { 'Content-Type': 'text/plain' });
    res.end('Hello World\n');
});
server.listen(port, hostname, function () { // start server
    console.log(`Server running at http://${hostname}:${port}/`);
})
</code></pre>
<h3 id="nodejs应用程序"><a class="header" href="#nodejs应用程序">Node.js应用程序</a></h3>
<pre><code class="language-shell">npx &lt;package&gt;  # -&gt; x, npm exec
</code></pre>
<h4 id="http-server"><a class="header" href="#http-server">http-server</a></h4>
<blockquote>
<p><em><code>http-server</code> is a simple, zero-configuration command-line <strong>static</strong> HTTP server. It is powerful enough for production usage, but it's simple and hackable enough to be used for testing, local development and learning.</em></p>
</blockquote>
<h5 id="用法-1"><a class="header" href="#用法-1">用法</a></h5>
<pre><code class="language-shell">http-server [./public]  # 如果&quot;./public&quot;不存在则默认为&quot;./&quot; 
            -p,--port=8080
            -a 0.0.0.0
            --cors=false
            -o [path]   # 在浏览器中打开指定路径
            --username USER
            --password
            -S,--tls,--ssl -C,--cert=cert.pem -K,--key=key.pem
</code></pre>
<h3 id="web前端打包"><a class="header" href="#web前端打包">Web前端打包</a></h3>
<p>将HTML文件引用的NPM包及其依赖库打包到单一文件，方便引用。</p>
<h4 id="browserify"><a class="header" href="#browserify">browserify</a></h4>
<pre><code class="language-shell">npm install -g browserify
</code></pre>
<p><a href="https://github.com/browserify/browserify#usage">browserify/browserify: browser-side require() the node.js way (github.com)</a></p>
<pre><code class="language-shell">browserify.cmd .\index.js  --outfile .\bundle.js 
</code></pre>
<blockquote>
<p><code>--outfile</code>：在Windows终端中执行命令，如果将输出定向到文件可能导致编码不匹配的问题（输出内容为UTF-8，而终端编码为UTF-16）从而导致乱码。使用该选项打开文件进行输出可避免该问题。</p>
</blockquote>
<h4 id="webpack"><a class="header" href="#webpack">webpack</a></h4>
<blockquote>
<p><em>internally builds a dependency graph from one or more entry points and then combines every module your project needs into one or more bundles, which are static assets to serve your content from.</em></p>
</blockquote>
<p>打包配置<code>webpack.config.js</code>：</p>
<pre><code class="language-javascript">const path = require('path');
module.exports = {
  entry: './src/index.js',
  output: {
    path: path.resolve(__dirname, 'dist'),
    filename: 'bundle.js',
  },
};
</code></pre>
<p>引用打包后的文件：</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot; /&gt;
    ...
  &lt;/head&gt;
  &lt;body&gt;
    ...
    &lt;script src=&quot;dist/bundle.js&quot;&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p><a href="https://webpack.js.org/guides/installation/#local-installation">Installation | webpack</a></p>
<p><a href="https://webpack.js.org/guides/getting-started">webpack</a></p>
<h4 id="esbuild"><a class="header" href="#esbuild">esbuild</a></h4>
<pre><code class="language-shell">npm install -g esbuild
esbuild app.jsx --bundle --outfile=out.js
</code></pre>
<p><a href="https://esbuild.github.io/getting-started/">esbuild - Getting Started</a></p>
<h2 id="typescript-1"><a class="header" href="#typescript-1">TypeScript</a></h2>
<blockquote>
<p><em>TypeScript is available as a <a href="https://www.npmjs.com/package/typescript">package on the npm registry</a> available as <code>&quot;typescript&quot;</code>.</em></p>
</blockquote>
<pre><code class="language-shell">npm install typescript --save-dev # install for current project
npm install -g typescript         # Globally Installing TypeScript
</code></pre>
<blockquote>
<p>codebases should prefer a project-wide installation over a global install so that they can benefit from reproducible builds across different machines.</p>
</blockquote>
<p><a href="https://www.typescriptlang.org/docs/bootstrap">TypeScript: Bootstrapping tools for TypeScript projects (typescriptlang.org)</a></p>
<h3 id="编译-4"><a class="header" href="#编译-4">编译</a></h3>
<p>将TypeScript源码转换为JavaScript。</p>
<ul>
<li><em>Erased Types</em></li>
<li><em>Downleveling</em></li>
<li><em>Strictness</em></li>
</ul>
<h4 id="编译项目-1"><a class="header" href="#编译项目-1">编译项目</a></h4>
<pre><code class="language-shell">npx tsc --init                 # 初始化项目，生成tsconfig.json
npx tsc                        # 编译项目
tsc -p ./path/to/tsconfig.json # 编译指定路径下的项目
npx tsc program.ts utils.ts    # 编译源码，忽略项目配置
</code></pre>
<h2 id="express"><a class="header" href="#express">Express</a></h2>
<blockquote>
<p><em>Fast, unopinionated, minimalist web framework for Node.js.</em></p>
</blockquote>
<p>Express封装了Node.js的<a href="JavaScript/JS%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83.html#HTTP%E6%9C%8D%E5%8A%A1"><code>http</code>和<code>https</code>库</a>，并提供高层次的HTTP处理接口，如处理不同的HTTP方法、API路由、服务静态文件和基于模板创建动态响应。</p>
<blockquote>
<ul>
<li>
<p><a href="https://expressjs.com/en/resources/frameworks.html">Frameworks built on Express (expressjs.com)</a></p>
</li>
<li>
<p><strong>Express middleware</strong></p>
<p><em>While Express itself is fairly minimalist, developers have created compatible <a href="https://expressjs.com/en/resources/middleware.html">middleware packages</a> to address almost any web development problem, related to cookies, sessions, user logins, URL parameters, POST data, security headers, ......</em></p>
</li>
</ul>
</blockquote>
<ul>
<li>Robust routing</li>
<li>Focus on high performance</li>
<li>Super-high test coverage</li>
<li>HTTP helpers (redirection, caching, etc)</li>
<li>View system supporting 14+ template engines</li>
<li>Content negotiation</li>
<li>Executable for generating applications quickly</li>
</ul>
<h3 id="express项目"><a class="header" href="#express项目">Express项目</a></h3>
<p>使用模板快速开始构建App。</p>
<pre><code class="language-shell">npm install -g express-generator@4
express /project/folder  # &quot;npx express-generator&quot; for Node.js 8.2+
npm install
npm start   # -&gt; http://localhost:3000
</code></pre>
<p>项目目录结构如下：</p>
<pre><code class="language-shell">/project/folder
├─bin
├─public
│  ├─images
│  ├─javascripts
│  └─stylesheets
├─routes
└─views
</code></pre>
<p>创建新项目并添加<code>express</code>库。</p>
<pre><code class="language-shell">npm init &amp;&amp; npm install express
</code></pre>
<h4 id="代码结构-2"><a class="header" href="#代码结构-2">代码结构</a></h4>
<pre><code class="language-javascript">const express = require('express')  // 导入express库
const app = express()               // 创建应用实例
const port = 5000
// 定义API和处理方法
app.get('/', (req, res) =&gt; {
    res.send('hello world!');
})
// 启动服务
app.listen(port, () =&gt; {
    console.log(`Example app listening on port ${port}.`);
})
</code></pre>
<p>监听多个端口与协议：</p>
<pre><code class="language-javascript">const http = require('http'),
      https = require('https'),
      express = require('express'),
      app = express();
http.createServer(app).listen(80); 
https.createServer({options}, app).listen(443);
</code></pre>
<p><a href="http://expressjs.com/en/starter/examples.html">Express examples (expressjs.com)</a></p>
<blockquote>
<p><a href="https://developer.mozilla.org/en-US/docs/Learn/Server-side/Express_Nodejs/Tutorial_local_library_website">Express Tutorial: The Local Library website - Learn web development | MDN (mozilla.org)</a></p>
<p><a href="https://developer.mozilla.org/en-US/docs/Learn/Server-side/Express_Nodejs/Introduction">Express/Node introduction - Learn web development | MDN (mozilla.org)</a></p>
</blockquote>
<h3 id="url处理函数"><a class="header" href="#url处理函数">URL处理函数</a></h3>
<p>一个URL可定义多个匹配的处理函数。</p>
<pre><code class="language-javascript">app.METHOD(PATH, HANDLER)
</code></pre>
<ul>
<li><code>METHOD</code>是HTTP方法；</li>
<li><code>PATH</code>是服务器的URL；</li>
<li><code>HANDLER</code>是处理函数。</li>
</ul>
<pre><code class="language-js">req
res
</code></pre>
<h4 id="服务静态文件"><a class="header" href="#服务静态文件">服务静态文件</a></h4>
<pre><code class="language-javascript">express.static(root, [options])
app.use(express.static('public'))  // 添加多个静态文件目录
app.use(express.static('files'))   // 按顺序查找静态资源
app.use('/static', express.static('public'))  // 为静态资源URL添加前缀
</code></pre>
<p><code>root</code>指定服务器上存放静态文件的根目录（可为绝对或相对路径，该目录名称不是URL的一部分）。</p>
<blockquote>
<p>使用反向代理提高静态资源的服务效率。</p>
</blockquote>
<h4 id="api路由"><a class="header" href="#api路由">API路由</a></h4>
<pre><code class="language-js">app.use('BASE_URL', Router)
</code></pre>
<h3 id="服务静态文件-1"><a class="header" href="#服务静态文件-1">服务静态文件</a></h3>
<h3 id="错误处理"><a class="header" href="#错误处理">错误处理</a></h3>
<h3 id="使用数据库"><a class="header" href="#使用数据库">使用数据库</a></h3>
<h2 id="angular"><a class="header" href="#angular">Angular</a></h2>
<p>Angular是一个用HTML和TypeScript构建客户端应用的平台与框架。</p>
<ul>
<li>模块<code>NgModule</code>；根模块<code>AppModule</code>提供了用来启动应用的引导机制。</li>
<li>组件<code>@Component()</code>：每个应用至少有一个组件（<em>根组件</em>），它会把组件树和页面中的DOM连接起来。每个组件都会定义一个类，其中包含应用的数据和逻辑，并与一个HTML<em>模板</em>相关联，该模板定义了一个供目标环境下显示的视图。</li>
<li>模板：模板中的<em>指令</em>会提供程序逻辑，而<em>绑定标记</em>会把你应用中的数据和 DOM 连接在一起。</li>
<li><em>服务</em>类：与特定视图无关并希望跨组件共享的数据或逻辑，通过<code>@Injectable()</code>让服务作为依赖<em>被注入到</em>客户组件中。</li>
<li>路由：</li>
</ul>
<p><img src="JavaScript/JS%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83.assets/angular-overview.png" alt="overview" /></p>
<p><a href="https://angular.cn/tutorial/toh-pt0">使用 Angular CLI 来创建最初的应用程序。</a></p>
<h3 id="angular命令行工具"><a class="header" href="#angular命令行工具">Angular命令行工具</a></h3>
<h5 id="安装和卸载命令行工具"><a class="header" href="#安装和卸载命令行工具">安装和卸载命令行工具</a></h5>
<pre><code class="language-shell">npm install -g @angular/cli			# sudo on Ubuntu
npm uninstall -g @angular/cli
npm cache clean --force
</code></pre>
<blockquote>
<p>Windows上使用PowerShell需要修改脚本执行策略：</p>
<pre><code class="language-powershell">Set-ExecutionPolicy -Scope CurrentUser -ExecutionPolicy RemoteSigned
</code></pre>
</blockquote>
<h5 id="创建新项目"><a class="header" href="#创建新项目">创建新项目</a></h5>
<pre><code class="language-shell">ng new my-app
npm install --legacy-peer-deps # 如果安装依赖出错使用该命令
</code></pre>
<h5 id="编译项目-2"><a class="header" href="#编译项目-2">编译项目</a></h5>
<pre><code class="language-shell">ng build
</code></pre>
<h5 id="启动应用"><a class="header" href="#启动应用">启动应用</a></h5>
<pre><code class="language-shell">ng serve --host=ws-gary --port port --ssl [--disableHostCheck]
</code></pre>
<h3 id="项目结构-1"><a class="header" href="#项目结构-1">项目结构</a></h3>
<p><code>package.json</code>：包含了项目的配置文件，包括项目名称、描述、源代码仓库、版本、许可证、项目构建、测试、启动命令、依赖包等信息。</p>
<p><code>angular.json</code>：Angular框架配置文件。</p>
<p><code>tsconfig.json</code>：TypeScript配置文件。</p>
<h3 id="编译-5"><a class="header" href="#编译-5">编译</a></h3>
<pre><code class="language-sh">ng update		# shou packages can be updated
ng update --all [--allow-dirty] [--force]
ng update @angular/core @angular/cli
</code></pre>
<h2 id="electron"><a class="header" href="#electron">Electron</a></h2>
<blockquote>
<p><em>Electron is a framework for building desktop applications using JavaScript, HTML, and CSS. By embedding <strong>Chromium</strong> and <strong>Node.js</strong> into its binary, Electron allows you to maintain one JavaScript codebase and create <strong>cross-platform apps</strong> that work on Windows, macOS, and Linux — no native development experience required.</em></p>
</blockquote>
<pre><code class="language-shell">git clone https://github.com/electron/electron-quick-start
cd electron-quick-start
npm install &amp;&amp; npm start
</code></pre>
<p><a href="https://www.electronjs.org/docs/latest/tutorial/tutorial-prerequisites">This tutorial will guide you through the process of developing a desktop application with Electron and distributing it to end users.</a></p>
<h2 id="开发工具"><a class="header" href="#开发工具">开发工具</a></h2>
<h3 id="vs-code"><a class="header" href="#vs-code">VS Code</a></h3>
<h5 id="调试"><a class="header" href="#调试">调试</a></h5>
<p>VS Code支持在浏览器中启动服务并调试Javascript程序，或通过Node.js执行环境进行调试。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="--fast-version-control"><a class="header" href="#--fast-version-control"><img src="开发环境/git.assets/logo@2x.png" alt="Git" style="zoom:50%;" />--fast-version-control</a></h1>
<h2 id="concept"><a class="header" href="#concept">Concept</a></h2>
<img src="开发环境/git.assets/clip_image001.png" alt="Remote  pull  checkout  fetch/clone  workspace  Repository  Index  push " style="zoom: 67%;" />
<h3 id="仓库结构"><a class="header" href="#仓库结构">仓库结构</a></h3>
<p>git仓库信息包含本地仓库(Repository)和远程仓库(<code>remote</code>)，两者具有相同结构。</p>
<p><img src="%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/git.assets/clip_image002.png" alt="index  READ " /></p>
<p>Your local repository consists of three &quot;trees&quot; maintained by git:</p>
<ol>
<li>
<p><strong>Working Directory</strong>: which holds the actual files (file system);</p>
</li>
<li>
<p><strong>Index</strong>: which acts as a <strong>staging area</strong>;</p>
<blockquote>
<p><em>Git uses its hash algorithm to index <strong>everything</strong> in your repo. Each file has a SHA that reflects the contents of that file. Each directory, in turn, is hashed. If a file in that directory changes, then the SHA of the directory changes too.</em></p>
</blockquote>
</li>
<li>
<p><strong>HEAD</strong>: which points to the last commit you've made.</p>
<blockquote>
<p><em>Each commit contains the SHA of the top-level directory in your repo along with some <a href="https://gist.github.com/masak/2415865">other info</a>.</em> </p>
</blockquote>
</li>
</ol>
<p>由于远程仓库可能由多人参与维护，因此其版本与本地仓库版本（<code>HEAD</code>）可能不同。因此，将本地仓库推送到远程之前，需要首先将远程仓库拉取(<code>fetch</code>)到本地，并保证本地提交版本未落后于远程版本。否则，需要暂存本地更改，并使用远程版本更新本地版本，再恢复本地更改后提交。强制提交本地落后的版本可能会产生文件内容冲突。</p>
<h3 id="repository"><a class="header" href="#repository">repository</a></h3>
<h3 id="alias"><a class="header" href="#alias">alias</a></h3>
<h3 id="bookmark"><a class="header" href="#bookmark">bookmark</a></h3>
<h3 id="workflow"><a class="header" href="#workflow"><a href="http://rogerdudler.github.io/git-guide/">Workflow</a></a></h3>
<h4 id="operations"><a class="header" href="#operations">Operations</a></h4>
<h5 id="stage"><a class="header" href="#stage">stage</a></h5>
<h5 id="commit"><a class="header" href="#commit">commit</a></h5>
<h5 id="使用git的原则"><a class="header" href="#使用git的原则">使用git的原则</a></h5>
<ul>
<li>
<p>Only put <em>source</em> files into version control, never <em>generated</em> files.</p>
</li>
<li>
<p>Commit binary files with caution and strongly avoid committing large files.</p>
</li>
<li>
<p><strong>never</strong> put confidential information into a repo, especially one you might share publicly. </p>
</li>
</ul>
<h4 id="status"><a class="header" href="#status">Status</a></h4>
<h5 id="trackedun-tracked"><a class="header" href="#trackedun-tracked">tracked/un-tracked</a></h5>
<h5 id="modified"><a class="header" href="#modified">modified</a></h5>
<h5 id="stagedun-staged"><a class="header" href="#stagedun-staged">staged/un-staged</a></h5>
<h5 id="committed"><a class="header" href="#committed">committed</a></h5>
<h2 id="安装git"><a class="header" href="#安装git">安装git</a></h2>
<h3 id="git配置"><a class="header" href="#git配置">git配置</a></h3>
<pre><code class="language-shell">git config --global init.defaultBranch &lt;name&gt;
git config --global --edit  # 打开git配置文件并编辑
</code></pre>
<p>添加<code>--global</code>将设置应用于当前系统用户下的所有仓库的默认配置。</p>
<h5 id="配置文件位置"><a class="header" href="#配置文件位置">配置文件位置</a></h5>
<div class="table-wrapper"><table><thead><tr><th>选项</th><th>说明</th><th>配置文件路径</th></tr></thead><tbody>
<tr><td><code>--system</code></td><td>默认配置</td><td><code>/etc/gitconfig</code></td></tr>
<tr><td><code>--global</code></td><td>用户全局配置</td><td><code>~/.gitconfig</code> or <code> ~/.config/git/config</code></td></tr>
<tr><td><code>--local</code></td><td>仓库配置</td><td><code>.git/config</code></td></tr>
</tbody></table>
</div>
<p>列出所有配置：</p>
<pre><code class="language-sh">git config -l,--list
</code></pre>
<p><code>.gitignore</code>：声明忽略仓库目录下的未追踪文件。</p>
<h5 id="git用户配置"><a class="header" href="#git用户配置">git用户配置</a></h5>
<p>使用git提交代码前需要配置<code>git</code>用户信息（用户名和邮箱）。</p>
<pre><code class="language-sh">git config user.name &quot;John Doe&quot;
git config user.email &quot;you@emal.com&quot;
</code></pre>
<h5 id="输出格式配置"><a class="header" href="#输出格式配置">输出格式配置</a></h5>
<pre><code class="language-shell">git config color.ui true    # 使用彩色输出
git config color.ui auto
</code></pre>
<h4 id="git图形界面"><a class="header" href="#git图形界面">git图形界面</a></h4>
<p><code>gitk</code></p>
<h2 id="管理仓库"><a class="header" href="#管理仓库">管理仓库</a></h2>
<h3 id="创建仓库"><a class="header" href="#创建仓库">创建仓库</a></h3>
<pre><code class="language-sh">git init [project-name]        # 默认在当前目录下创建仓库
git clone [url] [local_path]
</code></pre>
<p>在远程服务器创建仓库：</p>
<pre><code class="language-sh">git remote add origin &lt;server&gt;
</code></pre>
<h3 id="查看状态"><a class="header" href="#查看状态">查看状态</a></h3>
<p>列出仓库目录下的待提交的已更改文件以及未加入仓库的新文件。</p>
<pre><code class="language-sh">git status [-s | --short]
</code></pre>
<p><code>-s</code>：输出简洁信息。</p>
<p>对比文件的更改：</p>
<pre><code class="language-sh">git diff [--staged | --cached] [file] 
</code></pre>
<p>图形用户界面。</p>
<pre><code class="language-sh">git difftool [--tool-help]
</code></pre>
<h4 id="记录"><a class="header" href="#记录">记录</a></h4>
<p>查看当前分支的历史记录</p>
<pre><code class="language-shell">git log --author=bob --pretty=oneline
git log --name-status                       # 显示修改过的文件名
git log --graph --oneline --decorate --all  # 查看分支树
git show [commit]
</code></pre>
<h3 id="管理仓库内容"><a class="header" href="#管理仓库内容">管理仓库内容</a></h3>
<h4 id="添加文件"><a class="header" href="#添加文件">添加文件</a></h4>
<p>将未加入仓库的文件加入仓库以追踪更改；或者将已加入仓库的文件暂存（<code>stage</code>）等待提交（<code>commit</code>）。</p>
<pre><code class="language-sh">git add -i [file/dir]   # 'git add .' adding the current directory 
</code></pre>
<p><code>-i</code>：交互式添加文件。</p>
<blockquote>
<p>Marking merge-conflicted files as resolved.</p>
</blockquote>
<h4 id="编辑文件"><a class="header" href="#编辑文件">编辑文件</a></h4>
<p>直接使用文件系统命令移动文件，<code>git</code>可能无法检测重命到移动行为（可能任务先删除一个文件并创建另一个文件）。使用<code>git mv</code>更改文件名（移动文件）：</p>
<pre><code class="language-sh">git mv [file-original] [file-renamed]
</code></pre>
<p>如果被改名的文件已经做了修改，则修改和重命名记录都能被保留。</p>
<p>优先提交(commit)文件名修改。</p>
<blockquote>
</blockquote>
<h4 id="移除文件"><a class="header" href="#移除文件">移除文件</a></h4>
<p>从仓库中移除文件。</p>
<pre><code class="language-sh">git rm [-rf][--cached][file]
</code></pre>
<p><code>-f</code>：如果一个文件被修改过，则需要<code>-f</code>选项强制移除。该选项避免了意外数据丢失。</p>
<p><code>--cached</code>：保留本地文件。</p>
<h3 id="提交更改"><a class="header" href="#提交更改"><a href="https://git-scm.com/docs/git-commit">提交更改</a></a></h3>
<p>将本地仓库的更改保存为本地的最新版本（<code>HEAD</code>）。</p>
<pre><code class="language-sh">git commit [options] [files]
</code></pre>
<p>==默认提交暂存的文件==，如果命令列出文件，则忽略现阶段暂存的文件，直接提交列出的文件。</p>
<ul>
<li><code>-m 'message'</code>：提交信息。未提供选项则默认会弹出文本编辑器保存提交信息。</li>
<li><code>--dry-run</code>：列出提交的概览信息而不执行提交。</li>
<li><code>--amend</code>：追加内容，替换之前的提交（而不产生新的<code>commit ID</code>）。</li>
<li><code>-a</code>: 直接将所有修改过的已追踪的（包括未暂存的）文件提交，删除所有从工作树移除的文件。</li>
<li><code>--interactive</code>: 交互式决定每个文件是否要提交。</li>
</ul>
<p>最小化提交代码原则：每次提交包含单一的问题修复、功能更新，从而便与按主题追踪代码更改。</p>
<h5 id="提交信息书写规范"><a class="header" href="#提交信息书写规范">提交信息书写规范</a></h5>
<h3 id="推送更改"><a class="header" href="#推送更改">推送更改</a></h3>
<pre><code class="language-shell">git push origin &lt;branch&gt;   # 默认分支为master
</code></pre>
<p>如果本地仓库并非从远程复制过来，则需要首先连接到远程服务器：</p>
<pre><code class="language-shell">git remote add origin &lt;server&gt;
</code></pre>
<h3 id="替换本地修改"><a class="header" href="#替换本地修改">替换本地修改</a></h3>
<p>用最近提交版本还原工作目录下修改过的文件：</p>
<pre><code class="language-sh">git checkout -- &lt;filename&gt;
</code></pre>
<p>其他文件的修改不会受影响。</p>
<p>用服务器的版本替代本地的==修改和提交==：</p>
<pre><code class="language-sh">git fetch origin
git reset --hard origin/master
</code></pre>
<p><code>--hard</code>：删除所有比加载版本新的版本。</p>
<h3 id="过滤仓库内容"><a class="header" href="#过滤仓库内容">过滤仓库内容</a></h3>
<p>忽略已经提交到仓库的文件的最新更改：</p>
<pre><code class="language-sh">git update-index --assume-unchanged &lt;file&gt;
</code></pre>
<p>停止忽略：</p>
<pre><code class="language-sh">git update-index --no-assume-unchanged &lt;file&gt;
</code></pre>
<p>https://docs.microsoft.com/en-us/vsts/git/tutorial/ignore-files?view=vsts&amp;tabs=visual-studio</p>
<p>显示忽略的文件：</p>
<pre><code class="language-sh">git ls-files --other --ignored --exclude-standard
</code></pre>
<h3 id="分支branching"><a class="header" href="#分支branching">分支（Branching）</a></h3>
<p>如果有多项功能需要并行开发，可以使用分支来管理代码的多个版本。当功能开发测试完成，再将该分支合并回主线版本（<code>master</code>）。</p>
<blockquote>
<p><em>Branches are used to develop features isolated from each other. The <code>master</code> branch is the &quot;default&quot; branch when you create a repository. Use other branches for development and merge them back to the master branch upon completion.</em></p>
<p>新增或修改功能在分支进行，待测试完成后合并到主线版本；Bug修复在主线版本进行。</p>
</blockquote>
<p><img src="%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/git.assets/clip_image003.png" alt="branch" /></p>
<h4 id="创建分支"><a class="header" href="#创建分支">创建分支</a></h4>
<p>从当前状态创建并切换到一个新的分支<code>feature_x</code>：</p>
<pre><code class="language-sh">git checkout -b feature_x
</code></pre>
<blockquote>
<p>do commit before checkout to avoid data loss.</p>
</blockquote>
<p>仅创建分支：</p>
<pre><code class="language-shell">git branch [old_branch] new_branch  # 默认从当前分支创建分支
</code></pre>
<p>仅切换分支：</p>
<pre><code class="language-sh">git checkout &lt;branch_name&gt;  # e.g. master
</code></pre>
<p>为了使分支在远程仓库可用，需要将分支<a href="%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/git.html#%E6%8E%A8%E9%80%81%E6%9B%B4%E6%94%B9">推送到远程仓库</a>。</p>
<h4 id="分支信息"><a class="header" href="#分支信息">分支信息</a></h4>
<p>列出分支：</p>
<pre><code class="language-shell">git branch [--list]
</code></pre>
<h4 id="删除分支"><a class="header" href="#删除分支">删除分支</a></h4>
<p>删除一个分支。</p>
<pre><code class="language-sh">git branch -d,--delete feature_x
</code></pre>
<h3 id="更新与合并"><a class="header" href="#更新与合并"><a href="https://stackoverflow.com/q/292357/6571140">更新与合并</a></a></h3>
<p>获取远程仓库内容（稍后手动合并）：</p>
<pre><code class="language-shell">git fetch    # 仅更新本地HEAD，不合并工作目录
</code></pre>
<p>获取远程仓库内容，并与本地分支/工作目录合并：</p>
<pre><code class="language-sh">git pull [url] [branch]  # fetch + merge
</code></pre>
<p>当前目录下有更改而未保存时，不能使用远程目录覆盖当前内容，否则当前内容被远程覆盖导致数据丢失。如果直接尝试执行<code>git merge</code>或直接执行<code>git pull</code>将产生错误。为了将远程更新与本地更改合并：</p>
<ul>
<li>使用<code>git stash [push]</code>命令暂存本地更改，使本地<code>index</code>状态最新；</li>
<li>然后使用<code>git pull</code>或<code>git merge</code>将远程与本地仓库合并；</li>
<li>然后<code>git stash pop</code>恢复本地更改，待本地工作完成后再将本地更改提交到仓库。</li>
</ul>
<p>暂存最近更改：</p>
<pre><code class="language-sh">git stash push -m,--message &lt;message&gt;
</code></pre>
<p>需要预先<a href="%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/git.html#%E4%BB%93%E5%BA%93%E9%85%8D%E7%BD%AE">配置用户身份</a>。</p>
<pre><code class="language-shell">git stash list      # 列出暂存的更改版本
git stash show [id] # 列出对应版本和当前状态的变更信息
git stash pop       # 恢复最近更改
git stash drop      # 丢弃最近更改（需要先暂存）
</code></pre>
<p>如果本地提交和远程提交本版不同：</p>
<pre><code>hint: You have divergent branches and need to specify how to reconcile them.
hint: You can do so by running one of the following commands sometime before
hint: your next pull:
hint: 
hint:   git config pull.rebase false  # merge (the default strategy)
hint:   git config pull.rebase true   # rebase
hint:   git config pull.ff only       # fast-forward only
</code></pre>
<h4 id="分支合并"><a class="header" href="#分支合并">分支合并</a></h4>
<p>将当前分支与另一个分支合并：</p>
<pre><code class="language-sh">git merge &lt;branch&gt;
</code></pre>
<p>合并工具：</p>
<pre><code class="language-sh">git mergetool
</code></pre>
<h4 id="冲突与消除"><a class="header" href="#冲突与消除">冲突与消除</a></h4>
<p><code>git</code>尝试自动合并，当通常会产生冲突。用户需要手动编辑冲突文件来消除冲突。手动编辑完成后，使用：</p>
<pre><code class="language-shell">git add &lt;conflicted_file&gt;
</code></pre>
<p>以确认完成合并。在开始合并前，可以对比两个分支：</p>
<pre><code class="language-sh">git diff &lt;source_branch&gt; &lt;target_branch&gt;
</code></pre>
<p>https://git-scm.com/docs/git-mergetool</p>
<p>https://git-scm.com/docs/git-merge</p>
<h2 id="发布"><a class="header" href="#发布">发布</a></h2>
<h3 id="tagging"><a class="header" href="#tagging">tagging</a></h3>
<pre><code class="language-sh">git tag 1.0.0 &lt;short_commit_id&gt;   # commit id 前10位
</code></pre>
<h2 id="github"><a class="header" href="#github">GitHub</a></h2>
<h2 id="gitlab"><a class="header" href="#gitlab">GitLab</a></h2>
<h5 id="squash-and-merge-free"><a class="header" href="#squash-and-merge-free">Squash and merge (FREE)</a></h5>
<blockquote>
<p>As you work on a feature branch, you often create small, self-contained commits. These small commits help describe the process of building a feature, but can clutter your Git history after the feature is finished. As you finish features, you can combine these commits and ensure a cleaner merge history in your Git repository by using the <em>squash and merge</em> strategy.</p>
<ul>
<li>Small commits are joined together, making it simpler to revert all parts of a change.</li>
<li>When the single commit merges into the target branch, it retains the full commit history.</li>
<li>Your base branch remains clean, and contains meaningful commit messages.</li>
</ul>
<p>Each time a branch merges into your base branch, up to two commits are added:</p>
<ul>
<li>The single commit created by squashing the commits from the branch.</li>
<li>A merge commit, unless you have enabled fast-forward merges in your project. Fast-forward merges disable merge commits.</li>
</ul>
<p>By default, squashed commits contain the following metadata:</p>
<ul>
<li>Message: Description of the squash commit, or a customized message</li>
<li>Author: User that created the merge request</li>
<li>Committer: User who initiated the squash</li>
</ul>
<p>Project owners can create new default messages for all squash commits and merge commits.</p>
</blockquote>
<h3 id="角色与权限管理"><a class="header" href="#角色与权限管理">角色与权限管理</a></h3>
<h5 id="分支合标签保护"><a class="header" href="#分支合标签保护">分支合标签保护</a></h5>
<p>设置参与人员修改分支的权限。</p>
<pre><code class="language-ini">[Branch]
branch=&quot;master*&quot;
allow to merge=&quot;Maintainers&quot;
allow to push=&quot;Developers+Maintainers&quot;
[Tag]
tag=&quot;v-*&quot;
allow to create=&quot;Maintainers&quot;
</code></pre>
<h2 id="参考资料-2"><a class="header" href="#参考资料-2">参考资料</a></h2>
<ol>
<li><a href="https://git-scm.com/docs">git Reference</a>.</li>
<li><a href="http://book.git-scm.com/book/en/v2">Git - Book (git-scm.com)</a></li>
<li><a href="https://ndpsoftware.com/git-cheatsheet.html#loc=workspace;">workspace :: Git Cheatsheet :: NDP Software</a></li>
<li><a href="https://realpython.com/python-git-github-intro/#gitignore">Introduction to Git and GitHub for Python Developers – Real Python</a></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="文本查找"><a class="header" href="#文本查找">文本查找</a></h1>
<h2 id="wildcard-glob"><a class="header" href="#wildcard-glob">Wildcard (Glob)</a></h2>
<blockquote>
<p><em>In computer programming, glob patterns specify sets of filenames with wildcard characters.</em></p>
</blockquote>
<p><code>*</code>：匹配任意数量字符；</p>
<p><code>?</code>：匹配单个字符；</p>
<p><code>[abc]</code>：匹配集合中的单个字符；<code>[!...]</code>反向匹配。</p>
<p><code>[a-z]</code>：匹配范围内的单个字符。</p>
<h5 id="sql通配符"><a class="header" href="#sql通配符">SQL通配符</a></h5>
<p>SQL <code>LIKE</code>语句：<code>_</code>对应<code>?</code>；<code>%</code>对应<code>*</code>；不支持<code>[...]</code>。</p>
<p><a href="https://en.wikipedia.org/wiki/Glob_(programming)">glob (programming) - Wikipedia</a></p>
<h2 id="正则表达式regular-expression"><a class="header" href="#正则表达式regular-expression">正则表达式（Regular Expression）</a></h2>
<p>正则表达式定义了字符串的模式，可以用来搜索、编辑或处理文本。</p>
<p>正则表达式并不仅限于某一种编程语言，但是在每种语言中有细微的差别。</p>
<h3 id="表达式语法"><a class="header" href="#表达式语法">表达式语法</a></h3>
<p>正则表达式是一个字符串，其中包含：</p>
<ul>
<li>普通字符、转义字符；</li>
<li>字符集合；</li>
<li>匹配位置，位于匹配内容之前；</li>
<li>匹配次数，位于匹配内容之后。</li>
<li>运算符：
<ul>
<li><code>()</code>：优先级运算符，产生<strong>捕获组</strong>；</li>
<li><code>x|y|z</code>：<a href="%E7%AC%94%E8%AE%B0/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.html#%E9%80%89%E6%8B%A9">匹配其中一项</a>，从左至右依次尝试；使用<code>(...|...|...)</code>将选择内容括起来以免产生歧义。</li>
</ul>
</li>
</ul>
<h4 id="正则表达式类型"><a class="header" href="#正则表达式类型">正则表达式类型</a></h4>
<p>基本正则表达式（BRE）与扩展正则表达式（ERE）的主要区别是对特殊字符的解释：BRE需要使用<code>\</code>表示特殊字符，而ERE则恰好相反（使用<code>\</code>将特殊字符转为普通字符）。</p>
<ul>
<li>BRE：<code>\+</code>、<code>\?</code>、<code>\{...\}</code>、<code>\(...\)</code>、<code>\|</code>；</li>
<li>ERE：<code>+</code>、<code>?</code>、<code>{...}</code>、<code>(...)</code>、<code>|</code>；</li>
</ul>
<p>BRE和ERE对<a href="%E7%AC%94%E8%AE%B0/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.html#%E8%BD%AC%E4%B9%89%E5%AD%97%E7%AC%A6">其他转义字符</a>的处理方式一致，即<code>\CHAR</code>。</p>
<p>PRE在ERE基础上定义了许多扩展功能，如预定义的匹配集合、非捕获元等。</p>
<h4 id="匹配位置"><a class="header" href="#匹配位置">匹配位置</a></h4>
<p><code>^</code>：扫描行的开始 如：<code>^word</code>匹配所有以<code>word</code>开头的行。</p>
<p><code>$</code>：扫描行的结束 如：<code>word$</code>匹配所有以<code>word</code>结尾的行。</p>
<blockquote>
<p>当未指定匹配位置时，可在文本任何位置进行匹配。注意某些编程语言（例如Python）中提供的<code>match</code>方法限制了从开始位置匹配。</p>
<p>文本行的开始和结束可能包含空白字符，执行边界匹配时需要考虑。</p>
</blockquote>
<h4 id="匹配次数"><a class="header" href="#匹配次数">匹配次数</a></h4>
<div class="table-wrapper"><table><thead><tr><th>表达式</th><th>说明</th></tr></thead><tbody>
<tr><td><code>(...){n}</code></td><td>表达式重复<code>n</code>次</td></tr>
<tr><td><code>(...){m,n}</code><br /><code>(...){m,}</code></td><td>表达式至少重复m次（最多重复n次）</td></tr>
<tr><td><code>(...)?</code></td><td>匹配表达式0或者1次，相当于<code>{0,1}</code>（通配符）</td></tr>
<tr><td><code>(...)+</code></td><td>前面的表达式至少出现1次，相当于<code>{1,}</code></td></tr>
<tr><td><code>(...)*</code></td><td>表达式不出现或出现任意次，相当于<code>{0,}</code>（正则表达式中不代表匹配任意字符）</td></tr>
<tr><td><code>(...)*?</code><br/> <code>(...)+?</code></td><td>匹配尽可能多的文本（非贪婪模式）。</td></tr>
<tr><td><code>(...)??</code></td><td>匹配尽可能少的文本（非贪婪模式）*。</td></tr>
</tbody></table>
</div>
<blockquote>
<p>* <a href="https://www.jb51.net/article/31491.htm">正则表达式之 贪婪与非贪婪模式详解（概述）</a>。</p>
</blockquote>
<h4 id="非捕获选择"><a class="header" href="#非捕获选择">非捕获选择</a></h4>
<p>用圆括号将所有选择项括起来，相邻的选择项之间用<code>|</code>分隔。但用圆括号会有一个副作用，使相关的匹配会被捕获（<code>group</code>），此时可用<code>(?:A|B|...)</code>（非捕获元）放在第一个选项前来<a href="https://segmentfault.com/a/1190000010514763">消除这种副作用</a>（仅PRE支持）。</p>
<p>捕获组的内容可在表达式后续内容中进行引用：<code>([0-9]{3}),(\w{4})\1\2</code>（<code>\1</code>和<code>\2</code>分别代表之前出现过的捕获组内容）。捕获组的==索引顺序：从左至右，由外至内==；</p>
<blockquote>
<p><code>?=</code> 和 <code>?!</code>：正向/反向预查，在任何开始匹配圆括号内的正则表达式模式的位置来匹配搜索字符串，后者为负向预查，在任何开始不匹配该正则表达式模式的位置来匹配搜索字符串。</p>
</blockquote>
<h4 id="消费"><a class="header" href="#消费">消费</a></h4>
<p>当字符串的内容与模式匹配成功后，匹配内容及之前的内容将被消耗，后续匹配将从剩余字串继续匹配。</p>
<h3 id="字符"><a class="header" href="#字符">字符</a></h3>
<h4 id="字符集合"><a class="header" href="#字符集合">字符集合</a></h4>
<div class="table-wrapper"><table><thead><tr><th>预定义集合表达式</th><th>说明</th></tr></thead><tbody>
<tr><td><code>\d</code>/<code>\D</code></td><td><code>0~9</code>之间的任意数字；<code>\D</code>为补集*</td></tr>
<tr><td><code>\w</code>/<code>\W</code></td><td><strong>字母（包括非英语文字）、数字或下划线</strong>，<code>\W</code>为<code>\w</code>的补集；</td></tr>
<tr><td><code>\s</code>/<code>\S</code></td><td>==空白字符==：包括空格、制表符、换行符</td></tr>
<tr><td><code>\b</code></td><td>文字<strong>字符边界</strong>（boundary between a <code>\w</code> and a <code>\W</code> character）。<br />注意：两个非文字字符之间没有边界。</td></tr>
<tr><td><code>.</code></td><td>除换行符之外的任意一个字符</td></tr>
</tbody></table>
</div>
<blockquote>
<p><code>*</code>：<code>\d,\D</code>是PRE扩展，对于<code>grep</code>/<code>sed</code>等程序，如果使用ERE/BRE，可使用<code>[:digit:]</code>代替。</p>
</blockquote>
<p>各实现还定义了<a href="%E7%AC%94%E8%AE%B0/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.html#%E5%AE%9E%E7%8E%B0">扩展的字符集合</a>。</p>
<h5 id="自定义字符集合"><a class="header" href="#自定义字符集合">自定义字符集合</a></h5>
<p><code>[...]</code>用于自定义匹配范围，其中可以包括：</p>
<ul>
<li>
<p>普通字符：<code>[ab5@]</code>，<code>[a-z]</code>，<code>[0-9]</code>，<code>[a-zA-z0-9]</code>；</p>
</li>
<li>
<p>预定义集合：<code>[\d.+]</code>，<code>[[:digit:]a-z]</code>；</p>
</li>
<li>
<p>排除运算：<code>[^abc]</code>，除<code>a</code>,<code>b</code>,<code>c</code>以外的任意字符；</p>
</li>
<li>
<p>范围运算：<code>[f-k]</code>，<code>f</code>~<code>k</code>之间的任意字符；</p>
</li>
<li>
<p>排除范围：<code>[^A-F0~3]</code>，<code>A</code>~<code>F</code>以及<code>0</code>~<code>3</code>以外的任意字符。</p>
</li>
</ul>
<p>正则表达式的特殊符号（如<code>.+*</code>），被包含到中括号中，则失去特殊意义，除了<code>^</code>,<code>-</code>之外。</p>
<p><code>:</code>是普通字符。</p>
<h4 id="转义字符"><a class="header" href="#转义字符">转义字符</a></h4>
<div class="table-wrapper"><table><thead><tr><th>序列</th><th>代表字符</th><th>序列</th><th>代表字符</th></tr></thead><tbody>
<tr><td><code>\n</code></td><td>换行符</td><td><code>\\</code></td><td>反斜线</td></tr>
<tr><td><code>\t</code></td><td>制表符*</td><td><code>\r</code></td><td>回车符</td></tr>
<tr><td><code>\f</code></td><td>换页符</td><td><code>\v</code></td><td>垂直制表符</td></tr>
<tr><td><code>\^</code>,<code>\$</code>,<code>\.</code>,<code>\*</code>,,<code>\[</code>,<code>\]</code>, <code>\-</code></td><td>特殊字符</td><td><code>\xn</code></td><td>匹配十六进制码<code>n</code>表示的字符</td></tr>
</tbody></table>
</div>
<blockquote>
<p><code>*</code>：<code>\n</code>和<code>\\</code>是通用的，其他特殊序列如<code>\t</code>则可能被解释为字符<code>t</code>。</p>
</blockquote>
<p>注意：部分转移字符（例如<code>\n</code>、<code>\\</code>等）在编程语言的字符串中首先会被作为转义字符处理，因此在正则表达式中要额外使用<code>\</code>消除编程语言中的转义处理。在Python中可以使用原始字符串类型，以避免对字符串中的<code>\</code>的解释。</p>
<pre><code class="language-python">regexp_str = r'hello\.world\\'
regexp_str = 'hello\\.world\\\\'
</code></pre>
<h3 id="应用"><a class="header" href="#应用">应用</a></h3>
<h5 id="ip地址"><a class="header" href="#ip地址">IP地址</a></h5>
<p>Simple regex to check for an IP address:</p>
<pre><code class="language-sh">'^(?:[0-9]{1,3}\.){3}[0-9]{1,3}$'
</code></pre>
<p>Accurate regex to check for an IP address:</p>
<pre><code class="language-sh">'^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$'
</code></pre>
<p>Simple regex to extract IP addresses from longer text:</p>
<pre><code class="language-sh">'\b(?:[0-9]{1,3}\.){3}[0-9]{1,3}\b'  # \b for word space
</code></pre>
<p>Accurate regex to extract IP addresses from longer text:</p>
<pre><code class="language-sh">'(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)'
</code></pre>
<blockquote>
<p><em><code>(?:xxx)</code> 在<code>grep</code>中导致无匹配输出，在Python<code>re</code>中可以正常输出匹配。</em></p>
</blockquote>
<h5 id="url-1"><a class="header" href="#url-1">URL</a></h5>
<pre><code class="language-python">re.sub('https://.*?/', '', data, count=1)   # 获取URI
</code></pre>
<p><a href="https://en.wikipedia.org/wiki/Regular_expression">Regular expression</a></p>
<h3 id="实现"><a class="header" href="#实现">实现</a></h3>
<h4 id="预定义字符集"><a class="header" href="#预定义字符集">预定义字符集</a></h4>
<h5 id="grep-and-sed"><a class="header" href="#grep-and-sed">grep and sed</a></h5>
<div class="table-wrapper"><table><thead><tr><th>集合表达式</th><th>说明</th><th>集合表达式</th><th>说明</th></tr></thead><tbody>
<tr><td><code>[:ascii:]</code></td><td>ASCII字符</td><td><code>[:cntrl:]</code></td><td>ASCII控制字符</td></tr>
<tr><td><code>[:graph:]</code></td><td>非控制/空格字符</td><td><code>[:blank:]</code></td><td>空格或制表符</td></tr>
<tr><td><code>[:space:]</code></td><td>空白字符（包括垂直制表符）</td><td><code>[:punct:]</code></td><td>标点符号</td></tr>
<tr><td><code>[:digit:]</code></td><td>数字</td><td><code>[:xdigit:]</code></td><td>十六进制数字</td></tr>
<tr><td><code>[:alpha:]</code></td><td>字母</td><td><code>[:alnum:]</code></td><td>英语字母与数字</td></tr>
<tr><td><code>[:lower:]</code></td><td>小写字母</td><td><code>[:print:]</code></td><td>可打印字符（包括非ASCII字符）</td></tr>
<tr><td><code>[:upper:]</code></td><td>大写字母</td><td></td><td></td></tr>
</tbody></table>
</div>
<h5 id="python"><a class="header" href="#python">python</a></h5>
<div class="table-wrapper"><table><thead><tr><th>集合表达式</th><th>说明</th></tr></thead><tbody>
<tr><td><code>\NNN</code></td><td>匹配第$N$个捕获组内容（<code>[...]</code>中无效）</td></tr>
<tr><td><code>\A</code>/<code>\Z</code></td><td>匹配文本开始（<code>^</code>）和结束（<code>$</code>）；</td></tr>
</tbody></table>
</div>
<p><a href="https://docs.microsoft.com/en-us/dotnet/standard/base-types/regular-expressions">.NET regular expressions</a></p>
<p><a href="https://docs.microsoft.com/en-us/dotnet/standard/base-types/regular-expression-language-quick-reference">Regular Expression Language - Quick Reference</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="linux配置和管理"><a class="header" href="#linux配置和管理">Linux配置和管理</a></h1>
<h2 id="文件管理-1"><a class="header" href="#文件管理-1">文件管理</a></h2>
<p>在Linux/UNIX中，所有的对象都被视为文件，包括普通文件、目录、设备、套接字。</p>
<h3 id="目录路径"><a class="header" href="#目录路径">目录路径</a></h3>
<pre><code class="language-sh">pwd                   # Print Working Directory
dirname filename      # parent directory
basename filename     # 
</code></pre>
<blockquote>
<p><code>pwd</code>列出正在工作的目录，用于显示你当前所处的目录名。<code>pwd</code>命令总是返回你当前所处的目录的完全路径名。<code>dirname</code>返回查询路径的父目录（从文件路径中截取）。<code>basename</code>仅返回文件的名称。</p>
</blockquote>
<p><code>readlink</code>和<code>realpath</code>解析文件的绝对路径，跟踪解析所有符号链接。</p>
<pre><code class="language-shell">readlink -e \ # 解析过程中的所有目标必须存在 =&gt; realpath -e filename
         -f \ # 除最终目标外所有目标必须存在 =&gt; realpath    filename
         -m \ # 允许目标不存在             =&gt; realpath -m filename
         FILENAME 
</code></pre>
<h5 id="切换目录"><a class="header" href="#切换目录">切换目录</a></h5>
<pre><code class="language-shell">cd  [dir_name]     # 切换工作目录（Change Directory）
chroot [OPTION] NEWROOT [COMMAND [ARG]...]  # 切换命令运行的根目录
</code></pre>
<blockquote>
<p>不带任何参数时，将把你送回自己的用户主目录中（等效于<code>cd ~</code>）。<code>..</code>表示父目录。</p>
<p>登录完成后，工作目录为用户主目录。</p>
</blockquote>
<h5 id="创建目录"><a class="header" href="#创建目录">创建目录</a></h5>
<p>在每一个新的子目录中，均包含两个标准的项目：<code>.</code>代表当前目录和<code>..</code>代表父目录。</p>
<pre><code class="language-shell">mkdir -m,--mode=MODE -p dir_name 
install [OPTIONS] -d dir1 dir2 ...   # 创建目录并设置权限
</code></pre>
<blockquote>
<p><code>-m</code>：可用来创建一个带有特定权限的子目录（<code>chmod</code>声明方式）。
<code>-p</code>：父目录不存在的情况下首先创建父目录，忽略已存在目录（默认报错）。</p>
</blockquote>
<h5 id="删除目录"><a class="header" href="#删除目录">删除目录</a></h5>
<pre><code class="language-sh">rmdir -p dir_name ...   # -p 一次删除多个目录
</code></pre>
<blockquote>
<p><code>dir_name</code>不能为当前工作目录（即要在父目录中删除子目录）。应该拥有被删除目录的写该目录必须为空目录（即只包含<code>.</code>和<code>..</code>，否则使用<code>rm -rf dir_name</code>）。</p>
</blockquote>
<h4 id="显示目录中的项目"><a class="header" href="#显示目录中的项目">显示目录中的项目</a></h4>
<h5 id="列表显示"><a class="header" href="#列表显示">列表显示</a></h5>
<pre><code class="language-sh">ls [options] [dir_name]
</code></pre>
<h6 id="文件过滤选项"><a class="header" href="#文件过滤选项">文件过滤选项</a></h6>
<p><code>-a</code>：显示所有文件（包括以<code>.</code>开头的文件（夹）），<code>-A</code>仅忽略<code>.</code>和<code>..</code>；
<code>-R</code>：递归显示所有子目录的内容；
<code>-d</code>：只显示目录条目的信息；</p>
<h6 id="文件信息选项"><a class="header" href="#文件信息选项">文件信息选项</a></h6>
<p><code>-l</code>：列表显示目录中文件的详细信息，与其他排序方式组合使用时则显示相应的排序字段；<code>-g</code>与<code>-l</code>相似但不显示文件所有者，<code>-o</code>不显示用户组；</p>
<blockquote>
<p>文件类型信息：<code>-</code> 表示普通文件（<code>f</code>）；<code>d</code> 目录文件；<code>b</code>块设备文件例如磁盘；<code>c</code>字符设备文件，<code>p</code>命名管道（FIFO） ；<code>l</code>符号链接；<code>s</code> 套接字（socket）；</p>
</blockquote>
<p><code>--author</code>：显示文件创建者；
<code>-n</code>：显示数字形式的用户和用户组ID；
<code>-i</code>：<code>inode</code>序号将列在第一列；
<code>--time-STYLE</code>：时间显示格式，包括：<code>full-iso</code>（<code>2020-03-07 15:07:15.542112573 +0800</code>）、<code>long-iso</code>（<code>2020-03-07 17:34</code>）、<code>iso</code>（<code>03-07 15:07</code>）、<code>locale</code>（<code>Mar  7 15:07</code>）或<code>+FORMAT</code>；
<code>--full-time</code>：显示完整时间，等价于<code>-l --time-style=full-iso</code>；
<code>-h</code>：显示更加友好的文件长度信息（<code>1K 234M 2G</code>，等价<code>--human-readable</code>）；
<code>-s</code>：显示文件占用的磁盘容量；
<code>--block-size=SIZE</code>：<code>K,M,G,T,P,E,Z,Y</code> （powers of 1024）或 <code>KB,MB,...</code> （powers of 1000）</p>
<h6 id="排序选项"><a class="header" href="#排序选项">排序选项</a></h6>
<p><code>--sort=WORD</code>：<code>WORD=none(-U),size(-S),time(-t),version(-v),extension(-X)</code>，未声明排序选项时，<strong>默认</strong>按文件名排序。<code>-c</code>：按<code>ctime</code>（指文件的<code>inode</code>信息被改变的时间）排序；<code>-u</code>：按访问时间排序；<code>-t</code>：按修改时间排序，优先级低于<code>-c</code>和<code>-u</code>；
<code>-r</code>：反向排序；</p>
<h5 id="查看目录树"><a class="header" href="#查看目录树">查看<a href="Linux/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.html">目录树</a></a></h5>
<pre><code class="language-sh">tree -L &lt;n&gt; path  # not built-in
</code></pre>
<p><code>-L &lt;n&gt;</code>：搜索深度；<code>-l</code>：跟踪符号链接；</p>
<h4 id="文件信息-1"><a class="header" href="#文件信息-1">文件信息</a></h4>
<p>获取文件的信息：</p>
<pre><code class="language-sh">stat &lt;path/to/file&gt; -c,--format,--printf=FORMAT \
     -f,--file-system   # 显示文件所在文件系统信息而非文件信息
</code></pre>
<p>格式参数<code>FORMAT</code>可包含多个格式声明以及普通字符，<code>--printf</code>还可使用<code>&quot;\&quot;</code>转义字符；</p>
<div class="table-wrapper"><table><thead><tr><th>格式</th><th>内容</th><th>格式</th><th>内容</th><th>格式</th><th>内容</th><th>格式</th><th>内容</th><th>格式</th><th>内容</th></tr></thead><tbody>
<tr><td><code>%n</code></td><td>文件名</td><td><code>%F</code></td><td>文件类型</td><td><code>%g</code></td><td>group id</td><td><code>%y</code></td><td>修改时间</td><td><code>%a</code></td><td>八进制访问权限</td></tr>
<tr><td><code>%N</code></td><td><code>&quot;文件名&quot;</code></td><td><code>%s</code></td><td>file bytes</td><td><code>%G</code></td><td>group name</td><td><code>%Y</code></td><td>修改时间戳</td><td><code>%A</code></td><td>字母访问权限</td></tr>
<tr><td><code>%h</code></td><td>硬链接数</td><td><code>%m</code></td><td>挂载点</td><td><code>%u</code></td><td>owner id</td><td><code>%w</code></td><td>创建时间</td><td><code>%x</code></td><td>访问时间</td></tr>
<tr><td><code>%i</code></td><td>inode数</td><td><code>%C</code></td><td>SELinux</td><td><code>%U</code></td><td>owner name</td><td><code>%W</code></td><td>创建时间戳</td><td><code>%X</code></td><td>访问时间戳</td></tr>
</tbody></table>
</div>
<p>除<code>stat</code>外，还可以使用<code>date</code>获取<a href="Linux/Linux%E9%85%8D%E7%BD%AE%E5%92%8C%E7%AE%A1%E7%90%86.html#%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4">文件修改时间</a>：</p>
<pre><code class="language-sh">date -r &lt;filename&gt; [+&quot;%Y%m%d&quot;] 
</code></pre>
<p>获取文件类型：</p>
<pre><code class="language-shell">file &lt;path/to/file&gt; \
    -i，--mime      \  # =&gt; --mime-type + --mime encoding
    -z,--uncompress \  # 尝试解压压缩文件并查看其中内容
</code></pre>
<h5 id="修改文件属性"><a class="header" href="#修改文件属性">修改文件属性</a></h5>
<p><code>touch</code>可以用于<a href="https://askubuntu.com/questions/62492/how-can-i-change-the-date-modified-created-of-a-file">修改文件访问时间</a>。</p>
<pre><code class="language-shell">touch filename
touch -d &quot;2 hours ago&quot; filename
</code></pre>
<h3 id="普通文件"><a class="header" href="#普通文件">普通文件</a></h3>
<h4 id="移动"><a class="header" href="#移动">移动</a></h4>
<p>如果源文件/目录与目标文件/目录同名，则用源文件/目录替换同名目标文件/目录的内容；否则，将源文件/目录移动到目标目录中；此时，目标目录必须存在，不会首先创建目录。</p>
<pre><code class="language-shell">mv [-f]  file_path /path/newname
</code></pre>
<blockquote>
<p>如果源与目标所在路径相同，<code>mv</code>等效于重命名。</p>
</blockquote>
<h5 id="批量重命名"><a class="header" href="#批量重命名">批量重命名</a></h5>
<p>将文件名中已知的部分内容替换为新的内容，其余部分（使用通配符表示）不变。</p>
<pre><code class="language-sh">rename 's/pattern/replace/' FILES    # sed style
rename pattern replace FILES
</code></pre>
<p><code>pattern</code>为Perl正则表达式，文件名<code>FILES</code>支持通配符（<code>?*.txt</code>）。</p>
<blockquote>
<p>使用需注意，原始的<code>rename</code>不会检查已有文件而直接覆盖。</p>
</blockquote>
<h4 id="复制-1"><a class="header" href="#复制-1">复制</a></h4>
<pre><code class="language-sh">cp [-raf] file_path /path/filecopy  # -a 保留原属性
</code></pre>
<blockquote>
<p><code>cp</code>的文件创建行为与<code>mv</code>相同。</p>
</blockquote>
<h5 id="安装-3"><a class="header" href="#安装-3">安装</a></h5>
<p><code>install</code>支持设置目标文件的权限和属性（==不支持文件夹（递归）复制==）：</p>
<ul>
<li>
<p><code>-m,--mode=MODE</code>：设置访问权限；</p>
</li>
<li>
<p><code>-g,--group=GROUP</code>，<code>-o,--owner=OWNER</code>：设置所属关系（<code>chgrp,chown</code>），代替当前进程的默认值；</p>
</li>
<li>
<p><code>-p, --preserve-timestamps</code>：保留文件的访问/修改时间；</p>
</li>
</ul>
<pre><code class="language-shell">install [OPTION] -D [-T] SOURCE DEST   # single-file to file
</code></pre>
<blockquote>
<p><code>-D</code>：（递归）创建目标文件的父目录（<code>mkdir -p</code>），未指定该选项则不会自动创建目录；</p>
</blockquote>
<pre><code class="language-shell">install [OPTION] SOURCE... DIRECTORY   # single to dir
install [OPTION] -t DIRECTORY SOURCE...# multiple to dir (--target-directory)
</code></pre>
<blockquote>
<p><code>-b,--suffix=BACKUP</code>：备份选项以及备份目标文件夹；</p>
</blockquote>
<h4 id="删除文件"><a class="header" href="#删除文件">删除文件</a></h4>
<pre><code class="language-sh">rm [-rf] file  # can use wildcard
</code></pre>
<blockquote>
<p>使用<code>-rf</code>递归删除非空文件夹。</p>
</blockquote>
<h4 id="文件链接"><a class="header" href="#文件链接">文件链接</a></h4>
<p><strong>硬链接</strong>（<strong>hard link</strong>）：是对原文件的引用（引用同一个<code>inode</code>，在<code>inode</code>中计数），与原文件等价（即拥有相同访问权限）。删除硬链接将减小<code>inode</code>计数，到<code>inode</code>计数为0时删除文件。</p>
<p><strong>符号链接</strong>（<strong>symbolic/soft link</strong>）：保存到目标文件（夹）的路径（或相对路径），访问符号链接将跳转到目标文件（夹）。符号链接是一个独立的文件（具有相应的<code>inode</code>节点），因此具有独立的文件权限。删除原文件后，符号链接失效。</p>
<h5 id="创建链接"><a class="header" href="#创建链接">创建链接</a></h5>
<pre><code class="language-sh">ln -s /file/path /symbol/path	  # symbolic link
ln /file/path /symbol/path      # hard link file
ln -d /dir/path /symbol/path    # hard link 目录（不一定支持）
# -f,--force 移除已有文件链接 
</code></pre>
<p>符号链接的目标可以是任意内容（创建的时候不做检查合法性），符号链接支持跨文件系统。硬链接的目标必须存在且仅支持在同一设备的同一文件系统。</p>
<h5 id="访问链接"><a class="header" href="#访问链接">访问链接</a></h5>
<p>==文件链接解引用时，相对路径的父目录为文件链接所在目录==，解析符号链接目标时是递归式解析。</p>
<p>工作目录路径：如果切换工作目录到符号链接指向的目录，则工作目录路径为符号链接的路径而非目标目录的真实路径（比较<code>pwd</code>和<code>realpath</code>的输出结果），向上跳转（<code>..</code>）会返回符号链接所在目录。</p>
<p>在Linux中创建的符号链接在Windows中仍然能访问（WSL），但Windows不做递归解析，仅以当前工作目录路径为参考解析符号链接，因此<strong>使用相对路径的多级符号链接解析会出错</strong>。</p>
<h4 id="临时文件"><a class="header" href="#临时文件">临时文件</a></h4>
<p>在指定目录下（默认为<code>/tmp</code>）创建临时文件并输出文件路径。</p>
<pre><code class="language-shell">tempfile --directory PATH # [Debian] 
mktemp -p PATH     # [Fedora-coreutils]
       --directory # 创建目录而非文件
</code></pre>
<h3 id="查找文件"><a class="header" href="#查找文件">查找文件</a></h3>
<pre><code class="language-sh">which &lt;command&gt;
command -V &lt;command&gt;
</code></pre>
<blockquote>
<p>从系统环境变量中查找文件并返回绝对路径。</p>
</blockquote>
<h4 id="查找目录中的文件"><a class="header" href="#查找目录中的文件">查找目录中的文件</a></h4>
<pre><code class="language-sh">find [-HLP][-D debugopts][-Olevel][start_dir...][expression]
</code></pre>
<p><code>start_dir</code>表示查找路径，可以使用绝对路径，也可以使用相对路径，可以同时指定多个目录；如果没有指定，则<strong>默认为当前目录</strong>。==默认输出信息为查找到的文件夹和文件信息，并包含从查找目录开始的完整路径信息。==</p>
<h5 id="选项option"><a class="header" href="#选项option">选项（Option）</a></h5>
<p>选项<strong>控制<code>find</code>访问文件系统的行为</strong>。</p>
<p><code>-H</code>，<code>-L</code>和<code>-P</code>（默认）控制处理符号链接的行为。</p>
<blockquote>
<p><code>-P</code>表示不解析任何符号链接；
<code>-H</code>表示除了命令行提供的文件名外，不解析其他符号链接。如果符号链接不能被解析，则返回符号连接本身的信息；
<code>-L</code>表示在可能的情况下解析符号链接，反之返回符号链接自身的信息。（<code>-follow</code> deprecated）</p>
</blockquote>
<p><code>-D debugopts</code>：输出诊断信息。</p>
<p><code>-Olevel</code>：查询优化。默认首先执行基于文件名的表达式（<code>-name</code>，<code>-regex</code>等）；其次执行<code>-type</code>或<code>-xtype</code>的表达式（通过<code>readdir()</code>读取文件类型）。</p>
<p>读取上述选项之后，检查后续参数是否为文件/路径，直到以<code>-</code>、<code>(</code>、<code>!</code>开始的参数（也可以使用<code>--</code>声明选项参数的结束）。剩余参数为控制搜索行为的表达式。</p>
<h5 id="表达式expression"><a class="header" href="#表达式expression">表达式（Expression）</a></h5>
<p>表达式用于控制如何匹配文件以及对匹配文件的操作。表达式可以包含以下内容：</p>
<ul>
<li><code>Tests</code>：测试文件属性，返回<code>true|false</code>；</li>
<li><code>Actions</code>：对匹配结果执行操作，根据操作结果返回<code>true|false</code>；如果表达式没有包含操作，则默认为<code>-print</code>；</li>
<li><code>Global options</code>：全局选项，总是返回<code>true</code>；</li>
<li><code>Positional options</code>：仅影响其后的测试或操作，总是返回<code>true</code>；</li>
<li><code>Operator</code>：将表达式中多个内容连接起来：<code>-o</code>（逻辑<code>OR</code>）、<code>-a</code>（逻辑<code>AND</code>）；表达式内容之间默认使用<code>-a</code>连接；可以使用<code>()</code>声明优先级。</li>
</ul>
<h6 id="全局选项"><a class="header" href="#全局选项">全局选项</a></h6>
<ul>
<li><code>-d,-depth</code>：先处理文件夹中的内容，再处理文件夹本身；</li>
<li><code>-maxdepth,-mindepth LEVEL</code>：指定搜索的层级，<code>0</code>表示起始点本身；</li>
<li><code>-mount, -xdev</code>：不搜索挂载的其他文件系统目录；</li>
<li><code>-help,--help,--version</code>：帮助、版本信息。</li>
</ul>
<h6 id="位置选项"><a class="header" href="#位置选项">位置选项</a></h6>
<ul>
<li>
<p><code>-daystart</code>：计算时间时从今天开始，而非24小时前算起。影响其后的测试条件<code>-amin</code>, <code>-cmin</code>, <code>-mmin</code>, <code>-atime</code>, <code>-ctime</code>和<code>-mtime</code>。</p>
</li>
<li>
<p><code>-regextype TYPE</code>：默认为<code>emacs</code>，包括：<code>awk,egrep,grep,sed</code>等。</p>
<blockquote>
<p><code>-regextype egrep</code>在CentOS 7 上不支持<code>{}</code>。</p>
</blockquote>
</li>
</ul>
<h6 id="测试条件"><a class="header" href="#测试条件">测试条件</a></h6>
<div class="table-wrapper"><table><thead><tr><th>表达式</th><th>说明</th></tr></thead><tbody>
<tr><td><code>-name PATTERN</code></td><td>查找==文件名==匹配<code>PATTERN</code>的文件，可以使用通配符<code>*，？,[]</code>。</td></tr>
<tr><td><code>-path PATTERN</code></td><td>==从搜索路径开始的完整文件名（非绝对路径）==与<code>PATTERN</code>进行匹配<br />（<code>-wholename</code>）。</td></tr>
<tr><td><code>-regex PATTERN</code></td><td>使用正则表达式匹配文件。文件名以<code>./</code>开头的==完整相对路径==，<br />注意在正则表达式前添加<code>.*</code>以匹配前缀；</td></tr>
<tr><td><code>-atime [+-]N</code> <br/> <code>-ctime [+-]N</code> <br/> <code>-mtime [+-]N</code></td><td>判断最近访问(<code>-a</code>)，状态变化(<code>-c</code>)，修改(<code>-m</code>)时间：<br/>如果参数为<code>N</code>，表示时间在<code>N</code>天之内<br/>（0表示0~24小时，1表示24~48小时，…）</td></tr>
<tr><td><code>-amin [+-]N</code></td><td>时间单位为<code>min</code>（类似地<code>-cmin</code>，<code>-mmin</code>）</td></tr>
<tr><td><code>-anewer FILE</code></td><td>测试最近访问时间是否比<code>FILE</code>更近（<code>-cnewer,-newer</code>）。</td></tr>
<tr><td><code>-used [+-]N</code></td><td>在文件状态改变<code>N</code>天（<code>+N,-N</code>）之内文件被访问过。</td></tr>
<tr><td><code>-empty</code></td><td>测试文件或文件夹是否为空。</td></tr>
<tr><td><code>-size n[u]</code></td><td>文件大小：单位<code>u=cwbkMG:</code></td></tr>
<tr><td><code>-fstype TYPE</code></td><td>测试文件所在的文件系统的类型是否为<code>TYPE</code>。</td></tr>
<tr><td><code>-uid [+-]N</code></td><td>文件的用户ID（组ID<code>-gid</code>）是否为<code>N</code>（或<code>+N,-N</code>）。</td></tr>
<tr><td><code>-user NAME</code></td><td>文件的用户名（组名<code>-group</code>）是否为<code>NAME</code>（允许使用ID）。</td></tr>
<tr><td><code>-nouser</code></td><td>文件的用户ID（组ID<code>-nogroup</code>）没有对应的用户（组）。</td></tr>
<tr><td><code>-lname PATTERN</code></td><td>符号链接所指向的文件的文件名是否与<code>PATTERN</code>匹配。</td></tr>
<tr><td><code>-perm pmode</code></td><td>文件的权限是否与<code>pmode</code>匹配，<br/><code>pmode</code>可以是符号或数字模式，例如：<code>-perm 664</code>。<br/>直接指定单项权限<code>-readable</code>、<code>-writable</code>、<code>-executable</code>。</td></tr>
<tr><td><code>-type &lt;c&gt;</code></td><td><a href="Linux/Linux%E9%85%8D%E7%BD%AE%E5%92%8C%E7%AE%A1%E7%90%86.html#%E6%96%87%E4%BB%B6%E4%BF%A1%E6%81%AF%E9%80%89%E9%A1%B9">文件类型</a>： <code>bcdpfls</code></td></tr>
<tr><td><code>-xtype c</code></td><td>除符号链接以外，与<code>-type</code>作用一致；</td></tr>
<tr><td><code>-inum [+-]N</code></td><td>rarely useful.</td></tr>
<tr><td><code>-samefile NAME</code></td><td>文件与<code>NAME</code>为同一个文件。</td></tr>
<tr><td><code>-links [+-]N</code></td><td>File has n hard links.</td></tr>
</tbody></table>
</div>
<blockquote>
<p>匹配文件名的测试命令前添加<code>i</code>（例如<code>-iname</code>）为忽略大小写版本。
通配符需要使用引号包围以防被shell展开。
参数如果为<code>+N</code>，则表示大于<code>N</code>，如果为<code>-N</code>则表示小于<code>N</code>。</p>
</blockquote>
<h6 id="运算符-15"><a class="header" href="#运算符-15">运算符</a></h6>
<div class="table-wrapper"><table><thead><tr><th>运算符</th><th>表达式</th></tr></thead><tbody>
<tr><td><code>()</code></td><td><code>(EXPR)</code></td></tr>
<tr><td><code>!</code>   <code>-not</code></td><td><code>!EXPR</code>   <code>–not EXPR</code></td></tr>
<tr><td><code>-a</code>  <code>-and</code></td><td><code>EXPR1 –a EXPR2</code>  <code>EXPR1 –and EXPR2</code></td></tr>
<tr><td><code>-o</code>  <code>-or</code></td><td><code>EXPR1 –o EXPR2</code>  <code>EXPR1 –or EXPR2</code></td></tr>
<tr><td><code>,</code></td><td><code>EXPR1, EXPR2</code></td></tr>
</tbody></table>
</div>
<h6 id="动作"><a class="header" href="#动作">动作</a></h6>
<div class="table-wrapper"><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody>
<tr><td><code>-print, -print0</code></td><td><code>print0</code>会在文件名结尾追加“<code>null</code>”。</td></tr>
<tr><td><code>-fprint FILE</code><br/><code>-fprint0 FILE</code></td><td>打印完整文件名到<code>FILE</code>。<br/>如果文件不存在则创建文件；<br/>如果存在，则文件内容被删除；<br/>即使没有输出内容，该文件仍然会被创建。</td></tr>
<tr><td><code>-ls</code><br/><code>-fls FILE</code></td><td>以<code>ls -dils</code>格式打印到标准输出。<code>-fls</code>输出到文件。</td></tr>
<tr><td><code>-printf FORMAT</code><br/><code>-fprintf FILE FORMAT</code></td><td>位宽和精度说明类似于C语言的<code>printf</code>(<code>man find</code>)。</td></tr>
<tr><td><code>-execdir command</code><br/><code>-exec command</code></td><td><code>-execdir</code>将其后直到<code>;</code>的所有内容视为<code>command</code>，<br/>同时将其中的“<code>{}</code>”替换为查找结果的文件名。<br/><code>command</code>中的特殊字符需要使用“<code>\</code>”或“<code>'</code>”以防被shell展开。</td></tr>
<tr><td><code>-execdir command {}+</code><br/><code>-exec command {}+</code></td><td>命令末尾的“<code>{}</code>”展开为匹配文件名称的列表；</td></tr>
<tr><td><code>-okdir command</code><br/><code>-ok command</code></td><td>询问用户是否执行命令</td></tr>
<tr><td><code>-delete</code></td><td>删除成功返回真；如果失败，生成错误信息；</td></tr>
</tbody></table>
</div>
<h5 id="查找文件示例"><a class="header" href="#查找文件示例">查找文件示例</a></h5>
<p>高亮<code>find</code>查找结果：</p>
<pre><code class="language-sh">find ./ -name '*.tar.gz' | grep --color '.tar.gz'
</code></pre>
<p>打印查找到文件的详细信息。</p>
<pre><code class="language-sh">find ./ -name '*.tar.gz' -exec ls -lh {} ';' 
</code></pre>
<p>删除文件：</p>
<pre><code class="language-shell">find . -maxdepth 1 -newer archive.tar.gz -execdir rm -rf {} ';'
</code></pre>
<p>在过滤文件中查找内容：</p>
<pre><code class="language-sh">find ./ –name '*.cpp' –exec grep -Hn 'main' {} ';'
find ./ -name &quot;*.log&quot; | xargs grep –Hn 'ERROR'
</code></pre>
<p><em><code>grep</code>与<code>find</code>同时使用时，默认不会输出文件名（添加<code>-H</code>选项），也不会高亮文本（使用<code>--color</code>选项）。</em></p>
<h4 id="查找文件内容"><a class="header" href="#查找文件内容">查找文件内容</a></h4>
<p>使用<a href="Linux/Linux-Shell.html#grep"><code>grep</code></a>查找具有给定内容和文件名的文件：</p>
<pre><code class="language-sh">grep -rl 'main' --include='*.cpp' ./  # 输出匹配文件的文件名
grep -rn 'main' --include='*.cpp' ./  # 输出匹配行的行号和内容
</code></pre>
<h2 id="硬件管理"><a class="header" href="#硬件管理">硬件管理</a></h2>
<h3 id="查看硬件信息"><a class="header" href="#查看硬件信息">查看硬件信息</a></h3>
<pre><code class="language-shell">sudo dmidecode -t,--type type_code|type_keyword
sudo dmidecode [options] | grep -A16 'System Information$'   # 系统和主板信息
</code></pre>
<p>硬件类型（<code>type_keyword</code>）包括：<code>bios</code>, <code>system</code>, <code>baseboard</code>, <code>chassis</code>, <code>processor</code>, <code>memory</code>, <code>cache</code>, <code>connector</code>, <code>slot</code>。每种类型可能包括多个子类型（<code>type_code</code>）。</p>
<pre><code class="language-shell">sudo lshw \               # list hardware [yum install lshw]
     -class &lt;hw_class&gt; \  # class can be found using lshw -short
     -{html|xml|json}  \  # 输出格式
     -short \ # device tree: 优先级高于输出格式
     -businfo # showing bus information
</code></pre>
<p>硬件类型可通过<code>lshw -short</code>的输出获取，包括：<code>system</code>，<code>bus</code>，<code>memory</code>，<code>processor</code>，<code>storage</code>，<code>input</code>，<code>display</code>，<code>disk</code>，<code>volume</code>，<code>network</code>，<code>power</code>等。</p>
<blockquote>
<p>其他工具：<code>hwinfo</code>（默认未安装到系统）；<code>hardinfo</code>（图形界面）。</p>
</blockquote>
<h5 id="cpu-1"><a class="header" href="#cpu-1">CPU</a></h5>
<pre><code class="language-sh">lscpu              # CPU信息概述
nproc              # number of process unit
sudo lshw -C processor
cat /proc/cpuinfo  # CPU details
sudo dmidecode --type processor # details
</code></pre>
<blockquote>
<p><code>cpuid</code>获取详细信息（未安装）。</p>
</blockquote>
<pre><code class="language-sh">cat /proc/cpuinfo | grep name | cut -f2 -d: | uniq -c
# 8  Intel(R) Xeon(R) CPU            E5410   @ 2.33GHz
## (CPU with 8 logical core)
cat /proc/cpuinfo | grep 'physical id' | uniq -c
#      4 physical id      : 0
#      4 physical id      : 1
### (2 physical CPU with 4-core)
</code></pre>
<h5 id="内存-1"><a class="header" href="#内存-1">内存</a></h5>
<pre><code class="language-sh">free -h	-w	# summary
cat /proc/meminfo  # details
vmstat -s
sudo dmidecode -t memory   # Memory Device
</code></pre>
<blockquote>
<p>all tmpfs pages will be shown as “<code>Shmem</code>” in <code>/proc/meminfo</code> and “<code>Shared</code>” in <code>free(1)</code>.</p>
</blockquote>
<h5 id="磁盘信息"><a class="header" href="#磁盘信息">磁盘信息</a></h5>
<p>列出存储设备信息：</p>
<pre><code class="language-sh">sudo fdisk -l [device_name]  # 查看磁盘设备 =&gt; sudo parted /dev/sda print
lsblk    # 列出块设备
sudo blkid /dev/sda
# /dev/sda: UUID=&quot;3255683f-53a2-4fdf-91cf-b4c1041e2a62&quot; TYPE=&quot;ext4&quot;
</code></pre>
<p>查看序列号：</p>
<pre><code class="language-shell">udevadm info --query=all --name=/dev/sda | grep ID_SERIAL
hdparm -I /dev/sda   # install hdparm
lshw -class disk     # install lshw
smartctl -i /dev/sda # install smartmontools
</code></pre>
<blockquote>
<p>位于磁盘阵列中的磁盘序列号不可见（系统读取的是RAID分配的ID）。</p>
</blockquote>
<h5 id="文件系统信息"><a class="header" href="#文件系统信息">文件系统信息</a></h5>
<p>列出系统支持的文件系统：</p>
<pre><code class="language-shell">cat /proc/filesystems
</code></pre>
<blockquote>
<p><code>exfat</code>格式支持需要安装<code>exfat-fuse</code>和<code>exfat-utils</code>包；NTFS格式需要安装<code>ntfs-3g</code>包（CentOS）。</p>
</blockquote>
<p>列出挂载的（文件或目录所在）<a href="Linux/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.html#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%B1%BB%E5%9E%8B">文件系统</a>信息。</p>
<pre><code class="language-sh">df [-ahHkT] [目录或文件名]
# Filesystem      Size  Used Avail Use% Mounted on
# /dev/sdd        251G  1.6G  237G   1% /
# tmpfs            13G  252M   13G   2% /mnt/wsl
</code></pre>
<blockquote>
<p><code>-hH</code>：以合适的单位显示数据（1024进制，<code>-H</code>为1000进制），提高可读性；
<code>-i,--inodes</code>：显示<code>inode</code>信息而非磁盘容量信息；
<code>-T,--print-type</code>：==打印文件系统类型==，例如<code>ext4</code>、<code>tmpfs</code>等；
<code>-t,--type=TYPE</code>：仅显示指定类型文件系统；<code>-x,--exclude-type=TYPE</code>排除指定类型；</p>
</blockquote>
<p>列出文件或目录的<strong>磁盘占用量</strong>（<strong>disk usage</strong>）：</p>
<pre><code class="language-sh">du [-ahskm] 文件或目录名称
</code></pre>
<p><code>-c, --total</code>；
<code>-h, --human-readable</code>；
<code>-s, --summarize</code>；
<code>-d,--max-depth=N</code>：显示最大路径深度；</p>
<h3 id="磁盘管理"><a class="header" href="#磁盘管理">磁盘管理</a></h3>
<h4 id="磁盘分区与格式化"><a class="header" href="#磁盘分区与格式化">磁盘分区与格式化</a></h4>
<p><strong>注意：以下操作可能导致数据丢失，应事先做好数据备份！！！</strong></p>
<p>使用<code>fdisk</code>或<code>parted</code>操作文件分区表（<code>fdisk -l</code>查看<a href="Linux/Linux%E9%85%8D%E7%BD%AE%E5%92%8C%E7%AE%A1%E7%90%86.html#%E7%A3%81%E7%9B%98%E4%BF%A1%E6%81%AF">磁盘信息</a>）：</p>
<pre><code class="language-sh">sudo fdisk device_name   # 操作分区表
# fdisk命令
# [F] 列出未分区的空闲空间    n 新增分区
# l   列出已知分区类型        t 更改分区类型
# p   打印分区表             d 删除分区  
# [i] 打印选择的分区信息      v 验证分区表
# m   打印命令列表           g 创建GPT分区表
#                          o 创建DOS（MBR）分区表
# q   放弃更改并退出         w 保存分区更改
</code></pre>
<blockquote>
<p>未添加<code>device_name</code>时，列出系统内所有存储设备（<code>/dev</code>）的分区（partition）信息。</p>
<p><a href="https://gparted.org/livecd.php">GParted -- Live CD/USB/PXE/HD</a>：<em>With GParted you can resize, copy, and move partitions without data loss.</em> <code>gparted</code>是一款图形界面的分区工具。</p>
</blockquote>
<p>更改正在使用的分区：首先删除分区（记录下分区表的起止位置），然后重新创建分区，并指定新的起止位置（注意不要和已有分区重叠）和分区类型，保存并退出（<a href="https://www.codenotary.com/blog/enlarge-a-disk-and-partition-of-any-linux-vm-without-a-reboot/">使用工具</a><code>cloud-utils.growpart</code>）。分区表更改不会立即生效，因此可以修改正在使用的分区，重启机器或使用<code>partprobe [/dev/sda]</code>或<code>kpartx [/dev/sda]</code>命令重新载入新的分区表。如果是普通卷，则需要使用<code>resize2fs</code>更新文件系统容量，如果是LVM物理卷，则使用<code>pvresize</code>更新（<code>resize2fs</code>无法操作LVM物理卷）。</p>
<h5 id="磁盘格式化"><a class="header" href="#磁盘格式化">磁盘格式化</a></h5>
<p>新建分区后，需要对分区进行格式化设置文件系统才能进行<a href="Linux/Linux%E9%85%8D%E7%BD%AE%E5%92%8C%E7%AE%A1%E7%90%86.html#%E7%A3%81%E7%9B%98%E6%8C%82%E8%BD%BD%E4%B8%8E%E5%8D%B8%E9%99%A4">挂载使用</a>。整个磁盘也可以不进行分区直接格式化。</p>
<pre><code class="language-sh">mkfs -t &lt;fstype&gt; /dev/sda
mkfs.&lt;fstype&gt; options /dev/sda  # 格式化分区/dev/sda1
</code></pre>
<p><code>fstype</code>文件系统类型，例如 <code>ext4</code>, <code>xfs</code>, <code>btrfs </code>, <code>ZFS</code>等(<a href="Linux/Linux%E9%85%8D%E7%BD%AE%E5%92%8C%E7%AE%A1%E7%90%86.html#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E4%BF%A1%E6%81%AF">系统有支持</a>才会生效)。在选择文件系统类型时，如无特殊要求，选择系统中已有分区类型（默认类型），确保兼容和稳定性。</p>
<blockquote>
<p><code>mke2fs</code>：创建<code>ext2</code>/<code>ext3</code>/<code>ext4</code>文件系统，对应命令：<code>mkfs.ext2|3|4</code>。<code>ext</code>文件系统的<code>i-node</code>节点总数在文件系统创建后不能改变，调整文件系统容量将按比例调整inode数量（<code>bytes-per-inode</code>）。</p>
</blockquote>
<p><a href="https://linuxiac.com/linux-file-system-types-explained-which-one-should-you-use/">Linux File System Types Explained, Which One Should You Use (linuxiac.com)</a></p>
<h5 id="数据恢复"><a class="header" href="#数据恢复">数据恢复</a></h5>
<p><a href="https://www.cgsecurity.org/wiki/TestDisk_Step_By_Step">TestDisk Step By Step - CGSecurity</a></p>
<p><a href="https://www.dedoimedo.com/computers/linux-data-recovery.html">How to recover partitions and data using Linux - Tutorial (dedoimedo.com)</a></p>
<p><a href="https://www.simplified.guide/linux/disk-recover-partition-table">How to recover lost partition using Linux (simplified.guide)</a></p>
<blockquote>
<p><em>TestDisk is powerful free data recovery software! It was primarily designed to help recover lost partitions and/or make non-booting disks bootable again when these symptoms are caused by faulty software: certain types of viruses or human error (such as accidentally deleting a Partition Table).</em></p>
<p>==<em>Even though the old partition table was destroyed, it was just a pointer to the start and end addresses of the actual data, so to speak.</em>==</p>
</blockquote>
<p><a href="https://www.dedoimedo.com/computers/clonezilla.html">The new and definite CloneZilla tutorial (dedoimedo.com)</a></p>
<h4 id="磁盘检验"><a class="header" href="#磁盘检验">磁盘检验</a></h4>
<pre><code>fsck [-t &lt;fstype&gt;] [-ACay] /dev/sda
</code></pre>
<blockquote>
<p>用来检查和维护不一致的文件系统。若系统掉电或磁盘发生问题，可利用<code>fsck</code>命令对文件系统进行检查。</p>
</blockquote>
<h4 id="磁盘挂载与卸除"><a class="header" href="#磁盘挂载与卸除">磁盘挂载与卸除</a></h4>
<pre><code class="language-sh">mount -t &lt;fstype&gt; -L &lt;label&gt; -o &lt;opts&gt; -n /dev/dev_name /mnt/mnt_name
mount --move /mnt/userdirs /home    # move mount point of a filesystem
umount [-fn] [/dev/dev_name | /mnt/mnt_name]
findmnt --types &lt;fstype&gt;            # 查看已挂载的文件系统
</code></pre>
<blockquote>
<p>如果挂载的目标路径下有数据，则数据会被隐藏；卸载磁盘后可恢复访问原有数据<sup class="footnote-reference"><a href="#mount">1</a></sup>。</p>
<p><a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/8/html/managing_file_systems/assembly_mounting-file-systems_managing-file-systems">Sharing a mount on multiple mount points</a></p>
</blockquote>
<p>挂载NTFS文件系统：</p>
<pre><code class="language-shell">yum install fuse ntfs-3g   # centos
mount -t ntfs-3g /dev/sdb1 /mnt/win
</code></pre>
<p>如果卸除设备时出现<strong>设备忙</strong>的错误，可<a href="Linux/Linux%E9%85%8D%E7%BD%AE%E5%92%8C%E7%AE%A1%E7%90%86.html#%E6%9F%A5%E7%9C%8B%E8%BF%9B%E7%A8%8B%E6%89%93%E5%BC%80%E8%B5%84%E6%BA%90">查看正在使用该设备的进程</a>有哪些并尝试关闭进程。</p>
<h5 id="挂载cd"><a class="header" href="#挂载cd">挂载CD</a></h5>
<pre><code class="language-shell">mount -t auto [-r] /dev/cdrom /mnt/cdrom # 挂载CD
</code></pre>
<h5 id="挂载可移动介质"><a class="header" href="#挂载可移动介质">挂载可移动介质</a></h5>
<p>挂载磁盘的目标文件夹必须存在，挂载的磁盘应该已经使用支持的文件系统<a href="Linux/Linux%E9%85%8D%E7%BD%AE%E5%92%8C%E7%AE%A1%E7%90%86.html#%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F%E5%8C%96">格式化</a>。可移动磁盘设备标识类似于内置磁盘（使用<code>fdisk -l</code>或<code>parted -l</code>查看）。</p>
<h5 id="自动挂载"><a class="header" href="#自动挂载">自动挂载</a></h5>
<ol>
<li>
<p>将挂载命令写入开机启动脚本；</p>
</li>
<li>
<p>配置<code>systemd.mount</code><a href="https://www.freedesktop.org/software/systemd/man/systemd.mount.html">单元文件</a>；</p>
<pre><code class="language-ini">[Mount]
What=/dev/sda
Where=/data
Type=ext4
Options=
</code></pre>
</li>
<li>
<p>使用<code>/etc/fstab</code>配置，<code>systemd</code>会将其中的内容转换为单元文件；</p>
<pre><code class="language-shell"># DevicePath    MountPoint  FS Type      Mount Options       Dump  CheckOrder
/dev/sdba         /data      ext4             -               0        1
LABEL=t-home2     /home      ext4    defaults,auto_da_alloc   0        2
SERVER:PATH
</code></pre>
</li>
</ol>
<h4 id="逻辑卷管理lvm"><a class="header" href="#逻辑卷管理lvm">逻辑卷管理LVM</a></h4>
<blockquote>
<p>Logical Volume Management, gives users the power to pool and abstract the physical layout of component storage devices, to gather existing storage devices into groups and allocate logical units from the combined space as needed.</p>
</blockquote>
<h5 id="lvm存储信息"><a class="header" href="#lvm存储信息">LVM存储信息</a></h5>
<p>显示系统中的LVM兼容卷，包括可转换为LVM物理卷（<em>Physical Volumns</em>）的存储设备：</p>
<pre><code class="language-sh">sudo lvmdiskscan \
     -l # 仅显示LVM物理卷, ==&gt; pvscan, pvs, pvdisplay
</code></pre>
<p>显示系统中的物理卷组（<em>Virtual Group</em>）信息：</p>
<pre><code class="language-sh">sudo vgscan  # =&gt; vgs, vgdisplay
</code></pre>
<p>显示系统中的逻辑卷（<em>Logical Volumn</em>）：（逻辑卷设备路径、<code>VG Name</code>、<code>PV</code>）</p>
<pre><code class="language-sh">sudo lvscan # lvs, lvdisplay [-m]
</code></pre>
<h5 id="管理lvm存储"><a class="header" href="#管理lvm存储">管理LVM存储</a></h5>
<p>从原始磁盘创建LVM物理卷，注意将磁盘上原有数据备份，加入LVM管理后将覆盖原有数据。</p>
<blockquote>
<p>A header is written to storage devices to mark them as free to use as LVM components. </p>
</blockquote>
<pre><code class="language-sh">sudo pvcreate /dev/sda /dev/sdb ...
pvresize /dev/sda1
pvresize --setphysicalvolumesize 40G /dev/sda1 # shrink
</code></pre>
<blockquote>
<p>如果物理磁盘分区通过<code>fdisk</code>进行了扩展，可以通过<code>pvresize</code>更新LVM物理卷的容量。<a href="https://www.techrepublic.com/blog/smb-technologist/extending-partitions-on-linux-vmware-virtual-machines/">也可以将空余磁盘空间创建为一个新的物理分区</a>，设置为LVM PV并加入LVM虚拟卷组。</p>
</blockquote>
<p>将物理卷创建为卷组，通常只需要一个卷组并在此之上创建虚拟卷。</p>
<pre><code class="language-sh">sudo vgcreate volume_group_name /dev/sda /dev/sdb ...
</code></pre>
<p>向卷组中增加物理卷：</p>
<pre><code class="language-sh">sudo vgextend volume_group_name /dev/sdb
</code></pre>
<p>创建虚拟卷，创建后需要对虚拟卷进行<a href="Linux/Linux%E9%85%8D%E7%BD%AE%E5%92%8C%E7%AE%A1%E7%90%86.html#%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F%E5%8C%96">格式化</a>。</p>
<pre><code class="language-sh">sudo lvcreate -L 10G -n VolumnName LVMVolGroup   # 绝对容量
sudo lvcreate -l 100%FREE -n VolumnName2 LVMVolGroup # 相对容量
</code></pre>
<blockquote>
<p>虚拟卷的底层物理磁盘分配方案支持线性（<code>linear</code>，默认）、<code>striped</code>（RAID 0）、<code>raid1</code>等。</p>
</blockquote>
<p>虚拟卷容量调整，使用<code>-L</code>选项增加/减少绝对容量，或用<code>-l</code>选项增加相对容量。</p>
<pre><code class="language-sh">sudo lvresize -L +5G --resizefs LVMVolGroup/vol_name
sudo lvresize -l +100%FREE --resizefs LVMVolGroup/vol_name
</code></pre>
<blockquote>
<p><em>XFS filesystem shrinking is unsupported.</em> <code>resize2fs</code> <em>is for ext filesystems.</em></p>
</blockquote>
<h4 id="raid"><a class="header" href="#raid">RAID</a></h4>
<h5 id="hardware-raid"><a class="header" href="#hardware-raid">Hardware RAID</a></h5>
<p>在BIOS中配置磁盘的RAID选项，参考产品用户手册。</p>
<h5 id="software-raid"><a class="header" href="#software-raid">Software RAID</a></h5>
<ol>
<li><a href="https://www.digitalocean.com/community/tutorials/how-to-use-lvm-to-manage-storage-devices-on-ubuntu-18-04">How To Use LVM To Manage Storage Devices on Ubuntu 18.04</a>.</li>
<li><a href="https://www.digitalocean.com/community/tutorials/how-to-create-raid-arrays-with-mdadm-on-ubuntu-18-04">How To Create RAID Arrays with mdadm on Ubuntu 18.04 | DigitalOcean</a>.</li>
</ol>
<h3 id="显示设备"><a class="header" href="#显示设备">显示设备</a></h3>
<p>查看显示设备：</p>
<pre><code class="language-sh">lspci | grep -i vga            # &lt;== install pciutils
sudo lshow [-short] -c CLASS   # list hardware, CLASS for class/description
sudo lspci -v -s 03:00.0
</code></pre>
<h5 id="安装nvidia显卡驱动"><a class="header" href="#安装nvidia显卡驱动">安装Nvidia显卡驱动</a></h5>
<pre><code class="language-shell">rl=$(uname -r)
yum install gcc gcc-c++ make kernel-devel-$rl kernel-headers-$rl
apt install gcc make linux-headers-$rl [libglvnd]
</code></pre>
<blockquote>
<p>注意内核开发包的版本需要于系统内核版本完全一致，否则无法成功安装驱动程序。</p>
</blockquote>
<p>检查<code>nouveau</code>模块是否加载，已加载则先禁用</p>
<pre><code class="language-shell">lsmod | grep nouveau
# edit: /usr/lib/modprobe.d/blacklist-nouveau.conf  # [Ubuntu]/etc/modprobe.d/*
blacklist nouveau
options nouveau modeset=0
dracut -force   # 重启系统，使内核模块配置生效 [Ubuntu]update-initramfs -u
</code></pre>
<p>安装驱动程序：</p>
<pre><code class="language-shell">./NVIDIA-Linux-x86_64-390.46.run --no-opengl-files --ui=none --no-questions --accept-license
# edit: /etc/rc.d/rc.local
nvidia-smi -pm 1   # GPU驱动模式设置为常驻内存
nvidia-smi         # nvidia proprietary driver =&gt; watch -n 1 nvidia-smi
</code></pre>
<h5 id="ubuntu桌面版显卡驱动"><a class="header" href="#ubuntu桌面版显卡驱动">Ubuntu桌面版显卡驱动</a></h5>
<pre><code class="language-shell">ubuntu-drivers devices             # 列出可用驱动
sudo ubuntu-drivers autoinstall    # 安装推荐驱动
sudo apt install nvidia-driver-440 # 安装指定名称驱动
</code></pre>
<p>安装完成后重启。</p>
<p><a href="https://linuxconfig.org/how-to-install-the-nvidia-drivers-on-ubuntu-20-04-focal-fossa-linux">How to install the NVIDIA drivers on Ubuntu 20.04 Focal Fossa Linux - Linux Tutorials - Learn Linux Configuration</a>。</p>
<h3 id="网络设备配置管理"><a class="header" href="#网络设备配置管理"><a href="Linux/Linux%E9%85%8D%E7%BD%AE%E5%92%8C%E7%AE%A1%E7%90%86.html#%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87%E9%93%BE%E8%B7%AF%E7%AE%A1%E7%90%86">网络设备配置管理</a></a></h3>
<h2 id="系统配置"><a class="header" href="#系统配置">系统配置</a></h2>
<h3 id="系统信息-2"><a class="header" href="#系统信息-2">系统信息</a></h3>
<h4 id="操作系统"><a class="header" href="#操作系统">操作系统</a></h4>
<pre><code class="language-shell">uname [options]
</code></pre>
<div class="table-wrapper"><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody>
<tr><td><code> -a, --all</code></td><td>包括以下系统信息：</td></tr>
<tr><td><code>-s, --kernel-name</code></td><td>内核名称（<code>Linux</code>）</td></tr>
<tr><td><code>-n, --nodename</code></td><td>网络主机名称（使用<code>hostnamectl</code>设置）</td></tr>
<tr><td><code>-r, --kernel-release</code></td><td>内核发行版本（<code>3.10.0-1160.24.1.el7.x86_64</code>）</td></tr>
<tr><td><code>-v, --kernel-version</code></td><td>内核版本（<code>#1 SMP Thu Apr 8 19:51:47 UTC 2021</code>）</td></tr>
<tr><td><code>-m, --machine</code></td><td>机器的硬件架构名称（<code>x86_64</code>）</td></tr>
<tr><td><code>-o, --operating-system</code></td><td>操作系统（<code>GNU/Linux</code>）</td></tr>
</tbody></table>
</div>
<blockquote>
<p><code>-i,--hardware-platform</code>和<code>-p, --processor</code>（不可移植），通常与<code>-m</code>输出一致。</p>
</blockquote>
<h5 id="系统版本信息"><a class="header" href="#系统版本信息">系统版本信息</a></h5>
<pre><code class="language-sh">cat /etc/issue          # [Ubuntu]
cat /etc/lsb-release    # [Ubuntu]
cat /etc/os-release     # [Ubuntu|CentOS]
lsb_release -crid       # 包含版本号详细信息，CentOS需要安装redhat-lsb-core 
rpm -qa centos-release  # [Fedora/CentOS]
rpm -qi basesystem      # [Fedora/CentOS](包含安装日期)
</code></pre>
<h5 id="操作系统安装时间"><a class="header" href="#操作系统安装时间">操作系统安装时间</a></h5>
<p>通过文件系统创建时间判断操作系统安装时间：</p>
<pre><code class="language-shell">tune2fs -l $(df / | awk '$6 ~ /\// {print $1}') | grep 'Filesystem created:'  # -&gt; dumpe2fs
rpm -qi setup|setuptool|basesystem    # [Fedora/CentOS]
</code></pre>
<blockquote>
<p><code>tune2fs</code>是设置ext2/ext3/ext4文件系统参数的工具。</p>
</blockquote>
<h4 id="主机名"><a class="header" href="#主机名">主机名</a></h4>
<pre><code class="language-shell">hostnamectl  # 显示主机信息（主机名、系统名、架构...）
hostnamectl set-hostname 'gfs.server.03.net' # 设置主机名
sysctl -n kernel.hostname
</code></pre>
<blockquote>
<p>某些服务（例如Cloudera）需要检测主机名与域名（FQDN）的一致性，为了避免产生警告，将主机名设置为域名。</p>
<p>WSL-Ubuntu中<code>hostnamectl</code>不可用。</p>
</blockquote>
<h4 id="域名映射"><a class="header" href="#域名映射">域名映射</a></h4>
<pre><code class="language-sh">sudo vi /etc/hosts
# change &lt;hosts&gt; file
192.168.137.11 new-host-name
</code></pre>
<p>可能需要重启。</p>
<h4 id="日期时间"><a class="header" href="#日期时间">日期时间</a></h4>
<p>显示时间</p>
<pre><code class="language-sh">date                           # Sun May 16 13:07:15 CST 2021
date +'%H'                     # %T %c %F
date -d,--date='7:00:00' +'%s' # parse a date and display it
date --date='@2147483647'      # parse a timestamp (seconds)
date -r,--reference=FILE       # 显示文件最近修改时间
</code></pre>
<blockquote>
<p>默认显示当前时间，使用<code>-d,--date</code>指定要显示的时间的字符串；字符串缺少的部分设为当前时间。空字符串表示当天开始时间。</p>
</blockquote>
<p><a href="https://www.cyberciti.biz/faq/unix-linux-bash-get-time/">A list of date command field descriptors</a></p>
<h5 id="获取日期字段"><a class="header" href="#获取日期字段">获取日期字段</a></h5>
<div class="table-wrapper"><table><thead><tr><th>格式声明</th><th>含义</th><th>格式声明</th><th>含义</th><th>格式声明</th><th>含义</th></tr></thead><tbody>
<tr><td><code>%Y</code></td><td><code>YYYY</code></td><td><code>%m</code></td><td><code>mm</code></td><td><code>%d</code></td><td><code>dd</code></td></tr>
<tr><td><code>%H</code></td><td><code>HH</code>(00-23)</td><td><code>%M</code></td><td><code>MM</code>(00-59)</td><td><code>%S</code></td><td><code>SS</code></td></tr>
<tr><td><code>%s</code></td><td>时间戳（秒）</td><td><code>%3N</code></td><td>毫秒</td><td><code>%N</code></td><td>纳秒</td></tr>
<tr><td></td><td></td><td><code>%f</code></td><td>微秒</td><td></td><td></td></tr>
</tbody></table>
</div>
<h5 id="格式化日期字段"><a class="header" href="#格式化日期字段">格式化日期字段</a></h5>
<p><code>%</code>后可额外设置表示填充的字符：<code>-</code>不填充；<code>_</code>填充空格；<code>0</code>填充0（默认）；<code>^</code>使用大写字母；<code>#</code>（尽可能）改变字符大小写。</p>
<div class="table-wrapper"><table><thead><tr><th>格式</th><th>含义</th><th>格式</th><th>含义</th><th>格式</th><th>含义</th></tr></thead><tbody>
<tr><td><code>%c</code></td><td>locale's datetime</td><td><code>%x</code></td><td>locale' date</td><td><code>%X</code></td><td>locale's time</td></tr>
<tr><td><code>%D</code></td><td><code>%m/%d/%y</code></td><td><code>%F</code></td><td><code>%Y-%m-%d</code></td><td></td><td></td></tr>
<tr><td><code>%T</code></td><td><code>%H:%M:%S</code></td><td><code>%r</code></td><td><code>12:11:04 PM</code></td><td><code>%X</code></td><td><code>23:13:48</code>(locale)</td></tr>
<tr><td><code>%y</code></td><td><code>yy</code></td><td></td><td></td><td><code>%e</code></td><td><code>%_d</code></td></tr>
<tr><td><code>%I</code></td><td><code>hh</code>(01-12)</td><td><code>%k</code></td><td><code>_H</code>(0-23)</td><td><code>%l</code></td><td><code>_h</code></td></tr>
<tr><td><code>%j</code></td><td><code>ddd</code>: day of year</td><td><code>%w</code></td><td>day of week(0-6)<br/> 0 is Sunday</td><td><code>%u</code></td><td>day of week(1-7)<br/>1 is Monday</td></tr>
<tr><td><code>%W</code></td><td>week of year(00-53),<br/>Monday first</td><td><code>%U</code></td><td>week of year(00-53),<br/>Sunday first</td><td><code>%V</code></td><td>week of year(01-53),  <br/>Monday first</td></tr>
<tr><td><code>%p</code></td><td><code>AM/PM</code></td><td><code>%P</code></td><td><code>am/pm</code></td><td><code>%q</code></td><td>quater <code>00-04</code></td></tr>
<tr><td><code>%z</code></td><td>时区<code>-0400</code></td><td><code>%:z</code></td><td><code>-04:00</code></td><td><code>%::z</code></td><td><code>-04:00:00</code></td></tr>
<tr><td><code>%Z</code></td><td>时区类型<code>EDT/CST</code></td><td></td><td></td><td></td><td></td></tr>
</tbody></table>
</div>
<p>设置时间：</p>
<pre><code class="language-sh">timedatectl [status]		# 显示系统的日期、时间和时区等信息
timedatectl set-time &quot;2012-10-30 18:17:16&quot;  # &lt;== timedatectl set-ntp no
date -u,--utc=MMDDhhmmCCYY.ss  # print or set datetime
date -s,--set=STRING
timedatectl set-timezone &lt;Asia/Shanghai&gt;
timedatectl list-timezones	# 列出已知时区
</code></pre>
<p>系统启动时间：</p>
<pre><code class="language-shell">uptime
</code></pre>
<h3 id="系统引导配置"><a class="header" href="#系统引导配置">系统引导配置</a></h3>
<p>引导配置文件：</p>
<pre><code class="language-sh">/etc/default/grub
/etc/grub/grub.cfg # auto-generated by grub-update
</code></pre>
<p>选择默认用户界面：</p>
<pre><code class="language-sh">sudo systemctl set-default multiuser.target # terminal shell
sudo systemctl set-default graphical.target # GUI
</code></pre>
<h4 id="添加开机启动项"><a class="header" href="#添加开机启动项">添加开机启动项</a></h4>
<ol>
<li>
<p>编辑<code>/etc/rc.local</code>脚本（兼容性目的），并设定可执行权限（<code>sudo chmod 755</code>）</p>
<blockquote>
<p>适合较短的命令</p>
</blockquote>
</li>
<li>
<p>将启动项的脚本添加到<code>/etc/init.d</code>目录下，并设置可执行权限</p>
<pre><code class="language-sh">ln -s task.sh /etc/init.d/task
sudo chmod +x /etc/init.d/task
</code></pre>
<pre><code class="language-shell">cd /etc/init.d
sudo update-rc.d task defaults 95  # execute order
sudo update-rc.d -f task remove  # remove the task
</code></pre>
<p>如果使用需要开机通过<code>chkconfig</code>设置开机启动的服务，则脚本开头应该包含以下信息：</p>
<pre><code class="language-shell">#！/bin/bash
# chkconfig: 2345 20 80
# description: Saves and restores system entropy pool \
# for higher quality random number generation.
</code></pre>
<p><code>chkconfig: 2345 20 80</code>表示这个服务在运行级别2345下运行，20表示开机启动优先权重，80表示关闭优先权重。</p>
<p>也可以手动调用<code>chkconfig</code>添加开机启动服务</p>
<pre><code class="language-shell">chkconfig --add my-service
</code></pre>
<p>实际上<code>chkconfig --add</code>命令是将<code>/etc/init.d</code>中的启动脚本软连接到<code>/etc/rc.d/rcx.d</code>（<code>rc0.d ... rc6.d</code>）0-6个运行级别对应相应的目录，都是位于<code>/etc/init.d</code>中脚本的软连接。</p>
<p><code>/etc/init.d/</code>中的脚本，可以通过命令： </p>
<pre><code>service service_name [start/stop]
</code></pre>
<p>启动或者关闭（添加到启动脚本中实现自启动，见方法1或）。</p>
</li>
<li>
<p>将启动任务的脚本放到目录<code>/etc/profile.d</code>下，系统启动后将自动执行其中的shell脚本。</p>
</li>
<li>
<p>注册为<a href="https://askubuntu.com/questions/814/how-to-run-scripts-on-start-up/719157#719157"><code>systemd</code></a>托管的服务，在系统启动时运行。</p>
</li>
</ol>
<h3 id="内核配置"><a class="header" href="#内核配置">内核配置</a></h3>
<p>内核配置项对应文件系统中<code>/proc/sys</code>目录。</p>
<p>读取内核配置项：配置项具有分级结构（对应上述目录树），名称以<code>.</code>或<code>/</code>分隔。</p>
<pre><code class="language-shell">sysctl -n variable          # 输出value, 默认输出 variable = value
sysctl -a -pattern PATTERN  # 打印所有配置项（某些配置项需要管理员权限才可访问）
</code></pre>
<blockquote>
<p><code>-n,--values</code>：仅打印配置项的值；<code>-N,--names</code>：仅打印配置项的名称；</p>
</blockquote>
<pre><code class="language-shell">sysctl -q,--quiet \        # 不将设置的值回显到屏幕
       -w variable=value ...
</code></pre>
<p>加载内核配置：</p>
<pre><code class="language-shell">sysctl -p,--load [FILE] # 默认加载/etc/sysctl.conf
sysctl --system         # 加载系统中所有配置文件
</code></pre>
<h4 id="文件系统-4"><a class="header" href="#文件系统-4">文件系统</a></h4>
<h5 id="最大打开文件数量限制"><a class="header" href="#最大打开文件数量限制">最大打开文件数量限制</a></h5>
<pre><code class="language-shell">ulimit -n 8192  # 默认1024, 临时修改
</code></pre>
<p>编辑<code>/etc/security/limits.conf</code>，永久修改：</p>
<pre><code class="language-shell"># domain type item   value
    *    soft nofile 16384  # soft limits of Number of Open file
    *    hard nofile 16384  # hard limits 
</code></pre>
<p><a href="https://stackoverflow.com/questions/49632581/fix-with-ulimit-n-8192">linux - Fix with ulimit -n 8192 - Stack Overflow</a></p>
<h5 id="inotify文件监控数量限制"><a class="header" href="#inotify文件监控数量限制"><code>inotify</code>文件监控数量限制</a></h5>
<p>文件监控数量限制如果设置太小，容易触发<code>inotify watch limit reached</code>错误。临时设置运行时参数：</p>
<pre><code class="language-shell">sudo sysctl fs.inotify.max_user_watches=524288  # 8192 default
</code></pre>
<p>永久修改配置（<code>/etc/sysctl.conf</code>）并运行<code>sysctl -p</code>重新加载。</p>
<pre><code class="language-shell">fs.inotify.max_user_watches=524288
</code></pre>
<h3 id="字体"><a class="header" href="#字体">字体</a></h3>
<p>用户可将字体安装在<code>/usr/share/fonts</code>目录下，使用<code>fc-list</code>（需要安装<code>fontconfig</code>）可查看系统中可用字体。</p>
<pre><code class="language-shell">fc-list                                    # &quot;FONT_PATH: FONT_FAMILY:style=STYLE&quot;
fc-list : family                           # 仅输出字体名
fc-list :lang=zh family style file spacing # &quot;PATH: FAMILY:style=STYLE:spacing=SPACE&quot;
</code></pre>
<h3 id="日志-4"><a class="header" href="#日志-4">日志</a></h3>
<p>大部分的发行版都内置使用<code>syslog</code>系统日志，常见的日志一般存放在 <code>/var/log</code> 中。 </p>
<h5 id="常见的系统日志"><a class="header" href="#常见的系统日志">常见的系统日志</a></h5>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">日志名称</th><th style="text-align: left">记录信息</th></tr></thead><tbody>
<tr><td style="text-align: center"><code>alternatives.log</code></td><td style="text-align: left">系统的一些更新替代信息记录</td></tr>
<tr><td style="text-align: center"><code>apport.log</code></td><td style="text-align: left">应用程序崩溃信息记录</td></tr>
<tr><td style="text-align: center"><code>apt/history.log</code></td><td style="text-align: left">使用<code>apt</code>安装卸载软件的信息记录</td></tr>
<tr><td style="text-align: center"><code>apt/term.log</code></td><td style="text-align: left">使用<code>apt</code>时的具体操作，如package的下载、打开等</td></tr>
<tr><td style="text-align: center"><code>auth.log</code></td><td style="text-align: left">登录认证的信息记录</td></tr>
<tr><td style="text-align: center"><code>boot.log</code></td><td style="text-align: left">系统启动时的程序服务的日志信息</td></tr>
<tr><td style="text-align: center"><code>Consolekit/history</code></td><td style="text-align: left">控制台的信息记录</td></tr>
<tr><td style="text-align: center"><code>dist-upgrade</code></td><td style="text-align: left"><code>dist-upgrade</code> 这种更新方式的信息记录</td></tr>
<tr><td style="text-align: center"><code>dmesg</code></td><td style="text-align: left">启动时，显示屏幕上内核缓冲信息,与硬件有关的信息</td></tr>
<tr><td style="text-align: center"><code>dpkg.log</code></td><td style="text-align: left"><code>dpkg</code> 命令管理包的日志</td></tr>
<tr><td style="text-align: center"><code>faillog</code></td><td style="text-align: left">用户登录失败详细信息记录</td></tr>
<tr><td style="text-align: center"><code>fontconfig.log</code></td><td style="text-align: left">与字体配置有关的信息记录</td></tr>
<tr><td style="text-align: center"><code>kern.log</code></td><td style="text-align: left">内核产生的信息记录，在自己修改内核时有很大帮助</td></tr>
<tr><td style="text-align: center"><code>lastlog</code></td><td style="text-align: left">用户的最近一次信息记录。</td></tr>
<tr><td style="text-align: center"><code>wtmp</code></td><td style="text-align: left">登录信息的记录。</td></tr>
<tr><td style="text-align: center"><code>btmp</code></td><td style="text-align: left">远程登录信息记录。</td></tr>
<tr><td style="text-align: center"><code>syslog</code></td><td style="text-align: left">系统信息记录</td></tr>
</tbody></table>
</div>
<p>日志一般都是文本文件，可使用 <code>less</code>、<code>cat</code>、<code>more</code> 等工具查看。 <code>wtmp</code>、<code>lastlog </code>是二进制文件，需要使用<code>last</code>和<code>lastlog</code>工具来提取其中的信息。</p>
<h4 id="rsyslog"><a class="header" href="#rsyslog">rsyslog</a></h4>
<h4 id="systemd-journal"><a class="header" href="#systemd-journal">systemd-journal</a></h4>
<h5 id="查看日志"><a class="header" href="#查看日志">查看日志</a></h5>
<p>筛选日志：</p>
<pre><code class="language-shell">journalctl --system|user          # 查看系统/当前用户日志
journalctl -u,--unit=UNIT
           -t,--identifier=STRING # 查看指定syslog标识的日志
           -S,--since=DATE        # '2022-05-01 [12:00:00]'
           -U,--until=DATE
</code></pre>
<p>追踪日志更新：</p>
<pre><code class="language-shell">journalctl -f,--follow
           -n,--lines=NUM         # 显示日志数量
</code></pre>
<h5 id="日志存储设置"><a class="header" href="#日志存储设置">日志存储设置</a></h5>
<pre><code class="language-shell">journalctl --disk-usage
journalctl --rotate
journalctl --vacuum-time=2d   # 清理超过2天的日志
journalctl --vacuum-size=100M # 清理超过100M的日志
journalctl --vacuum-files=5   # 清理超过数量的日志
systemctl kill --kill-who=main --signal=SIGUSR2 systemd-journald.service
rm -rf /run/log/journal/* 
rm -rf /var/log/journal/* 
systemctl restart systemd-journald.service
journalctl --verify
</code></pre>
<h4 id="终端命令记录"><a class="header" href="#终端命令记录">终端命令记录</a></h4>
<pre><code class="language-sh">histroy   # 显示历史记录： cat ~/.bash_history
history -c  # 删除历史记录：rm ~/.bash_history
</code></pre>
<h4 id="用户登录信息"><a class="header" href="#用户登录信息">用户登录信息</a></h4>
<pre><code class="language-sh">who /var/log/wtmp  	# 查看用户登录历史记录
last [username] [-f /var/log/btmp] # 默认读取/var/log/wtmp
lastlog [-u username] [-t 5] [-b 60]
</code></pre>
<h4 id="浏览器桌面环境"><a class="header" href="#浏览器桌面环境">浏览器（桌面环境）</a></h4>
<pre><code class="language-sh">ls -l ~/.opera/cach4
ls -l ~/.mozilla/firefox/*.default/cache
</code></pre>
<h4 id="日志清理"><a class="header" href="#日志清理">日志清理</a></h4>
<p><code>logrotate</code>是Linux自带的文本日志处理工具，可进行切割、打包、压缩等处理。其配置文件位于<code>/etc/logrotate.conf</code>以及<code>/etc/logrotate.d/</code>。</p>
<pre><code class="language-shell">/tmp/dask/*log {
  rotate 7       # 指定日志文件删除之前转储的次数,0直接删除,-1不删除
  daily          # 指定转储周期:hourly,daily,weekly,monthly, yearly
  minsize 1M     # 文件大于1M时才会进行轮转
  maxsize 100M   # 文件大于100M时强制进行轮转(即使还未到轮换周期)
  size    100M   # 指定轮转大小: k/M/G (与轮转周期互斥)
  minage  10     # 文件创建超过10天才进行轮转
  maxage  100    # 移除创建超过100天的已轮转的文件
  missingok      # 忽略不存在的日志文件/nomissingok
  ifempty        # 即使日志文件为空文件也做轮转/noifempty
  dateext        # 使用当期日期作为命名格式,默认值取决于轮换周期
  dateformat -%Y%m%d%H # 
  nocompress     # 
  create [[mode] owner group] # 新日志文件的权限, 默认和原来的文件相同的权限
  copytruncate   # 复制并清空日志文件(override create)*
  prerotate
  	script	
  endscript
  postrotate     # postrotate脚本 
    /sbin/nginx -s reload  
  endscript  # postrotate脚本结束
}
</code></pre>
<blockquote>
<p><code>*</code>：适用于日志输出程序无法获取日志文件打开状态的情况；但可能造成少量日志丢失。</p>
</blockquote>
<p><code>logrotate</code>通过<code>ctrontab</code>调度，默认每天运行一次（除非任务指定更小的周期）。可手动立即执行：</p>
<pre><code class="language-shell">logrotate -s /var/lib/logrotate/logrotate.status /etc/logrotate.conf
</code></pre>
<h2 id="软件管理"><a class="header" href="#软件管理">软件管理</a></h2>
<p>各发行版提供的<a href="Linux/Linux%E9%85%8D%E7%BD%AE%E5%92%8C%E7%AE%A1%E7%90%86.html#Linux%E5%8F%91%E8%A1%8C%E7%89%88.md">软件仓库与软件管理方案</a>。本章介绍，当前主要的跨发行版软件管理解决方案。</p>
<h3 id="snap"><a class="header" href="#snap">Snap</a></h3>
<p>Snap将软件及其依赖打包到独立环境，它的运行环境是容器化的沙箱，从而避免各发行版兼容性问题并保证一定的安全性。</p>
<p><img src="Linux/Linux%E9%85%8D%E7%BD%AE%E5%92%8C%E7%AE%A1%E7%90%86.assets/image-20210731135944209.png" alt="image-20210731135944209" /></p>
<h4 id="安装snap"><a class="header" href="#安装snap">安装snap</a></h4>
<p>Ubuntu/Debian系统预装<code>snapd</code>，使用<code>snap version</code>查看。</p>
<pre><code class="language-shell">sudo yum install snapd  # [epel-release]
sudo systemctl enable snapd # 安装后需要手动启动
</code></pre>
<blockquote>
<p><code>snapd</code>无需持续在后台运行，仅在执行<code>snap</code>命令时被调用运行。</p>
</blockquote>
<h4 id="安装和升级snap软件"><a class="header" href="#安装和升级snap软件">安装和升级snap软件</a></h4>
<pre><code class="language-shell">snap find &quot;media player&quot;
sudo snapd install 'appname'
sudo snap refresh 'appname'    # update
snap list  # 列出已安装的软件的简要信息
snap info 'pkgname'| 'pkgname.snap'  # 查看[已安装]软件包信息
          --color=auto|always|never
          --verbose
</code></pre>
<p>安装<code>classic</code>类型的软件，此类软件不受沙盒限制：</p>
<pre><code class="language-shell">sudo ln -s /var/lib/snapd/snap /snap
sudo snap install julia --classic
</code></pre>
<p>下载<code>snap</code>包和离线安装：</p>
<pre><code class="language-shell">snap donwload 'package name'
              --target-directory=.
              --channel=5.x/stable
snap ack path/to/package_name.assert  
snap install path/to/package_name.snap
             --dangerous  # 如果没有执行ack,则需要该选项才可以安装
</code></pre>
<h5 id="snap安装目录"><a class="header" href="#snap安装目录">snap安装目录</a></h5>
<pre><code class="language-shell">/snap               # -&gt; Debian based
#/snap/bin                   - Symlinks to snap applications.
#/snap/&lt;snapname&gt;/&lt;revision&gt; - Mountpoint for snap content.
#/snap/&lt;snapname&gt;/current    - Symlink to current revision, if enabled.
/var/lib/snapd/snap # -&gt; RHEL based
</code></pre>
<h5 id="snapying用的配置文件数据目录"><a class="header" href="#snapying用的配置文件数据目录">snapying用的配置文件/数据目录</a></h5>
<pre><code class="language-shell">/var/snap/&quot;snap_name&quot;
</code></pre>
<h5 id="移除snap软件"><a class="header" href="#移除snap软件">移除snap软件</a></h5>
<pre><code class="language-shell">snap remove &quot;snap_name&quot;  
     --purge  # 不保存软件的数据
</code></pre>
<p>软件的所有数据将自动备份（<em>automatic snapshopt</em>）以便后续恢复。</p>
<h4 id="备份和恢复"><a class="header" href="#备份和恢复">备份和恢复</a></h4>
<pre><code class="language-shell">snap save 'appname' --users &quot;all&quot;  # 创建用户、系统和配置数据的快照。
snap saved --id ID
snap forget &quot;id&quot; &quot;appname&quot;
snap restore &quot;id&quot; &quot;snap_name&quot; --users &quot;all&quot;  # 使用指定快照恢复其中的用户、系统和配置数据。
snap export-snapshot &quot;id&quot; /path/to/export
snap import-snapshot /path/to/import
</code></pre>
<blockquote>
<p>不同版本（<code>epoch</code>）之间不能恢复数据。</p>
</blockquote>
<p>回退到上个版本并恢复数据(不包括共享数据)：</p>
<pre><code class="language-shell">sudo snap revert 'appname' --revision ID 
</code></pre>
<h4 id="snap配置"><a class="header" href="#snap配置">snap配置</a></h4>
<pre><code class="language-shell">snap get &quot;appname&quot;
snap set &quot;appname&quot; key1=value1 key2.subkey=value2
snap unset &quot;appname&quot; key1 key2
</code></pre>
<h4 id="管理snap应用的运行状态"><a class="header" href="#管理snap应用的运行状态">管理snap应用的运行状态</a></h4>
<p>查看服务运行状态和日志：</p>
<pre><code class="language-shell">snap services &lt;appaname&gt;  # 查看APP提供的服务的运行状态
# =&gt; systemctl status snap.&lt;appname&gt;.&lt;appserivce&gt;
snap logs -f &lt;appname&gt;.&lt;servicename&gt; 
</code></pre>
<h5 id="启动应用软件"><a class="header" href="#启动应用软件">启动应用软件</a></h5>
<p>如果安装未生成启动软件的快捷方式，可通过命令启动。</p>
<pre><code class="language-shell">snap run &lt;appcommand&gt;   # 命令可通过snap info查看
</code></pre>
<h5 id="管理软件服务"><a class="header" href="#管理软件服务">管理软件服务</a></h5>
<p>可使用<code>snap</code>或<code>systemctl</code>来控制服务运行。<code>snap</code>服务默认会在失效后自动重启。</p>
<pre><code class="language-shell">sudo snap start/restart/stop &lt;appname&gt;
sudo snap restart &lt;appname&gt;.&lt;servicename&gt;
sudo systemctl restart snap.&lt;appname&gt;.&lt;servicename&gt;
</code></pre>
<h3 id="appimage"><a class="header" href="#appimage">AppImage</a></h3>
<p>AppImage比较简单易用，不需要安装额外的工具，整个软件都在一个文件里，下载后可以直接运行。里面有个SquashFS的文件系统，运行的时候会挂在到一个临时的地方，里面有所有只读的文件，包括可执行文件、库文件、静态数据等。除此之外都和普通的软件运行环境是一样的。</p>
<p><a href="https://github.com/AppImage/AppImageKit/wiki/Similar-projects#comparison">Similar projects · AppImage/AppImageKit Wiki (github.com)</a></p>
<h3 id="flatpak"><a class="header" href="#flatpak">Flatpak</a></h3>
<h3 id="linuxbrew"><a class="header" href="#linuxbrew">linuxbrew</a></h3>
<p>安装发行版软件仓库缺失的软件。</p>
<h4 id="安装linuxbrew"><a class="header" href="#安装linuxbrew">安装linuxbrew</a></h4>
<pre><code class="language-shell">SRC_URL='https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh'
/bin/bash -c &quot;$(curl -fsSL $SRC_URL)&quot;
</code></pre>
<p>官方安装脚本下载以及官方源(github)的速度都比较慢，推荐<a href="Linux/Linux%E9%85%8D%E7%BD%AE%E5%92%8C%E7%AE%A1%E7%90%86.html#%E6%9C%AC%E5%9C%B0%E7%BD%91%E7%BB%9C%E4%BB%A3%E7%90%86">使用代理</a>进行安装。或者<a href="https://mirrors.tuna.tsinghua.edu.cn/help/homebrew/">使用国内镜像进行安装和后续软件安装</a>，配置镜像源相关环境变量：</p>
<pre><code class="language-shell">MIRROR=&quot;https://mirrors.tuna.tsinghua.edu.cn&quot;
export HOMEBREW_BREW_GIT_REMOTE=&quot;$MIRROR/git/homebrew/brew.git&quot;
export HOMEBREW_CORE_GIT_REMOTE=&quot;$MIRROR/git/homebrew/homebrew-core.git&quot;
export HOMEBREW_BOTTLE_DOMAIN=&quot;$MIRROR/homebrew-bottles&quot;
</code></pre>
<p>执行以下命令下载安装脚本并执行安装：</p>
<pre><code class="language-shell">git clone --depth=1 $MIRROR/git/homebrew/install.git brew-install
bash brew-install/install.sh
rm -rf brew-install
</code></pre>
<p>安装完成后根据输出提示，将初始化命令加入shell配置文件。然后，根据输出信息，安装建议的编译环境，用于<code>brew</code>进行本地编译打包。</p>
<blockquote>
<p><code>brew</code>的默认安装位置为<code>/home/linuxbrew/.linuxbrew/</code>。</p>
</blockquote>
<h4 id="安装软件"><a class="header" href="#安装软件">安装软件</a></h4>
<pre><code class="language-shell">brew install pkgname
</code></pre>
<p>查找软件可在<a href="https://brew.sh/">brew.sh</a>查找，或通过命令查找：</p>
<pre><code class="language-shell">brew search pkgname
</code></pre>
<h2 id="进程管理-1"><a class="header" href="#进程管理-1">进程管理</a></h2>
<h3 id="查看进程"><a class="header" href="#查看进程">查看进程</a></h3>
<pre><code class="language-shell">jobs [-lnprs] [jobspec ...] or jobs -x command [args]
#    Display status of jobs.
</code></pre>
<h4 id="查看并过滤进程"><a class="header" href="#查看并过滤进程">查看并过滤进程</a></h4>
<pre><code class="language-shell">ps -e|-A  \  # 查看所有进程
   -T|t   \  # 当前终端上的所有进程
   -x     \  # 没有关联控制终端（tty）的进程
   -r     \  # 正在运行的进程 
   -a     \  # 排除关联tty的所有进程或session leader   
   -d     \  # 除了session leader外的所有进程
   -N     \  # --deselect 反选
   H         # 将线程视作进程显示
</code></pre>
<h5 id="查找进程"><a class="header" href="#查找进程">查找进程</a></h5>
<pre><code class="language-shell">ps -C cmd1,cmd2,... \  # 根据命令名comm筛选
   -p 123,124,... \    # --pid,-q 根据进程号筛选
   -ppid 10       \    # 根据父进程号筛选
   -U EUID        \    # effective user ID (EUID) or name
   -u RUID        \    # real user ID (RUID) or name
</code></pre>
<blockquote>
<p><code>-C</code>匹配进程命令起始子串，不包括路径与特殊字符'<code>/-</code>'；无法匹配到僵尸进程。</p>
</blockquote>
<pre><code class="language-shell">pgrep -f PATTERN  \   # --full 匹配完整进程名
      -x          \   # --exact 完整匹配命令行
      -v          \   # --inverse 反向匹配
      -g PGID,... \   # --pgroup 匹配进程组ID
      -G GID,...  \   # --group 匹配real group IDs
      -i          \   # --ignore-case
      -n          \   # --newest 选择最近启动的进程
      -o          \   # --oldest
      -P PPID,... \   # --parent 匹配父进程ID
      -s SID,...  \   # --sessioin 匹配会话ID
      -u ID,...   \   # --euid 匹配effective user ID
      -U ID,...   \   # --uid 匹配real user ID
      -t TTY,...  \   # --terminal 匹配终端
      --ns PID --nslist ns,...
pgrep -l  \  # --list-name 列出PID和进程名
      -a  \  # --list-full 列出PID和命令行
      -c  \  # --count 输出匹配计数
</code></pre>
<p><code>ps -C</code>和<code>pgrep</code>无法匹配到僵尸进程<code>&lt;defunct&gt;</code>，可以利用<code>ps -ef</code>的输出内容进行匹配。</p>
<pre><code class="language-sh">ps -ef | grep defunct | grep -v grep
</code></pre>
<h5 id="输出进程信息"><a class="header" href="#输出进程信息">输出进程信息</a></h5>
<pre><code class="language-shell">ps -f|-F \  # 完全信息，包括命令行（-F包括附加信息）
   -l    \  # 显示更多信息，可以与-f|-F组合使用
ps -o pid,tid,... \ # 指定输出的字段
   -o '%cpu %mem' \ # 在单个参数中指定输出的字段
   -o class       \ # 可指定多个输出选项
   -o wchan:14    \ # 指定输出字段的位宽
   -o comm=       \ # 该字段不输出字段名(当所有字段都不输出字段名，省略表头)
</code></pre>
<div class="table-wrapper"><table><thead><tr><th></th><th></th><th></th><th></th></tr></thead><tbody>
<tr><td><code>pid</code></td><td>==进程编号==</td><td><code>ppid</code></td><td>父进程编号</td></tr>
<tr><td>`lwp</td><td>spid</td><td>tid`</td><td>轻量线程ID</td></tr>
<tr><td>`pgid</td><td>prp`</td><td>进程组编号</td><td><code>tgid</code></td></tr>
<tr><td>`%cpu</td><td>pcpu`</td><td>CPU占用率（小数）</td><td><code>c</code></td></tr>
<tr><td>`cputime</td><td>time`</td><td>==累计CPU占用时长==</td><td><code>pri</code></td></tr>
<tr><td><code>start_time</code></td><td>==进程启动时间/日期==</td><td><code>start</code></td><td>进程启动时间</td></tr>
<tr><td><code>etime</code></td><td>==进程启动后经过的时间==</td><td><code>etimes</code></td><td>单位为秒</td></tr>
<tr><td>`%mem</td><td>pmem`</td><td>内存占用比例</td><td>`vsz</td></tr>
<tr><td><code>sz</code></td><td>进程镜像大小</td><td><code>size</code></td><td>需要的交换空间大小</td></tr>
<tr><td>`args</td><td>cmd</td><td>command`</td><td>命令行参数</td></tr>
<tr><td>`sess</td><td>session</td><td>sid`</td><td>会话编号</td></tr>
<tr><td>`tty</td><td>tt</td><td>tname`</td><td>控制终端</td></tr>
<tr><td>`fgid</td><td>fsgid`</td><td>文件访问组编号</td><td>`fgroup</td></tr>
<tr><td>`state</td><td>s`</td><td></td><td><code>stat</code></td></tr>
</tbody></table>
</div>
<p>进程关联<a href="Linux/">用户信息</a>：</p>
<div class="table-wrapper"><table><thead><tr><th></th><th></th><th>real</th><th>effective</th><th>saved</th></tr></thead><tbody>
<tr><td>用户ID</td><td><code>uid</code></td><td><code>ruid</code></td><td>`euid</td><td>uid`</td></tr>
<tr><td>用户标识</td><td><code>user</code></td><td><code>ruser</code></td><td>`euser</td><td>user</td></tr>
<tr><td>组</td><td><code>gid</code></td><td><code>rgid</code></td><td>`egid</td><td>gid`</td></tr>
<tr><td>组标识</td><td><code>group</code></td><td><code>rgroup</code></td><td>`group</td><td>egroup`</td></tr>
</tbody></table>
</div>
<blockquote>
<p>需要systemd支持的字段：</p>
<ul>
<li><code>machine</code>：进程分配到的VM或容器名；</li>
<li><code>ouid</code>：进程会话所有者；</li>
<li><code>lsession</code>：进程的登录会话标识；</li>
</ul>
<p>其他：</p>
<p><code>psr</code>：为进程分配的处理器，<code>sgi_p</code>：进程当前运行的处理器；</p>
<p><code>cgroup</code>：控制组；</p>
<p><code>class|cls|policy</code>：进程调度类型；<code>sched</code>；</p>
<p><code>blocked|sig_block|sigmask</code>：阻止的信号（32或64位掩码）；
<code>caught|sig_catch|sigcatch</code>：捕获的信号（32或64位掩码）；
<code>ignored|sig_ignore, sigignore</code>：忽略的信号（32或64位掩码）；
<code>pending|sig</code>：挂起的信号（32或64位掩码）；</p>
<p><code>f|flag|flags</code>：进程标识。</p>
</blockquote>
<h5 id="进程树"><a class="header" href="#进程树">进程树</a></h5>
<pre><code class="language-shell">ps  f  \  # 显示为进程树
   -H  \  # 显示进程层级（缩进）
</code></pre>
<pre><code class="language-sh">pstree -U     \  # --unicode 使用UTF-8画线符号（默认）表示树
       -A     \  # --ascii 使用ASCII画线符号
       -h     \  # --highlight-all 重点显示当前进程及其祖先进程
       -H PID \  # --highlight-pid 重点显示给定进程及其祖先进程
       -g     \  # --show-pgids 显示进程组标识
       -p     \  # --show-pids 显示进程标识
       -s     \  # --show-parents 显示父进程标识
       -n     \  # --numeric-sort 根据PID对输出排序
       -l     \  # --long 不截断长行
       PID    \  # 进程树根节点的PID，默认为1（init/systemd）
       USER   \  # 显示指定用户的进程树
</code></pre>
<h4 id="任务状态"><a class="header" href="#任务状态">任务状态</a></h4>
<pre><code class="language-sh">top -b -n N \       # 非交互模式，刷新N次
    -o FIELD[-+] \  # 按字段排序：&quot;+&quot;=&gt;DESC; &quot;-&quot;=&gt;ASC
    -O              # 不执行命令，仅输出可用的排序字段
</code></pre>
<blockquote>
<p><code>top</code>命令显示的是你的程序占用的cpu的总数，也就是说如果你是4核cpu那么cpu最高占用率可达400%，<code>top</code>里显示的是把所有使用率加起来。</p>
<p>在<code>top</code>的运行环境中按下键盘的<code>1</code>，显示每个cpu核的状态。</p>
</blockquote>
<h5 id="交互环境命令"><a class="header" href="#交互环境命令">交互环境命令</a></h5>
<p>排序：<code>M-&gt;Mem, N-&gt;PID, P-&gt;%cpu, T-&gt;TIME+</code>。</p>
<h5 id="watch"><a class="header" href="#watch">watch</a></h5>
<pre><code class="language-shell">watch &quot;ps -ef | grep nginx | grep -v grep&quot; \
      -d,--difference        \ # 高亮两次更新的差别
      -n,--interval seconds  \ # 更新周期
</code></pre>
<p><code>watch</code>的命令参数可包含多条命令，输出结果包含每条命令的输出内容。</p>
<h4 id="查看进程打开资源"><a class="header" href="#查看进程打开资源">查看进程打开资源</a></h4>
<p>打开的文件可能是常规文件、文件夹、库、流、<a href="Linux/Linux%E9%85%8D%E7%BD%AE%E5%92%8C%E7%AE%A1%E7%90%86.html#%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E7%8A%B6%E6%80%81%E4%BF%A1%E6%81%AF">网络文件（套接字、NFS文件）</a>等。</p>
<pre><code class="language-shell">lsof   # list open files
lsof /bin/bash
#COMMAND      PID  USER  FD   TYPE DEVICE SIZE/OFF      NODE NAME
#mysqld_sa   1597 mysql txt    REG  253,0   960472 738200678 /usr/bin/bash
#sh         11503    es txt    REG  253,0   960472 738200678 /usr/bin/bash
#bash       16538  yarn txt    REG  253,0   960472 738200678 /usr/bin/bash
#bash       63028  yarn txt    REG  253,0   960472 738200678 /usr/bin/bash
</code></pre>
<blockquote>
<p>需要安装<code>lsof</code>。</p>
</blockquote>
<pre><code class="language-shell">fuser [options] file/fs  # identify processes using files or sockets
fuser /bin/bash  # 返回使用文件的进程号与使用方式（后缀）
# /usr/bin/bash:        1597e 11503e 13039e 63028e 63030e 64836e
</code></pre>
<h3 id="进程控制-1"><a class="header" href="#进程控制-1">进程控制</a></h3>
<h4 id="创建进程-3"><a class="header" href="#创建进程-3">创建进程</a></h4>
<p><code>nohup &amp;</code></p>
<h4 id="终止进程"><a class="header" href="#终止进程">终止进程</a></h4>
<p>如果父进程在子进程之后终止，但子进程终止时父进程没有进行最后的回收工作，子进程残留的数据结构称为僵尸进程。</p>
<h5 id="终止单个进程"><a class="header" href="#终止单个进程">终止单个进程</a></h5>
<p><code>kill</code>向进程发送信号使进程终止，默认信号是<code>-TERM</code>。</p>
<pre><code class="language-sh">kill [-s sigspec | -n signum | -sigspec] pid ...
kill -l [sigspec]
</code></pre>
<p><code>sigspec</code>表示信号名，<code>signum</code>表示信号值。</p>
<div class="table-wrapper"><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody>
<tr><td><code>-l, --list [sigspec]</code></td><td><strong>列出可发送的信号</strong>，如果给出信号名（值），<br />则将信号名（值）转换为信号值（名）</td></tr>
<tr><td><code>-s sigspec</code> <br /><code>-n signum</code>   <br /><code>-sigspec</code></td><td>指定发送的信号，例如：<code>-ABRT,-ALRM,-HUP,-KILL,-STOP,-SEGV, -TERM,-TRAP</code>。</td></tr>
</tbody></table>
</div>
<h5 id="终止匹配名称的进程"><a class="header" href="#终止匹配名称的进程">终止匹配名称的进程</a></h5>
<pre><code class="language-sh">killall [-s sigspec | -sigspec] [-e] [-I] [-g] [-i] [-u user] [-v] [-w] name ...
killall –l
</code></pre>
<p>选项</p>
<div class="table-wrapper"><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody>
<tr><td><code>-l, --list</code></td><td>列出可发送的信号</td></tr>
<tr><td><code>-s,--signal sigspec</code> <br/><code> -sigspec</code></td><td>指定发送的信号</td></tr>
<tr><td><code>-e, --exact</code></td><td>匹配名称</td></tr>
<tr><td><code>-I, --ignore--case</code></td><td>匹配名称时忽略大小写</td></tr>
<tr><td><code>-g, --process-group</code></td><td>向进程所属的进程组发送信号</td></tr>
<tr><td><code>-i, --interactive</code></td><td>在杀死进程前交互式确认</td></tr>
<tr><td><code>-q, --quiet</code></td><td>如果没有进程被杀死，不输出信息</td></tr>
<tr><td><code>-u, --user</code></td><td>仅杀死属于给定用户的进程</td></tr>
<tr><td><code>-v, --verbose</code></td><td>报告信号是否成功发送</td></tr>
<tr><td><code>-w, --wait</code></td><td>等待所有被杀死的进程结束</td></tr>
</tbody></table>
</div>
<h5 id="终止匹配的进程"><a class="header" href="#终止匹配的进程">终止匹配的进程</a></h5>
<pre><code class="language-shell">pkill [options] --signal SIGNAL PATTERN
</code></pre>
<h5 id="终止图形进程"><a class="header" href="#终止图形进程">终止图形进程</a></h5>
<pre><code class="language-sh">xkill
</code></pre>
<p>出现“<code>x</code>”标志的鼠标，点击需要中止的程序即可。</p>
<h4 id="清理进程"><a class="header" href="#清理进程">清理进程</a></h4>
<pre><code class="language-shell">wait -f -n [CH_PID,,,]  # 清理子进程
</code></pre>
<h3 id="服务"><a class="header" href="#服务">服务</a></h3>
<h4 id="systemd"><a class="header" href="#systemd">systemd</a></h4>
<p><code>systemd</code>（<em><strong>system and service manager</strong></em>），init system (<code>PID=1</code><sup class="footnote-reference"><a href="#pid1">2</a></sup>, started by the kernel, to bring up userspace) managing userspace services. (<em>fast and efficient boot-up</em>)</p>
<blockquote>
<p><code>sysvinit</code></p>
</blockquote>
<pre><code class="language-shell">/sbin/init -&gt; ../lib/systemd/systemd
</code></pre>
<p>system instance: system.conf and the files in system.conf.d</p>
<p>user instance:  user.conf and the files in user.conf.d</p>
<p>&quot;units&quot; of 11 different types. states: <code>active/inactive/activating/decativating/failed</code>；</p>
<p>Units are named as their configuration files</p>
<p>Processes systemd spawns are placed in individual Linux control groups named after the unit which they belong to in the private systemd hierarchy. <code>/sys/fs/cgroup/systemd/</code></p>
<p>transaction system: before executing a requested operation, systemd will verify that it makes sense, fixing it if possible, and only failing if it really cannot work.</p>
<ul>
<li>
<p>Service：管理控制守护进程及其相关进程；</p>
</li>
<li>
<p><a href="https://man7.org/linux/man-pages/man5/systemd.socket.5.html">Socket</a>：用于提前创建套接字资源。</p>
</li>
<li>
<p><a href="https://man7.org/linux/man-pages/man5/systemd.target.5.html">Target</a>：group units（使用<code>Requires,After</code>）。</p>
<p>default.target whose  job is to activate on-boot services and other on-boot units by pulling them in via dependencies.<code> graphical.target</code>/<code>multi-user.target</code></p>
</li>
<li>
<p>Device：expose kernel devices</p>
</li>
<li>
<p><a href="https://man7.org/linux/man-pages/man5/systemd.mount.5.html">Mount</a>/Swap：mount points/memory swap（类似于<code>mount</code>命令）</p>
</li>
<li>
<p>Automount</p>
</li>
<li>
<p>Timer：定时触发其他单元；</p>
</li>
<li>
<p><a href="https://man7.org/linux/man-pages/man5/systemd.path.5.html">Path</a>：</p>
</li>
<li>
<p><a href="https://man7.org/linux/man-pages/man5/systemd.slice.5.html">Slice</a>：分组资源管理；</p>
</li>
<li>
<p>Scope：管理外部进程</p>
</li>
</ul>
<p>信号处理：</p>
<p><code>SIGTERM</code>：重启systemd system manager；</p>
<p><code>SIGINT</code>（<code>Ctrl+Alt+Del</code>）：If this signal is received  more than 7 times per 2s, an immediate reboot is triggered.</p>
<p><code>SIGHUP</code>：<code>systemctl daemon-reload</code></p>
<p>管理器交互命令可以用于管理服务。<code>systemctl</code> are used to give commands to the manager.</p>
<pre><code class="language-sh">systemctl --version # 查看版本和加载模块
systemctl {start|stop|reload|restart|kill} &lt;service&gt;
systemctl {enable|unmask} --now &lt;service&gt; # 启用并立即启动服务
systemctl {disable|mask} &lt;service&gt;        # 禁用/屏蔽服务
systemctl status &lt;service&gt;
systemctl show &lt;service&gt;
systemctl list-unit-files --type {service|target} # 列出已安装单元
systemctl list-units --type {...}                 # 列出已加载单元
systemctl daemon-reload  # 重新加载服务单元配置（不影响现有服务）
</code></pre>
<blockquote>
<p>此外，<code>systemdctl</code>还可用于控制系统</p>
<pre><code class="language-sh">systemctl {poweroff|reboot[arg]|suspend|hibernate}
</code></pre>
</blockquote>
<blockquote>
<p><code>service</code>命令也用用管理服务，在Ubuntu中其实际调用的是<code>systemctl</code>。</p>
</blockquote>
<p><a href="http://www.ruanyifeng.com/blog/2016/03/systemd-tutorial-commands.html">Systemd 入门教程：命令篇 - 阮一峰的网络日志 (ruanyifeng.com)</a></p>
<h5 id="管理配置文件"><a class="header" href="#管理配置文件">管理配置文件</a></h5>
<blockquote>
<p><em>A unit file is a plain text ini-style file that encodes information about a <strong>service</strong>, <strong>socket</strong>, <strong>device</strong>, <strong>mount point</strong>, <strong>automount point</strong>, <strong>swap file</strong> or <strong>partition</strong>, <strong>start-up target</strong>, <strong>watched file system path</strong>, <strong>timer</strong> controlled and supervised by <code>systemd</code>, <strong>resource management slice</strong> or <strong>group of externally created processes</strong>.</em></p>
</blockquote>
<p>服务配置文件（<code>.ini</code>格式）位于<code>/lib/systemd/system</code>(<code>/lib-&gt;/usr/lib</code>)；<code>systemctl enable</code>会在<code>/etc/systemd/system</code>目录（某些服务也直接置于<code>*.target</code>子目录下）创建一个指向服务单元的链接（也可直接在该目录下储存配置文件或链接其他位置的配置文件，但无法使用<code>enable/disable</code>命令）。</p>
<blockquote>
<p><code>pkg-config systemd --variable=systemdsystemunitdir</code>：系统服务配置文件路径；</p>
<p><code>pkg-config systemd --variable=systemduserunitdir</code>；</p>
<p>不同于其他<code>systemctl</code>命令，==必须以管理员权限执行==<code>systemctl enable|disable</code>以创建或删除服务配置文件的链接。</p>
</blockquote>
<p>配置文件名由管理单元名和类型名组成，如<code>unit-name[@instance-name].service</code>（<strong>服务模板</strong>：在配置文件中通过<code>&quot;%i&quot;</code>引用实例名称）。文件格式：<code>key=value</code>，<code>=</code>前后空格被忽略；<code>#</code>或<code>;</code>为注释行；<code>\</code>用于换行拼接（连接时添加空格，换行符后的注释行被忽略，随后的内容将继续被拼接）；</p>
<p>boolean：<code>1,yes,true,on</code>，<code>0,no,false,off</code></p>
<p>time：默认为秒，&quot;<code>2min 200ms</code>&quot;, s&quot;, &quot;min&quot;, &quot;h&quot;, &quot;d&quot;, &quot;w&quot;, &quot;ms&quot;, &quot;us&quot;.</p>
<p>multiple settings form a list, empty value &quot;resets&quot;</p>
<pre><code class="language-ini">[Unit]
Description=The descript of the service
Documentation=http://,https://,file:,info:,man:,
Wants/Requires/Requisite/BindsTo/PartOf/Upholds=
Conflicts=
Before/After=
After=network.target ... nginx.service mongod.service
[Install]
Alias=sshd.service   # create symlinks 
WantedBy/RequiredBy=multi-user.target
</code></pre>
<p><a href="https://www.freedesktop.org/software/systemd/man/systemd.unit.html#"><code>Unit</code>和<code>Install</code></a>是所有单元类型配置文件共有的部分。</p>
<p><code>foo.service.d/*.conf</code>：在该目录下添加配置文件覆盖该服务的默认配置。</p>
<p><strong>单元参数说明</strong>：</p>
<ol>
<li>依赖声明：==不影响启动顺序（可并行启动）==
<ul>
<li><code>Wants=</code>：one-time effect <code>=&gt; [Install] WantedBy=</code>：<code>foo.service.wants/</code>
<ul>
<li><code>Requires=</code>：<code>=&gt; [Install] RequiredBy=</code>
<ul>
<li><code>Requisite=</code>：<code>=&gt; RequisiteOf=</code></li>
<li><code>BindsTo=</code>：<code>=&gt; BoundBy=</code> </li>
<li><code>PartOf=</code>：<code>=&gt; ConsistsOf=</code></li>
</ul>
</li>
<li><code>UpHolds=</code>：continuous effect,</li>
</ul>
</li>
<li><code>Conflicts=</code>：<code>=&gt; ConflictedBy=</code></li>
</ul>
</li>
<li>启动顺序
<ul>
<li><code>Before=, After=</code></li>
<li><code>OnFailure=,OnSuccess=</code></li>
</ul>
</li>
</ol>
<p>Specifiers available in unit files: https://www.freedesktop.org/software/systemd/man/systemd.unit.html#Specifiers</p>
<p><strong>服务单元参数说明</strong>：</p>
<pre><code class="language-ini">[Service]
Type=simple/exec/forking/oneshot/dbus/notify/idle
ExecStartPre=/usr/local/nginx/sbin/nginx -t -c conf/nginx.conf # 启动前的检测
ExecStart=/usr/local/nginx/sbin/nginx -c conf/nginx.conf       # 启动服务的命令
ExecStartPost=/bin/sleep 1                                     # 启动服务后的命令
ExecReload=/usr/local/nginx/sbin/nginx -s reload               # reload命令
ExecStop=/bin/kill -s TERM $MAINPID                            # stop命令
StandardOutput=syslog
User=service_user
Environment=&quot;VAR=VALUE&quot;    &quot;VAR2=VALUE2&quot;
Environment=&quot;VAR3=VALUE3&quot;  # 可声明多行环境变量
KillMode=control-group, mixed, process, none
KillSignal=SIGTERM
</code></pre>
<ol>
<li>
<p><code>Type=</code>：服务类型</p>
<ul>
<li><code>simple</code>（默认）：认为<code>ExecStart=</code>配置的进程为服务主进程；当服务主进程被创建后（服务执行程序还未运行）即认为服务启动（即使随后服务启动过程出错，<code>systemctl start</code>仍然报告启动成功）并继续启动后续服务。
<ul>
<li><code>exec</code>：等待服务进程被执行后才认为服务启动（<code>systemd</code> 219版本不支持，245版本支持该类型）；
<ul>
<li><code>notify</code>：类似于<code>exec</code>，但服务启动后需要发送一个通知消息，服务管理在收到通知消息后，认为服务启动完成并继续启动后续服务；设置<code>NotifyAccess=</code>以访问<code>systemd</code>提供的通知套接字。</li>
</ul>
</li>
<li><code>oneshot</code>：类似于<code>simple</code>，服务主进程退出后即认为服务启动完成，通常用于设置==开机启动任务==；<code>RemainAfterExit=yes</code>用于表示服务在启动完成后进入<code>active</code>状态，否则，由于没有配置持续运行的进程，服务状态将变为<code>deactivating</code>或<code>dead</code>状态。</li>
<li><code>dbus</code>：类似于<code>simple</code>，服务获得一个D-Bus总线名（<code>BusName=</code>）后，即认为完成启动；默认依赖<code>dbus.socket</code>；</li>
<li><code>idle</code>：类似于<code>simple</code>，但会延迟服务程序的执行时间(最多5s)，直到活动任务被执行。</li>
</ul>
</li>
<li><code>forking</code>：<code>ExecStart=</code>配置的进程会调用<code>fork()</code>来启动后台服务（Unix服务启动协议）。父进程在后台进程启动完成后退出，服务管理认为服务启动完成。==如果服务自身可以输出主进程ID到文件，则推荐使用<code>PIDFile=</code>选项==，使得<code>systemd</code>能够可靠地识别服务主进程从而判断服务状态 。如果未设置<code>PIDFile</code>，则<strong>默认</strong><code>GuessMainPID=yes</code>以尝试获取服务主进程ID，但如果服务存在多个守护进程，则不一定准确。</li>
</ul>
<p>对于长期运行服务，首先推荐使用简单且快速的<code>Type=simlpe</code>。但如果需要获取服务启动状态，或其他服务依赖此服务，则推荐使用<code>notify</code>或<code>dbus</code>；如果服务程序并不支持<code>notify</code>或<code>dbus</code>，则使用<code>forking</code>。对于==仅启动时执行一次==的服务，则可以使用<code>oneshot</code>。</p>
</li>
<li>
<p><a href="https://man7.org/linux/man-pages/man5/systemd.exec.5.html">服务单元执行环境配置</a>：</p>
<ol>
<li>
<p><code>RootDirectory=</code>(<code>chroot</code>)</p>
</li>
<li>
<p><code>WorkingDirectory=</code></p>
</li>
<li>
<p><code>User=, Group=</code></p>
</li>
<li>
<p>进程资源限制<code>ulimit</code>：<code>LimitCPU/LimitFSIZE/LimitNOFILE...</code>；</p>
</li>
<li>
<p>CPU调度策略：<code>CPUSchedulingPolicy/CPUAffinity...</code></p>
</li>
<li>
<p><code>Environment=,EnvironmentFile=</code>：定义传递给服务的环境变量（定义不支持Shell变量替换，重复定义将替换之前的定义）；</p>
<ul>
<li><code>$PATH</code>：默认值<code>/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin</code>；</li>
<li><code>$MAINPID</code>：服务主进程ID，用于管理服务控制进程的关闭和重载；</li>
<li><code>$PIDFILE</code>：通过<code>PIDFile=</code>传递，用于服务守护进程写入进程ID；</li>
</ul>
</li>
<li>
<p><code>StandardInput=,StandardOutput=,StandardError=</code>：<code>inherit, null, tty, kmsg, journal+console, kmsg+console, socket or fd:name.</code></p>
<ul>
<li><code>journal</code>：发送到journal，输出日志通过<code>journalctl</code>查看</li>
<li><code>syslog</code>：发送到系统的syslog服务和journal。</li>
<li><code>file:path</code>(<code>v236+</code>), <code>append:path</code>(<code>v240+</code>), <code>truncate:path</code>：输出到指定文件（<a href="https://unix.stackexchange.com/a/479669/247982">219版本不支持</a>，对于不支持的版本使用文件重定向标准输出）。</li>
</ul>
<blockquote>
<p><code>systemd</code>管理的服务产生的日志可通过<code>journalctl</code>查看。</p>
<pre><code class="language-shell">journalctl [FIELD=VALUE...] \ # 未添加匹配条件则返回所有日志 systemd.journal-fields
    --options
</code></pre>
</blockquote>
</li>
<li>
<p><code>SyslogIdentifier=,SyslogFacility=,SyslogLevel=</code></p>
</li>
</ol>
</li>
<li>
<p><code>ExecStart=</code>：服务启动命令。==除非是<code>oneshot</code>类型==，否则仅能给定一条命令。==命令必须以可执行程序的绝对路径开头==（对于其他<code>Exec</code>命令也一样）。</p>
<blockquote>
<p><code>systemd-path search-binaries-default</code>：如果返回路径，则表示支持直接使用位于路径的命令名。</p>
</blockquote>
<blockquote>
<p>命令参数支持环境变量替换：<code>${VARIABLE}</code>始终解释为一个参数，<code>$VARIABLE</code>必须与命令行==其他内容使用空格分开==（否则不会展开），展开后会按空白分割为多个参数；</p>
<p>支持Systemd定义的<code>%</code>特殊变量。</p>
<pre><code class="language-shell">--opt1 $VARIABLE1  --opt2=${VARIABLE2}
# --opt2=$VARIABLE3 无法完成变量替换
</code></pre>
<p>命令中不能包含重定向（<code>&lt;,&lt;&lt;,&gt;,&gt;&gt;</code>）、管道（<code>|</code>）和后台执行（<code>&amp;</code>）等Shell语法。显式使用<code>bash</code>命令</p>
<pre><code class="language-shell">ExecStart=bash -c 'dmesg | tac'
</code></pre>
<p>命令前缀：</p>
<ul>
<li><code>-</code>：记非零错误返回，但处理行为等效于命令成功执行；</li>
<li><code>:</code>：不替换命令行环境变量；</li>
<li>&quot;<code>+</code>&quot;以完整权限执行，不受用户和分组设置限制；</li>
</ul>
</blockquote>
</li>
<li>
<p><code>ExecStartPre=, ExecStartPost=</code>：类似于<code>ExecStart=</code>：，分别在<code>ExecStart=</code>：前后执行，并可指定多条命令。<code>ExecStart=</code>仅在<code>ExecStartPre=</code>执行成功的情况下执行，否则服务启动失败(<code>ExecStartPost=</code>类似)。<code>ExecStartPre=</code>不应用于启动长期运行程序（<code>ExecStartPre=</code>启动进程所创建的子进程会在服务程序执行前被终止）。任何<code>Exec*=</code>命令执行失败或超时，则会跳转到执行<code>ExecStopPost</code>（跳过<code>ExecStop=</code>）。</p>
</li>
<li>
<p><code>ExecReload=</code>：服务重新加载配置的一条或多条命令（语法类似于<code>ExecStart=</code>）。</p>
</li>
<li>
<p><code>ExecStop=,ExecStopPost=</code>：停止服务的一条或多条命令。如果未指定，则向服务发送``KillSignal=<code>或</code>RestartKillSignal=`指定的信号以终止服务进程。</p>
</li>
<li>
<p><code>TimeoutSec=,RestartSec=,TimeoutStartSec=,TimeoutStopSec=</code>服务启动/停止超时期限。</p>
</li>
<li>
<p><code>Restart=no|on-success|on-failure|on-abnormal|on-watchdog|on-abort|always</code></p>
</li>
<li>
<p><code>SuccessExitStatus=TEMPFAIL 250 SIGKILL</code>：成功退出状态，默认包括<code>0</code>，<code>SIGHUP</code>，<code>SIGINT</code>，<code>SIGTERM</code>和<code>SIGPIPE</code>。</p>
</li>
<li></li>
</ol>
<p><a href="https://www.freedesktop.org/software/systemd/man/systemd.service.html">systemd.service (www.freedesktop.org)</a></p>
<h5 id="服务沙盒"><a class="header" href="#服务沙盒">服务沙盒</a></h5>
<p>以下选项用于屏蔽向服务进程暴露的系统资源（需要底层安全机制支持才开启，如<code>ProtectSystem</code>需要包含文件系统命名空间的内核）。</p>
<pre><code class="language-ini">ProtectSystem=false|true|full|strict*
ProtectHome=false|true|read-only|tmpfs
PrivateTmp=false|true
</code></pre>
<blockquote>
<p><code>*</code>：<code>strict</code>，<code>tmpfs</code>在<code>219</code>版本（CentOS 7）不可用。</p>
</blockquote>
<ul>
<li>[Mastering systemd: Securing and sandboxing applications and services | Enable Sysadmin (redhat.com)](https://www.redhat.com/sysadmin/mastering-systemd#:~:text=Systemd provides a significant number of security features,this option to full also makes %2Fetc read-only.)</li>
<li><a href="https://www.freedesktop.org/software/systemd/man/systemd.exec.html#Sandboxing">systemd.exec Sandboxing(www.freedesktop.org)</a></li>
</ul>
<p>问题：</p>
<ul>
<li>
<p>开启<code>ProtectSystem</code>后无法对用户家目录进行写操作。</p>
<p>如果使用普通用户运行服务，则不用担心该服务修改系统资源（无权限）。因此，可以关闭<code>ProctectSystem</code>选项。也可尝试将服务的写入目录修改为其他位置，例如<code>/tmp</code>或<code>/var</code>（适用于以<code>root</code>运行的服务）。</p>
</li>
</ul>
<h5 id="挂载单元配置"><a class="header" href="#挂载单元配置">挂载单元配置</a></h5>
<pre><code class="language-ini">[Mount]
What=/dev/DEVNAME
Where=/mnt/MOUNT_PATH
Type=fs_type
Options=
DirectoryMode=0755  # 自动创建挂载点
TimeoutSec=
# Check systemd.exec(5) and systemd.kill(5) for more settings.
</code></pre>
<h5 id="定时单元器配置"><a class="header" href="#定时单元器配置">定时单元器配置</a></h5>
<pre><code class="language-ini">[Timer]
OnActiveSec/OnUnitActiveSec=   # 相对定时器(执行单元)上次触发时间设置定时器
OnUnitInactiveSec=             # 相对定时器执行单元上次休眠时间设置定时器
OnCalendar=                    # systemd.time(7) 
Unit=                          # 定时器超时后触发的单元名称
</code></pre>
<h4 id="supervisor"><a class="header" href="#supervisor">supervisor</a></h4>
<p><a href="http://supervisord.org/introduction.html">Introduction — Supervisor 4.2.2 documentation (supervisord.org)</a></p>
<blockquote>
<p>Supervisor is a client/server system that allows its users to control a number of processes on UNIX-like operating systems. It is not meant to be run as a substitute for <code>init</code> as “process id 1”. Instead it is meant to be used to ==control processes related to a project or a customer==,</p>
<p><code>supervisord</code> starts processes as its subprocesses via <code>fork</code>/<code>exec</code> and subprocesses don’t daemonize. It always knows the true up/down status of its children. If supervisord is started as root, it is possible to allow “normal” users to control (“stop”, “start”, and “restart” ) such processes.</p>
</blockquote>
<p>client/server system</p>
<p>delegation: Supervisorctl allows a very limited form of access to the machine, essentially allowing users to see process status and control supervisord-controlled subprocesses by emitting “stop”, “start”, and “restart” commands from a simple shell or web UI.</p>
<p><code>/etc/supervisord.conf</code></p>
<pre><code class="language-shell">supervisord -c conf_file
            -n, --nodaemon
            -q ,--childlogdir=PATH # must exist, for auto-mode child proocess
            -k, --nocleanup  # prevent removal of old AUTO process log files    
supervisorctl -c conf_file
              -i,--interactive   # 启动交互式命令
              -r,--history-file  # 记录输入命令(realine模块可用)
              ACTION args...
ACTION:
  add/update NAME[:*]... # activate/update process/group config 
  remove NAME ...        # deactivate process config
  clear NAME ...         # clear process log 
  pid [NAME]             # get pid of supervisord/subprocess
  reload                 # restart remote supervisord
  reread                 # reload daemon's config without restart
  start NAME[:*]...      # start process/group (not reread configs)
  restart NAME[:*]...    # restart process/group (not reread configs)
  status [NAME[:*]...]   # 返回进程(组)状态
  tail [-f] NAME [stdout|stderr] # 输出日志的最后部分
</code></pre>
<blockquote>
<p><code>all</code>用于参数中表示所有进程和分组。</p>
</blockquote>
<h5 id="supervisord-as-a-system-service"><a class="header" href="#supervisord-as-a-system-service">supervisord as a <a href="https://github.com/Supervisor/initscripts">system service</a></a></h5>
<pre><code class="language-ini"># supervisord service for systemd (CentOS 7.0+)
[Unit]
Description=Supervisor daemon
[Service]
Type=forking
ExecStart=/usr/bin/supervisord
ExecStop=/usr/bin/supervisorctl $OPTIONS shutdown
ExecReload=/usr/bin/supervisorctl $OPTIONS reload
KillMode=process
Restart=on-failure
RestartSec=42s
[Install]
WantedBy=multi-user.target
</code></pre>
<h5 id="supervisord"><a class="header" href="#supervisord"><code>supervisord</code></a></h5>
<pre><code class="language-ini">[supervisord]
logfile=$CWD/supervisord.log # (-l,--logfile=FILE)
logfile_maxbytes=50MB  # rotate limit (-y,--logfile_maxbytes=BYTES)
logfile_backups=10     # number of rotates (-z,--logfile_backups=NUM)
loglevel=info          # (-e,--loglevel=LEVEL)
pidfile=$CWD/supervisord.pid # (-j,--pidfile=FILE)
directory=$PWD         # workdir of supervisord daemon (-d,--directory=PATH)
environment=KEY=&quot;val&quot;,KEY2=&quot;val2&quot; # for all subprocess
</code></pre>
<p>信号处理：</p>
<ul>
<li><code>SIGTERM/SIGINT/SIGQUIT</code>：<code>supervisord</code>及其管理的子进程将会关闭。</li>
<li><code>SIGHUP</code>：关闭所有进程，重新加载配置，并重启所有进程。</li>
<li><code>SIGUSR2</code>：关闭并重新打开主日志以及子进程日志。</li>
</ul>
<h5 id="服务进程配置"><a class="header" href="#服务进程配置">服务进程配置</a></h5>
<pre><code class="language-ini">[program:SERVICE_NAME]
command=/path/to/programname  # relative is OK
user=gary                     # 启动进程的用户
numprocs=1
priority=999                  # Lower priorities indicate programs that start first
autostart=true                # start with supervisord
autorestart=unexpected        # false, unexpected, or true
startsecs=1                   # 0不检查是否进程在运行
startretries=3
exitcodes=0                   # 正常退出代码（,分隔）
stopwaitsecs=10               # 进程停止等待时间（超时使用SIGKILL强制停止）
stopasgroup=false             # 用于停止具有子进程的进程（如Flask调试模式）
stdout_logfile=AUTO           # 进程的标准输出文件
stdout_logfile_maxbytes=50MB  # 日志文件轮转大小
stdout_logfile_backups=10     # 日志轮转数量限制
stderr_logfile=AUTO           # stderr_logfile_maxbytes/stderr_logfile_backups
stdout_syslog=10              # 使用进程名输出到syslog / stderr_syslog
redirect_stderr=false         # 将进程的错误输出重定向到supervisord的输出
environment=                  # 传递给进程的环境变量
directory=                    # 进程运行的工作目录
</code></pre>
<blockquote>
<p>服务进程本身不应该以守护进程模式运行。</p>
<p>自动重启：如果<code>autorestart=unexpected</code>，则在非手动停止进程的情况下，如果进程退出代码非<code>exitcodes</code>列出的，则重启该进程。</p>
<p><em><code>AUTO</code> log files and their backups will be deleted when <strong>supervisord</strong> restarts.</em></p>
<p>输出文件名为可包含变量<code>group_name</code>, <code>host_node_name</code>, <code>process_num</code>, <code>program_name</code>和<code>here</code>的Python字符串表达式。</p>
</blockquote>
<img src="Linux/Linux配置和管理.assets/subprocess-transitions.png" alt="Subprocess State Transition Graph" style="zoom:50%;" />
<p>服务分组：同类型服务；</p>
<pre><code class="language-ini">[group:foo]
programs=bar,baz
priority=999
</code></pre>
<h5 id="supervisorctl访问supervisord"><a class="header" href="#supervisorctl访问supervisord"><code>supervisorctl</code>访问<code>supervisord</code></a></h5>
<p><code>supervisorctl</code>可访问本地（UNIX套接字）或远程的<code>supervisord</code>服务（TCP/IP套接字）。</p>
<pre><code class="language-ini">[supervisorctl]
serverurl=unix:///tmp/supervisor.sock  # (-s,--serverurl URL)
# serverurl=http://127.0.0.1:9001
username=gary        # (-u,--username NAME)
password=gang2019    # (-p,--password)
prompt=mysupervisor  # 命令行提示符
</code></pre>
<h5 id="使用web访问supervisord"><a class="header" href="#使用web访问supervisord">使用Web访问<code>supervisord</code></a></h5>
<pre><code class="language-shell">[inet_http_server]
port=0.0.0.0:9001
username=gary
password=gang2019  # or passord hash: {SHA}82ab876d1387bfafe46cc1c8a2ef074eae50cb1d
</code></pre>
<blockquote>
<p>重启<code>supervisor</code>（使用<code>systemctl</code>）。</p>
</blockquote>
<h5 id="xml-rpc接口"><a class="header" href="#xml-rpc接口"><a href="http://supervisord.org/api.html">XML-RPC接口</a></a></h5>
<pre><code class="language-python">from xmlrpc.client import ServerProxy
server = ServerProxy('http://localhost:9001/RPC2')
server.supervisor.getState()
server.system.listMethods()
server.system.methodHelp('supervisor.shutdown')
</code></pre>
<h5 id="子配置文件"><a class="header" href="#子配置文件">子配置文件</a></h5>
<pre><code class="language-ini">[include]
files=/path/filename.conf /path/*.conf foo.conf config??.conf
</code></pre>
<p><a href="http://supervisord.org/api.html#xml-rpc">XML-RPC API Documentation — Supervisor 4.2.2 documentation (supervisord.org)</a></p>
<p><a href="http://supervisord.org/index.html">Supervisor: A Process Control System — Supervisor 4.2.4 documentation (supervisord.org)</a></p>
<h5 id="process-monitoring-and-events"><a class="header" href="#process-monitoring-and-events">Process Monitoring and Events</a></h5>
<p>Supervisor continually emits event notifications, and the subscribed listener will be notified.</p>
<p>provide a mechanism for code to be run (e.g. send an email, make an HTTP request, etc) when some condition related to subprocess state is met.</p>
<p>The event notification protocol is based on communication via a subprocess’ stdin and stdout.</p>
<p><a href="http://supervisord.org/events.html#example-event-listener-implementation">Example Event Listener Implementation</a></p>
<h4 id="服务管理程序对比"><a class="header" href="#服务管理程序对比">服务管理程序对比</a></h4>
<p><code>supervisord</code>主要用于管理用户服务进程，<code>systemd</code>处理服务管理外，还支持系统中其他对象如外部设备、套接字、定时器等的管理。</p>
<p><code>systemd</code>具有启动依赖管理控制功能，可以实现有依赖关系的一组对象的正确启动和运行管理；<code>supervisord</code>仅支持进程分组，无依赖解析功能。<code>systemd</code>具有完善的进程资源控制和系统调度策略设置，<code>supervisor</code>可实现较为简单的资源控制。</p>
<p><code>supervisord</code>提供网络访问接口并有可用的Web访问UI，可方便普通用户实现进程管理；<code>systemd</code>需要管理权限执行管理控制功能。</p>
<p><code>superivord</code>发布于2004年，<code>systemd</code>发布于2010年。<code>systemd</code>现在为多数Linux发行版的<code>init</code>程序，因此开箱即用。<code>supervisord</code>需要以Python库或发行版软件仓库软件的方式进行安装。</p>
<p>对于较为简单的服务进程配置管理，<code>supervisord</code>和<code>systemd</code>都能有效实现；对于有远程管理需求的场景，<code>supervisord</code>提供网络访问接口更适合。对于复杂的服务配置管控需求以及<code>supervisor</code>不支持的管控对象，使用<code>systemd</code>更加合适。</p>
<h2 id="网络管理"><a class="header" href="#网络管理">网络管理</a></h2>
<h3 id="网络管理工具"><a class="header" href="#网络管理工具">网络管理工具</a></h3>
<p><code>net-tools</code>：包含<code>arp, ifconfig, netstat, rarp, nameif and route</code>。</p>
<p><code>ip</code>：<em>show/manipulate routing, <a href="Linux/Linux%E9%85%8D%E7%BD%AE%E5%92%8C%E7%AE%A1%E7%90%86.html#%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87">network devices</a>, interfaces and tunnels</em>，代替<code>net-tools</code>。</p>
<p><code>NetworkManager</code>：包含<code>NetworkManager</code>服务和命令行工具<code>nmcli</code>、<code>nmtui</code>等。</p>
<blockquote>
<p>与使用<code>ip</code>的功能相同，使用<code>nmcli+NetworkManager</code>将管理功能与用户交互分离。</p>
</blockquote>
<h4 id="networkd"><a class="header" href="#networkd"><code>networkd</code></a></h4>
<h4 id="networkmanager"><a class="header" href="#networkmanager">NetworkManager</a></h4>
<p><code>NetworkManager</code>用于代替已有的配置工具<code>ifconfig</code>及其配置文件。<code>NetworkManager</code>作为<code>systemd</code>服务运行（服务的配置文件为<code>/etc/NetworkManager/NetworkManager.conf</code>）。</p>
<p><code>udev</code>设备管理器发现系统新加入设备，通知<code>NetworkManager</code>通过D-Bus来检测和初始化配置网络设备实现即插即用（配置信息动态生成并存储于内存中）。</p>
<p>永久配置文件检查（如果未找到配置文件，则尝试从DHCP服务器获取配置信息）：</p>
<ul>
<li>
<p><code>etc/sysconfig/network-scripts/ifcfg-*</code>：后向兼容<code>ifconfig</code>配置文件；</p>
</li>
<li>
<p><code>/etc/NetworkManager/system-connections/</code>：<code>NetworkManager</code>配置文件。</p>
</li>
</ul>
<p><code>nmcli</code>是NetworkManger的命令行工具（客户端），<code>nmtui</code>是对应的终端图形界面工具。</p>
<blockquote>
<pre><code class="language-shell">yum install NetworkManaget-tui  # nmcli随NetworkManager安装
</code></pre>
</blockquote>
<p>图形化配置接口：</p>
<pre><code class="language-shell">nmtui edit &lt;ifname&gt;    # in CentOS
</code></pre>
<blockquote>
<p>在修改配置时，不要修改设备（<code>00:0C:29:BD:83:63 (ens32)</code>）</p>
</blockquote>
<h3 id="网络状态"><a class="header" href="#网络状态">网络状态</a></h3>
<h4 id="主机名和域名"><a class="header" href="#主机名和域名">主机名和域名</a></h4>
<p><code>hostname</code>可以读取主机的主机名、域名和对应的IP地址（<code>/etc/hostname</code>）。</p>
<ul>
<li><code>-A</code>：所有主机名；<code>-s</code>返回一个短主机名；<code>-f</code>返回长主机名；</li>
<li><code>-I</code>：所有IP地址；<code>-i</code>还首先读取IPv6地址；</li>
<li><code>-d</code>：DNS域名；</li>
</ul>
<blockquote>
<p>使用<code>hostnamectl</code>设置主机名。</p>
</blockquote>
<h5 id="域名地址映射"><a class="header" href="#域名地址映射">域名地址映射*</a></h5>
<pre><code class="language-shell">dig [@dns_server] domain_name
dig -x ip_addr   # reverse lookup
nslookup &lt;domain&gt;
</code></pre>
<blockquote>
<p>支持反向查询<code>nslookup &lt;ipaddr&gt;</code>，但查询到的域名不是通常使用的域名，也可能查不到结果。</p>
</blockquote>
<pre><code class="language-shell">whois &lt;ipaddr|domain&gt;     # sudo apt install whois
</code></pre>
<blockquote>
<p>查询IP地址/域名==所有者==。</p>
</blockquote>
<h4 id="网络接口信息"><a class="header" href="#网络接口信息">网络接口信息</a></h4>
<pre><code class="language-shell">nmcli   # 代替ifconfig
netstat -i  # 输出网络接口设备的统计信息；
        -ie # =&gt; ifconfig
</code></pre>
<p>使用<code>ip</code>工具列出设备参数(<code>type,mtu,qdisc,state,mode,qlen,mac</code>)：</p>
<pre><code class="language-shell">ip link [show] [up|down] [dev eth0] [type bridge] [master br0] # 显示链路信息
ip address ...   # 显示链路层以及网络地址信息
</code></pre>
<p>使用<code>nmcli</code>查看网络接口连接：</p>
<pre><code class="language-shell">nmcli c[onnection] [show] --active # summary table
# NAME  UUID                                  TYPE      DEVICE
# eth0  cb149a11-edae-3f8f-9af1-7dc541e1ac5d  ethernet  ens32
nmcli connection show &lt;name/id&gt;  # interface details
</code></pre>
<blockquote>
<p>设备未知的接口通常是由于<a href="Linux/Linux%E9%85%8D%E7%BD%AE%E5%92%8C%E7%AE%A1%E7%90%86.html#%E7%BC%96%E8%BE%91%E7%BD%91%E7%BB%9C%E6%8E%A5%E5%8F%A3%E9%85%8D%E7%BD%AE">配置文件</a>存在错误。</p>
</blockquote>
<p>查看网络设备信息：</p>
<pre><code class="language-shell">nmcli d[evice] [show] # summary table
# DEVICE  TYPE      STATE      CONNECTION
# ens33   ethernet  connected  ens33
# lo      loopback  unmanaged  --
nmcli device show &lt;device&gt; # device details
</code></pre>
<h4 id="网络通信状态信息"><a class="header" href="#网络通信状态信息">网络通信状态信息</a></h4>
<pre><code class="language-shell">netstat -a      # 列出tcp,udp和unix协议套接字连接(默认仅显示unix套接字连接) *
        -{t|u}  # 只列出TCP/UDP连接
        -l      # 只列出监听中的连接
        -p      # 列出进程ID和命令名
        -e      # 列出进程用户和进程文件的Inode编号
        -n      # 禁用对IP地址/端口的反向域名解析，加快查询速度
</code></pre>
<blockquote>
<p><code>*</code>：需要安装<code>net-tools</code>包。</p>
</blockquote>
<p>示例：</p>
<pre><code class="language-sh">sudo netstat -anp | grep ESTABLISHED   # 打印active状态的连接
sudo netstat -anp | grep apache2       # 查看指定服务是否正常运行
</code></pre>
<p>通过访问套接字获取连接信息：</p>
<pre><code class="language-shell">ss -n   # 禁止解析服务名称
   -r   # 尝试解析地址端口信息
   -a/l # 显示所有/监听套接字信息 
   -m   # 显示套接字内存占用
   -p   # 显示使用套接字的进程
   -e   # 显示扩展信息
   -i   # 显示TCP内部信息
   -s   # 打印汇总信息
   -N,--net=NSNAME # 切换网络命名空间
   -f,--family=unix/inet/inet6/link/netlink/vsock
</code></pre>
<p>由于网络连接（套接字）是特殊文件，因此可以使用<code>lsof</code>查看（<code>lsof</code>用于<a href="Linux/Linux%E9%85%8D%E7%BD%AE%E5%92%8C%E7%AE%A1%E7%90%86.html#%E6%9F%A5%E7%9C%8B%E8%BF%9B%E7%A8%8B%E6%89%93%E5%BC%80%E8%B5%84%E6%BA%90">列举进程打开的文件</a>）。</p>
<pre><code class="language-shell">lsof -i -P -n
</code></pre>
<blockquote>
<ul>
<li>
<p><code>-i [addr]</code>：列出使用互联网地址的文件（套接字）；地址格式</p>
<p><code>[46][protocol][@hostname|hostaddr][:service|port]</code></p>
</li>
<li>
<p><code>-U</code> 筛选使用UNIX套接字的进程。</p>
</li>
<li>
<p><code>-P</code>：禁止将端口号解析为服务名；</p>
</li>
<li>
<p><code>-n</code>：禁止将IP地址解析为主机名或域名。</p>
</li>
</ul>
</blockquote>
<h5 id="网络协议统计信息"><a class="header" href="#网络协议统计信息">网络协议统计信息</a></h5>
<pre><code class="language-shell">netstat -s
</code></pre>
<h5 id="监控网络通信状态"><a class="header" href="#监控网络通信状态">监控网络通信状态</a></h5>
<pre><code class="language-shell">iftop   # apt|yum install iftop  =&gt; 主机间通信速率
nload   # apt|yum install nload  =&gt; 网络接口通信统计
bmon    # apt|yum install bmon   =&gt; 系统带宽监控
nethogs # yum install nethogs    =&gt; 进程通信统计
</code></pre>
<blockquote>
<p><a href="Linux/../%E5%BA%94%E7%94%A8%E8%BD%AF%E4%BB%B6/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AE%A1%E7%90%86%E8%BD%AF%E4%BB%B6.html#%E7%B3%BB%E7%BB%9F%E7%9B%91%E6%8E%A7%E8%BD%AF%E4%BB%B6">系统监控工具</a>也可以监控网络通信状态的基本参数。</p>
</blockquote>
<h5 id="网络可达性检测"><a class="header" href="#网络可达性检测">网络可达性检测</a></h5>
<p><code>ping</code>：<em>is part of <code>iputils</code> package</em>。</p>
<pre><code class="language-shell">ping \             # ICMP ECHO_REQUEST
     -4|6  \       # IPv4/IPv6
     -c count \ 
     -D            # print timestamp before each line
     -I interface  # 设置源地址或源接口名称
</code></pre>
<p><code>tracepath</code>：<em>is part of <code>iputils</code> package.</em></p>
<pre><code class="language-shell">tracepath -4|6 -n|b # n|b 仅打印IP地址/打印主机名和IP地址
</code></pre>
<h3 id="网络设备链路管理"><a class="header" href="#网络设备链路管理">网络设备链路管理</a></h3>
<h4 id="网络配置数据"><a class="header" href="#网络配置数据">网络配置数据</a></h4>
<p>系统中可能存在的网络设备和接口配置文件：</p>
<ul>
<li>
<p><code>ifup/ifdown</code>（<code>/etc/network/interfaces</code>）</p>
</li>
<li>
<p><code>networkd</code></p>
<pre><code class="language-ini">[connection]
id=br0_eno1
uuid=ccfcb8fa-5f16-4407-ae6c-1af6c9117265
type=bridge
autoconnect=false
interface-name=br0_eno1
permissions=
timestamp=1650420144
[bridge]
stp=false
[ipv4]
address1=172.28.76.22/24,172.28.76.234
dns=172.28.28.28;223.5.5.5;
dns-priority=100
dns-search=
method=manual
[ipv6]
addr-gen-mode=stable-privacy
dns-priority=100
dns-search=
method=link-local
[proxy]
</code></pre>
</li>
<li>
<p><code>ifconfig</code>（<code>etc/sysconfig/network-scripts/ifcfg-*</code>）</p>
<pre><code class="language-ini">TYPE=Ethernet
NAME=eth0                # 应该和配置文件后缀匹配
DEVICE=ens33             # 绑定的设备名
UUID=a016f249-6703-42eb-a207-e40f80de212f # 绑定的设备UUID
HWADDR=84:16:f9:03:fd:85 # 绑定的设备MAC(old)
IPADDR=192.168.2.203
PREFIX=24                # &lt;-&gt; NETMASK
GATEWAY=192.168.178.2
DNS1=223.5.5.5
DNS2=8.8.8.8
ONBOOT=yes
BOOTPROTO=static  # dhcp|bootp|none|static
</code></pre>
</li>
<li>
<p><code>NetworkManager</code>（<code>/etc/NetworkManager/system-connections</code>）</p>
</li>
</ul>
<h5 id="netplan"><a class="header" href="#netplan">netplan</a></h5>
<p><code>netplan</code>在系统启动早期将配置信息解析并提供给系统的网络管理服务（如<code>NetworkManager</code>）。</p>
<ul>
<li>默认由<code>systemd-networkd</code>管理网络设备，其他服务如<code>NetworkManager</code>可替代其功能。</li>
</ul>
<p><code>netplan</code>配置文件位于<code> /{lib,etc,run}/netplan/*.yaml</code>：</p>
<ul>
<li>对于不同目录下的同名配置文件，仅读取最高优先级目录下的文件（<code>/run&gt;/etc&gt;/lib</code>）；</li>
<li>对于不同名文件，将按文件名字典顺序读取配置文件，并将新内容追加/覆盖已读取内容。</li>
</ul>
<p>配置文件格式（YAML）：</p>
<pre><code class="language-yaml">network:  # 网络配置的根节点
    renderer: networkd|NetworkManager  #  networking backend, 
    ethernets:  # 设备分组, 如: ethernet, modem, wifi
        ens33:  # 设备ID
            dhcp4: false
            dhcp6: true
            addresses:
                - 192.168.0.200/24 # IPv4
                    lifetime: 0
                    label: &quot;maas&quot;
                - &quot;2001:1::1/64&quot;   # IPv6
            gateway4: 192.168.0.1  #! deprecated
            gateway6: &quot;2001:4::1&quot;  #! deprecated
            routes:   # 静态路由*
                - to: default # could be 0/0 or 0.0.0.0/0 optionally 默认路由
                  via: 192.168.0.1  # 默认网关
                  metric: 100
                  on-link: true
                - to: default # could be ::/0 optionally
                  via: cf02:de:ad:be:ef::2
            nameservers:  # 手动地址配置时设置
                addresses: [ 223.5.5.5, &quot;FEDC::1&quot; ]
                search: [lab, home]  #**
            match:
                macaddress: 52:54:00:6b:3c:58 
            macaddress: 52:54:00:6b:3c:59  # 修改匹配设备的MAC地址
            mtu: 1500   # 修改匹配设备的MAC地址
            
    version: 2
</code></pre>
<p>应用配置文件：</p>
<pre><code class="language-shell">sudo netplan generate  # 生成后端配置文件
sudo netplan apply     # 直接应用配置
sudo netplan try       # validate the config and then apply
</code></pre>
<h4 id="物理链路管理"><a class="header" href="#物理链路管理">物理链路管理</a></h4>
<h5 id="创建和删除链路"><a class="header" href="#创建和删除链路">创建和删除链路</a></h5>
<pre><code class="language-shell">ip link add \     # 添加虚拟链路
   link DEVICE \  # 指定物理设备(某些链路类型无物理设备，如IP-over-IP)
   name NAME \    # 默认为物理设备名称
   type TYPE \    # 链路类型：bridge,veth,vlan,macvlan,mactap,ip6tnl,gre,...
   index ID       # 链路编号
</code></pre>
<blockquote>
<p>其他参数包括：<code>mtu,address,broadcast,txqueuelen,numtxqueues,numrxqueues,... </code>。</p>
<p>不同类型链路采用不同的数据链路层协议。</p>
</blockquote>
<pre><code class="language-shell">ip link delete {dev NAME|group GROUP} type TYPE
</code></pre>
<pre><code class="language-shell">nmcli connection add type &lt;type&gt; ifname &lt;ifname&gt; ... # 创建链路
nmcli connection delete &lt;ifname&gt; 
</code></pre>
<h5 id="配置链路参数"><a class="header" href="#配置链路参数">配置链路参数</a></h5>
<pre><code class="language-shell">ip link set [dev NAME] [group GROUP] prop VALUE 
ip address {add|change|replace} IFADDR dev NAME  # 配置IP地址
</code></pre>
<p>如果指定了<code>group</code>则修改设备所属分组，如果未指定设备，则修改分组中所有设备的属性。配置了IP地址的链路能够使用IP协议进行通信。</p>
<pre><code class="language-shell">nmcli connection modify &lt;ifname&gt; [+-]ipv4.addresses 192.168.0.58[/24]
nmcli connection modify &lt;ifname&gt; [+-]ipv4.dns 114.114.114.114
nmcli connection modify &lt;ifname&gt; [-]ipv4.gateway 192.168.0.2
# ipv4.method manual must be supplied with address
nmcli connection modify &lt;ifname&gt; ipv4.method manual \
                                 ipv4.addresses 192.168.0.58/24 
nmcli edit &lt;ifname/id&gt;  # 交互式编辑模式,查看和编辑配置项                                 
</code></pre>
<h5 id="启用和停用链路"><a class="header" href="#启用和停用链路">启用和停用链路</a></h5>
<pre><code class="language-shell">nmcli c reload
nmcli c up &lt;interface&gt;    # if interface exist
</code></pre>
<h4 id="虚拟网桥管理"><a class="header" href="#虚拟网桥管理">虚拟网桥管理</a></h4>
<h5 id="创建和配置虚拟网桥"><a class="header" href="#创建和配置虚拟网桥">创建和配置虚拟网桥</a></h5>
<pre><code class="language-shell">ip link add BRIDGE_NAME type bridge 
brctl addbr BRIDGE_NAME
nmcli connection add type bridge CONN_NAME BRIDGE_NAME ifname BRIDGE_NAME
</code></pre>
<p><a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/8/html/configuring_and_managing_networking/configuring-a-network-bridge_configuring-and-managing-networking">Chapter 12. Configuring a network bridge Red Hat Enterprise Linux 8 | Red Hat Customer Portal</a></p>
<h5 id="将网卡绑定至网桥"><a class="header" href="#将网卡绑定至网桥">将网卡绑定至网桥</a></h5>
<pre><code class="language-shell">ip link set dev IFNAME master BRIDGE_NAME
nmcli connection modify DEVICE_NAME master BRIDGE_NAME
nmcli connection add type ethernet slave-type bridge CONN_NAME DEVICE_NAME ifname IF_NAME master bridge0
</code></pre>
<h4 id="虚拟网卡管理"><a class="header" href="#虚拟网卡管理">虚拟网卡管理</a></h4>
<h5 id="tap网卡"><a class="header" href="#tap网卡">tap网卡</a></h5>
<pre><code class="language-shell">ip tuntap add dev tap1 mode tap
</code></pre>
<p>Tap网卡创建是临时的，如果要永久生效，可将上述命令添加到开机启动命令（如<code>rc.local</code>）。</p>
<p><a href="https://superuser.com/questions/854401/how-to-make-tap-interfaces-persistent-after-reboot">linux - How to make tap interfaces persistent after reboot? - Super User</a></p>
<h3 id="防火墙"><a class="header" href="#防火墙">防火墙</a></h3>
<p>Linux内核使用<a href="Linux/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.html#Netfilter/iptables">Netfilter/iptables</a>过滤包，其中<code>iptables</code>为用户交互接口（<code>iptable-services</code>）。</p>
<h4 id="防火墙规则管理"><a class="header" href="#防火墙规则管理">防火墙规则管理</a></h4>
<pre><code class="language-shell">iptables -t,--table TABLE -OP CHAIN rule_spec  # 链名为大写，表名为小写
</code></pre>
<p><code>-t TABLE</code>：指定访问的<a href="Linux/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.html#%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F-%E8%A1%A8">表</a>（省略则查看<code>filter</code>表）；</p>
<p><code>-OP CHAIN</code>：指定访问的<a href="Linux/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.html#%E5%A4%84%E7%90%86%E4%BD%8D%E7%BD%AE-%E9%93%BE">链</a>（省略链名则查看所有链）及其操作（例如<code>-L FORWARD</code>）；</p>
<h5 id="查询规则"><a class="header" href="#查询规则">查询规则</a></h5>
<pre><code class="language-sh">iptables -t TABLE -L,--list CHAIN -v -n --line-number -x  # 列出所有规则
iptables -t TABLE -C,--check CHAIN RULE_SPEC  # 检查指定规则是否存在
</code></pre>
<p><code>-n</code>：不反向解析IP地址（显示IP地址而非域名，加快速度）；
<code>--line,--line-number</code>：显示规则编号；
<code>-v</code>：显示更多信息（分组数、字节数等）；
<code>-x</code>：显示精确的计数，而非经过单位转换的数据。</p>
<h5 id="管理规则"><a class="header" href="#管理规则">管理规则</a></h5>
<pre><code class="language-sh">iptables -I,--insert  CHAIN [NUM] RULE -j TARGET # 在表首部插入一条规则
iptables -A,--append  CHAIN       RULE -j TARGET # 在表尾部插入一条规则
iptables -R,--replace CHAIN  NUM  RULE -j TARGET # 替换指定编号的规则
iptables -D,--delete  CHAIN       RULE -j TARGET # 删除匹配条件的规则
iptables -D           CHAIN  NUM                 # 删除指定编号的规则
iptables -F,--flush   CHAIN                      # 清空表中的规则
</code></pre>
<blockquote>
<p>默认的表为<code>-t filter</code>。</p>
</blockquote>
<p>添加相同的规则不会覆盖已有规则，可用以下命令修改已有规则的动作：</p>
<pre><code class="language-sh">iptables -t filter -R INPUT 2 &lt;rules&gt; -j &lt;traget&gt;  # 修改指定规则的动作
</code></pre>
<blockquote>
<p>必须指定要修改规则的条件，否则该规则的条件将变为默认值（例如IP将变为<code>anywhere</code>）。</p>
</blockquote>
<p>修改默认策略</p>
<pre><code class="language-sh">iptables -t filter -P FORWARD DROP
</code></pre>
<h5 id="黑白名单机制"><a class="header" href="#黑白名单机制">黑白名单机制</a></h5>
<p>黑名单：将默认策略设置为<code>ACCEPT</code>；在规则中添加阻止策略。</p>
<p>白名单：将默认策略设置为<code>DROP</code>，在规则中添加允许策略。</p>
<blockquote>
<p>默认策略设置为<code>DROP</code>的缺点：在对应的链中没有设置任何规则时，管理员也会把自己拒之门外；即使对应的链中存在放行规则，当不小心使用&quot;<code>iptables -F</code>&quot;清空规则时，放行规则被删除，则所有数据包都无法进入。所以，如果想要使用&quot;白名单&quot;的机制，最好将链的默认策略保持为&quot;<code>ACCEPT</code>&quot;，然后将&quot;拒绝所有请求&quot;这条规则放在链的尾部，将&quot;放行规则&quot;放在前面，这样做，既能实现&quot;白名单&quot;机制，又能保证在规则被清空时，管理员还有机会连接到主机。</p>
</blockquote>
<h5 id="自定义链"><a class="header" href="#自定义链">自定义链</a></h5>
<p>自定义链仅对应一种类型的表，自定义链中规则配置方式与默认链相同。</p>
<pre><code class="language-sh">iptables -t filter -N,--new-chain IN_WEB   # 创建用于filter表的自定义链
iptables -E,--rename-chain IN_WEB WEB      # 重命名
iptables -X,--delete-chain WEB             # 删除自定义链，需未被引用且不包含任何规则
iptables -t filter -I INPUT RULE -j IN_WEB # 引用自定义链
</code></pre>
<h5 id="保存规则"><a class="header" href="#保存规则">保存规则</a></h5>
<p>通过<code>iptables</code>对规则的修改并非永久生效，当重启<code>iptables</code>服务或者重启服务器以后规则便失效了。如果想要修改永久生效，必须使用<code>service iptables save</code>保存规则，如果误操作了规则但是并没有保存，那么使用<code>service iptables restart</code>命令重启<code>iptables</code>以后即恢复修改前的状态。</p>
<blockquote>
<p>目前的发现版多数已用防火墙软件（如<code>CentOS/firewall</code>、<code>Ubuntu/ufw</code>）代替了<code>iptable-services</code>了，因此使用上述方法需要安装该服务。</p>
</blockquote>
<pre><code class="language-sh">iptables-save     # 将防火墙规则导出到标准输出
iptables-restore  # 从标准输入导入防火墙规则
</code></pre>
<h4 id="包匹配条件"><a class="header" href="#包匹配条件">包匹配条件</a></h4>
<p>多个条件之间具有<code>AND</code>关系，使用<code>!</code>对条件取反。</p>
<p><strong>基本匹配条件</strong>：</p>
<pre><code class="language-sh"># IP地址
-s sip1,sip2 -d dip1
-s ip/mask
# 协议类型
-p tcp # all, tcp, udp, udplite, icmp, icmpv6,esp, ah, sctp, mh
# 网卡接口
-i eth0 -o eth1
</code></pre>
<blockquote>
<p><code>-i</code>选项只能用于上图中的<code>PREROUTING</code>链、<code>INPUT</code>链、<code>FORWARD</code>链；<code>-o</code>选项只能用于<code>FORWARD</code>链、<code>OUTPUT</code>链、<code>POSTROUTING</code>链。</p>
</blockquote>
<p><strong>扩展匹配条件</strong>：由<code>netfilter</code>的扩展模块处理的条件。</p>
<pre><code class="language-sh"># 端口
-m tcp --sport 1:1024 --dport 22     # 需要指定扩展模块tcp, udp, icmp
-m tcp --sport :1024 --dport 10000:  # 可省略一个端口边界参数
-m multiport --dports 22,36,80:100
# IP范围
-m iprange --src-range 192.168.1.127-192.168.1.146  # --dst-range
# 字符串：匹配报文中包含的字符串
-m string --algo bm --string xyz
# time
-m time --datestart 2017-12-24 --datestop 2017-12-27
-m time --timestart 09:00:00 --timestop 18:00:00
-m time --weekdays 6,7 --monthdays 22,23
</code></pre>
<blockquote>
<p>当扩展模块的名称与协议名称相同的情况下，如果已经指定了协议，则可以省略模块选项。</p>
<p><code>--algo</code>指定字符串匹配算法，可选算法有<code>bm</code>与<code>kmp</code>。</p>
</blockquote>
<pre><code class="language-sh"># connlimit 限制连接数量
-m connlimit --connlimit-above 2 --connlimit-mask 24 -j DROP
</code></pre>
<blockquote>
<p><code>--connlimit-mask</code>表示对一个网段施加连接数限制（未指定时为对每个IP的连接数进行限制）</p>
</blockquote>
<pre><code class="language-sh"># limit 使用令牌桶限制报文速率
-p icmp -m limit --limit 10/minute -j ACCEPT
-p icmp -m limit --limit-burst 3 --limit 10/minute -j ACCEPT
</code></pre>
<blockquote>
<p><code>--limit</code>：报文允许的速率（令牌的生成速率，单位可以是<code>second</code>,<code>minute</code>,<code>hour</code>,<code>day</code>）；
<code>--limit-burst</code>：允许的突发流量（令牌桶的容量，默认值为5）；</p>
<p>需要添加一条默认<code>DROP/REJECT</code>的规则，以丢弃超过速率限制的包。</p>
</blockquote>
<p>其他扩展条件：<code>tcp-flags</code>、<code>state</code></p>
<p>http://www.zsythink.net/archives/1578</p>
<h4 id="动作-1"><a class="header" href="#动作-1">动作</a></h4>
<p><code>REJECT</code>可以附加发送一个ICMP响应报文。</p>
<pre><code class="language-sh">-j REJCT --reject-with icmp-host-unreachable
</code></pre>
<pre><code class="language-sh">-j LOG --log-prefix &quot;logname&quot; --log-level alert
</code></pre>
<blockquote>
<p><code>LOG</code>动作默认将报文的相关信息记录在<code>/var/log/message</code>文件中，通过修改<code>/etc/rsyslog.conf</code>（或<code>/etc/syslog.conf</code>），</p>
<pre><code class="language-sh">kern.warning /var/log/iptables.log
</code></pre>
<p><code>--log-level</code>：<code>emerg</code>，<code>alert</code>，<code>crit</code>，<code>error</code>，<code>warning</code>，<code>notice</code>，<code>info</code>，<code>debug</code>。</p>
</blockquote>
<h4 id="端口管理"><a class="header" href="#端口管理">端口管理</a></h4>
<pre><code class="language-sh">sudo vi /etc/sysconfig/iptables
</code></pre>
<h5 id="端口权限"><a class="header" href="#端口权限">端口权限</a></h5>
<p>小于1024的端口号（特权端口）不允许非root用户打开，以防恶意程序占用这些端口建立恶意服务。</p>
<p>如果用户需要使用这些端口，解决方法包括：</p>
<ol>
<li>
<p>使用Apache或nginx作为代理服务器；</p>
</li>
<li>
<p>使用iptables设置防火墙规则，<a href="https://confluence.atlassian.com/confkb/permission-denied-error-when-binding-a-port-290750651.html">使得低端口在内部自动转发至高端口</a>；</p>
</li>
<li>
<p>jsvc</p>
</li>
<li>
<p>authbind</p>
</li>
<li>
<p><a href="https://superuser.com/questions/710253/allow-non-root-process-to-bind-to-port-80-and-443#">设置文件打开端口的权限</a></p>
<pre><code class="language-shell">sudo setcap CAP_NET_BIND_SERVICE=+eip /path/to/binary
</code></pre>
</li>
</ol>
<h3 id="路由配置"><a class="header" href="#路由配置">路由配置</a></h3>
<h4 id="转发功能"><a class="header" href="#转发功能">转发功能</a></h4>
<p>开启防火墙的转发功能。</p>
<pre><code class="language-sh">echo 1 &gt; /proc/sys/net/ipv4/ip_forward  # 设置为1开启转发，0关闭转发
sysctl -w net.ipv4.ip_foward=1
</code></pre>
<p>上述方式为设置系统运行时变量，要永久生效需要修改系统配置。</p>
<blockquote>
<p>Ubuntu使用<code>ufw</code>管理防火墙规则，其配置文件在<code>/etc/ufw/sysctl.conf</code>，其中对应的配置项为：</p>
<pre><code class="language-shell">net/ipv4/ip_forward=1
net/ipv6/conf/default/forwarding=1
net/ipv6/conf/all/forwarding=1
</code></pre>
<p>CentOS7中配置<code>/usr/lib/sysctl.d/00-system.conf</code>，并设置<code>net.ipv4.ip_forward=1</code>。</p>
</blockquote>
<p>设置<a href="Linux/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.html#%E5%86%85%E6%A0%B8%E9%98%B2%E7%81%AB%E5%A2%99">防火墙转发规则</a>：</p>
<pre><code class="language-sh">iptables -I FORWARD -m state --state ESTABLISHED,RELATED -j ACCEPT
</code></pre>
<h4 id="nat"><a class="header" href="#nat">NAT</a></h4>
<pre><code class="language-sh"># SNAT: 将源内网地址映射到公网地址
iptables -t nat -A POSTROUTING -s 10.1.0.0/16 -o eth0 -j SNAT --to-source 192.168.1.146 
# 动态SNAT: 动态将源内网地址映射到动态变化的公网地址
iptables -t nat -A POSTROUTING -s 10.1.0.0/16 -o eth0 -j MASQUERADE 
# DNAT: 将目的公网地址+端口映射到内网地址+端口
iptables -t nat -I PREROUTING \
  -d 192.168.1.146 -p tcp --dport 3389 -j DNAT --to-destination 10.1.0.6:3389
</code></pre>
<blockquote>
<p>DNAT在理论上只配置DNAT规则即可，但是如果在测试时无法正常DNAT，可以尝试增加对应的SNAT，此处按照配置SNAT的流程进行。</p>
<p>如果没有动态SNAT的需求，没有必要使用<code>MASQUERADE</code>，因为SNAT更加高效。</p>
</blockquote>
<h5 id="本机端口转发"><a class="header" href="#本机端口转发">本机端口转发</a></h5>
<pre><code class="language-sh">iptables -t nat -A PREROUTING -p tcp --dport 80 -j REDIRECT --to-ports 8080 # INPUT
iptables -t nat -A OUTPUT -p tcp --dport 80 -j REDIRECT --to-port 8080      # LOCAL
iptables -t nat -A PREROUTING -i eth0 -p tcp --dport 1186 -j DNAT --to-destination 127.0.0.1:1186
</code></pre>
<blockquote>
<p>将访问本机80端口的请求重定向到本机的8080端口（修改目标端口）。</p>
</blockquote>
<p>如果要从外部访问本机<code>localhost</code>监听的端口，可使用DNAT将地址和端口映射到本机换回地址和相应端口（需要开启本地换回路由：<code>sysctl -w net.ipv4.conf.&lt;ifname&gt;.route_localnet=1</code> ，<code>ifname</code>为输入网络接口）。</p>
<h4 id="路由表"><a class="header" href="#路由表">路由表</a></h4>
<h5 id="获取路由信息"><a class="header" href="#获取路由信息">获取路由信息</a></h5>
<pre><code class="language-shell">ip {r|route}
#default via 192.168.178.2 dev ens32 proto static
#default via 172.28.76.234 dev ens33 scope link metric 1
#172.28.76.0/24 dev ens33 proto kernel scope link src 172.28.76.234
#192.168.178.0/24 dev ens32 proto kernel scope link src 192.168.178.40
</code></pre>
<p>表格形式：</p>
<pre><code class="language-shell">route [-nee]   
#Destination    Gateway        Genmask       Flags  Metric ...  Iface
#0.0.0.0        192.168.178.2  0.0.0.0        UG      0    ...  ens32
#0.0.0.0        172.28.76.234  0.0.0.0        UG      1    ...  ens33
#172.28.76.0    0.0.0.0        255.255.255.0  U       0    ...  ens33
#192.168.178.0  0.0.0.0        255.255.255.0  U       0    ...  ens32
netstat -r -n
#Kernel IP routing table
#Destination    Gateway        Genmask        Flags MSS Window irtt Iface
#0.0.0.0        172.28.76.234  0.0.0.0        UG      0 0         0 ens33
#172.28.76.0    0.0.0.0        255.255.255.0  U       0 0         0 ens33
</code></pre>
<blockquote>
<p><code>ee</code>：显示更多信息。</p>
</blockquote>
<ul>
<li>
<p>路由类型</p>
<p>主机路由：掩码为32位；
网络路由：
默认路由：目标为<code>0.0.0.0/0.0.0.0</code>。当主机不能在路由表中查找到目标主机的IP地址或网络路由时，数据包就被发送到默认路由（默认网关）上。</p>
</li>
<li>
<p>Flags说明：
<code>U</code> (route is up)：活动路由；
<code>H</code> (target is host)：目的地址是主机；
<code>G</code> (use gateway)： 需要网关转发；</p>
</li>
<li>
<p><code>Metric</code>：路由距离，到达指定网络所需的中转数。</p>
</li>
<li>
<p><code>Iface</code>: 当前路由会使用哪个接口来发送数据</p>
</li>
</ul>
<h5 id="配置静态路由"><a class="header" href="#配置静态路由">配置静态路由</a></h5>
<pre><code class="language-shell">route [add|del] [-net | -host] target [netmask Nm] [gw Gw] [[dev] If]
route add default gw 192.168.1.1
route add -net 5.0.0.0 netmask 255.0.0.0 reject # 设置到指定网络为不可达
</code></pre>
<blockquote>
<p>没有修改已有路由的命令（例如修改metric），需要先删除再添加一条。</p>
</blockquote>
<p>上述命令仅在当前运行环境中有效，要永久保存需要将其添加至文件中。可直接在在<code>/etc/rc.local</code>中添加上述命令，则开机会自动添加静态路由，但如果开机状态下重启网络服务则不会再次执行<code>/etc/rc.local</code>，导致静态路由失效。</p>
<p>另一种方式是编辑<code>/etc/sysconfig/static-routes</code>（CentOS/Fedora），该文件由网络服务自动加载。</p>
<pre><code class="language-shell">any -net 192.56.76.0 netmask 255.255.255.0 dev eth0
</code></pre>
<blockquote>
<p>由<code>any</code>开头的行将被解释为静态路由项。</p>
<blockquote>
<p>Ubuntu静态路由配置？</p>
</blockquote>
</blockquote>
<p><code>ip</code>工具包用于替换<code>route</code>等管理工具：</p>
<pre><code class="language-shell">ip route {add|del|change|append|replace} ROUTE
#  ROUTE= [TYPE] NETWORK/MASK [via [FAMILY] GW_IP] [dev DEVICE] [weight NUM]
ip route add default via 192.168.1.1 dev eth0  # 设置默认路由
</code></pre>
<p><code>TYPE</code>：路由类型，包括<code>unicast,mulitcast,broadcast,nat,local,...</code>；</p>
<p><code>FAMILY</code>：协议族：<code> inet,inet6,mpls,bridge,link</code>；</p>
<h3 id="本地网络代理"><a class="header" href="#本地网络代理">本地网络代理</a></h3>
<p>可配置系统范围（<code>/etc/environment</code>）或用户范围（<code>~/.bashrc</code>或<code>~/.profile</code>）。</p>
<pre><code class="language-shell">export http_proxy=&quot;http://USERNAME:PASSWORD@proxy.server.net:port/&quot;
export https_proxy=&quot;http://proxy.server.net:port/&quot;
export ftp_proxy=&quot;http://proxy.server.net:port/&quot;
export no_proxy=&quot;localhost, 127.0.0.1, 192.168.178.4&quot;  #*
</code></pre>
<blockquote>
<p><code>*</code>：<code>no_proxy</code>不支持通配符，如果要写一个网段，只能逐个地址列出。<a href="https://unix.stackexchange.com/questions/23452/set-a-network-range-in-the-no-proxy-environment-variable"><code>no_proxy</code>主要用于匹配域名后缀，而非IP地址（前缀）</a>。</p>
</blockquote>
<p>如果是系统范围代理，还需设置<code>/etc/sudoers.d/proxy</code>，避免环境变量被覆盖。</p>
<pre><code class="language-shell">Defaults env_keep+=&quot;http_proxy https_proxy no_proxy&quot;
</code></pre>
<h3 id="网络服务"><a class="header" href="#网络服务">网络服务</a></h3>
<pre><code class="language-sh">systemctl restart networking
</code></pre>
<h4 id="常用网络服务"><a class="header" href="#常用网络服务">常用网络服务</a></h4>
<p>远程访问</p>
<h4 id="x-window"><a class="header" href="#x-window">X-Window</a></h4>
<p><a href="https://wiki.ubuntu.org.cn/%E7%90%86%E8%A7%A3_Xwindow">https://wiki.ubuntu.org.cn/%E7%90%86%E8%A7%A3_Xwindow</a></p>
<h2 id="安全"><a class="header" href="#安全">安全</a></h2>
<h3 id="内核强制访问控制"><a class="header" href="#内核强制访问控制">内核强制访问控制</a></h3>
<p>Both SELinux and AppArmor supports the Type Enforcement security model, which is a type of mandatory access control, based on rules where <strong>subjects (processes or users) are allowed to access objects (files, directories, sockets, etc.)</strong>. </p>
<p><a href="https://www.tecmint.com/mandatory-access-control-with-selinux-or-apparmor-linux/">Implementing Mandatory Access Control with SELinux or AppArmor in Linux (tecmint.com)</a></p>
<h4 id="security-enhanced-linux"><a class="header" href="#security-enhanced-linux">Security Enhanced Linux</a></h4>
<p>SELinux支持更强的访问控制。</p>
<p>查看SELinux状态：</p>
<pre><code class="language-sh">getenforce
sestatus -v
</code></pre>
<p>临时关闭（设置成<code>permissive</code>模式，仅产生日志不进行控制）：</p>
<pre><code class="language-sh">sudo setenforce 0	# setenforce 1 =&gt; enforcing mode 
</code></pre>
<p>永久关闭：</p>
<pre><code class="language-sh"># sudo vi /etc/selinux/config
SELINUX=disabled   # SELINUX=enforcing|permissive|disabled
</code></pre>
<h5 id="selinux策略"><a class="header" href="#selinux策略">SELinux策略</a></h5>
<p>查看<code>boolean</code>策略状态：</p>
<pre><code class="language-shell">getsebool -a [se_boolean_entry]
</code></pre>
<p>设置<code>boolean</code>策略：</p>
<pre><code class="language-shell">setsebool -PV se_bool_entry value  # (1|true|on,0|false|off)
</code></pre>
<h4 id="apparmor"><a class="header" href="#apparmor">Apparmor</a></h4>
<p>AppArmor是与SELinux类似的一个访问控制系统，通过它你可以指定程序可以读、写或运行哪些文件，是否可以打开网络端口等。</p>
<p><a href="http://www.361way.com/linux-apparmor/3646.html">linux内核强制访问控制－－Apparmor - 运维之路 (361way.com)</a></p>
<p><a href="http://www.361way.com/apparmor-selinux/3648.html">AppArmor与SELinux - 运维之路 (361way.com)</a></p>
<h3 id="数字证书"><a class="header" href="#数字证书">数字证书</a></h3>
<h4 id="安装证书"><a class="header" href="#安装证书">安装证书</a></h4>
<p>系统信任证书目录位于<code>/usr/local/share/ca-certificates</code>。将证书文件置于该目录下，并将权限设置为<code>644</code>。</p>
<pre><code class="language-shell">sudo apt install ca-certificates
sudo update ca-certificates   # needs super user privilege
</code></pre>
<h4 id="生成证书和私钥"><a class="header" href="#生成证书和私钥">生成证书和私钥</a></h4>
<p>OpenSSL是一个非常有用的开源命令行工具包，可用于 <a href="https://www.ssl.com/zh-CN/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/%E4%BB%80%E4%B9%88%E6%98%AFx-509%E8%AF%81%E4%B9%A6/">X.509</a> 证书，证书签名请求（CSRs）和加密密钥。</p>
<pre><code class="language-sh">openssl req -x509 -newkey rsa:4096 -keyout key.pem -out cert.pem -days 365
openssl x509 -in cert.pem -text -noout  # 查看证书结构信息
</code></pre>
<blockquote>
<p><code>key.pem</code>为私钥；<code>cert.pem</code>为证书（包含公钥）；生成签名过程设置的密码是在使用密钥的时候使用。</p>
<p>使用私钥和证书需要输入制作时设置的密码。</p>
<p><a href="Linux/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.html#%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6">PEM格式</a>。</p>
</blockquote>
<h5 id="详细步骤"><a class="header" href="#详细步骤">详细步骤</a></h5>
<p>Create an RSA Keypair：</p>
<pre><code class="language-sh">sudo apt install openssl
openssl genrsa -des3 -passout pass:PASSWORD -out keypair.key 2048
</code></pre>
<p>Extract the Private Key：</p>
<pre><code class="language-sh">openssl rsa -passin pass:PASSWORD -in keypair.key -out private.key
</code></pre>
<p>Creating a “Certificate Signing Request” or <code>CSR</code> File：</p>
<pre><code class="language-sh">openssl req -new -key private.key -out service.csr
</code></pre>
<p>Creating the Certificate “<code>.crt</code>” File：</p>
<pre><code class="language-sh">openssl x509 -req -days 365 -in service.csr -signkey private.key -out service.crt
</code></pre>
<p>https://www.rosehosting.com/blog/how-to-generate-a-self-signed-ssl-certificate-on-linux/</p>
<p>https://www.linux.com/tutorials/creating-self-signed-ssl-certificates-apache-linux/</p>
<h3 id="ssltls"><a class="header" href="#ssltls">SSL/TLS</a></h3>
<h2 id="权限管理"><a class="header" href="#权限管理">权限管理</a></h2>
<h3 id="用户管理"><a class="header" href="#用户管理">用户管理</a></h3>
<h4 id="创建用户"><a class="header" href="#创建用户">创建用户</a></h4>
<pre><code class="language-shell">useradd -m -c &quot;FULL NAME&quot; -g GROUP USERNAME   # [lowlevel]
adduser --home DIR --shell SHELL --ingroup GROUP USERNAME 
</code></pre>
<blockquote>
<p><code>adduser</code>在Debian系发行版上重新封装了底层<code>useradd</code>命令，其他发行版上是<code>useradd</code>的别名。以下均为<code>useradd</code>选项。</p>
<p>有效用户名模式：<code>[a-z_][a-z0-9_-]*[$]?</code>，长度不超过32。</p>
<p><code>-c &quot;COMMENT&quot;</code>：通常用于设置用户名全称；</p>
<p><code>-s,--shell SHELL</code> 用户的登录shell程序，<code>/etc/default/useradd#SHELL</code>（<code>chsh</code>）。</p>
</blockquote>
<h5 id="用户目录"><a class="header" href="#用户目录">用户目录</a></h5>
<ul>
<li><code>-b,--base-dir BASE_DIR</code>：用户主目录的根目录路径，默认值为<code>/etc/default/useradd#HOME=/home</code>；</li>
<li><code>-d,--home-dir HOME_DIR</code>：用户主目录路径，默认值为<code>$BASE_DIR/USERNAME</code>；</li>
<li>使用<code>-m,--create-home</code>保证创建用户目录；<code> -M,--no-create-home</code>不创建用户目录（通常用于运行系统服务的非登录用户）；</li>
</ul>
<h5 id="用户组"><a class="header" href="#用户组">用户组</a></h5>
<ul>
<li><code>-g,--gid GROUP</code>：用户的初始登录组（<em>primary group</em>：ID或名称，必须存在）。
如果未指定该选项，默认（<code>/etc/login.defs#USERGROUPS_ENAB=yes</code>）会自动创建与用户名同名的组（等效于指定<code>-U,--create-user-group</code>选项）；如果<code>USERGROUPS_ENAB=no</code>，则新用户的主要组设置为<code>/etc/default/useradd#GROUP=100</code>。</li>
<li><code>-G,--groups groupname[,...]</code>：将用户<a href="Linux/Linux%E9%85%8D%E7%BD%AE%E5%92%8C%E7%AE%A1%E7%90%86.html#%E7%BB%84%E7%AE%A1%E7%90%86">添加至组</a>（<em>supplementary groups</em>）；</li>
</ul>
<h5 id="账户和密码有效性"><a class="header" href="#账户和密码有效性">账户和密码有效性</a></h5>
<ul>
<li><code>-f,--inactive DAYS</code>：密码过期后账户被禁用前的天数。</li>
<li><code>-e,--expiredate YYYY-MM-DD</code>：账户失效（禁用）日期，默认值为<code>/etc/default/useradd#EXPIRE=''</code>（不失效）；</li>
</ul>
<h4 id="修改用户"><a class="header" href="#修改用户">修改用户</a></h4>
<p>使用<code>usermod</code>修改用户属性（多数属性对应的选项与<code>useradd</code>相同)。</p>
<pre><code class="language-shell">usermod -a,--append -G GROUPNAME  # 将用户添加到supplementary groups
usermod -l,--login NAME # 修改登录名 
usermod -m,--move-home -d,--home HOME  # (移动)修改用户主目录
</code></pre>
<h5 id="设置账户有效期限"><a class="header" href="#设置账户有效期限">设置账户有效期限</a></h5>
<pre><code class="language-shell">usermod -e,--expiredate YYYY-MM-DD/N/-1 USER # 设置失效日期*
chage   -E,--expiredate YYYY-MM-DD/N/-1 USER  
</code></pre>
<blockquote>
<p><code>*</code>：<code>N</code>表示自1970年1月1日的天数。</p>
</blockquote>
<p>此外，<a href="Linux/Linux%E9%85%8D%E7%BD%AE%E5%92%8C%E7%AE%A1%E7%90%86.html#%E5%AF%86%E7%A0%81%E6%9C%89%E6%95%88%E6%9C%9F%E9%85%8D%E7%BD%AE">账户密码失效</a>后账户也会处于失效状态。</p>
<h5 id="设置和更新密码"><a class="header" href="#设置和更新密码">设置和更新密码</a></h5>
<p>创建用户时默认禁用密码。使用<code>passwd</code>设置和更新密码（<code>root</code>账号可修改普通用户的密码，用户忘记密码可通过<code>root</code>帐号使用<code>passwd</code>指令来处理即可）。</p>
<pre><code class="language-sh">passwd username
usermod -p,--password ENCRYPT_PASSWORD
passwd -d,--delete  # 删除(置空)用户密码
</code></pre>
<blockquote>
<p>如果<code>root</code>帐号忘记了，可以进入单人维护模式，此时系统会给予提供<code>root</code>权限的<code>bash</code>接口，再用<code>passwd</code>修改密码；或者利用Live CD开机后挂载根目录去修改<code>/etc/shadow</code>，将<code>root</code>的密码删除，重新开机后再用<code>passwd</code>设置新密码。</p>
</blockquote>
<h5 id="密码有效期配置"><a class="header" href="#密码有效期配置">密码有效期配置</a></h5>
<pre><code class="language-shell">passwd -e,--expire  # 立即使用户密码失效, 用户必须在下次登录时重设密码
passwd -x,--maxdays  DAYS USER #-&gt;chage -M 密码有效期天数(99999/-1)*
passwd -i,--inactive DAYS USER #-&gt;chage -I 密码失效后禁用账户前的天数(never)
passwd -n,--mindays  DAYS USER #-&gt;chage -m 两次修改密码之间至少相隔的天数(0)
passwd -w,--warndays DAYS USER #-&gt;chage -W 需要修改密码前向发送警告的天数(7)
</code></pre>
<blockquote>
<p><code>*</code>：<code>chage</code>的长选项与<code>passwd</code>对应长选项一致。</p>
</blockquote>
<p>显示密码状态：</p>
<pre><code class="language-shell">passwd -S &lt;user&gt;  # 使用-a代替&lt;user&gt;查看所有用户的密码状态。
# gary P 06/02/2022  0 99999 7 -1
chage -l &lt;user&gt;
# Last password change                              : Jun 02, 2022
# Password expires                                  : never
# Password inactive                                 : never
# Account expires                                   : never
# Minimum number of days between password change    : 0
# Maximum number of days between password change    : 99999
# Number of days of warning before password expires : 7
</code></pre>
<h4 id="删除用户"><a class="header" href="#删除用户">删除用户</a></h4>
<pre><code class="language-shell">userdel -f $USER     # deluser [Debian]
rm -rf /home/$USER
</code></pre>
<h4 id="查看用户信息"><a class="header" href="#查看用户信息">查看用户信息</a></h4>
<p>查系统中的<a href="Linux/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.html#%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF%E5%AD%98%E5%82%A8">用户信息</a>：</p>
<pre><code class="language-shell">/etc/passwd  # User account information.
/etc/shadow  # Secure user account information. [read by root only]
</code></pre>
<p>查看当前登录的所有用户：</p>
<pre><code class="language-sh">w
# 09:42:35 up 26 min,  3 users,  load average: 0.18, 0.12, 0.09
#USER  TTY    FROM           LOGIN@   IDLE   JCPU   PCPU WHAT
#root  pts/0  172.28.76.41   09:17    3.00s  0.13s  0.03s w
#root  pts/1  172.28.76.239  09:19   22:45   0.02s  0.02s -bash
</code></pre>
<blockquote>
<p><code>who</code>显示的信息没有<code>w</code>完整。<code>who</code>可以显示系统引导终端（<code>tty1</code>）。</p>
</blockquote>
<p>查看指定用户信息：</p>
<pre><code class="language-shell">id $USER  
# uid=1000(gary) gid=1000(gary) groups=1000(gary),...(secondary groups)
groups $USER        # 查看用户所属组
username=$(whoami)  # return user name
sudo whoami         # -&gt; root
</code></pre>
<blockquote>
<p><a href="https://linuxize.com/post/how-to-add-user-to-group-in-linux/">How to Add User to Group in Linux | Linuxize</a></p>
</blockquote>
<h3 id="组管理"><a class="header" href="#组管理">组管理</a></h3>
<pre><code class="language-shell">groupadd groupname
groupdel groupname
addgroup [options] [--gid ID] group
</code></pre>
<pre><code class="language-shell">sudo usermod -g groupname username      # change user's primary group
sudo usermod -a -G group[,...] username # add user to a secondary group
adduser user group  # add user to grpup
</code></pre>
<blockquote>
<p>If you omit the <code>-a</code> option, the user will be removed from any groups not listed after the <code>-G</code> option.</p>
</blockquote>
<pre><code class="language-shell">sudo gpasswd -d username groupname  # Remove a User From a Group
</code></pre>
<h5 id="查看组信息"><a class="header" href="#查看组信息">查看组信息</a></h5>
<pre><code class="language-shell">/etc/group   # Group account information.
/etc/gshadow # Secure group account information.
</code></pre>
<h3 id="访问权限控制"><a class="header" href="#访问权限控制">访问权限控制</a></h3>
<h4 id="访问权限"><a class="header" href="#访问权限">访问权限</a></h4>
<p>修改用户访问文件的权限：</p>
<pre><code class="language-sh">chmod [ugoa][+-=][rwxXstugo],... FILE ...
chmod OCTAL-MODE FILE ...
</code></pre>
<p><code>ugoa</code>分别代表文件所有用户，文件同组用户，其他用户和所有用户（省略则默认为<code>a</code>，umask？）；<code>+-=</code>表示增加、删除和设置权限。</p>
<p>权限模式：<code>rwxXst</code>中的一个或多个，或<code>ugo</code>中的一个</p>
<div class="table-wrapper"><table><thead><tr><th>标识</th><th>说明</th><th>标识</th><th>说明</th><th>标识</th><th>说明</th></tr></thead><tbody>
<tr><td><code>r</code></td><td>读文件</td><td><code>w</code></td><td>写文件</td><td><code>x</code></td><td>访问/执行</td></tr>
<tr><td><code>s</code></td><td>设置用户或组</td><td><code>t</code></td><td>限制删除</td><td><code>X</code></td><td>*</td></tr>
<tr><td><code>u</code></td><td>授予所有者权限</td><td><code>g</code></td><td>授予组用户权限</td><td><code>o</code></td><td>授予其他组权限</td></tr>
</tbody></table>
</div>
<blockquote>
<p><code>*</code>：<code>X</code>表示仅当目标为目录或已经具有其他用户执行权限时，才设置该目标的访问/执行权限。</p>
</blockquote>
<p><code>OCTAL-MODE</code>为1~4数字（取值范围0~7，3bit），第一位代表（设置用户ID，设置组ID和限制删除），其余三位数字分别代表<code>ugo</code>对应的<code>rwx</code>权限。</p>
<h4 id="ownership"><a class="header" href="#ownership">Ownership</a></h4>
<p>获取对象的所有者信息：</p>
<pre><code class="language-shell">ls -l /opt/360es/ | awk '{print $3,$4}'    # 根据字段位置确定
ls -l /opt/360es/ | sed -n '2,$p' | awk '{printf &quot;user=%s,group=%s\n&quot;,$3,$4}'
stat /path/file --format=&quot;user=%U group=%G&quot;
</code></pre>
<p>从外部（互联网）获取的文件（档案），其所有者信息非本机用户，因此导致本机用户无法正常访问文件，所以需要<strong>修改文件的所有者/组</strong>。</p>
<pre><code class="language-sh">chown -hR owner[:group] FILE
chgrp
</code></pre>
<blockquote>
<p><code>--dereference</code>：影响符号链接指向的文件而非符号链接；<code>-h,--no-dereference</code>相反；
<code>--from=CURRENT_OWNER:CURRENT_GROUP</code>：仅当文件的当前属性匹配才进行修改；
<code>--reference=RFILE</code>：使用<code>RFILE</code>的属性作为修改后的属性；
<code>-R</code>：递归修改。符号链接指向的文件夹的遍历规则根据以下选项决定：</p>
<ul>
<li><code>-H</code>：遍历命令行参数为符号链接锁指向的文件夹；</li>
<li><code>-L</code>：遍历所有符号链接指向的文件夹；</li>
<li><code>-P</code>：步遍历符号链接指向的文件夹（默认）。</li>
</ul>
</blockquote>
<h4 id="提升权限"><a class="header" href="#提升权限">提升权限</a></h4>
<h5 id="切换登录用户"><a class="header" href="#切换登录用户">切换登录用户</a></h5>
<pre><code class="language-sh">su - username # switch user
</code></pre>
<blockquote>
<p>不支持切换到非登录用户。</p>
</blockquote>
<h5 id="以管理员身份运行"><a class="header" href="#以管理员身份运行">以管理员身份运行</a></h5>
<pre><code class="language-shell">sudo \
    -u, --user=user \ # 指定用户执行输入的命令
    -i,--login \      # 使用指定用户登录shell
    [command]         # 运行命令（未指定则切换终端用户）
</code></pre>
<p>当前多数发行版默认禁用<code>root</code>账户，并以安装系统期间创建的账户作为管理员。管理员需要使用<code>sudo</code>命令并提供密码以暂时获得<code>root</code>账户<a href="Linux/Linux%E9%85%8D%E7%BD%AE%E5%92%8C%E7%AE%A1%E7%90%86.html#%E6%8F%90%E5%8D%87%E6%9D%83%E9%99%90">权限</a>（使用<code>sudo</code>命令创建的文件其所属用户和组为<code>root</code>）。将其他用户加入<code>sudo</code>用户组使其具有运行<code>sudo</code>的权限。如果要恢复<code>root</code>账户（不推荐），为其设置密码：</p>
<pre><code class="language-shell">sudo passwd root
</code></pre>
<h2 id="帮助文档"><a class="header" href="#帮助文档">帮助文档</a></h2>
<h5 id="linux-manual"><a class="header" href="#linux-manual">Linux Manual</a></h5>
<ol>
<li>可执行程序和Shell命令；</li>
<li>系统调用函数文档；</li>
<li>库函数文档；</li>
<li>特殊设备文件（通常位于<code>/dev</code>）；</li>
<li>系统内置文件格式和规范（如<code>/etc/passwd</code>）；</li>
<li>游戏；</li>
<li>其他，如<code>man(7)</code>；</li>
<li>系统管理命令（管理员使用）；</li>
<li>内核过程（非标准）。</li>
</ol>
<h2 id="急救模式"><a class="header" href="#急救模式">急救模式</a></h2>
<p><em><strong>emergency mode</strong></em></p>
<h3 id="进入急救模式"><a class="header" href="#进入急救模式">进入急救模式</a></h3>
<ol>
<li>
<p>GRUB系统选择界面按<code>e</code>进入启动配置项编辑模式；</p>
<pre><code class="language-shell">linux16 /vmlinuz-....   # 添加rd.break
</code></pre>
</li>
<li>
<p>按<code>Ctrl+X</code>进入急救模式。</p>
</li>
</ol>
<h3 id="修复磁盘"><a class="header" href="#修复磁盘">修复磁盘</a></h3>
<h5 id="修复xfs文件系统"><a class="header" href="#修复xfs文件系统"><a href="https://blog.csdn.net/heian_99/article/details/123380912">修复XFS文件系统</a></a></h5>
<p>由于突然断电，导致XFS文件系统数据损坏。</p>
<pre><code class="language-shell">ls -l /dev/mapper  # 找到dm-0对应的挂载点并卸载设备
umount /dev/mapper/centos-root
xfs_repair -L /dev/mapper/centos-root # 修复该设备
init 6 # 成功修复后重启设备
</code></pre>
<h2 id="参考资料-3"><a class="header" href="#参考资料-3">参考资料</a></h2>
<div class="footnote-definition" id="mount"><sup class="footnote-definition-label">1</sup>
<p><a href="https://superuser.com/questions/663213/two-distinct-mount-points-with-one-device">linux - Two distinct mount points with one device - Super User</a>.
<sup class="footnote-reference"><a href="#pid1">2</a></sup>:<a href="http://0pointer.de/blog/projects/systemd.html">Rethinking PID 1 (0pointer.de)</a>.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="linux配置和管理-1"><a class="header" href="#linux配置和管理-1">Linux配置和管理</a></h1>
<h2 id="文件管理-2"><a class="header" href="#文件管理-2">文件管理</a></h2>
<p>在Linux/UNIX中，所有的对象都被视为文件，包括普通文件、目录、设备、套接字。</p>
<h3 id="目录路径-1"><a class="header" href="#目录路径-1">目录路径</a></h3>
<pre><code class="language-sh">pwd                   # Print Working Directory
dirname filename      # parent directory
basename filename     # 
</code></pre>
<blockquote>
<p><code>pwd</code>列出正在工作的目录，用于显示你当前所处的目录名。<code>pwd</code>命令总是返回你当前所处的目录的完全路径名。<code>dirname</code>返回查询路径的父目录（从文件路径中截取）。<code>basename</code>仅返回文件的名称。</p>
</blockquote>
<p><code>readlink</code>和<code>realpath</code>解析文件的绝对路径，跟踪解析所有符号链接。</p>
<pre><code class="language-shell">readlink -e \ # 解析过程中的所有目标必须存在 =&gt; realpath -e filename
         -f \ # 除最终目标外所有目标必须存在 =&gt; realpath    filename
         -m \ # 允许目标不存在             =&gt; realpath -m filename
         FILENAME 
</code></pre>
<h5 id="切换目录-1"><a class="header" href="#切换目录-1">切换目录</a></h5>
<pre><code class="language-shell">cd  [dir_name]     # 切换工作目录（Change Directory）
chroot [OPTION] NEWROOT [COMMAND [ARG]...]  # 切换命令运行的根目录
</code></pre>
<blockquote>
<p>不带任何参数时，将把你送回自己的用户主目录中（等效于<code>cd ~</code>）。<code>..</code>表示父目录。</p>
<p>登录完成后，工作目录为用户主目录。</p>
</blockquote>
<h5 id="创建目录-1"><a class="header" href="#创建目录-1">创建目录</a></h5>
<p>在每一个新的子目录中，均包含两个标准的项目：<code>.</code>代表当前目录和<code>..</code>代表父目录。</p>
<pre><code class="language-shell">mkdir -m,--mode=MODE -p dir_name 
install [OPTIONS] -d dir1 dir2 ...   # 创建目录并设置权限
</code></pre>
<blockquote>
<p><code>-m</code>：可用来创建一个带有特定权限的子目录（<code>chmod</code>声明方式）。
<code>-p</code>：父目录不存在的情况下首先创建父目录，忽略已存在目录（默认报错）。</p>
</blockquote>
<h5 id="删除目录-1"><a class="header" href="#删除目录-1">删除目录</a></h5>
<pre><code class="language-sh">rmdir -p dir_name ...   # -p 一次删除多个目录
</code></pre>
<blockquote>
<p><code>dir_name</code>不能为当前工作目录（即要在父目录中删除子目录）。应该拥有被删除目录的写该目录必须为空目录（即只包含<code>.</code>和<code>..</code>，否则使用<code>rm -rf dir_name</code>）。</p>
</blockquote>
<h4 id="显示目录中的项目-1"><a class="header" href="#显示目录中的项目-1">显示目录中的项目</a></h4>
<h5 id="列表显示-1"><a class="header" href="#列表显示-1">列表显示</a></h5>
<pre><code class="language-sh">ls [options] [dir_name]
</code></pre>
<h6 id="文件过滤选项-1"><a class="header" href="#文件过滤选项-1">文件过滤选项</a></h6>
<p><code>-a</code>：显示所有文件（包括以<code>.</code>开头的文件（夹）），<code>-A</code>仅忽略<code>.</code>和<code>..</code>；
<code>-R</code>：递归显示所有子目录的内容；
<code>-d</code>：只显示目录条目的信息；</p>
<h6 id="文件信息选项-1"><a class="header" href="#文件信息选项-1">文件信息选项</a></h6>
<p><code>-l</code>：列表显示目录中文件的详细信息，与其他排序方式组合使用时则显示相应的排序字段；<code>-g</code>与<code>-l</code>相似但不显示文件所有者，<code>-o</code>不显示用户组；</p>
<blockquote>
<p>文件类型信息：<code>-</code> 表示普通文件（<code>f</code>）；<code>d</code> 目录文件；<code>b</code>块设备文件例如磁盘；<code>c</code>字符设备文件，<code>p</code>命名管道（FIFO） ；<code>l</code>符号链接；<code>s</code> 套接字（socket）；</p>
</blockquote>
<p><code>--author</code>：显示文件创建者；
<code>-n</code>：显示数字形式的用户和用户组ID；
<code>-i</code>：<code>inode</code>序号将列在第一列；
<code>--time-STYLE</code>：时间显示格式，包括：<code>full-iso</code>（<code>2020-03-07 15:07:15.542112573 +0800</code>）、<code>long-iso</code>（<code>2020-03-07 17:34</code>）、<code>iso</code>（<code>03-07 15:07</code>）、<code>locale</code>（<code>Mar  7 15:07</code>）或<code>+FORMAT</code>；
<code>--full-time</code>：显示完整时间，等价于<code>-l --time-style=full-iso</code>；
<code>-h</code>：显示更加友好的文件长度信息（<code>1K 234M 2G</code>，等价<code>--human-readable</code>）；
<code>-s</code>：显示文件占用的磁盘容量；
<code>--block-size=SIZE</code>：<code>K,M,G,T,P,E,Z,Y</code> （powers of 1024）或 <code>KB,MB,...</code> （powers of 1000）</p>
<h6 id="排序选项-1"><a class="header" href="#排序选项-1">排序选项</a></h6>
<p><code>--sort=WORD</code>：<code>WORD=none(-U),size(-S),time(-t),version(-v),extension(-X)</code>，未声明排序选项时，<strong>默认</strong>按文件名排序。<code>-c</code>：按<code>ctime</code>（指文件的<code>inode</code>信息被改变的时间）排序；<code>-u</code>：按访问时间排序；<code>-t</code>：按修改时间排序，优先级低于<code>-c</code>和<code>-u</code>；
<code>-r</code>：反向排序；</p>
<h5 id="查看目录树-1"><a class="header" href="#查看目录树-1">查看<a href="Linux/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.html">目录树</a></a></h5>
<pre><code class="language-sh">tree -L &lt;n&gt; path  # not built-in
</code></pre>
<p><code>-L &lt;n&gt;</code>：搜索深度；<code>-l</code>：跟踪符号链接；</p>
<h4 id="文件信息-2"><a class="header" href="#文件信息-2">文件信息</a></h4>
<p>获取文件的信息：</p>
<pre><code class="language-sh">stat &lt;path/to/file&gt; -c,--format,--printf=FORMAT \
     -f,--file-system   # 显示文件所在文件系统信息而非文件信息
</code></pre>
<p>格式参数<code>FORMAT</code>可包含多个格式声明以及普通字符，<code>--printf</code>还可使用<code>&quot;\&quot;</code>转义字符；</p>
<div class="table-wrapper"><table><thead><tr><th>格式</th><th>内容</th><th>格式</th><th>内容</th><th>格式</th><th>内容</th><th>格式</th><th>内容</th><th>格式</th><th>内容</th></tr></thead><tbody>
<tr><td><code>%n</code></td><td>文件名</td><td><code>%F</code></td><td>文件类型</td><td><code>%g</code></td><td>group id</td><td><code>%y</code></td><td>修改时间</td><td><code>%a</code></td><td>八进制访问权限</td></tr>
<tr><td><code>%N</code></td><td><code>&quot;文件名&quot;</code></td><td><code>%s</code></td><td>file bytes</td><td><code>%G</code></td><td>group name</td><td><code>%Y</code></td><td>修改时间戳</td><td><code>%A</code></td><td>字母访问权限</td></tr>
<tr><td><code>%h</code></td><td>硬链接数</td><td><code>%m</code></td><td>挂载点</td><td><code>%u</code></td><td>owner id</td><td><code>%w</code></td><td>创建时间</td><td><code>%x</code></td><td>访问时间</td></tr>
<tr><td><code>%i</code></td><td>inode数</td><td><code>%C</code></td><td>SELinux</td><td><code>%U</code></td><td>owner name</td><td><code>%W</code></td><td>创建时间戳</td><td><code>%X</code></td><td>访问时间戳</td></tr>
</tbody></table>
</div>
<p>除<code>stat</code>外，还可以使用<code>date</code>获取<a href="Linux/Linux%E9%85%8D%E7%BD%AE%E5%92%8C%E7%AE%A1%E7%90%86.html#%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4">文件修改时间</a>：</p>
<pre><code class="language-sh">date -r &lt;filename&gt; [+&quot;%Y%m%d&quot;] 
</code></pre>
<p>获取文件类型：</p>
<pre><code class="language-shell">file &lt;path/to/file&gt; \
    -i，--mime      \  # =&gt; --mime-type + --mime encoding
    -z,--uncompress \  # 尝试解压压缩文件并查看其中内容
</code></pre>
<h5 id="修改文件属性-1"><a class="header" href="#修改文件属性-1">修改文件属性</a></h5>
<p><code>touch</code>可以用于<a href="https://askubuntu.com/questions/62492/how-can-i-change-the-date-modified-created-of-a-file">修改文件访问时间</a>。</p>
<pre><code class="language-shell">touch filename
touch -d &quot;2 hours ago&quot; filename
</code></pre>
<h3 id="普通文件-1"><a class="header" href="#普通文件-1">普通文件</a></h3>
<h4 id="移动-1"><a class="header" href="#移动-1">移动</a></h4>
<p>如果源文件/目录与目标文件/目录同名，则用源文件/目录替换同名目标文件/目录的内容；否则，将源文件/目录移动到目标目录中；此时，目标目录必须存在，不会首先创建目录。</p>
<pre><code class="language-shell">mv [-f]  file_path /path/newname
</code></pre>
<blockquote>
<p>如果源与目标所在路径相同，<code>mv</code>等效于重命名。</p>
</blockquote>
<h5 id="批量重命名-1"><a class="header" href="#批量重命名-1">批量重命名</a></h5>
<p>将文件名中已知的部分内容替换为新的内容，其余部分（使用通配符表示）不变。</p>
<pre><code class="language-sh">rename 's/pattern/replace/' FILES    # sed style
rename pattern replace FILES
</code></pre>
<p><code>pattern</code>为Perl正则表达式，文件名<code>FILES</code>支持通配符（<code>?*.txt</code>）。</p>
<blockquote>
<p>使用需注意，原始的<code>rename</code>不会检查已有文件而直接覆盖。</p>
</blockquote>
<h4 id="复制-2"><a class="header" href="#复制-2">复制</a></h4>
<pre><code class="language-sh">cp [-raf] file_path /path/filecopy  # -a 保留原属性
</code></pre>
<blockquote>
<p><code>cp</code>的文件创建行为与<code>mv</code>相同。</p>
</blockquote>
<h5 id="安装-4"><a class="header" href="#安装-4">安装</a></h5>
<p><code>install</code>支持设置目标文件的权限和属性（==不支持文件夹（递归）复制==）：</p>
<ul>
<li>
<p><code>-m,--mode=MODE</code>：设置访问权限；</p>
</li>
<li>
<p><code>-g,--group=GROUP</code>，<code>-o,--owner=OWNER</code>：设置所属关系（<code>chgrp,chown</code>），代替当前进程的默认值；</p>
</li>
<li>
<p><code>-p, --preserve-timestamps</code>：保留文件的访问/修改时间；</p>
</li>
</ul>
<pre><code class="language-shell">install [OPTION] -D [-T] SOURCE DEST   # single-file to file
</code></pre>
<blockquote>
<p><code>-D</code>：（递归）创建目标文件的父目录（<code>mkdir -p</code>），未指定该选项则不会自动创建目录；</p>
</blockquote>
<pre><code class="language-shell">install [OPTION] SOURCE... DIRECTORY   # single to dir
install [OPTION] -t DIRECTORY SOURCE...# multiple to dir (--target-directory)
</code></pre>
<blockquote>
<p><code>-b,--suffix=BACKUP</code>：备份选项以及备份目标文件夹；</p>
</blockquote>
<h4 id="删除文件-1"><a class="header" href="#删除文件-1">删除文件</a></h4>
<pre><code class="language-sh">rm [-rf] file  # can use wildcard
</code></pre>
<blockquote>
<p>使用<code>-rf</code>递归删除非空文件夹。</p>
</blockquote>
<h4 id="文件链接-1"><a class="header" href="#文件链接-1">文件链接</a></h4>
<p><strong>硬链接</strong>（<strong>hard link</strong>）：是对原文件的引用（引用同一个<code>inode</code>，在<code>inode</code>中计数），与原文件等价（即拥有相同访问权限）。删除硬链接将减小<code>inode</code>计数，到<code>inode</code>计数为0时删除文件。</p>
<p><strong>符号链接</strong>（<strong>symbolic/soft link</strong>）：保存到目标文件（夹）的路径（或相对路径），访问符号链接将跳转到目标文件（夹）。符号链接是一个独立的文件（具有相应的<code>inode</code>节点），因此具有独立的文件权限。删除原文件后，符号链接失效。</p>
<h5 id="创建链接-1"><a class="header" href="#创建链接-1">创建链接</a></h5>
<pre><code class="language-sh">ln -s /file/path /symbol/path	  # symbolic link
ln /file/path /symbol/path      # hard link file
ln -d /dir/path /symbol/path    # hard link 目录（不一定支持）
# -f,--force 移除已有文件链接 
</code></pre>
<p>符号链接的目标可以是任意内容（创建的时候不做检查合法性），符号链接支持跨文件系统。硬链接的目标必须存在且仅支持在同一设备的同一文件系统。</p>
<h5 id="访问链接-1"><a class="header" href="#访问链接-1">访问链接</a></h5>
<p>==文件链接解引用时，相对路径的父目录为文件链接所在目录==，解析符号链接目标时是递归式解析。</p>
<p>工作目录路径：如果切换工作目录到符号链接指向的目录，则工作目录路径为符号链接的路径而非目标目录的真实路径（比较<code>pwd</code>和<code>realpath</code>的输出结果），向上跳转（<code>..</code>）会返回符号链接所在目录。</p>
<p>在Linux中创建的符号链接在Windows中仍然能访问（WSL），但Windows不做递归解析，仅以当前工作目录路径为参考解析符号链接，因此<strong>使用相对路径的多级符号链接解析会出错</strong>。</p>
<h4 id="临时文件-1"><a class="header" href="#临时文件-1">临时文件</a></h4>
<p>在指定目录下（默认为<code>/tmp</code>）创建临时文件并输出文件路径。</p>
<pre><code class="language-shell">tempfile --directory PATH # [Debian] 
mktemp -p PATH     # [Fedora-coreutils]
       --directory # 创建目录而非文件
</code></pre>
<h3 id="查找文件-1"><a class="header" href="#查找文件-1">查找文件</a></h3>
<pre><code class="language-sh">which &lt;command&gt;
command -V &lt;command&gt;
</code></pre>
<blockquote>
<p>从系统环境变量中查找文件并返回绝对路径。</p>
</blockquote>
<h4 id="查找目录中的文件-1"><a class="header" href="#查找目录中的文件-1">查找目录中的文件</a></h4>
<pre><code class="language-sh">find [-HLP][-D debugopts][-Olevel][start_dir...][expression]
</code></pre>
<p><code>start_dir</code>表示查找路径，可以使用绝对路径，也可以使用相对路径，可以同时指定多个目录；如果没有指定，则<strong>默认为当前目录</strong>。==默认输出信息为查找到的文件夹和文件信息，并包含从查找目录开始的完整路径信息。==</p>
<h5 id="选项option-1"><a class="header" href="#选项option-1">选项（Option）</a></h5>
<p>选项<strong>控制<code>find</code>访问文件系统的行为</strong>。</p>
<p><code>-H</code>，<code>-L</code>和<code>-P</code>（默认）控制处理符号链接的行为。</p>
<blockquote>
<p><code>-P</code>表示不解析任何符号链接；
<code>-H</code>表示除了命令行提供的文件名外，不解析其他符号链接。如果符号链接不能被解析，则返回符号连接本身的信息；
<code>-L</code>表示在可能的情况下解析符号链接，反之返回符号链接自身的信息。（<code>-follow</code> deprecated）</p>
</blockquote>
<p><code>-D debugopts</code>：输出诊断信息。</p>
<p><code>-Olevel</code>：查询优化。默认首先执行基于文件名的表达式（<code>-name</code>，<code>-regex</code>等）；其次执行<code>-type</code>或<code>-xtype</code>的表达式（通过<code>readdir()</code>读取文件类型）。</p>
<p>读取上述选项之后，检查后续参数是否为文件/路径，直到以<code>-</code>、<code>(</code>、<code>!</code>开始的参数（也可以使用<code>--</code>声明选项参数的结束）。剩余参数为控制搜索行为的表达式。</p>
<h5 id="表达式expression-1"><a class="header" href="#表达式expression-1">表达式（Expression）</a></h5>
<p>表达式用于控制如何匹配文件以及对匹配文件的操作。表达式可以包含以下内容：</p>
<ul>
<li><code>Tests</code>：测试文件属性，返回<code>true|false</code>；</li>
<li><code>Actions</code>：对匹配结果执行操作，根据操作结果返回<code>true|false</code>；如果表达式没有包含操作，则默认为<code>-print</code>；</li>
<li><code>Global options</code>：全局选项，总是返回<code>true</code>；</li>
<li><code>Positional options</code>：仅影响其后的测试或操作，总是返回<code>true</code>；</li>
<li><code>Operator</code>：将表达式中多个内容连接起来：<code>-o</code>（逻辑<code>OR</code>）、<code>-a</code>（逻辑<code>AND</code>）；表达式内容之间默认使用<code>-a</code>连接；可以使用<code>()</code>声明优先级。</li>
</ul>
<h6 id="全局选项-1"><a class="header" href="#全局选项-1">全局选项</a></h6>
<ul>
<li><code>-d,-depth</code>：先处理文件夹中的内容，再处理文件夹本身；</li>
<li><code>-maxdepth,-mindepth LEVEL</code>：指定搜索的层级，<code>0</code>表示起始点本身；</li>
<li><code>-mount, -xdev</code>：不搜索挂载的其他文件系统目录；</li>
<li><code>-help,--help,--version</code>：帮助、版本信息。</li>
</ul>
<h6 id="位置选项-1"><a class="header" href="#位置选项-1">位置选项</a></h6>
<ul>
<li>
<p><code>-daystart</code>：计算时间时从今天开始，而非24小时前算起。影响其后的测试条件<code>-amin</code>, <code>-cmin</code>, <code>-mmin</code>, <code>-atime</code>, <code>-ctime</code>和<code>-mtime</code>。</p>
</li>
<li>
<p><code>-regextype TYPE</code>：默认为<code>emacs</code>，包括：<code>awk,egrep,grep,sed</code>等。</p>
<blockquote>
<p><code>-regextype egrep</code>在CentOS 7 上不支持<code>{}</code>。</p>
</blockquote>
</li>
</ul>
<h6 id="测试条件-1"><a class="header" href="#测试条件-1">测试条件</a></h6>
<div class="table-wrapper"><table><thead><tr><th>表达式</th><th>说明</th></tr></thead><tbody>
<tr><td><code>-name PATTERN</code></td><td>查找==文件名==匹配<code>PATTERN</code>的文件，可以使用通配符<code>*，？,[]</code>。</td></tr>
<tr><td><code>-path PATTERN</code></td><td>==从搜索路径开始的完整文件名（非绝对路径）==与<code>PATTERN</code>进行匹配<br />（<code>-wholename</code>）。</td></tr>
<tr><td><code>-regex PATTERN</code></td><td>使用正则表达式匹配文件。文件名以<code>./</code>开头的==完整相对路径==，<br />注意在正则表达式前添加<code>.*</code>以匹配前缀；</td></tr>
<tr><td><code>-atime [+-]N</code> <br/> <code>-ctime [+-]N</code> <br/> <code>-mtime [+-]N</code></td><td>判断最近访问(<code>-a</code>)，状态变化(<code>-c</code>)，修改(<code>-m</code>)时间：<br/>如果参数为<code>N</code>，表示时间在<code>N</code>天之内<br/>（0表示0~24小时，1表示24~48小时，…）</td></tr>
<tr><td><code>-amin [+-]N</code></td><td>时间单位为<code>min</code>（类似地<code>-cmin</code>，<code>-mmin</code>）</td></tr>
<tr><td><code>-anewer FILE</code></td><td>测试最近访问时间是否比<code>FILE</code>更近（<code>-cnewer,-newer</code>）。</td></tr>
<tr><td><code>-used [+-]N</code></td><td>在文件状态改变<code>N</code>天（<code>+N,-N</code>）之内文件被访问过。</td></tr>
<tr><td><code>-empty</code></td><td>测试文件或文件夹是否为空。</td></tr>
<tr><td><code>-size n[u]</code></td><td>文件大小：单位<code>u=cwbkMG:</code></td></tr>
<tr><td><code>-fstype TYPE</code></td><td>测试文件所在的文件系统的类型是否为<code>TYPE</code>。</td></tr>
<tr><td><code>-uid [+-]N</code></td><td>文件的用户ID（组ID<code>-gid</code>）是否为<code>N</code>（或<code>+N,-N</code>）。</td></tr>
<tr><td><code>-user NAME</code></td><td>文件的用户名（组名<code>-group</code>）是否为<code>NAME</code>（允许使用ID）。</td></tr>
<tr><td><code>-nouser</code></td><td>文件的用户ID（组ID<code>-nogroup</code>）没有对应的用户（组）。</td></tr>
<tr><td><code>-lname PATTERN</code></td><td>符号链接所指向的文件的文件名是否与<code>PATTERN</code>匹配。</td></tr>
<tr><td><code>-perm pmode</code></td><td>文件的权限是否与<code>pmode</code>匹配，<br/><code>pmode</code>可以是符号或数字模式，例如：<code>-perm 664</code>。<br/>直接指定单项权限<code>-readable</code>、<code>-writable</code>、<code>-executable</code>。</td></tr>
<tr><td><code>-type &lt;c&gt;</code></td><td><a href="Linux/Linux%E9%85%8D%E7%BD%AE%E5%92%8C%E7%AE%A1%E7%90%86.html#%E6%96%87%E4%BB%B6%E4%BF%A1%E6%81%AF%E9%80%89%E9%A1%B9">文件类型</a>： <code>bcdpfls</code></td></tr>
<tr><td><code>-xtype c</code></td><td>除符号链接以外，与<code>-type</code>作用一致；</td></tr>
<tr><td><code>-inum [+-]N</code></td><td>rarely useful.</td></tr>
<tr><td><code>-samefile NAME</code></td><td>文件与<code>NAME</code>为同一个文件。</td></tr>
<tr><td><code>-links [+-]N</code></td><td>File has n hard links.</td></tr>
</tbody></table>
</div>
<blockquote>
<p>匹配文件名的测试命令前添加<code>i</code>（例如<code>-iname</code>）为忽略大小写版本。
通配符需要使用引号包围以防被shell展开。
参数如果为<code>+N</code>，则表示大于<code>N</code>，如果为<code>-N</code>则表示小于<code>N</code>。</p>
</blockquote>
<h6 id="运算符-16"><a class="header" href="#运算符-16">运算符</a></h6>
<div class="table-wrapper"><table><thead><tr><th>运算符</th><th>表达式</th></tr></thead><tbody>
<tr><td><code>()</code></td><td><code>(EXPR)</code></td></tr>
<tr><td><code>!</code>   <code>-not</code></td><td><code>!EXPR</code>   <code>–not EXPR</code></td></tr>
<tr><td><code>-a</code>  <code>-and</code></td><td><code>EXPR1 –a EXPR2</code>  <code>EXPR1 –and EXPR2</code></td></tr>
<tr><td><code>-o</code>  <code>-or</code></td><td><code>EXPR1 –o EXPR2</code>  <code>EXPR1 –or EXPR2</code></td></tr>
<tr><td><code>,</code></td><td><code>EXPR1, EXPR2</code></td></tr>
</tbody></table>
</div>
<h6 id="动作-2"><a class="header" href="#动作-2">动作</a></h6>
<div class="table-wrapper"><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody>
<tr><td><code>-print, -print0</code></td><td><code>print0</code>会在文件名结尾追加“<code>null</code>”。</td></tr>
<tr><td><code>-fprint FILE</code><br/><code>-fprint0 FILE</code></td><td>打印完整文件名到<code>FILE</code>。<br/>如果文件不存在则创建文件；<br/>如果存在，则文件内容被删除；<br/>即使没有输出内容，该文件仍然会被创建。</td></tr>
<tr><td><code>-ls</code><br/><code>-fls FILE</code></td><td>以<code>ls -dils</code>格式打印到标准输出。<code>-fls</code>输出到文件。</td></tr>
<tr><td><code>-printf FORMAT</code><br/><code>-fprintf FILE FORMAT</code></td><td>位宽和精度说明类似于C语言的<code>printf</code>(<code>man find</code>)。</td></tr>
<tr><td><code>-execdir command</code><br/><code>-exec command</code></td><td><code>-execdir</code>将其后直到<code>;</code>的所有内容视为<code>command</code>，<br/>同时将其中的“<code>{}</code>”替换为查找结果的文件名。<br/><code>command</code>中的特殊字符需要使用“<code>\</code>”或“<code>'</code>”以防被shell展开。</td></tr>
<tr><td><code>-execdir command {}+</code><br/><code>-exec command {}+</code></td><td>命令末尾的“<code>{}</code>”展开为匹配文件名称的列表；</td></tr>
<tr><td><code>-okdir command</code><br/><code>-ok command</code></td><td>询问用户是否执行命令</td></tr>
<tr><td><code>-delete</code></td><td>删除成功返回真；如果失败，生成错误信息；</td></tr>
</tbody></table>
</div>
<h5 id="查找文件示例-1"><a class="header" href="#查找文件示例-1">查找文件示例</a></h5>
<p>高亮<code>find</code>查找结果：</p>
<pre><code class="language-sh">find ./ -name '*.tar.gz' | grep --color '.tar.gz'
</code></pre>
<p>打印查找到文件的详细信息。</p>
<pre><code class="language-sh">find ./ -name '*.tar.gz' -exec ls -lh {} ';' 
</code></pre>
<p>删除文件：</p>
<pre><code class="language-shell">find . -maxdepth 1 -newer archive.tar.gz -execdir rm -rf {} ';'
</code></pre>
<p>在过滤文件中查找内容：</p>
<pre><code class="language-sh">find ./ –name '*.cpp' –exec grep -Hn 'main' {} ';'
find ./ -name &quot;*.log&quot; | xargs grep –Hn 'ERROR'
</code></pre>
<p><em><code>grep</code>与<code>find</code>同时使用时，默认不会输出文件名（添加<code>-H</code>选项），也不会高亮文本（使用<code>--color</code>选项）。</em></p>
<h4 id="查找文件内容-1"><a class="header" href="#查找文件内容-1">查找文件内容</a></h4>
<p>使用<a href="Linux/Linux-Shell.html#grep"><code>grep</code></a>查找具有给定内容和文件名的文件：</p>
<pre><code class="language-sh">grep -rl 'main' --include='*.cpp' ./  # 输出匹配文件的文件名
grep -rn 'main' --include='*.cpp' ./  # 输出匹配行的行号和内容
</code></pre>
<h2 id="硬件管理-1"><a class="header" href="#硬件管理-1">硬件管理</a></h2>
<h3 id="查看硬件信息-1"><a class="header" href="#查看硬件信息-1">查看硬件信息</a></h3>
<pre><code class="language-shell">sudo dmidecode -t,--type type_code|type_keyword
sudo dmidecode [options] | grep -A16 'System Information$'   # 系统和主板信息
</code></pre>
<p>硬件类型（<code>type_keyword</code>）包括：<code>bios</code>, <code>system</code>, <code>baseboard</code>, <code>chassis</code>, <code>processor</code>, <code>memory</code>, <code>cache</code>, <code>connector</code>, <code>slot</code>。每种类型可能包括多个子类型（<code>type_code</code>）。</p>
<pre><code class="language-shell">sudo lshw \               # list hardware [yum install lshw]
     -class &lt;hw_class&gt; \  # class can be found using lshw -short
     -{html|xml|json}  \  # 输出格式
     -short \ # device tree: 优先级高于输出格式
     -businfo # showing bus information
</code></pre>
<p>硬件类型可通过<code>lshw -short</code>的输出获取，包括：<code>system</code>，<code>bus</code>，<code>memory</code>，<code>processor</code>，<code>storage</code>，<code>input</code>，<code>display</code>，<code>disk</code>，<code>volume</code>，<code>network</code>，<code>power</code>等。</p>
<blockquote>
<p>其他工具：<code>hwinfo</code>（默认未安装到系统）；<code>hardinfo</code>（图形界面）。</p>
</blockquote>
<h5 id="cpu-2"><a class="header" href="#cpu-2">CPU</a></h5>
<pre><code class="language-sh">lscpu              # CPU信息概述
nproc              # number of process unit
sudo lshw -C processor
cat /proc/cpuinfo  # CPU details
sudo dmidecode --type processor # details
</code></pre>
<blockquote>
<p><code>cpuid</code>获取详细信息（未安装）。</p>
</blockquote>
<pre><code class="language-sh">cat /proc/cpuinfo | grep name | cut -f2 -d: | uniq -c
# 8  Intel(R) Xeon(R) CPU            E5410   @ 2.33GHz
## (CPU with 8 logical core)
cat /proc/cpuinfo | grep 'physical id' | uniq -c
#      4 physical id      : 0
#      4 physical id      : 1
### (2 physical CPU with 4-core)
</code></pre>
<h5 id="内存-2"><a class="header" href="#内存-2">内存</a></h5>
<pre><code class="language-sh">free -h	-w	# summary
cat /proc/meminfo  # details
vmstat -s
sudo dmidecode -t memory   # Memory Device
</code></pre>
<blockquote>
<p>all tmpfs pages will be shown as “<code>Shmem</code>” in <code>/proc/meminfo</code> and “<code>Shared</code>” in <code>free(1)</code>.</p>
</blockquote>
<h5 id="磁盘信息-1"><a class="header" href="#磁盘信息-1">磁盘信息</a></h5>
<p>列出存储设备信息：</p>
<pre><code class="language-sh">sudo fdisk -l [device_name]  # 查看磁盘设备 =&gt; sudo parted /dev/sda print
lsblk    # 列出块设备
sudo blkid /dev/sda
# /dev/sda: UUID=&quot;3255683f-53a2-4fdf-91cf-b4c1041e2a62&quot; TYPE=&quot;ext4&quot;
</code></pre>
<p>查看序列号：</p>
<pre><code class="language-shell">udevadm info --query=all --name=/dev/sda | grep ID_SERIAL
hdparm -I /dev/sda   # install hdparm
lshw -class disk     # install lshw
smartctl -i /dev/sda # install smartmontools
</code></pre>
<blockquote>
<p>位于磁盘阵列中的磁盘序列号不可见（系统读取的是RAID分配的ID）。</p>
</blockquote>
<h5 id="文件系统信息-1"><a class="header" href="#文件系统信息-1">文件系统信息</a></h5>
<p>列出系统支持的文件系统：</p>
<pre><code class="language-shell">cat /proc/filesystems
</code></pre>
<blockquote>
<p><code>exfat</code>格式支持需要安装<code>exfat-fuse</code>和<code>exfat-utils</code>包；NTFS格式需要安装<code>ntfs-3g</code>包（CentOS）。</p>
</blockquote>
<p>列出挂载的（文件或目录所在）<a href="Linux/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.html#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%B1%BB%E5%9E%8B">文件系统</a>信息。</p>
<pre><code class="language-sh">df [-ahHkT] [目录或文件名]
# Filesystem      Size  Used Avail Use% Mounted on
# /dev/sdd        251G  1.6G  237G   1% /
# tmpfs            13G  252M   13G   2% /mnt/wsl
</code></pre>
<blockquote>
<p><code>-hH</code>：以合适的单位显示数据（1024进制，<code>-H</code>为1000进制），提高可读性；
<code>-i,--inodes</code>：显示<code>inode</code>信息而非磁盘容量信息；
<code>-T,--print-type</code>：==打印文件系统类型==，例如<code>ext4</code>、<code>tmpfs</code>等；
<code>-t,--type=TYPE</code>：仅显示指定类型文件系统；<code>-x,--exclude-type=TYPE</code>排除指定类型；</p>
</blockquote>
<p>列出文件或目录的<strong>磁盘占用量</strong>（<strong>disk usage</strong>）：</p>
<pre><code class="language-sh">du [-ahskm] 文件或目录名称
</code></pre>
<p><code>-c, --total</code>；
<code>-h, --human-readable</code>；
<code>-s, --summarize</code>；
<code>-d,--max-depth=N</code>：显示最大路径深度；</p>
<h3 id="磁盘管理-1"><a class="header" href="#磁盘管理-1">磁盘管理</a></h3>
<h4 id="磁盘分区与格式化-1"><a class="header" href="#磁盘分区与格式化-1">磁盘分区与格式化</a></h4>
<p><strong>注意：以下操作可能导致数据丢失，应事先做好数据备份！！！</strong></p>
<p>使用<code>fdisk</code>或<code>parted</code>操作文件分区表（<code>fdisk -l</code>查看<a href="Linux/Linux%E9%85%8D%E7%BD%AE%E5%92%8C%E7%AE%A1%E7%90%86.html#%E7%A3%81%E7%9B%98%E4%BF%A1%E6%81%AF">磁盘信息</a>）：</p>
<pre><code class="language-sh">sudo fdisk device_name   # 操作分区表
# fdisk命令
# [F] 列出未分区的空闲空间    n 新增分区
# l   列出已知分区类型        t 更改分区类型
# p   打印分区表             d 删除分区  
# [i] 打印选择的分区信息      v 验证分区表
# m   打印命令列表           g 创建GPT分区表
#                          o 创建DOS（MBR）分区表
# q   放弃更改并退出         w 保存分区更改
</code></pre>
<blockquote>
<p>未添加<code>device_name</code>时，列出系统内所有存储设备（<code>/dev</code>）的分区（partition）信息。</p>
<p><a href="https://gparted.org/livecd.php">GParted -- Live CD/USB/PXE/HD</a>：<em>With GParted you can resize, copy, and move partitions without data loss.</em> <code>gparted</code>是一款图形界面的分区工具。</p>
</blockquote>
<p>更改正在使用的分区：首先删除分区（记录下分区表的起止位置），然后重新创建分区，并指定新的起止位置（注意不要和已有分区重叠）和分区类型，保存并退出（<a href="https://www.codenotary.com/blog/enlarge-a-disk-and-partition-of-any-linux-vm-without-a-reboot/">使用工具</a><code>cloud-utils.growpart</code>）。分区表更改不会立即生效，因此可以修改正在使用的分区，重启机器或使用<code>partprobe [/dev/sda]</code>或<code>kpartx [/dev/sda]</code>命令重新载入新的分区表。如果是普通卷，则需要使用<code>resize2fs</code>更新文件系统容量，如果是LVM物理卷，则使用<code>pvresize</code>更新（<code>resize2fs</code>无法操作LVM物理卷）。</p>
<h5 id="磁盘格式化-1"><a class="header" href="#磁盘格式化-1">磁盘格式化</a></h5>
<p>新建分区后，需要对分区进行格式化设置文件系统才能进行<a href="Linux/Linux%E9%85%8D%E7%BD%AE%E5%92%8C%E7%AE%A1%E7%90%86.html#%E7%A3%81%E7%9B%98%E6%8C%82%E8%BD%BD%E4%B8%8E%E5%8D%B8%E9%99%A4">挂载使用</a>。整个磁盘也可以不进行分区直接格式化。</p>
<pre><code class="language-sh">mkfs -t &lt;fstype&gt; /dev/sda
mkfs.&lt;fstype&gt; options /dev/sda  # 格式化分区/dev/sda1
</code></pre>
<p><code>fstype</code>文件系统类型，例如 <code>ext4</code>, <code>xfs</code>, <code>btrfs </code>, <code>ZFS</code>等(<a href="Linux/Linux%E9%85%8D%E7%BD%AE%E5%92%8C%E7%AE%A1%E7%90%86.html#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E4%BF%A1%E6%81%AF">系统有支持</a>才会生效)。在选择文件系统类型时，如无特殊要求，选择系统中已有分区类型（默认类型），确保兼容和稳定性。</p>
<blockquote>
<p><code>mke2fs</code>：创建<code>ext2</code>/<code>ext3</code>/<code>ext4</code>文件系统，对应命令：<code>mkfs.ext2|3|4</code>。<code>ext</code>文件系统的<code>i-node</code>节点总数在文件系统创建后不能改变，调整文件系统容量将按比例调整inode数量（<code>bytes-per-inode</code>）。</p>
</blockquote>
<p><a href="https://linuxiac.com/linux-file-system-types-explained-which-one-should-you-use/">Linux File System Types Explained, Which One Should You Use (linuxiac.com)</a></p>
<h5 id="数据恢复-1"><a class="header" href="#数据恢复-1">数据恢复</a></h5>
<p><a href="https://www.cgsecurity.org/wiki/TestDisk_Step_By_Step">TestDisk Step By Step - CGSecurity</a></p>
<p><a href="https://www.dedoimedo.com/computers/linux-data-recovery.html">How to recover partitions and data using Linux - Tutorial (dedoimedo.com)</a></p>
<p><a href="https://www.simplified.guide/linux/disk-recover-partition-table">How to recover lost partition using Linux (simplified.guide)</a></p>
<blockquote>
<p><em>TestDisk is powerful free data recovery software! It was primarily designed to help recover lost partitions and/or make non-booting disks bootable again when these symptoms are caused by faulty software: certain types of viruses or human error (such as accidentally deleting a Partition Table).</em></p>
<p>==<em>Even though the old partition table was destroyed, it was just a pointer to the start and end addresses of the actual data, so to speak.</em>==</p>
</blockquote>
<p><a href="https://www.dedoimedo.com/computers/clonezilla.html">The new and definite CloneZilla tutorial (dedoimedo.com)</a></p>
<h4 id="磁盘检验-1"><a class="header" href="#磁盘检验-1">磁盘检验</a></h4>
<pre><code>fsck [-t &lt;fstype&gt;] [-ACay] /dev/sda
</code></pre>
<blockquote>
<p>用来检查和维护不一致的文件系统。若系统掉电或磁盘发生问题，可利用<code>fsck</code>命令对文件系统进行检查。</p>
</blockquote>
<h4 id="磁盘挂载与卸除-1"><a class="header" href="#磁盘挂载与卸除-1">磁盘挂载与卸除</a></h4>
<pre><code class="language-sh">mount -t &lt;fstype&gt; -L &lt;label&gt; -o &lt;opts&gt; -n /dev/dev_name /mnt/mnt_name
mount --move /mnt/userdirs /home    # move mount point of a filesystem
umount [-fn] [/dev/dev_name | /mnt/mnt_name]
findmnt --types &lt;fstype&gt;            # 查看已挂载的文件系统
</code></pre>
<blockquote>
<p>如果挂载的目标路径下有数据，则数据会被隐藏；卸载磁盘后可恢复访问原有数据<sup class="footnote-reference"><a href="#mount">1</a></sup>。</p>
<p><a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/8/html/managing_file_systems/assembly_mounting-file-systems_managing-file-systems">Sharing a mount on multiple mount points</a></p>
</blockquote>
<p>挂载NTFS文件系统：</p>
<pre><code class="language-shell">yum install fuse ntfs-3g   # centos
mount -t ntfs-3g /dev/sdb1 /mnt/win
</code></pre>
<p>如果卸除设备时出现<strong>设备忙</strong>的错误，可<a href="Linux/Linux%E9%85%8D%E7%BD%AE%E5%92%8C%E7%AE%A1%E7%90%86.html#%E6%9F%A5%E7%9C%8B%E8%BF%9B%E7%A8%8B%E6%89%93%E5%BC%80%E8%B5%84%E6%BA%90">查看正在使用该设备的进程</a>有哪些并尝试关闭进程。</p>
<h5 id="挂载cd-1"><a class="header" href="#挂载cd-1">挂载CD</a></h5>
<pre><code class="language-shell">mount -t auto [-r] /dev/cdrom /mnt/cdrom # 挂载CD
</code></pre>
<h5 id="挂载可移动介质-1"><a class="header" href="#挂载可移动介质-1">挂载可移动介质</a></h5>
<p>挂载磁盘的目标文件夹必须存在，挂载的磁盘应该已经使用支持的文件系统<a href="Linux/Linux%E9%85%8D%E7%BD%AE%E5%92%8C%E7%AE%A1%E7%90%86.html#%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F%E5%8C%96">格式化</a>。可移动磁盘设备标识类似于内置磁盘（使用<code>fdisk -l</code>或<code>parted -l</code>查看）。</p>
<h5 id="自动挂载-1"><a class="header" href="#自动挂载-1">自动挂载</a></h5>
<ol>
<li>
<p>将挂载命令写入开机启动脚本；</p>
</li>
<li>
<p>配置<code>systemd.mount</code><a href="https://www.freedesktop.org/software/systemd/man/systemd.mount.html">单元文件</a>；</p>
<pre><code class="language-ini">[Mount]
What=/dev/sda
Where=/data
Type=ext4
Options=
</code></pre>
</li>
<li>
<p>使用<code>/etc/fstab</code>配置，<code>systemd</code>会将其中的内容转换为单元文件；</p>
<pre><code class="language-shell"># DevicePath    MountPoint  FS Type      Mount Options       Dump  CheckOrder
/dev/sdba         /data      ext4             -               0        1
LABEL=t-home2     /home      ext4    defaults,auto_da_alloc   0        2
SERVER:PATH
</code></pre>
</li>
</ol>
<h4 id="逻辑卷管理lvm-1"><a class="header" href="#逻辑卷管理lvm-1">逻辑卷管理LVM</a></h4>
<blockquote>
<p>Logical Volume Management, gives users the power to pool and abstract the physical layout of component storage devices, to gather existing storage devices into groups and allocate logical units from the combined space as needed.</p>
</blockquote>
<h5 id="lvm存储信息-1"><a class="header" href="#lvm存储信息-1">LVM存储信息</a></h5>
<p>显示系统中的LVM兼容卷，包括可转换为LVM物理卷（<em>Physical Volumns</em>）的存储设备：</p>
<pre><code class="language-sh">sudo lvmdiskscan \
     -l # 仅显示LVM物理卷, ==&gt; pvscan, pvs, pvdisplay
</code></pre>
<p>显示系统中的物理卷组（<em>Virtual Group</em>）信息：</p>
<pre><code class="language-sh">sudo vgscan  # =&gt; vgs, vgdisplay
</code></pre>
<p>显示系统中的逻辑卷（<em>Logical Volumn</em>）：（逻辑卷设备路径、<code>VG Name</code>、<code>PV</code>）</p>
<pre><code class="language-sh">sudo lvscan # lvs, lvdisplay [-m]
</code></pre>
<h5 id="管理lvm存储-1"><a class="header" href="#管理lvm存储-1">管理LVM存储</a></h5>
<p>从原始磁盘创建LVM物理卷，注意将磁盘上原有数据备份，加入LVM管理后将覆盖原有数据。</p>
<blockquote>
<p>A header is written to storage devices to mark them as free to use as LVM components. </p>
</blockquote>
<pre><code class="language-sh">sudo pvcreate /dev/sda /dev/sdb ...
pvresize /dev/sda1
pvresize --setphysicalvolumesize 40G /dev/sda1 # shrink
</code></pre>
<blockquote>
<p>如果物理磁盘分区通过<code>fdisk</code>进行了扩展，可以通过<code>pvresize</code>更新LVM物理卷的容量。<a href="https://www.techrepublic.com/blog/smb-technologist/extending-partitions-on-linux-vmware-virtual-machines/">也可以将空余磁盘空间创建为一个新的物理分区</a>，设置为LVM PV并加入LVM虚拟卷组。</p>
</blockquote>
<p>将物理卷创建为卷组，通常只需要一个卷组并在此之上创建虚拟卷。</p>
<pre><code class="language-sh">sudo vgcreate volume_group_name /dev/sda /dev/sdb ...
</code></pre>
<p>向卷组中增加物理卷：</p>
<pre><code class="language-sh">sudo vgextend volume_group_name /dev/sdb
</code></pre>
<p>创建虚拟卷，创建后需要对虚拟卷进行<a href="Linux/Linux%E9%85%8D%E7%BD%AE%E5%92%8C%E7%AE%A1%E7%90%86.html#%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F%E5%8C%96">格式化</a>。</p>
<pre><code class="language-sh">sudo lvcreate -L 10G -n VolumnName LVMVolGroup   # 绝对容量
sudo lvcreate -l 100%FREE -n VolumnName2 LVMVolGroup # 相对容量
</code></pre>
<blockquote>
<p>虚拟卷的底层物理磁盘分配方案支持线性（<code>linear</code>，默认）、<code>striped</code>（RAID 0）、<code>raid1</code>等。</p>
</blockquote>
<p>虚拟卷容量调整，使用<code>-L</code>选项增加/减少绝对容量，或用<code>-l</code>选项增加相对容量。</p>
<pre><code class="language-sh">sudo lvresize -L +5G --resizefs LVMVolGroup/vol_name
sudo lvresize -l +100%FREE --resizefs LVMVolGroup/vol_name
</code></pre>
<blockquote>
<p><em>XFS filesystem shrinking is unsupported.</em> <code>resize2fs</code> <em>is for ext filesystems.</em></p>
</blockquote>
<h4 id="raid-1"><a class="header" href="#raid-1">RAID</a></h4>
<h5 id="hardware-raid-1"><a class="header" href="#hardware-raid-1">Hardware RAID</a></h5>
<p>在BIOS中配置磁盘的RAID选项，参考产品用户手册。</p>
<h5 id="software-raid-1"><a class="header" href="#software-raid-1">Software RAID</a></h5>
<ol>
<li><a href="https://www.digitalocean.com/community/tutorials/how-to-use-lvm-to-manage-storage-devices-on-ubuntu-18-04">How To Use LVM To Manage Storage Devices on Ubuntu 18.04</a>.</li>
<li><a href="https://www.digitalocean.com/community/tutorials/how-to-create-raid-arrays-with-mdadm-on-ubuntu-18-04">How To Create RAID Arrays with mdadm on Ubuntu 18.04 | DigitalOcean</a>.</li>
</ol>
<h3 id="显示设备-1"><a class="header" href="#显示设备-1">显示设备</a></h3>
<p>查看显示设备：</p>
<pre><code class="language-sh">lspci | grep -i vga            # &lt;== install pciutils
sudo lshow [-short] -c CLASS   # list hardware, CLASS for class/description
sudo lspci -v -s 03:00.0
</code></pre>
<h5 id="安装nvidia显卡驱动-1"><a class="header" href="#安装nvidia显卡驱动-1">安装Nvidia显卡驱动</a></h5>
<pre><code class="language-shell">rl=$(uname -r)
yum install gcc gcc-c++ make kernel-devel-$rl kernel-headers-$rl
apt install gcc make linux-headers-$rl [libglvnd]
</code></pre>
<blockquote>
<p>注意内核开发包的版本需要于系统内核版本完全一致，否则无法成功安装驱动程序。</p>
</blockquote>
<p>检查<code>nouveau</code>模块是否加载，已加载则先禁用</p>
<pre><code class="language-shell">lsmod | grep nouveau
# edit: /usr/lib/modprobe.d/blacklist-nouveau.conf  # [Ubuntu]/etc/modprobe.d/*
blacklist nouveau
options nouveau modeset=0
dracut -force   # 重启系统，使内核模块配置生效 [Ubuntu]update-initramfs -u
</code></pre>
<p>安装驱动程序：</p>
<pre><code class="language-shell">./NVIDIA-Linux-x86_64-390.46.run --no-opengl-files --ui=none --no-questions --accept-license
# edit: /etc/rc.d/rc.local
nvidia-smi -pm 1   # GPU驱动模式设置为常驻内存
nvidia-smi         # nvidia proprietary driver =&gt; watch -n 1 nvidia-smi
</code></pre>
<h5 id="ubuntu桌面版显卡驱动-1"><a class="header" href="#ubuntu桌面版显卡驱动-1">Ubuntu桌面版显卡驱动</a></h5>
<pre><code class="language-shell">ubuntu-drivers devices             # 列出可用驱动
sudo ubuntu-drivers autoinstall    # 安装推荐驱动
sudo apt install nvidia-driver-440 # 安装指定名称驱动
</code></pre>
<p>安装完成后重启。</p>
<p><a href="https://linuxconfig.org/how-to-install-the-nvidia-drivers-on-ubuntu-20-04-focal-fossa-linux">How to install the NVIDIA drivers on Ubuntu 20.04 Focal Fossa Linux - Linux Tutorials - Learn Linux Configuration</a>。</p>
<h3 id="网络设备配置管理-1"><a class="header" href="#网络设备配置管理-1"><a href="Linux/Linux%E9%85%8D%E7%BD%AE%E5%92%8C%E7%AE%A1%E7%90%86.html#%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87%E9%93%BE%E8%B7%AF%E7%AE%A1%E7%90%86">网络设备配置管理</a></a></h3>
<h2 id="系统配置-1"><a class="header" href="#系统配置-1">系统配置</a></h2>
<h3 id="系统信息-3"><a class="header" href="#系统信息-3">系统信息</a></h3>
<h4 id="操作系统-1"><a class="header" href="#操作系统-1">操作系统</a></h4>
<pre><code class="language-shell">uname [options]
</code></pre>
<div class="table-wrapper"><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody>
<tr><td><code> -a, --all</code></td><td>包括以下系统信息：</td></tr>
<tr><td><code>-s, --kernel-name</code></td><td>内核名称（<code>Linux</code>）</td></tr>
<tr><td><code>-n, --nodename</code></td><td>网络主机名称（使用<code>hostnamectl</code>设置）</td></tr>
<tr><td><code>-r, --kernel-release</code></td><td>内核发行版本（<code>3.10.0-1160.24.1.el7.x86_64</code>）</td></tr>
<tr><td><code>-v, --kernel-version</code></td><td>内核版本（<code>#1 SMP Thu Apr 8 19:51:47 UTC 2021</code>）</td></tr>
<tr><td><code>-m, --machine</code></td><td>机器的硬件架构名称（<code>x86_64</code>）</td></tr>
<tr><td><code>-o, --operating-system</code></td><td>操作系统（<code>GNU/Linux</code>）</td></tr>
</tbody></table>
</div>
<blockquote>
<p><code>-i,--hardware-platform</code>和<code>-p, --processor</code>（不可移植），通常与<code>-m</code>输出一致。</p>
</blockquote>
<h5 id="系统版本信息-1"><a class="header" href="#系统版本信息-1">系统版本信息</a></h5>
<pre><code class="language-sh">cat /etc/issue          # [Ubuntu]
cat /etc/lsb-release    # [Ubuntu]
cat /etc/os-release     # [Ubuntu|CentOS]
lsb_release -crid       # 包含版本号详细信息，CentOS需要安装redhat-lsb-core 
rpm -qa centos-release  # [Fedora/CentOS]
rpm -qi basesystem      # [Fedora/CentOS](包含安装日期)
</code></pre>
<h5 id="操作系统安装时间-1"><a class="header" href="#操作系统安装时间-1">操作系统安装时间</a></h5>
<p>通过文件系统创建时间判断操作系统安装时间：</p>
<pre><code class="language-shell">tune2fs -l $(df / | awk '$6 ~ /\// {print $1}') | grep 'Filesystem created:'  # -&gt; dumpe2fs
rpm -qi setup|setuptool|basesystem    # [Fedora/CentOS]
</code></pre>
<blockquote>
<p><code>tune2fs</code>是设置ext2/ext3/ext4文件系统参数的工具。</p>
</blockquote>
<h4 id="主机名-1"><a class="header" href="#主机名-1">主机名</a></h4>
<pre><code class="language-shell">hostnamectl  # 显示主机信息（主机名、系统名、架构...）
hostnamectl set-hostname 'gfs.server.03.net' # 设置主机名
sysctl -n kernel.hostname
</code></pre>
<blockquote>
<p>某些服务（例如Cloudera）需要检测主机名与域名（FQDN）的一致性，为了避免产生警告，将主机名设置为域名。</p>
<p>WSL-Ubuntu中<code>hostnamectl</code>不可用。</p>
</blockquote>
<h4 id="域名映射-1"><a class="header" href="#域名映射-1">域名映射</a></h4>
<pre><code class="language-sh">sudo vi /etc/hosts
# change &lt;hosts&gt; file
192.168.137.11 new-host-name
</code></pre>
<p>可能需要重启。</p>
<h4 id="日期时间-1"><a class="header" href="#日期时间-1">日期时间</a></h4>
<p>显示时间</p>
<pre><code class="language-sh">date                           # Sun May 16 13:07:15 CST 2021
date +'%H'                     # %T %c %F
date -d,--date='7:00:00' +'%s' # parse a date and display it
date --date='@2147483647'      # parse a timestamp (seconds)
date -r,--reference=FILE       # 显示文件最近修改时间
</code></pre>
<blockquote>
<p>默认显示当前时间，使用<code>-d,--date</code>指定要显示的时间的字符串；字符串缺少的部分设为当前时间。空字符串表示当天开始时间。</p>
</blockquote>
<p><a href="https://www.cyberciti.biz/faq/unix-linux-bash-get-time/">A list of date command field descriptors</a></p>
<h5 id="获取日期字段-1"><a class="header" href="#获取日期字段-1">获取日期字段</a></h5>
<div class="table-wrapper"><table><thead><tr><th>格式声明</th><th>含义</th><th>格式声明</th><th>含义</th><th>格式声明</th><th>含义</th></tr></thead><tbody>
<tr><td><code>%Y</code></td><td><code>YYYY</code></td><td><code>%m</code></td><td><code>mm</code></td><td><code>%d</code></td><td><code>dd</code></td></tr>
<tr><td><code>%H</code></td><td><code>HH</code>(00-23)</td><td><code>%M</code></td><td><code>MM</code>(00-59)</td><td><code>%S</code></td><td><code>SS</code></td></tr>
<tr><td><code>%s</code></td><td>时间戳（秒）</td><td><code>%3N</code></td><td>毫秒</td><td><code>%N</code></td><td>纳秒</td></tr>
<tr><td></td><td></td><td><code>%f</code></td><td>微秒</td><td></td><td></td></tr>
</tbody></table>
</div>
<h5 id="格式化日期字段-1"><a class="header" href="#格式化日期字段-1">格式化日期字段</a></h5>
<p><code>%</code>后可额外设置表示填充的字符：<code>-</code>不填充；<code>_</code>填充空格；<code>0</code>填充0（默认）；<code>^</code>使用大写字母；<code>#</code>（尽可能）改变字符大小写。</p>
<div class="table-wrapper"><table><thead><tr><th>格式</th><th>含义</th><th>格式</th><th>含义</th><th>格式</th><th>含义</th></tr></thead><tbody>
<tr><td><code>%c</code></td><td>locale's datetime</td><td><code>%x</code></td><td>locale' date</td><td><code>%X</code></td><td>locale's time</td></tr>
<tr><td><code>%D</code></td><td><code>%m/%d/%y</code></td><td><code>%F</code></td><td><code>%Y-%m-%d</code></td><td></td><td></td></tr>
<tr><td><code>%T</code></td><td><code>%H:%M:%S</code></td><td><code>%r</code></td><td><code>12:11:04 PM</code></td><td><code>%X</code></td><td><code>23:13:48</code>(locale)</td></tr>
<tr><td><code>%y</code></td><td><code>yy</code></td><td></td><td></td><td><code>%e</code></td><td><code>%_d</code></td></tr>
<tr><td><code>%I</code></td><td><code>hh</code>(01-12)</td><td><code>%k</code></td><td><code>_H</code>(0-23)</td><td><code>%l</code></td><td><code>_h</code></td></tr>
<tr><td><code>%j</code></td><td><code>ddd</code>: day of year</td><td><code>%w</code></td><td>day of week(0-6)<br/> 0 is Sunday</td><td><code>%u</code></td><td>day of week(1-7)<br/>1 is Monday</td></tr>
<tr><td><code>%W</code></td><td>week of year(00-53),<br/>Monday first</td><td><code>%U</code></td><td>week of year(00-53),<br/>Sunday first</td><td><code>%V</code></td><td>week of year(01-53),  <br/>Monday first</td></tr>
<tr><td><code>%p</code></td><td><code>AM/PM</code></td><td><code>%P</code></td><td><code>am/pm</code></td><td><code>%q</code></td><td>quater <code>00-04</code></td></tr>
<tr><td><code>%z</code></td><td>时区<code>-0400</code></td><td><code>%:z</code></td><td><code>-04:00</code></td><td><code>%::z</code></td><td><code>-04:00:00</code></td></tr>
<tr><td><code>%Z</code></td><td>时区类型<code>EDT/CST</code></td><td></td><td></td><td></td><td></td></tr>
</tbody></table>
</div>
<p>设置时间：</p>
<pre><code class="language-sh">timedatectl [status]		# 显示系统的日期、时间和时区等信息
timedatectl set-time &quot;2012-10-30 18:17:16&quot;  # &lt;== timedatectl set-ntp no
date -u,--utc=MMDDhhmmCCYY.ss  # print or set datetime
date -s,--set=STRING
timedatectl set-timezone &lt;Asia/Shanghai&gt;
timedatectl list-timezones	# 列出已知时区
</code></pre>
<p>系统启动时间：</p>
<pre><code class="language-shell">uptime
</code></pre>
<h3 id="系统引导配置-1"><a class="header" href="#系统引导配置-1">系统引导配置</a></h3>
<p>引导配置文件：</p>
<pre><code class="language-sh">/etc/default/grub
/etc/grub/grub.cfg # auto-generated by grub-update
</code></pre>
<p>选择默认用户界面：</p>
<pre><code class="language-sh">sudo systemctl set-default multiuser.target # terminal shell
sudo systemctl set-default graphical.target # GUI
</code></pre>
<h4 id="添加开机启动项-1"><a class="header" href="#添加开机启动项-1">添加开机启动项</a></h4>
<ol>
<li>
<p>编辑<code>/etc/rc.local</code>脚本（兼容性目的），并设定可执行权限（<code>sudo chmod 755</code>）</p>
<blockquote>
<p>适合较短的命令</p>
</blockquote>
</li>
<li>
<p>将启动项的脚本添加到<code>/etc/init.d</code>目录下，并设置可执行权限</p>
<pre><code class="language-sh">ln -s task.sh /etc/init.d/task
sudo chmod +x /etc/init.d/task
</code></pre>
<pre><code class="language-shell">cd /etc/init.d
sudo update-rc.d task defaults 95  # execute order
sudo update-rc.d -f task remove  # remove the task
</code></pre>
<p>如果使用需要开机通过<code>chkconfig</code>设置开机启动的服务，则脚本开头应该包含以下信息：</p>
<pre><code class="language-shell">#！/bin/bash
# chkconfig: 2345 20 80
# description: Saves and restores system entropy pool \
# for higher quality random number generation.
</code></pre>
<p><code>chkconfig: 2345 20 80</code>表示这个服务在运行级别2345下运行，20表示开机启动优先权重，80表示关闭优先权重。</p>
<p>也可以手动调用<code>chkconfig</code>添加开机启动服务</p>
<pre><code class="language-shell">chkconfig --add my-service
</code></pre>
<p>实际上<code>chkconfig --add</code>命令是将<code>/etc/init.d</code>中的启动脚本软连接到<code>/etc/rc.d/rcx.d</code>（<code>rc0.d ... rc6.d</code>）0-6个运行级别对应相应的目录，都是位于<code>/etc/init.d</code>中脚本的软连接。</p>
<p><code>/etc/init.d/</code>中的脚本，可以通过命令： </p>
<pre><code>service service_name [start/stop]
</code></pre>
<p>启动或者关闭（添加到启动脚本中实现自启动，见方法1或）。</p>
</li>
<li>
<p>将启动任务的脚本放到目录<code>/etc/profile.d</code>下，系统启动后将自动执行其中的shell脚本。</p>
</li>
<li>
<p>注册为<a href="https://askubuntu.com/questions/814/how-to-run-scripts-on-start-up/719157#719157"><code>systemd</code></a>托管的服务，在系统启动时运行。</p>
</li>
</ol>
<h3 id="内核配置-1"><a class="header" href="#内核配置-1">内核配置</a></h3>
<p>内核配置项对应文件系统中<code>/proc/sys</code>目录。</p>
<p>读取内核配置项：配置项具有分级结构（对应上述目录树），名称以<code>.</code>或<code>/</code>分隔。</p>
<pre><code class="language-shell">sysctl -n variable          # 输出value, 默认输出 variable = value
sysctl -a -pattern PATTERN  # 打印所有配置项（某些配置项需要管理员权限才可访问）
</code></pre>
<blockquote>
<p><code>-n,--values</code>：仅打印配置项的值；<code>-N,--names</code>：仅打印配置项的名称；</p>
</blockquote>
<pre><code class="language-shell">sysctl -q,--quiet \        # 不将设置的值回显到屏幕
       -w variable=value ...
</code></pre>
<p>加载内核配置：</p>
<pre><code class="language-shell">sysctl -p,--load [FILE] # 默认加载/etc/sysctl.conf
sysctl --system         # 加载系统中所有配置文件
</code></pre>
<h4 id="文件系统-5"><a class="header" href="#文件系统-5">文件系统</a></h4>
<h5 id="最大打开文件数量限制-1"><a class="header" href="#最大打开文件数量限制-1">最大打开文件数量限制</a></h5>
<pre><code class="language-shell">ulimit -n 8192  # 默认1024, 临时修改
</code></pre>
<p>编辑<code>/etc/security/limits.conf</code>，永久修改：</p>
<pre><code class="language-shell"># domain type item   value
    *    soft nofile 16384  # soft limits of Number of Open file
    *    hard nofile 16384  # hard limits 
</code></pre>
<p><a href="https://stackoverflow.com/questions/49632581/fix-with-ulimit-n-8192">linux - Fix with ulimit -n 8192 - Stack Overflow</a></p>
<h5 id="inotify文件监控数量限制-1"><a class="header" href="#inotify文件监控数量限制-1"><code>inotify</code>文件监控数量限制</a></h5>
<p>文件监控数量限制如果设置太小，容易触发<code>inotify watch limit reached</code>错误。临时设置运行时参数：</p>
<pre><code class="language-shell">sudo sysctl fs.inotify.max_user_watches=524288  # 8192 default
</code></pre>
<p>永久修改配置（<code>/etc/sysctl.conf</code>）并运行<code>sysctl -p</code>重新加载。</p>
<pre><code class="language-shell">fs.inotify.max_user_watches=524288
</code></pre>
<h3 id="字体-1"><a class="header" href="#字体-1">字体</a></h3>
<p>用户可将字体安装在<code>/usr/share/fonts</code>目录下，使用<code>fc-list</code>（需要安装<code>fontconfig</code>）可查看系统中可用字体。</p>
<pre><code class="language-shell">fc-list                                    # &quot;FONT_PATH: FONT_FAMILY:style=STYLE&quot;
fc-list : family                           # 仅输出字体名
fc-list :lang=zh family style file spacing # &quot;PATH: FAMILY:style=STYLE:spacing=SPACE&quot;
</code></pre>
<h3 id="日志-5"><a class="header" href="#日志-5">日志</a></h3>
<p>大部分的发行版都内置使用<code>syslog</code>系统日志，常见的日志一般存放在 <code>/var/log</code> 中。 </p>
<h5 id="常见的系统日志-1"><a class="header" href="#常见的系统日志-1">常见的系统日志</a></h5>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">日志名称</th><th style="text-align: left">记录信息</th></tr></thead><tbody>
<tr><td style="text-align: center"><code>alternatives.log</code></td><td style="text-align: left">系统的一些更新替代信息记录</td></tr>
<tr><td style="text-align: center"><code>apport.log</code></td><td style="text-align: left">应用程序崩溃信息记录</td></tr>
<tr><td style="text-align: center"><code>apt/history.log</code></td><td style="text-align: left">使用<code>apt</code>安装卸载软件的信息记录</td></tr>
<tr><td style="text-align: center"><code>apt/term.log</code></td><td style="text-align: left">使用<code>apt</code>时的具体操作，如package的下载、打开等</td></tr>
<tr><td style="text-align: center"><code>auth.log</code></td><td style="text-align: left">登录认证的信息记录</td></tr>
<tr><td style="text-align: center"><code>boot.log</code></td><td style="text-align: left">系统启动时的程序服务的日志信息</td></tr>
<tr><td style="text-align: center"><code>Consolekit/history</code></td><td style="text-align: left">控制台的信息记录</td></tr>
<tr><td style="text-align: center"><code>dist-upgrade</code></td><td style="text-align: left"><code>dist-upgrade</code> 这种更新方式的信息记录</td></tr>
<tr><td style="text-align: center"><code>dmesg</code></td><td style="text-align: left">启动时，显示屏幕上内核缓冲信息,与硬件有关的信息</td></tr>
<tr><td style="text-align: center"><code>dpkg.log</code></td><td style="text-align: left"><code>dpkg</code> 命令管理包的日志</td></tr>
<tr><td style="text-align: center"><code>faillog</code></td><td style="text-align: left">用户登录失败详细信息记录</td></tr>
<tr><td style="text-align: center"><code>fontconfig.log</code></td><td style="text-align: left">与字体配置有关的信息记录</td></tr>
<tr><td style="text-align: center"><code>kern.log</code></td><td style="text-align: left">内核产生的信息记录，在自己修改内核时有很大帮助</td></tr>
<tr><td style="text-align: center"><code>lastlog</code></td><td style="text-align: left">用户的最近一次信息记录。</td></tr>
<tr><td style="text-align: center"><code>wtmp</code></td><td style="text-align: left">登录信息的记录。</td></tr>
<tr><td style="text-align: center"><code>btmp</code></td><td style="text-align: left">远程登录信息记录。</td></tr>
<tr><td style="text-align: center"><code>syslog</code></td><td style="text-align: left">系统信息记录</td></tr>
</tbody></table>
</div>
<p>日志一般都是文本文件，可使用 <code>less</code>、<code>cat</code>、<code>more</code> 等工具查看。 <code>wtmp</code>、<code>lastlog </code>是二进制文件，需要使用<code>last</code>和<code>lastlog</code>工具来提取其中的信息。</p>
<h4 id="rsyslog-1"><a class="header" href="#rsyslog-1">rsyslog</a></h4>
<h4 id="systemd-journal-1"><a class="header" href="#systemd-journal-1">systemd-journal</a></h4>
<h5 id="查看日志-1"><a class="header" href="#查看日志-1">查看日志</a></h5>
<p>筛选日志：</p>
<pre><code class="language-shell">journalctl --system|user          # 查看系统/当前用户日志
journalctl -u,--unit=UNIT
           -t,--identifier=STRING # 查看指定syslog标识的日志
           -S,--since=DATE        # '2022-05-01 [12:00:00]'
           -U,--until=DATE
</code></pre>
<p>追踪日志更新：</p>
<pre><code class="language-shell">journalctl -f,--follow
           -n,--lines=NUM         # 显示日志数量
</code></pre>
<h5 id="日志存储设置-1"><a class="header" href="#日志存储设置-1">日志存储设置</a></h5>
<pre><code class="language-shell">journalctl --disk-usage
journalctl --rotate
journalctl --vacuum-time=2d   # 清理超过2天的日志
journalctl --vacuum-size=100M # 清理超过100M的日志
journalctl --vacuum-files=5   # 清理超过数量的日志
systemctl kill --kill-who=main --signal=SIGUSR2 systemd-journald.service
rm -rf /run/log/journal/* 
rm -rf /var/log/journal/* 
systemctl restart systemd-journald.service
journalctl --verify
</code></pre>
<h4 id="终端命令记录-1"><a class="header" href="#终端命令记录-1">终端命令记录</a></h4>
<pre><code class="language-sh">histroy   # 显示历史记录： cat ~/.bash_history
history -c  # 删除历史记录：rm ~/.bash_history
</code></pre>
<h4 id="用户登录信息-1"><a class="header" href="#用户登录信息-1">用户登录信息</a></h4>
<pre><code class="language-sh">who /var/log/wtmp  	# 查看用户登录历史记录
last [username] [-f /var/log/btmp] # 默认读取/var/log/wtmp
lastlog [-u username] [-t 5] [-b 60]
</code></pre>
<h4 id="浏览器桌面环境-1"><a class="header" href="#浏览器桌面环境-1">浏览器（桌面环境）</a></h4>
<pre><code class="language-sh">ls -l ~/.opera/cach4
ls -l ~/.mozilla/firefox/*.default/cache
</code></pre>
<h4 id="日志清理-1"><a class="header" href="#日志清理-1">日志清理</a></h4>
<p><code>logrotate</code>是Linux自带的文本日志处理工具，可进行切割、打包、压缩等处理。其配置文件位于<code>/etc/logrotate.conf</code>以及<code>/etc/logrotate.d/</code>。</p>
<pre><code class="language-shell">/tmp/dask/*log {
  rotate 7       # 指定日志文件删除之前转储的次数,0直接删除,-1不删除
  daily          # 指定转储周期:hourly,daily,weekly,monthly, yearly
  minsize 1M     # 文件大于1M时才会进行轮转
  maxsize 100M   # 文件大于100M时强制进行轮转(即使还未到轮换周期)
  size    100M   # 指定轮转大小: k/M/G (与轮转周期互斥)
  minage  10     # 文件创建超过10天才进行轮转
  maxage  100    # 移除创建超过100天的已轮转的文件
  missingok      # 忽略不存在的日志文件/nomissingok
  ifempty        # 即使日志文件为空文件也做轮转/noifempty
  dateext        # 使用当期日期作为命名格式,默认值取决于轮换周期
  dateformat -%Y%m%d%H # 
  nocompress     # 
  create [[mode] owner group] # 新日志文件的权限, 默认和原来的文件相同的权限
  copytruncate   # 复制并清空日志文件(override create)*
  prerotate
  	script	
  endscript
  postrotate     # postrotate脚本 
    /sbin/nginx -s reload  
  endscript  # postrotate脚本结束
}
</code></pre>
<blockquote>
<p><code>*</code>：适用于日志输出程序无法获取日志文件打开状态的情况；但可能造成少量日志丢失。</p>
</blockquote>
<p><code>logrotate</code>通过<code>ctrontab</code>调度，默认每天运行一次（除非任务指定更小的周期）。可手动立即执行：</p>
<pre><code class="language-shell">logrotate -s /var/lib/logrotate/logrotate.status /etc/logrotate.conf
</code></pre>
<h2 id="软件管理-1"><a class="header" href="#软件管理-1">软件管理</a></h2>
<p>各发行版提供的<a href="Linux/Linux%E9%85%8D%E7%BD%AE%E5%92%8C%E7%AE%A1%E7%90%86.html#Linux%E5%8F%91%E8%A1%8C%E7%89%88.md">软件仓库与软件管理方案</a>。本章介绍，当前主要的跨发行版软件管理解决方案。</p>
<h3 id="snap-1"><a class="header" href="#snap-1">Snap</a></h3>
<p>Snap将软件及其依赖打包到独立环境，它的运行环境是容器化的沙箱，从而避免各发行版兼容性问题并保证一定的安全性。</p>
<p><img src="Linux/Linux%E9%85%8D%E7%BD%AE%E5%92%8C%E7%AE%A1%E7%90%86.assets/image-20210731135944209.png" alt="image-20210731135944209" /></p>
<h4 id="安装snap-1"><a class="header" href="#安装snap-1">安装snap</a></h4>
<p>Ubuntu/Debian系统预装<code>snapd</code>，使用<code>snap version</code>查看。</p>
<pre><code class="language-shell">sudo yum install snapd  # [epel-release]
sudo systemctl enable snapd # 安装后需要手动启动
</code></pre>
<blockquote>
<p><code>snapd</code>无需持续在后台运行，仅在执行<code>snap</code>命令时被调用运行。</p>
</blockquote>
<h4 id="安装和升级snap软件-1"><a class="header" href="#安装和升级snap软件-1">安装和升级snap软件</a></h4>
<pre><code class="language-shell">snap find &quot;media player&quot;
sudo snapd install 'appname'
sudo snap refresh 'appname'    # update
snap list  # 列出已安装的软件的简要信息
snap info 'pkgname'| 'pkgname.snap'  # 查看[已安装]软件包信息
          --color=auto|always|never
          --verbose
</code></pre>
<p>安装<code>classic</code>类型的软件，此类软件不受沙盒限制：</p>
<pre><code class="language-shell">sudo ln -s /var/lib/snapd/snap /snap
sudo snap install julia --classic
</code></pre>
<p>下载<code>snap</code>包和离线安装：</p>
<pre><code class="language-shell">snap donwload 'package name'
              --target-directory=.
              --channel=5.x/stable
snap ack path/to/package_name.assert  
snap install path/to/package_name.snap
             --dangerous  # 如果没有执行ack,则需要该选项才可以安装
</code></pre>
<h5 id="snap安装目录-1"><a class="header" href="#snap安装目录-1">snap安装目录</a></h5>
<pre><code class="language-shell">/snap               # -&gt; Debian based
#/snap/bin                   - Symlinks to snap applications.
#/snap/&lt;snapname&gt;/&lt;revision&gt; - Mountpoint for snap content.
#/snap/&lt;snapname&gt;/current    - Symlink to current revision, if enabled.
/var/lib/snapd/snap # -&gt; RHEL based
</code></pre>
<h5 id="snapying用的配置文件数据目录-1"><a class="header" href="#snapying用的配置文件数据目录-1">snapying用的配置文件/数据目录</a></h5>
<pre><code class="language-shell">/var/snap/&quot;snap_name&quot;
</code></pre>
<h5 id="移除snap软件-1"><a class="header" href="#移除snap软件-1">移除snap软件</a></h5>
<pre><code class="language-shell">snap remove &quot;snap_name&quot;  
     --purge  # 不保存软件的数据
</code></pre>
<p>软件的所有数据将自动备份（<em>automatic snapshopt</em>）以便后续恢复。</p>
<h4 id="备份和恢复-1"><a class="header" href="#备份和恢复-1">备份和恢复</a></h4>
<pre><code class="language-shell">snap save 'appname' --users &quot;all&quot;  # 创建用户、系统和配置数据的快照。
snap saved --id ID
snap forget &quot;id&quot; &quot;appname&quot;
snap restore &quot;id&quot; &quot;snap_name&quot; --users &quot;all&quot;  # 使用指定快照恢复其中的用户、系统和配置数据。
snap export-snapshot &quot;id&quot; /path/to/export
snap import-snapshot /path/to/import
</code></pre>
<blockquote>
<p>不同版本（<code>epoch</code>）之间不能恢复数据。</p>
</blockquote>
<p>回退到上个版本并恢复数据(不包括共享数据)：</p>
<pre><code class="language-shell">sudo snap revert 'appname' --revision ID 
</code></pre>
<h4 id="snap配置-1"><a class="header" href="#snap配置-1">snap配置</a></h4>
<pre><code class="language-shell">snap get &quot;appname&quot;
snap set &quot;appname&quot; key1=value1 key2.subkey=value2
snap unset &quot;appname&quot; key1 key2
</code></pre>
<h4 id="管理snap应用的运行状态-1"><a class="header" href="#管理snap应用的运行状态-1">管理snap应用的运行状态</a></h4>
<p>查看服务运行状态和日志：</p>
<pre><code class="language-shell">snap services &lt;appaname&gt;  # 查看APP提供的服务的运行状态
# =&gt; systemctl status snap.&lt;appname&gt;.&lt;appserivce&gt;
snap logs -f &lt;appname&gt;.&lt;servicename&gt; 
</code></pre>
<h5 id="启动应用软件-1"><a class="header" href="#启动应用软件-1">启动应用软件</a></h5>
<p>如果安装未生成启动软件的快捷方式，可通过命令启动。</p>
<pre><code class="language-shell">snap run &lt;appcommand&gt;   # 命令可通过snap info查看
</code></pre>
<h5 id="管理软件服务-1"><a class="header" href="#管理软件服务-1">管理软件服务</a></h5>
<p>可使用<code>snap</code>或<code>systemctl</code>来控制服务运行。<code>snap</code>服务默认会在失效后自动重启。</p>
<pre><code class="language-shell">sudo snap start/restart/stop &lt;appname&gt;
sudo snap restart &lt;appname&gt;.&lt;servicename&gt;
sudo systemctl restart snap.&lt;appname&gt;.&lt;servicename&gt;
</code></pre>
<h3 id="appimage-1"><a class="header" href="#appimage-1">AppImage</a></h3>
<p>AppImage比较简单易用，不需要安装额外的工具，整个软件都在一个文件里，下载后可以直接运行。里面有个SquashFS的文件系统，运行的时候会挂在到一个临时的地方，里面有所有只读的文件，包括可执行文件、库文件、静态数据等。除此之外都和普通的软件运行环境是一样的。</p>
<p><a href="https://github.com/AppImage/AppImageKit/wiki/Similar-projects#comparison">Similar projects · AppImage/AppImageKit Wiki (github.com)</a></p>
<h3 id="flatpak-1"><a class="header" href="#flatpak-1">Flatpak</a></h3>
<h3 id="linuxbrew-1"><a class="header" href="#linuxbrew-1">linuxbrew</a></h3>
<p>安装发行版软件仓库缺失的软件。</p>
<h4 id="安装linuxbrew-1"><a class="header" href="#安装linuxbrew-1">安装linuxbrew</a></h4>
<pre><code class="language-shell">SRC_URL='https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh'
/bin/bash -c &quot;$(curl -fsSL $SRC_URL)&quot;
</code></pre>
<p>官方安装脚本下载以及官方源(github)的速度都比较慢，推荐<a href="Linux/Linux%E9%85%8D%E7%BD%AE%E5%92%8C%E7%AE%A1%E7%90%86.html#%E6%9C%AC%E5%9C%B0%E7%BD%91%E7%BB%9C%E4%BB%A3%E7%90%86">使用代理</a>进行安装。或者<a href="https://mirrors.tuna.tsinghua.edu.cn/help/homebrew/">使用国内镜像进行安装和后续软件安装</a>，配置镜像源相关环境变量：</p>
<pre><code class="language-shell">MIRROR=&quot;https://mirrors.tuna.tsinghua.edu.cn&quot;
export HOMEBREW_BREW_GIT_REMOTE=&quot;$MIRROR/git/homebrew/brew.git&quot;
export HOMEBREW_CORE_GIT_REMOTE=&quot;$MIRROR/git/homebrew/homebrew-core.git&quot;
export HOMEBREW_BOTTLE_DOMAIN=&quot;$MIRROR/homebrew-bottles&quot;
</code></pre>
<p>执行以下命令下载安装脚本并执行安装：</p>
<pre><code class="language-shell">git clone --depth=1 $MIRROR/git/homebrew/install.git brew-install
bash brew-install/install.sh
rm -rf brew-install
</code></pre>
<p>安装完成后根据输出提示，将初始化命令加入shell配置文件。然后，根据输出信息，安装建议的编译环境，用于<code>brew</code>进行本地编译打包。</p>
<blockquote>
<p><code>brew</code>的默认安装位置为<code>/home/linuxbrew/.linuxbrew/</code>。</p>
</blockquote>
<h4 id="安装软件-1"><a class="header" href="#安装软件-1">安装软件</a></h4>
<pre><code class="language-shell">brew install pkgname
</code></pre>
<p>查找软件可在<a href="https://brew.sh/">brew.sh</a>查找，或通过命令查找：</p>
<pre><code class="language-shell">brew search pkgname
</code></pre>
<h2 id="进程管理-2"><a class="header" href="#进程管理-2">进程管理</a></h2>
<h3 id="查看进程-1"><a class="header" href="#查看进程-1">查看进程</a></h3>
<pre><code class="language-shell">jobs [-lnprs] [jobspec ...] or jobs -x command [args]
#    Display status of jobs.
</code></pre>
<h4 id="查看并过滤进程-1"><a class="header" href="#查看并过滤进程-1">查看并过滤进程</a></h4>
<pre><code class="language-shell">ps -e|-A  \  # 查看所有进程
   -T|t   \  # 当前终端上的所有进程
   -x     \  # 没有关联控制终端（tty）的进程
   -r     \  # 正在运行的进程 
   -a     \  # 排除关联tty的所有进程或session leader   
   -d     \  # 除了session leader外的所有进程
   -N     \  # --deselect 反选
   H         # 将线程视作进程显示
</code></pre>
<h5 id="查找进程-1"><a class="header" href="#查找进程-1">查找进程</a></h5>
<pre><code class="language-shell">ps -C cmd1,cmd2,... \  # 根据命令名comm筛选
   -p 123,124,... \    # --pid,-q 根据进程号筛选
   -ppid 10       \    # 根据父进程号筛选
   -U EUID        \    # effective user ID (EUID) or name
   -u RUID        \    # real user ID (RUID) or name
</code></pre>
<blockquote>
<p><code>-C</code>匹配进程命令起始子串，不包括路径与特殊字符'<code>/-</code>'；无法匹配到僵尸进程。</p>
</blockquote>
<pre><code class="language-shell">pgrep -f PATTERN  \   # --full 匹配完整进程名
      -x          \   # --exact 完整匹配命令行
      -v          \   # --inverse 反向匹配
      -g PGID,... \   # --pgroup 匹配进程组ID
      -G GID,...  \   # --group 匹配real group IDs
      -i          \   # --ignore-case
      -n          \   # --newest 选择最近启动的进程
      -o          \   # --oldest
      -P PPID,... \   # --parent 匹配父进程ID
      -s SID,...  \   # --sessioin 匹配会话ID
      -u ID,...   \   # --euid 匹配effective user ID
      -U ID,...   \   # --uid 匹配real user ID
      -t TTY,...  \   # --terminal 匹配终端
      --ns PID --nslist ns,...
pgrep -l  \  # --list-name 列出PID和进程名
      -a  \  # --list-full 列出PID和命令行
      -c  \  # --count 输出匹配计数
</code></pre>
<p><code>ps -C</code>和<code>pgrep</code>无法匹配到僵尸进程<code>&lt;defunct&gt;</code>，可以利用<code>ps -ef</code>的输出内容进行匹配。</p>
<pre><code class="language-sh">ps -ef | grep defunct | grep -v grep
</code></pre>
<h5 id="输出进程信息-1"><a class="header" href="#输出进程信息-1">输出进程信息</a></h5>
<pre><code class="language-shell">ps -f|-F \  # 完全信息，包括命令行（-F包括附加信息）
   -l    \  # 显示更多信息，可以与-f|-F组合使用
ps -o pid,tid,... \ # 指定输出的字段
   -o '%cpu %mem' \ # 在单个参数中指定输出的字段
   -o class       \ # 可指定多个输出选项
   -o wchan:14    \ # 指定输出字段的位宽
   -o comm=       \ # 该字段不输出字段名(当所有字段都不输出字段名，省略表头)
</code></pre>
<div class="table-wrapper"><table><thead><tr><th></th><th></th><th></th><th></th></tr></thead><tbody>
<tr><td><code>pid</code></td><td>==进程编号==</td><td><code>ppid</code></td><td>父进程编号</td></tr>
<tr><td>`lwp</td><td>spid</td><td>tid`</td><td>轻量线程ID</td></tr>
<tr><td>`pgid</td><td>prp`</td><td>进程组编号</td><td><code>tgid</code></td></tr>
<tr><td>`%cpu</td><td>pcpu`</td><td>CPU占用率（小数）</td><td><code>c</code></td></tr>
<tr><td>`cputime</td><td>time`</td><td>==累计CPU占用时长==</td><td><code>pri</code></td></tr>
<tr><td><code>start_time</code></td><td>==进程启动时间/日期==</td><td><code>start</code></td><td>进程启动时间</td></tr>
<tr><td><code>etime</code></td><td>==进程启动后经过的时间==</td><td><code>etimes</code></td><td>单位为秒</td></tr>
<tr><td>`%mem</td><td>pmem`</td><td>内存占用比例</td><td>`vsz</td></tr>
<tr><td><code>sz</code></td><td>进程镜像大小</td><td><code>size</code></td><td>需要的交换空间大小</td></tr>
<tr><td>`args</td><td>cmd</td><td>command`</td><td>命令行参数</td></tr>
<tr><td>`sess</td><td>session</td><td>sid`</td><td>会话编号</td></tr>
<tr><td>`tty</td><td>tt</td><td>tname`</td><td>控制终端</td></tr>
<tr><td>`fgid</td><td>fsgid`</td><td>文件访问组编号</td><td>`fgroup</td></tr>
<tr><td>`state</td><td>s`</td><td></td><td><code>stat</code></td></tr>
</tbody></table>
</div>
<p>进程关联<a href="Linux/">用户信息</a>：</p>
<div class="table-wrapper"><table><thead><tr><th></th><th></th><th>real</th><th>effective</th><th>saved</th></tr></thead><tbody>
<tr><td>用户ID</td><td><code>uid</code></td><td><code>ruid</code></td><td>`euid</td><td>uid`</td></tr>
<tr><td>用户标识</td><td><code>user</code></td><td><code>ruser</code></td><td>`euser</td><td>user</td></tr>
<tr><td>组</td><td><code>gid</code></td><td><code>rgid</code></td><td>`egid</td><td>gid`</td></tr>
<tr><td>组标识</td><td><code>group</code></td><td><code>rgroup</code></td><td>`group</td><td>egroup`</td></tr>
</tbody></table>
</div>
<blockquote>
<p>需要systemd支持的字段：</p>
<ul>
<li><code>machine</code>：进程分配到的VM或容器名；</li>
<li><code>ouid</code>：进程会话所有者；</li>
<li><code>lsession</code>：进程的登录会话标识；</li>
</ul>
<p>其他：</p>
<p><code>psr</code>：为进程分配的处理器，<code>sgi_p</code>：进程当前运行的处理器；</p>
<p><code>cgroup</code>：控制组；</p>
<p><code>class|cls|policy</code>：进程调度类型；<code>sched</code>；</p>
<p><code>blocked|sig_block|sigmask</code>：阻止的信号（32或64位掩码）；
<code>caught|sig_catch|sigcatch</code>：捕获的信号（32或64位掩码）；
<code>ignored|sig_ignore, sigignore</code>：忽略的信号（32或64位掩码）；
<code>pending|sig</code>：挂起的信号（32或64位掩码）；</p>
<p><code>f|flag|flags</code>：进程标识。</p>
</blockquote>
<h5 id="进程树-1"><a class="header" href="#进程树-1">进程树</a></h5>
<pre><code class="language-shell">ps  f  \  # 显示为进程树
   -H  \  # 显示进程层级（缩进）
</code></pre>
<pre><code class="language-sh">pstree -U     \  # --unicode 使用UTF-8画线符号（默认）表示树
       -A     \  # --ascii 使用ASCII画线符号
       -h     \  # --highlight-all 重点显示当前进程及其祖先进程
       -H PID \  # --highlight-pid 重点显示给定进程及其祖先进程
       -g     \  # --show-pgids 显示进程组标识
       -p     \  # --show-pids 显示进程标识
       -s     \  # --show-parents 显示父进程标识
       -n     \  # --numeric-sort 根据PID对输出排序
       -l     \  # --long 不截断长行
       PID    \  # 进程树根节点的PID，默认为1（init/systemd）
       USER   \  # 显示指定用户的进程树
</code></pre>
<h4 id="任务状态-1"><a class="header" href="#任务状态-1">任务状态</a></h4>
<pre><code class="language-sh">top -b -n N \       # 非交互模式，刷新N次
    -o FIELD[-+] \  # 按字段排序：&quot;+&quot;=&gt;DESC; &quot;-&quot;=&gt;ASC
    -O              # 不执行命令，仅输出可用的排序字段
</code></pre>
<blockquote>
<p><code>top</code>命令显示的是你的程序占用的cpu的总数，也就是说如果你是4核cpu那么cpu最高占用率可达400%，<code>top</code>里显示的是把所有使用率加起来。</p>
<p>在<code>top</code>的运行环境中按下键盘的<code>1</code>，显示每个cpu核的状态。</p>
</blockquote>
<h5 id="交互环境命令-1"><a class="header" href="#交互环境命令-1">交互环境命令</a></h5>
<p>排序：<code>M-&gt;Mem, N-&gt;PID, P-&gt;%cpu, T-&gt;TIME+</code>。</p>
<h5 id="watch-1"><a class="header" href="#watch-1">watch</a></h5>
<pre><code class="language-shell">watch &quot;ps -ef | grep nginx | grep -v grep&quot; \
      -d,--difference        \ # 高亮两次更新的差别
      -n,--interval seconds  \ # 更新周期
</code></pre>
<p><code>watch</code>的命令参数可包含多条命令，输出结果包含每条命令的输出内容。</p>
<h4 id="查看进程打开资源-1"><a class="header" href="#查看进程打开资源-1">查看进程打开资源</a></h4>
<p>打开的文件可能是常规文件、文件夹、库、流、<a href="Linux/Linux%E9%85%8D%E7%BD%AE%E5%92%8C%E7%AE%A1%E7%90%86.html#%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E7%8A%B6%E6%80%81%E4%BF%A1%E6%81%AF">网络文件（套接字、NFS文件）</a>等。</p>
<pre><code class="language-shell">lsof   # list open files
lsof /bin/bash
#COMMAND      PID  USER  FD   TYPE DEVICE SIZE/OFF      NODE NAME
#mysqld_sa   1597 mysql txt    REG  253,0   960472 738200678 /usr/bin/bash
#sh         11503    es txt    REG  253,0   960472 738200678 /usr/bin/bash
#bash       16538  yarn txt    REG  253,0   960472 738200678 /usr/bin/bash
#bash       63028  yarn txt    REG  253,0   960472 738200678 /usr/bin/bash
</code></pre>
<blockquote>
<p>需要安装<code>lsof</code>。</p>
</blockquote>
<pre><code class="language-shell">fuser [options] file/fs  # identify processes using files or sockets
fuser /bin/bash  # 返回使用文件的进程号与使用方式（后缀）
# /usr/bin/bash:        1597e 11503e 13039e 63028e 63030e 64836e
</code></pre>
<h3 id="进程控制-2"><a class="header" href="#进程控制-2">进程控制</a></h3>
<h4 id="创建进程-4"><a class="header" href="#创建进程-4">创建进程</a></h4>
<p><code>nohup &amp;</code></p>
<h4 id="终止进程-1"><a class="header" href="#终止进程-1">终止进程</a></h4>
<p>如果父进程在子进程之后终止，但子进程终止时父进程没有进行最后的回收工作，子进程残留的数据结构称为僵尸进程。</p>
<h5 id="终止单个进程-1"><a class="header" href="#终止单个进程-1">终止单个进程</a></h5>
<p><code>kill</code>向进程发送信号使进程终止，默认信号是<code>-TERM</code>。</p>
<pre><code class="language-sh">kill [-s sigspec | -n signum | -sigspec] pid ...
kill -l [sigspec]
</code></pre>
<p><code>sigspec</code>表示信号名，<code>signum</code>表示信号值。</p>
<div class="table-wrapper"><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody>
<tr><td><code>-l, --list [sigspec]</code></td><td><strong>列出可发送的信号</strong>，如果给出信号名（值），<br />则将信号名（值）转换为信号值（名）</td></tr>
<tr><td><code>-s sigspec</code> <br /><code>-n signum</code>   <br /><code>-sigspec</code></td><td>指定发送的信号，例如：<code>-ABRT,-ALRM,-HUP,-KILL,-STOP,-SEGV, -TERM,-TRAP</code>。</td></tr>
</tbody></table>
</div>
<h5 id="终止匹配名称的进程-1"><a class="header" href="#终止匹配名称的进程-1">终止匹配名称的进程</a></h5>
<pre><code class="language-sh">killall [-s sigspec | -sigspec] [-e] [-I] [-g] [-i] [-u user] [-v] [-w] name ...
killall –l
</code></pre>
<p>选项</p>
<div class="table-wrapper"><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody>
<tr><td><code>-l, --list</code></td><td>列出可发送的信号</td></tr>
<tr><td><code>-s,--signal sigspec</code> <br/><code> -sigspec</code></td><td>指定发送的信号</td></tr>
<tr><td><code>-e, --exact</code></td><td>匹配名称</td></tr>
<tr><td><code>-I, --ignore--case</code></td><td>匹配名称时忽略大小写</td></tr>
<tr><td><code>-g, --process-group</code></td><td>向进程所属的进程组发送信号</td></tr>
<tr><td><code>-i, --interactive</code></td><td>在杀死进程前交互式确认</td></tr>
<tr><td><code>-q, --quiet</code></td><td>如果没有进程被杀死，不输出信息</td></tr>
<tr><td><code>-u, --user</code></td><td>仅杀死属于给定用户的进程</td></tr>
<tr><td><code>-v, --verbose</code></td><td>报告信号是否成功发送</td></tr>
<tr><td><code>-w, --wait</code></td><td>等待所有被杀死的进程结束</td></tr>
</tbody></table>
</div>
<h5 id="终止匹配的进程-1"><a class="header" href="#终止匹配的进程-1">终止匹配的进程</a></h5>
<pre><code class="language-shell">pkill [options] --signal SIGNAL PATTERN
</code></pre>
<h5 id="终止图形进程-1"><a class="header" href="#终止图形进程-1">终止图形进程</a></h5>
<pre><code class="language-sh">xkill
</code></pre>
<p>出现“<code>x</code>”标志的鼠标，点击需要中止的程序即可。</p>
<h4 id="清理进程-1"><a class="header" href="#清理进程-1">清理进程</a></h4>
<pre><code class="language-shell">wait -f -n [CH_PID,,,]  # 清理子进程
</code></pre>
<h3 id="服务-1"><a class="header" href="#服务-1">服务</a></h3>
<h4 id="systemd-1"><a class="header" href="#systemd-1">systemd</a></h4>
<p><code>systemd</code>（<em><strong>system and service manager</strong></em>），init system (<code>PID=1</code><sup class="footnote-reference"><a href="#pid1">2</a></sup>, started by the kernel, to bring up userspace) managing userspace services. (<em>fast and efficient boot-up</em>)</p>
<blockquote>
<p><code>sysvinit</code></p>
</blockquote>
<pre><code class="language-shell">/sbin/init -&gt; ../lib/systemd/systemd
</code></pre>
<p>system instance: system.conf and the files in system.conf.d</p>
<p>user instance:  user.conf and the files in user.conf.d</p>
<p>&quot;units&quot; of 11 different types. states: <code>active/inactive/activating/decativating/failed</code>；</p>
<p>Units are named as their configuration files</p>
<p>Processes systemd spawns are placed in individual Linux control groups named after the unit which they belong to in the private systemd hierarchy. <code>/sys/fs/cgroup/systemd/</code></p>
<p>transaction system: before executing a requested operation, systemd will verify that it makes sense, fixing it if possible, and only failing if it really cannot work.</p>
<ul>
<li>
<p>Service：管理控制守护进程及其相关进程；</p>
</li>
<li>
<p><a href="https://man7.org/linux/man-pages/man5/systemd.socket.5.html">Socket</a>：用于提前创建套接字资源。</p>
</li>
<li>
<p><a href="https://man7.org/linux/man-pages/man5/systemd.target.5.html">Target</a>：group units（使用<code>Requires,After</code>）。</p>
<p>default.target whose  job is to activate on-boot services and other on-boot units by pulling them in via dependencies.<code> graphical.target</code>/<code>multi-user.target</code></p>
</li>
<li>
<p>Device：expose kernel devices</p>
</li>
<li>
<p><a href="https://man7.org/linux/man-pages/man5/systemd.mount.5.html">Mount</a>/Swap：mount points/memory swap（类似于<code>mount</code>命令）</p>
</li>
<li>
<p>Automount</p>
</li>
<li>
<p>Timer：定时触发其他单元；</p>
</li>
<li>
<p><a href="https://man7.org/linux/man-pages/man5/systemd.path.5.html">Path</a>：</p>
</li>
<li>
<p><a href="https://man7.org/linux/man-pages/man5/systemd.slice.5.html">Slice</a>：分组资源管理；</p>
</li>
<li>
<p>Scope：管理外部进程</p>
</li>
</ul>
<p>信号处理：</p>
<p><code>SIGTERM</code>：重启systemd system manager；</p>
<p><code>SIGINT</code>（<code>Ctrl+Alt+Del</code>）：If this signal is received  more than 7 times per 2s, an immediate reboot is triggered.</p>
<p><code>SIGHUP</code>：<code>systemctl daemon-reload</code></p>
<p>管理器交互命令可以用于管理服务。<code>systemctl</code> are used to give commands to the manager.</p>
<pre><code class="language-sh">systemctl --version # 查看版本和加载模块
systemctl {start|stop|reload|restart|kill} &lt;service&gt;
systemctl {enable|unmask} --now &lt;service&gt; # 启用并立即启动服务
systemctl {disable|mask} &lt;service&gt;        # 禁用/屏蔽服务
systemctl status &lt;service&gt;
systemctl show &lt;service&gt;
systemctl list-unit-files --type {service|target} # 列出已安装单元
systemctl list-units --type {...}                 # 列出已加载单元
systemctl daemon-reload  # 重新加载服务单元配置（不影响现有服务）
</code></pre>
<blockquote>
<p>此外，<code>systemdctl</code>还可用于控制系统</p>
<pre><code class="language-sh">systemctl {poweroff|reboot[arg]|suspend|hibernate}
</code></pre>
</blockquote>
<blockquote>
<p><code>service</code>命令也用用管理服务，在Ubuntu中其实际调用的是<code>systemctl</code>。</p>
</blockquote>
<p><a href="http://www.ruanyifeng.com/blog/2016/03/systemd-tutorial-commands.html">Systemd 入门教程：命令篇 - 阮一峰的网络日志 (ruanyifeng.com)</a></p>
<h5 id="管理配置文件-1"><a class="header" href="#管理配置文件-1">管理配置文件</a></h5>
<blockquote>
<p><em>A unit file is a plain text ini-style file that encodes information about a <strong>service</strong>, <strong>socket</strong>, <strong>device</strong>, <strong>mount point</strong>, <strong>automount point</strong>, <strong>swap file</strong> or <strong>partition</strong>, <strong>start-up target</strong>, <strong>watched file system path</strong>, <strong>timer</strong> controlled and supervised by <code>systemd</code>, <strong>resource management slice</strong> or <strong>group of externally created processes</strong>.</em></p>
</blockquote>
<p>服务配置文件（<code>.ini</code>格式）位于<code>/lib/systemd/system</code>(<code>/lib-&gt;/usr/lib</code>)；<code>systemctl enable</code>会在<code>/etc/systemd/system</code>目录（某些服务也直接置于<code>*.target</code>子目录下）创建一个指向服务单元的链接（也可直接在该目录下储存配置文件或链接其他位置的配置文件，但无法使用<code>enable/disable</code>命令）。</p>
<blockquote>
<p><code>pkg-config systemd --variable=systemdsystemunitdir</code>：系统服务配置文件路径；</p>
<p><code>pkg-config systemd --variable=systemduserunitdir</code>；</p>
<p>不同于其他<code>systemctl</code>命令，==必须以管理员权限执行==<code>systemctl enable|disable</code>以创建或删除服务配置文件的链接。</p>
</blockquote>
<p>配置文件名由管理单元名和类型名组成，如<code>unit-name[@instance-name].service</code>（<strong>服务模板</strong>：在配置文件中通过<code>&quot;%i&quot;</code>引用实例名称）。文件格式：<code>key=value</code>，<code>=</code>前后空格被忽略；<code>#</code>或<code>;</code>为注释行；<code>\</code>用于换行拼接（连接时添加空格，换行符后的注释行被忽略，随后的内容将继续被拼接）；</p>
<p>boolean：<code>1,yes,true,on</code>，<code>0,no,false,off</code></p>
<p>time：默认为秒，&quot;<code>2min 200ms</code>&quot;, s&quot;, &quot;min&quot;, &quot;h&quot;, &quot;d&quot;, &quot;w&quot;, &quot;ms&quot;, &quot;us&quot;.</p>
<p>multiple settings form a list, empty value &quot;resets&quot;</p>
<pre><code class="language-ini">[Unit]
Description=The descript of the service
Documentation=http://,https://,file:,info:,man:,
Wants/Requires/Requisite/BindsTo/PartOf/Upholds=
Conflicts=
Before/After=
After=network.target ... nginx.service mongod.service
[Install]
Alias=sshd.service   # create symlinks 
WantedBy/RequiredBy=multi-user.target
</code></pre>
<p><a href="https://www.freedesktop.org/software/systemd/man/systemd.unit.html#"><code>Unit</code>和<code>Install</code></a>是所有单元类型配置文件共有的部分。</p>
<p><code>foo.service.d/*.conf</code>：在该目录下添加配置文件覆盖该服务的默认配置。</p>
<p><strong>单元参数说明</strong>：</p>
<ol>
<li>依赖声明：==不影响启动顺序（可并行启动）==
<ul>
<li><code>Wants=</code>：one-time effect <code>=&gt; [Install] WantedBy=</code>：<code>foo.service.wants/</code>
<ul>
<li><code>Requires=</code>：<code>=&gt; [Install] RequiredBy=</code>
<ul>
<li><code>Requisite=</code>：<code>=&gt; RequisiteOf=</code></li>
<li><code>BindsTo=</code>：<code>=&gt; BoundBy=</code> </li>
<li><code>PartOf=</code>：<code>=&gt; ConsistsOf=</code></li>
</ul>
</li>
<li><code>UpHolds=</code>：continuous effect,</li>
</ul>
</li>
<li><code>Conflicts=</code>：<code>=&gt; ConflictedBy=</code></li>
</ul>
</li>
<li>启动顺序
<ul>
<li><code>Before=, After=</code></li>
<li><code>OnFailure=,OnSuccess=</code></li>
</ul>
</li>
</ol>
<p>Specifiers available in unit files: https://www.freedesktop.org/software/systemd/man/systemd.unit.html#Specifiers</p>
<p><strong>服务单元参数说明</strong>：</p>
<pre><code class="language-ini">[Service]
Type=simple/exec/forking/oneshot/dbus/notify/idle
ExecStartPre=/usr/local/nginx/sbin/nginx -t -c conf/nginx.conf # 启动前的检测
ExecStart=/usr/local/nginx/sbin/nginx -c conf/nginx.conf       # 启动服务的命令
ExecStartPost=/bin/sleep 1                                     # 启动服务后的命令
ExecReload=/usr/local/nginx/sbin/nginx -s reload               # reload命令
ExecStop=/bin/kill -s TERM $MAINPID                            # stop命令
StandardOutput=syslog
User=service_user
Environment=&quot;VAR=VALUE&quot;    &quot;VAR2=VALUE2&quot;
Environment=&quot;VAR3=VALUE3&quot;  # 可声明多行环境变量
KillMode=control-group, mixed, process, none
KillSignal=SIGTERM
</code></pre>
<ol>
<li>
<p><code>Type=</code>：服务类型</p>
<ul>
<li><code>simple</code>（默认）：认为<code>ExecStart=</code>配置的进程为服务主进程；当服务主进程被创建后（服务执行程序还未运行）即认为服务启动（即使随后服务启动过程出错，<code>systemctl start</code>仍然报告启动成功）并继续启动后续服务。
<ul>
<li><code>exec</code>：等待服务进程被执行后才认为服务启动（<code>systemd</code> 219版本不支持，245版本支持该类型）；
<ul>
<li><code>notify</code>：类似于<code>exec</code>，但服务启动后需要发送一个通知消息，服务管理在收到通知消息后，认为服务启动完成并继续启动后续服务；设置<code>NotifyAccess=</code>以访问<code>systemd</code>提供的通知套接字。</li>
</ul>
</li>
<li><code>oneshot</code>：类似于<code>simple</code>，服务主进程退出后即认为服务启动完成，通常用于设置==开机启动任务==；<code>RemainAfterExit=yes</code>用于表示服务在启动完成后进入<code>active</code>状态，否则，由于没有配置持续运行的进程，服务状态将变为<code>deactivating</code>或<code>dead</code>状态。</li>
<li><code>dbus</code>：类似于<code>simple</code>，服务获得一个D-Bus总线名（<code>BusName=</code>）后，即认为完成启动；默认依赖<code>dbus.socket</code>；</li>
<li><code>idle</code>：类似于<code>simple</code>，但会延迟服务程序的执行时间(最多5s)，直到活动任务被执行。</li>
</ul>
</li>
<li><code>forking</code>：<code>ExecStart=</code>配置的进程会调用<code>fork()</code>来启动后台服务（Unix服务启动协议）。父进程在后台进程启动完成后退出，服务管理认为服务启动完成。==如果服务自身可以输出主进程ID到文件，则推荐使用<code>PIDFile=</code>选项==，使得<code>systemd</code>能够可靠地识别服务主进程从而判断服务状态 。如果未设置<code>PIDFile</code>，则<strong>默认</strong><code>GuessMainPID=yes</code>以尝试获取服务主进程ID，但如果服务存在多个守护进程，则不一定准确。</li>
</ul>
<p>对于长期运行服务，首先推荐使用简单且快速的<code>Type=simlpe</code>。但如果需要获取服务启动状态，或其他服务依赖此服务，则推荐使用<code>notify</code>或<code>dbus</code>；如果服务程序并不支持<code>notify</code>或<code>dbus</code>，则使用<code>forking</code>。对于==仅启动时执行一次==的服务，则可以使用<code>oneshot</code>。</p>
</li>
<li>
<p><a href="https://man7.org/linux/man-pages/man5/systemd.exec.5.html">服务单元执行环境配置</a>：</p>
<ol>
<li>
<p><code>RootDirectory=</code>(<code>chroot</code>)</p>
</li>
<li>
<p><code>WorkingDirectory=</code></p>
</li>
<li>
<p><code>User=, Group=</code></p>
</li>
<li>
<p>进程资源限制<code>ulimit</code>：<code>LimitCPU/LimitFSIZE/LimitNOFILE...</code>；</p>
</li>
<li>
<p>CPU调度策略：<code>CPUSchedulingPolicy/CPUAffinity...</code></p>
</li>
<li>
<p><code>Environment=,EnvironmentFile=</code>：定义传递给服务的环境变量（定义不支持Shell变量替换，重复定义将替换之前的定义）；</p>
<ul>
<li><code>$PATH</code>：默认值<code>/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin</code>；</li>
<li><code>$MAINPID</code>：服务主进程ID，用于管理服务控制进程的关闭和重载；</li>
<li><code>$PIDFILE</code>：通过<code>PIDFile=</code>传递，用于服务守护进程写入进程ID；</li>
</ul>
</li>
<li>
<p><code>StandardInput=,StandardOutput=,StandardError=</code>：<code>inherit, null, tty, kmsg, journal+console, kmsg+console, socket or fd:name.</code></p>
<ul>
<li><code>journal</code>：发送到journal，输出日志通过<code>journalctl</code>查看</li>
<li><code>syslog</code>：发送到系统的syslog服务和journal。</li>
<li><code>file:path</code>(<code>v236+</code>), <code>append:path</code>(<code>v240+</code>), <code>truncate:path</code>：输出到指定文件（<a href="https://unix.stackexchange.com/a/479669/247982">219版本不支持</a>，对于不支持的版本使用文件重定向标准输出）。</li>
</ul>
<blockquote>
<p><code>systemd</code>管理的服务产生的日志可通过<code>journalctl</code>查看。</p>
<pre><code class="language-shell">journalctl [FIELD=VALUE...] \ # 未添加匹配条件则返回所有日志 systemd.journal-fields
    --options
</code></pre>
</blockquote>
</li>
<li>
<p><code>SyslogIdentifier=,SyslogFacility=,SyslogLevel=</code></p>
</li>
</ol>
</li>
<li>
<p><code>ExecStart=</code>：服务启动命令。==除非是<code>oneshot</code>类型==，否则仅能给定一条命令。==命令必须以可执行程序的绝对路径开头==（对于其他<code>Exec</code>命令也一样）。</p>
<blockquote>
<p><code>systemd-path search-binaries-default</code>：如果返回路径，则表示支持直接使用位于路径的命令名。</p>
</blockquote>
<blockquote>
<p>命令参数支持环境变量替换：<code>${VARIABLE}</code>始终解释为一个参数，<code>$VARIABLE</code>必须与命令行==其他内容使用空格分开==（否则不会展开），展开后会按空白分割为多个参数；</p>
<p>支持Systemd定义的<code>%</code>特殊变量。</p>
<pre><code class="language-shell">--opt1 $VARIABLE1  --opt2=${VARIABLE2}
# --opt2=$VARIABLE3 无法完成变量替换
</code></pre>
<p>命令中不能包含重定向（<code>&lt;,&lt;&lt;,&gt;,&gt;&gt;</code>）、管道（<code>|</code>）和后台执行（<code>&amp;</code>）等Shell语法。显式使用<code>bash</code>命令</p>
<pre><code class="language-shell">ExecStart=bash -c 'dmesg | tac'
</code></pre>
<p>命令前缀：</p>
<ul>
<li><code>-</code>：记非零错误返回，但处理行为等效于命令成功执行；</li>
<li><code>:</code>：不替换命令行环境变量；</li>
<li>&quot;<code>+</code>&quot;以完整权限执行，不受用户和分组设置限制；</li>
</ul>
</blockquote>
</li>
<li>
<p><code>ExecStartPre=, ExecStartPost=</code>：类似于<code>ExecStart=</code>：，分别在<code>ExecStart=</code>：前后执行，并可指定多条命令。<code>ExecStart=</code>仅在<code>ExecStartPre=</code>执行成功的情况下执行，否则服务启动失败(<code>ExecStartPost=</code>类似)。<code>ExecStartPre=</code>不应用于启动长期运行程序（<code>ExecStartPre=</code>启动进程所创建的子进程会在服务程序执行前被终止）。任何<code>Exec*=</code>命令执行失败或超时，则会跳转到执行<code>ExecStopPost</code>（跳过<code>ExecStop=</code>）。</p>
</li>
<li>
<p><code>ExecReload=</code>：服务重新加载配置的一条或多条命令（语法类似于<code>ExecStart=</code>）。</p>
</li>
<li>
<p><code>ExecStop=,ExecStopPost=</code>：停止服务的一条或多条命令。如果未指定，则向服务发送``KillSignal=<code>或</code>RestartKillSignal=`指定的信号以终止服务进程。</p>
</li>
<li>
<p><code>TimeoutSec=,RestartSec=,TimeoutStartSec=,TimeoutStopSec=</code>服务启动/停止超时期限。</p>
</li>
<li>
<p><code>Restart=no|on-success|on-failure|on-abnormal|on-watchdog|on-abort|always</code></p>
</li>
<li>
<p><code>SuccessExitStatus=TEMPFAIL 250 SIGKILL</code>：成功退出状态，默认包括<code>0</code>，<code>SIGHUP</code>，<code>SIGINT</code>，<code>SIGTERM</code>和<code>SIGPIPE</code>。</p>
</li>
<li></li>
</ol>
<p><a href="https://www.freedesktop.org/software/systemd/man/systemd.service.html">systemd.service (www.freedesktop.org)</a></p>
<h5 id="服务沙盒-1"><a class="header" href="#服务沙盒-1">服务沙盒</a></h5>
<p>以下选项用于屏蔽向服务进程暴露的系统资源（需要底层安全机制支持才开启，如<code>ProtectSystem</code>需要包含文件系统命名空间的内核）。</p>
<pre><code class="language-ini">ProtectSystem=false|true|full|strict*
ProtectHome=false|true|read-only|tmpfs
PrivateTmp=false|true
</code></pre>
<blockquote>
<p><code>*</code>：<code>strict</code>，<code>tmpfs</code>在<code>219</code>版本（CentOS 7）不可用。</p>
</blockquote>
<ul>
<li>[Mastering systemd: Securing and sandboxing applications and services | Enable Sysadmin (redhat.com)](https://www.redhat.com/sysadmin/mastering-systemd#:~:text=Systemd provides a significant number of security features,this option to full also makes %2Fetc read-only.)</li>
<li><a href="https://www.freedesktop.org/software/systemd/man/systemd.exec.html#Sandboxing">systemd.exec Sandboxing(www.freedesktop.org)</a></li>
</ul>
<p>问题：</p>
<ul>
<li>
<p>开启<code>ProtectSystem</code>后无法对用户家目录进行写操作。</p>
<p>如果使用普通用户运行服务，则不用担心该服务修改系统资源（无权限）。因此，可以关闭<code>ProctectSystem</code>选项。也可尝试将服务的写入目录修改为其他位置，例如<code>/tmp</code>或<code>/var</code>（适用于以<code>root</code>运行的服务）。</p>
</li>
</ul>
<h5 id="挂载单元配置-1"><a class="header" href="#挂载单元配置-1">挂载单元配置</a></h5>
<pre><code class="language-ini">[Mount]
What=/dev/DEVNAME
Where=/mnt/MOUNT_PATH
Type=fs_type
Options=
DirectoryMode=0755  # 自动创建挂载点
TimeoutSec=
# Check systemd.exec(5) and systemd.kill(5) for more settings.
</code></pre>
<h5 id="定时单元器配置-1"><a class="header" href="#定时单元器配置-1">定时单元器配置</a></h5>
<pre><code class="language-ini">[Timer]
OnActiveSec/OnUnitActiveSec=   # 相对定时器(执行单元)上次触发时间设置定时器
OnUnitInactiveSec=             # 相对定时器执行单元上次休眠时间设置定时器
OnCalendar=                    # systemd.time(7) 
Unit=                          # 定时器超时后触发的单元名称
</code></pre>
<h4 id="supervisor-1"><a class="header" href="#supervisor-1">supervisor</a></h4>
<p><a href="http://supervisord.org/introduction.html">Introduction — Supervisor 4.2.2 documentation (supervisord.org)</a></p>
<blockquote>
<p>Supervisor is a client/server system that allows its users to control a number of processes on UNIX-like operating systems. It is not meant to be run as a substitute for <code>init</code> as “process id 1”. Instead it is meant to be used to ==control processes related to a project or a customer==,</p>
<p><code>supervisord</code> starts processes as its subprocesses via <code>fork</code>/<code>exec</code> and subprocesses don’t daemonize. It always knows the true up/down status of its children. If supervisord is started as root, it is possible to allow “normal” users to control (“stop”, “start”, and “restart” ) such processes.</p>
</blockquote>
<p>client/server system</p>
<p>delegation: Supervisorctl allows a very limited form of access to the machine, essentially allowing users to see process status and control supervisord-controlled subprocesses by emitting “stop”, “start”, and “restart” commands from a simple shell or web UI.</p>
<p><code>/etc/supervisord.conf</code></p>
<pre><code class="language-shell">supervisord -c conf_file
            -n, --nodaemon
            -q ,--childlogdir=PATH # must exist, for auto-mode child proocess
            -k, --nocleanup  # prevent removal of old AUTO process log files    
supervisorctl -c conf_file
              -i,--interactive   # 启动交互式命令
              -r,--history-file  # 记录输入命令(realine模块可用)
              ACTION args...
ACTION:
  add/update NAME[:*]... # activate/update process/group config 
  remove NAME ...        # deactivate process config
  clear NAME ...         # clear process log 
  pid [NAME]             # get pid of supervisord/subprocess
  reload                 # restart remote supervisord
  reread                 # reload daemon's config without restart
  start NAME[:*]...      # start process/group (not reread configs)
  restart NAME[:*]...    # restart process/group (not reread configs)
  status [NAME[:*]...]   # 返回进程(组)状态
  tail [-f] NAME [stdout|stderr] # 输出日志的最后部分
</code></pre>
<blockquote>
<p><code>all</code>用于参数中表示所有进程和分组。</p>
</blockquote>
<h5 id="supervisord-as-a-system-service-1"><a class="header" href="#supervisord-as-a-system-service-1">supervisord as a <a href="https://github.com/Supervisor/initscripts">system service</a></a></h5>
<pre><code class="language-ini"># supervisord service for systemd (CentOS 7.0+)
[Unit]
Description=Supervisor daemon
[Service]
Type=forking
ExecStart=/usr/bin/supervisord
ExecStop=/usr/bin/supervisorctl $OPTIONS shutdown
ExecReload=/usr/bin/supervisorctl $OPTIONS reload
KillMode=process
Restart=on-failure
RestartSec=42s
[Install]
WantedBy=multi-user.target
</code></pre>
<h5 id="supervisord-1"><a class="header" href="#supervisord-1"><code>supervisord</code></a></h5>
<pre><code class="language-ini">[supervisord]
logfile=$CWD/supervisord.log # (-l,--logfile=FILE)
logfile_maxbytes=50MB  # rotate limit (-y,--logfile_maxbytes=BYTES)
logfile_backups=10     # number of rotates (-z,--logfile_backups=NUM)
loglevel=info          # (-e,--loglevel=LEVEL)
pidfile=$CWD/supervisord.pid # (-j,--pidfile=FILE)
directory=$PWD         # workdir of supervisord daemon (-d,--directory=PATH)
environment=KEY=&quot;val&quot;,KEY2=&quot;val2&quot; # for all subprocess
</code></pre>
<p>信号处理：</p>
<ul>
<li><code>SIGTERM/SIGINT/SIGQUIT</code>：<code>supervisord</code>及其管理的子进程将会关闭。</li>
<li><code>SIGHUP</code>：关闭所有进程，重新加载配置，并重启所有进程。</li>
<li><code>SIGUSR2</code>：关闭并重新打开主日志以及子进程日志。</li>
</ul>
<h5 id="服务进程配置-1"><a class="header" href="#服务进程配置-1">服务进程配置</a></h5>
<pre><code class="language-ini">[program:SERVICE_NAME]
command=/path/to/programname  # relative is OK
user=gary                     # 启动进程的用户
numprocs=1
priority=999                  # Lower priorities indicate programs that start first
autostart=true                # start with supervisord
autorestart=unexpected        # false, unexpected, or true
startsecs=1                   # 0不检查是否进程在运行
startretries=3
exitcodes=0                   # 正常退出代码（,分隔）
stopwaitsecs=10               # 进程停止等待时间（超时使用SIGKILL强制停止）
stopasgroup=false             # 用于停止具有子进程的进程（如Flask调试模式）
stdout_logfile=AUTO           # 进程的标准输出文件
stdout_logfile_maxbytes=50MB  # 日志文件轮转大小
stdout_logfile_backups=10     # 日志轮转数量限制
stderr_logfile=AUTO           # stderr_logfile_maxbytes/stderr_logfile_backups
stdout_syslog=10              # 使用进程名输出到syslog / stderr_syslog
redirect_stderr=false         # 将进程的错误输出重定向到supervisord的输出
environment=                  # 传递给进程的环境变量
directory=                    # 进程运行的工作目录
</code></pre>
<blockquote>
<p>服务进程本身不应该以守护进程模式运行。</p>
<p>自动重启：如果<code>autorestart=unexpected</code>，则在非手动停止进程的情况下，如果进程退出代码非<code>exitcodes</code>列出的，则重启该进程。</p>
<p><em><code>AUTO</code> log files and their backups will be deleted when <strong>supervisord</strong> restarts.</em></p>
<p>输出文件名为可包含变量<code>group_name</code>, <code>host_node_name</code>, <code>process_num</code>, <code>program_name</code>和<code>here</code>的Python字符串表达式。</p>
</blockquote>
<img src="Linux/Linux配置和管理.assets/subprocess-transitions.png" alt="Subprocess State Transition Graph" style="zoom:50%;" />
<p>服务分组：同类型服务；</p>
<pre><code class="language-ini">[group:foo]
programs=bar,baz
priority=999
</code></pre>
<h5 id="supervisorctl访问supervisord-1"><a class="header" href="#supervisorctl访问supervisord-1"><code>supervisorctl</code>访问<code>supervisord</code></a></h5>
<p><code>supervisorctl</code>可访问本地（UNIX套接字）或远程的<code>supervisord</code>服务（TCP/IP套接字）。</p>
<pre><code class="language-ini">[supervisorctl]
serverurl=unix:///tmp/supervisor.sock  # (-s,--serverurl URL)
# serverurl=http://127.0.0.1:9001
username=gary        # (-u,--username NAME)
password=gang2019    # (-p,--password)
prompt=mysupervisor  # 命令行提示符
</code></pre>
<h5 id="使用web访问supervisord-1"><a class="header" href="#使用web访问supervisord-1">使用Web访问<code>supervisord</code></a></h5>
<pre><code class="language-shell">[inet_http_server]
port=0.0.0.0:9001
username=gary
password=gang2019  # or passord hash: {SHA}82ab876d1387bfafe46cc1c8a2ef074eae50cb1d
</code></pre>
<blockquote>
<p>重启<code>supervisor</code>（使用<code>systemctl</code>）。</p>
</blockquote>
<h5 id="xml-rpc接口-1"><a class="header" href="#xml-rpc接口-1"><a href="http://supervisord.org/api.html">XML-RPC接口</a></a></h5>
<pre><code class="language-python">from xmlrpc.client import ServerProxy
server = ServerProxy('http://localhost:9001/RPC2')
server.supervisor.getState()
server.system.listMethods()
server.system.methodHelp('supervisor.shutdown')
</code></pre>
<h5 id="子配置文件-1"><a class="header" href="#子配置文件-1">子配置文件</a></h5>
<pre><code class="language-ini">[include]
files=/path/filename.conf /path/*.conf foo.conf config??.conf
</code></pre>
<p><a href="http://supervisord.org/api.html#xml-rpc">XML-RPC API Documentation — Supervisor 4.2.2 documentation (supervisord.org)</a></p>
<p><a href="http://supervisord.org/index.html">Supervisor: A Process Control System — Supervisor 4.2.4 documentation (supervisord.org)</a></p>
<h5 id="process-monitoring-and-events-1"><a class="header" href="#process-monitoring-and-events-1">Process Monitoring and Events</a></h5>
<p>Supervisor continually emits event notifications, and the subscribed listener will be notified.</p>
<p>provide a mechanism for code to be run (e.g. send an email, make an HTTP request, etc) when some condition related to subprocess state is met.</p>
<p>The event notification protocol is based on communication via a subprocess’ stdin and stdout.</p>
<p><a href="http://supervisord.org/events.html#example-event-listener-implementation">Example Event Listener Implementation</a></p>
<h4 id="服务管理程序对比-1"><a class="header" href="#服务管理程序对比-1">服务管理程序对比</a></h4>
<p><code>supervisord</code>主要用于管理用户服务进程，<code>systemd</code>处理服务管理外，还支持系统中其他对象如外部设备、套接字、定时器等的管理。</p>
<p><code>systemd</code>具有启动依赖管理控制功能，可以实现有依赖关系的一组对象的正确启动和运行管理；<code>supervisord</code>仅支持进程分组，无依赖解析功能。<code>systemd</code>具有完善的进程资源控制和系统调度策略设置，<code>supervisor</code>可实现较为简单的资源控制。</p>
<p><code>supervisord</code>提供网络访问接口并有可用的Web访问UI，可方便普通用户实现进程管理；<code>systemd</code>需要管理权限执行管理控制功能。</p>
<p><code>superivord</code>发布于2004年，<code>systemd</code>发布于2010年。<code>systemd</code>现在为多数Linux发行版的<code>init</code>程序，因此开箱即用。<code>supervisord</code>需要以Python库或发行版软件仓库软件的方式进行安装。</p>
<p>对于较为简单的服务进程配置管理，<code>supervisord</code>和<code>systemd</code>都能有效实现；对于有远程管理需求的场景，<code>supervisord</code>提供网络访问接口更适合。对于复杂的服务配置管控需求以及<code>supervisor</code>不支持的管控对象，使用<code>systemd</code>更加合适。</p>
<h2 id="网络管理-1"><a class="header" href="#网络管理-1">网络管理</a></h2>
<h3 id="网络管理工具-1"><a class="header" href="#网络管理工具-1">网络管理工具</a></h3>
<p><code>net-tools</code>：包含<code>arp, ifconfig, netstat, rarp, nameif and route</code>。</p>
<p><code>ip</code>：<em>show/manipulate routing, <a href="Linux/Linux%E9%85%8D%E7%BD%AE%E5%92%8C%E7%AE%A1%E7%90%86.html#%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87">network devices</a>, interfaces and tunnels</em>，代替<code>net-tools</code>。</p>
<p><code>NetworkManager</code>：包含<code>NetworkManager</code>服务和命令行工具<code>nmcli</code>、<code>nmtui</code>等。</p>
<blockquote>
<p>与使用<code>ip</code>的功能相同，使用<code>nmcli+NetworkManager</code>将管理功能与用户交互分离。</p>
</blockquote>
<h4 id="networkd-1"><a class="header" href="#networkd-1"><code>networkd</code></a></h4>
<h4 id="networkmanager-1"><a class="header" href="#networkmanager-1">NetworkManager</a></h4>
<p><code>NetworkManager</code>用于代替已有的配置工具<code>ifconfig</code>及其配置文件。<code>NetworkManager</code>作为<code>systemd</code>服务运行（服务的配置文件为<code>/etc/NetworkManager/NetworkManager.conf</code>）。</p>
<p><code>udev</code>设备管理器发现系统新加入设备，通知<code>NetworkManager</code>通过D-Bus来检测和初始化配置网络设备实现即插即用（配置信息动态生成并存储于内存中）。</p>
<p>永久配置文件检查（如果未找到配置文件，则尝试从DHCP服务器获取配置信息）：</p>
<ul>
<li>
<p><code>etc/sysconfig/network-scripts/ifcfg-*</code>：后向兼容<code>ifconfig</code>配置文件；</p>
</li>
<li>
<p><code>/etc/NetworkManager/system-connections/</code>：<code>NetworkManager</code>配置文件。</p>
</li>
</ul>
<p><code>nmcli</code>是NetworkManger的命令行工具（客户端），<code>nmtui</code>是对应的终端图形界面工具。</p>
<blockquote>
<pre><code class="language-shell">yum install NetworkManaget-tui  # nmcli随NetworkManager安装
</code></pre>
</blockquote>
<p>图形化配置接口：</p>
<pre><code class="language-shell">nmtui edit &lt;ifname&gt;    # in CentOS
</code></pre>
<blockquote>
<p>在修改配置时，不要修改设备（<code>00:0C:29:BD:83:63 (ens32)</code>）</p>
</blockquote>
<h3 id="网络状态-1"><a class="header" href="#网络状态-1">网络状态</a></h3>
<h4 id="主机名和域名-1"><a class="header" href="#主机名和域名-1">主机名和域名</a></h4>
<p><code>hostname</code>可以读取主机的主机名、域名和对应的IP地址（<code>/etc/hostname</code>）。</p>
<ul>
<li><code>-A</code>：所有主机名；<code>-s</code>返回一个短主机名；<code>-f</code>返回长主机名；</li>
<li><code>-I</code>：所有IP地址；<code>-i</code>还首先读取IPv6地址；</li>
<li><code>-d</code>：DNS域名；</li>
</ul>
<blockquote>
<p>使用<code>hostnamectl</code>设置主机名。</p>
</blockquote>
<h5 id="域名地址映射-1"><a class="header" href="#域名地址映射-1">域名地址映射*</a></h5>
<pre><code class="language-shell">dig [@dns_server] domain_name
dig -x ip_addr   # reverse lookup
nslookup &lt;domain&gt;
</code></pre>
<blockquote>
<p>支持反向查询<code>nslookup &lt;ipaddr&gt;</code>，但查询到的域名不是通常使用的域名，也可能查不到结果。</p>
</blockquote>
<pre><code class="language-shell">whois &lt;ipaddr|domain&gt;     # sudo apt install whois
</code></pre>
<blockquote>
<p>查询IP地址/域名==所有者==。</p>
</blockquote>
<h4 id="网络接口信息-1"><a class="header" href="#网络接口信息-1">网络接口信息</a></h4>
<pre><code class="language-shell">nmcli   # 代替ifconfig
netstat -i  # 输出网络接口设备的统计信息；
        -ie # =&gt; ifconfig
</code></pre>
<p>使用<code>ip</code>工具列出设备参数(<code>type,mtu,qdisc,state,mode,qlen,mac</code>)：</p>
<pre><code class="language-shell">ip link [show] [up|down] [dev eth0] [type bridge] [master br0] # 显示链路信息
ip address ...   # 显示链路层以及网络地址信息
</code></pre>
<p>使用<code>nmcli</code>查看网络接口连接：</p>
<pre><code class="language-shell">nmcli c[onnection] [show] --active # summary table
# NAME  UUID                                  TYPE      DEVICE
# eth0  cb149a11-edae-3f8f-9af1-7dc541e1ac5d  ethernet  ens32
nmcli connection show &lt;name/id&gt;  # interface details
</code></pre>
<blockquote>
<p>设备未知的接口通常是由于<a href="Linux/Linux%E9%85%8D%E7%BD%AE%E5%92%8C%E7%AE%A1%E7%90%86.html#%E7%BC%96%E8%BE%91%E7%BD%91%E7%BB%9C%E6%8E%A5%E5%8F%A3%E9%85%8D%E7%BD%AE">配置文件</a>存在错误。</p>
</blockquote>
<p>查看网络设备信息：</p>
<pre><code class="language-shell">nmcli d[evice] [show] # summary table
# DEVICE  TYPE      STATE      CONNECTION
# ens33   ethernet  connected  ens33
# lo      loopback  unmanaged  --
nmcli device show &lt;device&gt; # device details
</code></pre>
<h4 id="网络通信状态信息-1"><a class="header" href="#网络通信状态信息-1">网络通信状态信息</a></h4>
<pre><code class="language-shell">netstat -a      # 列出tcp,udp和unix协议套接字连接(默认仅显示unix套接字连接) *
        -{t|u}  # 只列出TCP/UDP连接
        -l      # 只列出监听中的连接
        -p      # 列出进程ID和命令名
        -e      # 列出进程用户和进程文件的Inode编号
        -n      # 禁用对IP地址/端口的反向域名解析，加快查询速度
</code></pre>
<blockquote>
<p><code>*</code>：需要安装<code>net-tools</code>包。</p>
</blockquote>
<p>示例：</p>
<pre><code class="language-sh">sudo netstat -anp | grep ESTABLISHED   # 打印active状态的连接
sudo netstat -anp | grep apache2       # 查看指定服务是否正常运行
</code></pre>
<p>通过访问套接字获取连接信息：</p>
<pre><code class="language-shell">ss -n   # 禁止解析服务名称
   -r   # 尝试解析地址端口信息
   -a/l # 显示所有/监听套接字信息 
   -m   # 显示套接字内存占用
   -p   # 显示使用套接字的进程
   -e   # 显示扩展信息
   -i   # 显示TCP内部信息
   -s   # 打印汇总信息
   -N,--net=NSNAME # 切换网络命名空间
   -f,--family=unix/inet/inet6/link/netlink/vsock
</code></pre>
<p>由于网络连接（套接字）是特殊文件，因此可以使用<code>lsof</code>查看（<code>lsof</code>用于<a href="Linux/Linux%E9%85%8D%E7%BD%AE%E5%92%8C%E7%AE%A1%E7%90%86.html#%E6%9F%A5%E7%9C%8B%E8%BF%9B%E7%A8%8B%E6%89%93%E5%BC%80%E8%B5%84%E6%BA%90">列举进程打开的文件</a>）。</p>
<pre><code class="language-shell">lsof -i -P -n
</code></pre>
<blockquote>
<ul>
<li>
<p><code>-i [addr]</code>：列出使用互联网地址的文件（套接字）；地址格式</p>
<p><code>[46][protocol][@hostname|hostaddr][:service|port]</code></p>
</li>
<li>
<p><code>-U</code> 筛选使用UNIX套接字的进程。</p>
</li>
<li>
<p><code>-P</code>：禁止将端口号解析为服务名；</p>
</li>
<li>
<p><code>-n</code>：禁止将IP地址解析为主机名或域名。</p>
</li>
</ul>
</blockquote>
<h5 id="网络协议统计信息-1"><a class="header" href="#网络协议统计信息-1">网络协议统计信息</a></h5>
<pre><code class="language-shell">netstat -s
</code></pre>
<h5 id="监控网络通信状态-1"><a class="header" href="#监控网络通信状态-1">监控网络通信状态</a></h5>
<pre><code class="language-shell">iftop   # apt|yum install iftop  =&gt; 主机间通信速率
nload   # apt|yum install nload  =&gt; 网络接口通信统计
bmon    # apt|yum install bmon   =&gt; 系统带宽监控
nethogs # yum install nethogs    =&gt; 进程通信统计
</code></pre>
<blockquote>
<p><a href="Linux/../%E5%BA%94%E7%94%A8%E8%BD%AF%E4%BB%B6/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AE%A1%E7%90%86%E8%BD%AF%E4%BB%B6.html#%E7%B3%BB%E7%BB%9F%E7%9B%91%E6%8E%A7%E8%BD%AF%E4%BB%B6">系统监控工具</a>也可以监控网络通信状态的基本参数。</p>
</blockquote>
<h5 id="网络可达性检测-1"><a class="header" href="#网络可达性检测-1">网络可达性检测</a></h5>
<p><code>ping</code>：<em>is part of <code>iputils</code> package</em>。</p>
<pre><code class="language-shell">ping \             # ICMP ECHO_REQUEST
     -4|6  \       # IPv4/IPv6
     -c count \ 
     -D            # print timestamp before each line
     -I interface  # 设置源地址或源接口名称
</code></pre>
<p><code>tracepath</code>：<em>is part of <code>iputils</code> package.</em></p>
<pre><code class="language-shell">tracepath -4|6 -n|b # n|b 仅打印IP地址/打印主机名和IP地址
</code></pre>
<h3 id="网络设备链路管理-1"><a class="header" href="#网络设备链路管理-1">网络设备链路管理</a></h3>
<h4 id="网络配置数据-1"><a class="header" href="#网络配置数据-1">网络配置数据</a></h4>
<p>系统中可能存在的网络设备和接口配置文件：</p>
<ul>
<li>
<p><code>ifup/ifdown</code>（<code>/etc/network/interfaces</code>）</p>
</li>
<li>
<p><code>networkd</code></p>
<pre><code class="language-ini">[connection]
id=br0_eno1
uuid=ccfcb8fa-5f16-4407-ae6c-1af6c9117265
type=bridge
autoconnect=false
interface-name=br0_eno1
permissions=
timestamp=1650420144
[bridge]
stp=false
[ipv4]
address1=172.28.76.22/24,172.28.76.234
dns=172.28.28.28;223.5.5.5;
dns-priority=100
dns-search=
method=manual
[ipv6]
addr-gen-mode=stable-privacy
dns-priority=100
dns-search=
method=link-local
[proxy]
</code></pre>
</li>
<li>
<p><code>ifconfig</code>（<code>etc/sysconfig/network-scripts/ifcfg-*</code>）</p>
<pre><code class="language-ini">TYPE=Ethernet
NAME=eth0                # 应该和配置文件后缀匹配
DEVICE=ens33             # 绑定的设备名
UUID=a016f249-6703-42eb-a207-e40f80de212f # 绑定的设备UUID
HWADDR=84:16:f9:03:fd:85 # 绑定的设备MAC(old)
IPADDR=192.168.2.203
PREFIX=24                # &lt;-&gt; NETMASK
GATEWAY=192.168.178.2
DNS1=223.5.5.5
DNS2=8.8.8.8
ONBOOT=yes
BOOTPROTO=static  # dhcp|bootp|none|static
</code></pre>
</li>
<li>
<p><code>NetworkManager</code>（<code>/etc/NetworkManager/system-connections</code>）</p>
</li>
</ul>
<h5 id="netplan-1"><a class="header" href="#netplan-1">netplan</a></h5>
<p><code>netplan</code>在系统启动早期将配置信息解析并提供给系统的网络管理服务（如<code>NetworkManager</code>）。</p>
<ul>
<li>默认由<code>systemd-networkd</code>管理网络设备，其他服务如<code>NetworkManager</code>可替代其功能。</li>
</ul>
<p><code>netplan</code>配置文件位于<code> /{lib,etc,run}/netplan/*.yaml</code>：</p>
<ul>
<li>对于不同目录下的同名配置文件，仅读取最高优先级目录下的文件（<code>/run&gt;/etc&gt;/lib</code>）；</li>
<li>对于不同名文件，将按文件名字典顺序读取配置文件，并将新内容追加/覆盖已读取内容。</li>
</ul>
<p>配置文件格式（YAML）：</p>
<pre><code class="language-yaml">network:  # 网络配置的根节点
    renderer: networkd|NetworkManager  #  networking backend, 
    ethernets:  # 设备分组, 如: ethernet, modem, wifi
        ens33:  # 设备ID
            dhcp4: false
            dhcp6: true
            addresses:
                - 192.168.0.200/24 # IPv4
                    lifetime: 0
                    label: &quot;maas&quot;
                - &quot;2001:1::1/64&quot;   # IPv6
            gateway4: 192.168.0.1  #! deprecated
            gateway6: &quot;2001:4::1&quot;  #! deprecated
            routes:   # 静态路由*
                - to: default # could be 0/0 or 0.0.0.0/0 optionally 默认路由
                  via: 192.168.0.1  # 默认网关
                  metric: 100
                  on-link: true
                - to: default # could be ::/0 optionally
                  via: cf02:de:ad:be:ef::2
            nameservers:  # 手动地址配置时设置
                addresses: [ 223.5.5.5, &quot;FEDC::1&quot; ]
                search: [lab, home]  #**
            match:
                macaddress: 52:54:00:6b:3c:58 
            macaddress: 52:54:00:6b:3c:59  # 修改匹配设备的MAC地址
            mtu: 1500   # 修改匹配设备的MAC地址
            
    version: 2
</code></pre>
<p>应用配置文件：</p>
<pre><code class="language-shell">sudo netplan generate  # 生成后端配置文件
sudo netplan apply     # 直接应用配置
sudo netplan try       # validate the config and then apply
</code></pre>
<h4 id="物理链路管理-1"><a class="header" href="#物理链路管理-1">物理链路管理</a></h4>
<h5 id="创建和删除链路-1"><a class="header" href="#创建和删除链路-1">创建和删除链路</a></h5>
<pre><code class="language-shell">ip link add \     # 添加虚拟链路
   link DEVICE \  # 指定物理设备(某些链路类型无物理设备，如IP-over-IP)
   name NAME \    # 默认为物理设备名称
   type TYPE \    # 链路类型：bridge,veth,vlan,macvlan,mactap,ip6tnl,gre,...
   index ID       # 链路编号
</code></pre>
<blockquote>
<p>其他参数包括：<code>mtu,address,broadcast,txqueuelen,numtxqueues,numrxqueues,... </code>。</p>
<p>不同类型链路采用不同的数据链路层协议。</p>
</blockquote>
<pre><code class="language-shell">ip link delete {dev NAME|group GROUP} type TYPE
</code></pre>
<pre><code class="language-shell">nmcli connection add type &lt;type&gt; ifname &lt;ifname&gt; ... # 创建链路
nmcli connection delete &lt;ifname&gt; 
</code></pre>
<h5 id="配置链路参数-1"><a class="header" href="#配置链路参数-1">配置链路参数</a></h5>
<pre><code class="language-shell">ip link set [dev NAME] [group GROUP] prop VALUE 
ip address {add|change|replace} IFADDR dev NAME  # 配置IP地址
</code></pre>
<p>如果指定了<code>group</code>则修改设备所属分组，如果未指定设备，则修改分组中所有设备的属性。配置了IP地址的链路能够使用IP协议进行通信。</p>
<pre><code class="language-shell">nmcli connection modify &lt;ifname&gt; [+-]ipv4.addresses 192.168.0.58[/24]
nmcli connection modify &lt;ifname&gt; [+-]ipv4.dns 114.114.114.114
nmcli connection modify &lt;ifname&gt; [-]ipv4.gateway 192.168.0.2
# ipv4.method manual must be supplied with address
nmcli connection modify &lt;ifname&gt; ipv4.method manual \
                                 ipv4.addresses 192.168.0.58/24 
nmcli edit &lt;ifname/id&gt;  # 交互式编辑模式,查看和编辑配置项                                 
</code></pre>
<h5 id="启用和停用链路-1"><a class="header" href="#启用和停用链路-1">启用和停用链路</a></h5>
<pre><code class="language-shell">nmcli c reload
nmcli c up &lt;interface&gt;    # if interface exist
</code></pre>
<h4 id="虚拟网桥管理-1"><a class="header" href="#虚拟网桥管理-1">虚拟网桥管理</a></h4>
<h5 id="创建和配置虚拟网桥-1"><a class="header" href="#创建和配置虚拟网桥-1">创建和配置虚拟网桥</a></h5>
<pre><code class="language-shell">ip link add BRIDGE_NAME type bridge 
brctl addbr BRIDGE_NAME
nmcli connection add type bridge CONN_NAME BRIDGE_NAME ifname BRIDGE_NAME
</code></pre>
<p><a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/8/html/configuring_and_managing_networking/configuring-a-network-bridge_configuring-and-managing-networking">Chapter 12. Configuring a network bridge Red Hat Enterprise Linux 8 | Red Hat Customer Portal</a></p>
<h5 id="将网卡绑定至网桥-1"><a class="header" href="#将网卡绑定至网桥-1">将网卡绑定至网桥</a></h5>
<pre><code class="language-shell">ip link set dev IFNAME master BRIDGE_NAME
nmcli connection modify DEVICE_NAME master BRIDGE_NAME
nmcli connection add type ethernet slave-type bridge CONN_NAME DEVICE_NAME ifname IF_NAME master bridge0
</code></pre>
<h4 id="虚拟网卡管理-1"><a class="header" href="#虚拟网卡管理-1">虚拟网卡管理</a></h4>
<h5 id="tap网卡-1"><a class="header" href="#tap网卡-1">tap网卡</a></h5>
<pre><code class="language-shell">ip tuntap add dev tap1 mode tap
</code></pre>
<p>Tap网卡创建是临时的，如果要永久生效，可将上述命令添加到开机启动命令（如<code>rc.local</code>）。</p>
<p><a href="https://superuser.com/questions/854401/how-to-make-tap-interfaces-persistent-after-reboot">linux - How to make tap interfaces persistent after reboot? - Super User</a></p>
<h3 id="防火墙-1"><a class="header" href="#防火墙-1">防火墙</a></h3>
<p>Linux内核使用<a href="Linux/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.html#Netfilter/iptables">Netfilter/iptables</a>过滤包，其中<code>iptables</code>为用户交互接口（<code>iptable-services</code>）。</p>
<h4 id="防火墙规则管理-1"><a class="header" href="#防火墙规则管理-1">防火墙规则管理</a></h4>
<pre><code class="language-shell">iptables -t,--table TABLE -OP CHAIN rule_spec  # 链名为大写，表名为小写
</code></pre>
<p><code>-t TABLE</code>：指定访问的<a href="Linux/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.html#%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F-%E8%A1%A8">表</a>（省略则查看<code>filter</code>表）；</p>
<p><code>-OP CHAIN</code>：指定访问的<a href="Linux/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.html#%E5%A4%84%E7%90%86%E4%BD%8D%E7%BD%AE-%E9%93%BE">链</a>（省略链名则查看所有链）及其操作（例如<code>-L FORWARD</code>）；</p>
<h5 id="查询规则-1"><a class="header" href="#查询规则-1">查询规则</a></h5>
<pre><code class="language-sh">iptables -t TABLE -L,--list CHAIN -v -n --line-number -x  # 列出所有规则
iptables -t TABLE -C,--check CHAIN RULE_SPEC  # 检查指定规则是否存在
</code></pre>
<p><code>-n</code>：不反向解析IP地址（显示IP地址而非域名，加快速度）；
<code>--line,--line-number</code>：显示规则编号；
<code>-v</code>：显示更多信息（分组数、字节数等）；
<code>-x</code>：显示精确的计数，而非经过单位转换的数据。</p>
<h5 id="管理规则-1"><a class="header" href="#管理规则-1">管理规则</a></h5>
<pre><code class="language-sh">iptables -I,--insert  CHAIN [NUM] RULE -j TARGET # 在表首部插入一条规则
iptables -A,--append  CHAIN       RULE -j TARGET # 在表尾部插入一条规则
iptables -R,--replace CHAIN  NUM  RULE -j TARGET # 替换指定编号的规则
iptables -D,--delete  CHAIN       RULE -j TARGET # 删除匹配条件的规则
iptables -D           CHAIN  NUM                 # 删除指定编号的规则
iptables -F,--flush   CHAIN                      # 清空表中的规则
</code></pre>
<blockquote>
<p>默认的表为<code>-t filter</code>。</p>
</blockquote>
<p>添加相同的规则不会覆盖已有规则，可用以下命令修改已有规则的动作：</p>
<pre><code class="language-sh">iptables -t filter -R INPUT 2 &lt;rules&gt; -j &lt;traget&gt;  # 修改指定规则的动作
</code></pre>
<blockquote>
<p>必须指定要修改规则的条件，否则该规则的条件将变为默认值（例如IP将变为<code>anywhere</code>）。</p>
</blockquote>
<p>修改默认策略</p>
<pre><code class="language-sh">iptables -t filter -P FORWARD DROP
</code></pre>
<h5 id="黑白名单机制-1"><a class="header" href="#黑白名单机制-1">黑白名单机制</a></h5>
<p>黑名单：将默认策略设置为<code>ACCEPT</code>；在规则中添加阻止策略。</p>
<p>白名单：将默认策略设置为<code>DROP</code>，在规则中添加允许策略。</p>
<blockquote>
<p>默认策略设置为<code>DROP</code>的缺点：在对应的链中没有设置任何规则时，管理员也会把自己拒之门外；即使对应的链中存在放行规则，当不小心使用&quot;<code>iptables -F</code>&quot;清空规则时，放行规则被删除，则所有数据包都无法进入。所以，如果想要使用&quot;白名单&quot;的机制，最好将链的默认策略保持为&quot;<code>ACCEPT</code>&quot;，然后将&quot;拒绝所有请求&quot;这条规则放在链的尾部，将&quot;放行规则&quot;放在前面，这样做，既能实现&quot;白名单&quot;机制，又能保证在规则被清空时，管理员还有机会连接到主机。</p>
</blockquote>
<h5 id="自定义链-1"><a class="header" href="#自定义链-1">自定义链</a></h5>
<p>自定义链仅对应一种类型的表，自定义链中规则配置方式与默认链相同。</p>
<pre><code class="language-sh">iptables -t filter -N,--new-chain IN_WEB   # 创建用于filter表的自定义链
iptables -E,--rename-chain IN_WEB WEB      # 重命名
iptables -X,--delete-chain WEB             # 删除自定义链，需未被引用且不包含任何规则
iptables -t filter -I INPUT RULE -j IN_WEB # 引用自定义链
</code></pre>
<h5 id="保存规则-1"><a class="header" href="#保存规则-1">保存规则</a></h5>
<p>通过<code>iptables</code>对规则的修改并非永久生效，当重启<code>iptables</code>服务或者重启服务器以后规则便失效了。如果想要修改永久生效，必须使用<code>service iptables save</code>保存规则，如果误操作了规则但是并没有保存，那么使用<code>service iptables restart</code>命令重启<code>iptables</code>以后即恢复修改前的状态。</p>
<blockquote>
<p>目前的发现版多数已用防火墙软件（如<code>CentOS/firewall</code>、<code>Ubuntu/ufw</code>）代替了<code>iptable-services</code>了，因此使用上述方法需要安装该服务。</p>
</blockquote>
<pre><code class="language-sh">iptables-save     # 将防火墙规则导出到标准输出
iptables-restore  # 从标准输入导入防火墙规则
</code></pre>
<h4 id="包匹配条件-1"><a class="header" href="#包匹配条件-1">包匹配条件</a></h4>
<p>多个条件之间具有<code>AND</code>关系，使用<code>!</code>对条件取反。</p>
<p><strong>基本匹配条件</strong>：</p>
<pre><code class="language-sh"># IP地址
-s sip1,sip2 -d dip1
-s ip/mask
# 协议类型
-p tcp # all, tcp, udp, udplite, icmp, icmpv6,esp, ah, sctp, mh
# 网卡接口
-i eth0 -o eth1
</code></pre>
<blockquote>
<p><code>-i</code>选项只能用于上图中的<code>PREROUTING</code>链、<code>INPUT</code>链、<code>FORWARD</code>链；<code>-o</code>选项只能用于<code>FORWARD</code>链、<code>OUTPUT</code>链、<code>POSTROUTING</code>链。</p>
</blockquote>
<p><strong>扩展匹配条件</strong>：由<code>netfilter</code>的扩展模块处理的条件。</p>
<pre><code class="language-sh"># 端口
-m tcp --sport 1:1024 --dport 22     # 需要指定扩展模块tcp, udp, icmp
-m tcp --sport :1024 --dport 10000:  # 可省略一个端口边界参数
-m multiport --dports 22,36,80:100
# IP范围
-m iprange --src-range 192.168.1.127-192.168.1.146  # --dst-range
# 字符串：匹配报文中包含的字符串
-m string --algo bm --string xyz
# time
-m time --datestart 2017-12-24 --datestop 2017-12-27
-m time --timestart 09:00:00 --timestop 18:00:00
-m time --weekdays 6,7 --monthdays 22,23
</code></pre>
<blockquote>
<p>当扩展模块的名称与协议名称相同的情况下，如果已经指定了协议，则可以省略模块选项。</p>
<p><code>--algo</code>指定字符串匹配算法，可选算法有<code>bm</code>与<code>kmp</code>。</p>
</blockquote>
<pre><code class="language-sh"># connlimit 限制连接数量
-m connlimit --connlimit-above 2 --connlimit-mask 24 -j DROP
</code></pre>
<blockquote>
<p><code>--connlimit-mask</code>表示对一个网段施加连接数限制（未指定时为对每个IP的连接数进行限制）</p>
</blockquote>
<pre><code class="language-sh"># limit 使用令牌桶限制报文速率
-p icmp -m limit --limit 10/minute -j ACCEPT
-p icmp -m limit --limit-burst 3 --limit 10/minute -j ACCEPT
</code></pre>
<blockquote>
<p><code>--limit</code>：报文允许的速率（令牌的生成速率，单位可以是<code>second</code>,<code>minute</code>,<code>hour</code>,<code>day</code>）；
<code>--limit-burst</code>：允许的突发流量（令牌桶的容量，默认值为5）；</p>
<p>需要添加一条默认<code>DROP/REJECT</code>的规则，以丢弃超过速率限制的包。</p>
</blockquote>
<p>其他扩展条件：<code>tcp-flags</code>、<code>state</code></p>
<p>http://www.zsythink.net/archives/1578</p>
<h4 id="动作-3"><a class="header" href="#动作-3">动作</a></h4>
<p><code>REJECT</code>可以附加发送一个ICMP响应报文。</p>
<pre><code class="language-sh">-j REJCT --reject-with icmp-host-unreachable
</code></pre>
<pre><code class="language-sh">-j LOG --log-prefix &quot;logname&quot; --log-level alert
</code></pre>
<blockquote>
<p><code>LOG</code>动作默认将报文的相关信息记录在<code>/var/log/message</code>文件中，通过修改<code>/etc/rsyslog.conf</code>（或<code>/etc/syslog.conf</code>），</p>
<pre><code class="language-sh">kern.warning /var/log/iptables.log
</code></pre>
<p><code>--log-level</code>：<code>emerg</code>，<code>alert</code>，<code>crit</code>，<code>error</code>，<code>warning</code>，<code>notice</code>，<code>info</code>，<code>debug</code>。</p>
</blockquote>
<h4 id="端口管理-1"><a class="header" href="#端口管理-1">端口管理</a></h4>
<pre><code class="language-sh">sudo vi /etc/sysconfig/iptables
</code></pre>
<h5 id="端口权限-1"><a class="header" href="#端口权限-1">端口权限</a></h5>
<p>小于1024的端口号（特权端口）不允许非root用户打开，以防恶意程序占用这些端口建立恶意服务。</p>
<p>如果用户需要使用这些端口，解决方法包括：</p>
<ol>
<li>
<p>使用Apache或nginx作为代理服务器；</p>
</li>
<li>
<p>使用iptables设置防火墙规则，<a href="https://confluence.atlassian.com/confkb/permission-denied-error-when-binding-a-port-290750651.html">使得低端口在内部自动转发至高端口</a>；</p>
</li>
<li>
<p>jsvc</p>
</li>
<li>
<p>authbind</p>
</li>
<li>
<p><a href="https://superuser.com/questions/710253/allow-non-root-process-to-bind-to-port-80-and-443#">设置文件打开端口的权限</a></p>
<pre><code class="language-shell">sudo setcap CAP_NET_BIND_SERVICE=+eip /path/to/binary
</code></pre>
</li>
</ol>
<h3 id="路由配置-1"><a class="header" href="#路由配置-1">路由配置</a></h3>
<h4 id="转发功能-1"><a class="header" href="#转发功能-1">转发功能</a></h4>
<p>开启防火墙的转发功能。</p>
<pre><code class="language-sh">echo 1 &gt; /proc/sys/net/ipv4/ip_forward  # 设置为1开启转发，0关闭转发
sysctl -w net.ipv4.ip_foward=1
</code></pre>
<p>上述方式为设置系统运行时变量，要永久生效需要修改系统配置。</p>
<blockquote>
<p>Ubuntu使用<code>ufw</code>管理防火墙规则，其配置文件在<code>/etc/ufw/sysctl.conf</code>，其中对应的配置项为：</p>
<pre><code class="language-shell">net/ipv4/ip_forward=1
net/ipv6/conf/default/forwarding=1
net/ipv6/conf/all/forwarding=1
</code></pre>
<p>CentOS7中配置<code>/usr/lib/sysctl.d/00-system.conf</code>，并设置<code>net.ipv4.ip_forward=1</code>。</p>
</blockquote>
<p>设置<a href="Linux/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.html#%E5%86%85%E6%A0%B8%E9%98%B2%E7%81%AB%E5%A2%99">防火墙转发规则</a>：</p>
<pre><code class="language-sh">iptables -I FORWARD -m state --state ESTABLISHED,RELATED -j ACCEPT
</code></pre>
<h4 id="nat-1"><a class="header" href="#nat-1">NAT</a></h4>
<pre><code class="language-sh"># SNAT: 将源内网地址映射到公网地址
iptables -t nat -A POSTROUTING -s 10.1.0.0/16 -o eth0 -j SNAT --to-source 192.168.1.146 
# 动态SNAT: 动态将源内网地址映射到动态变化的公网地址
iptables -t nat -A POSTROUTING -s 10.1.0.0/16 -o eth0 -j MASQUERADE 
# DNAT: 将目的公网地址+端口映射到内网地址+端口
iptables -t nat -I PREROUTING \
  -d 192.168.1.146 -p tcp --dport 3389 -j DNAT --to-destination 10.1.0.6:3389
</code></pre>
<blockquote>
<p>DNAT在理论上只配置DNAT规则即可，但是如果在测试时无法正常DNAT，可以尝试增加对应的SNAT，此处按照配置SNAT的流程进行。</p>
<p>如果没有动态SNAT的需求，没有必要使用<code>MASQUERADE</code>，因为SNAT更加高效。</p>
</blockquote>
<h5 id="本机端口转发-1"><a class="header" href="#本机端口转发-1">本机端口转发</a></h5>
<pre><code class="language-sh">iptables -t nat -A PREROUTING -p tcp --dport 80 -j REDIRECT --to-ports 8080 # INPUT
iptables -t nat -A OUTPUT -p tcp --dport 80 -j REDIRECT --to-port 8080      # LOCAL
iptables -t nat -A PREROUTING -i eth0 -p tcp --dport 1186 -j DNAT --to-destination 127.0.0.1:1186
</code></pre>
<blockquote>
<p>将访问本机80端口的请求重定向到本机的8080端口（修改目标端口）。</p>
</blockquote>
<p>如果要从外部访问本机<code>localhost</code>监听的端口，可使用DNAT将地址和端口映射到本机换回地址和相应端口（需要开启本地换回路由：<code>sysctl -w net.ipv4.conf.&lt;ifname&gt;.route_localnet=1</code> ，<code>ifname</code>为输入网络接口）。</p>
<h4 id="路由表-1"><a class="header" href="#路由表-1">路由表</a></h4>
<h5 id="获取路由信息-1"><a class="header" href="#获取路由信息-1">获取路由信息</a></h5>
<pre><code class="language-shell">ip {r|route}
#default via 192.168.178.2 dev ens32 proto static
#default via 172.28.76.234 dev ens33 scope link metric 1
#172.28.76.0/24 dev ens33 proto kernel scope link src 172.28.76.234
#192.168.178.0/24 dev ens32 proto kernel scope link src 192.168.178.40
</code></pre>
<p>表格形式：</p>
<pre><code class="language-shell">route [-nee]   
#Destination    Gateway        Genmask       Flags  Metric ...  Iface
#0.0.0.0        192.168.178.2  0.0.0.0        UG      0    ...  ens32
#0.0.0.0        172.28.76.234  0.0.0.0        UG      1    ...  ens33
#172.28.76.0    0.0.0.0        255.255.255.0  U       0    ...  ens33
#192.168.178.0  0.0.0.0        255.255.255.0  U       0    ...  ens32
netstat -r -n
#Kernel IP routing table
#Destination    Gateway        Genmask        Flags MSS Window irtt Iface
#0.0.0.0        172.28.76.234  0.0.0.0        UG      0 0         0 ens33
#172.28.76.0    0.0.0.0        255.255.255.0  U       0 0         0 ens33
</code></pre>
<blockquote>
<p><code>ee</code>：显示更多信息。</p>
</blockquote>
<ul>
<li>
<p>路由类型</p>
<p>主机路由：掩码为32位；
网络路由：
默认路由：目标为<code>0.0.0.0/0.0.0.0</code>。当主机不能在路由表中查找到目标主机的IP地址或网络路由时，数据包就被发送到默认路由（默认网关）上。</p>
</li>
<li>
<p>Flags说明：
<code>U</code> (route is up)：活动路由；
<code>H</code> (target is host)：目的地址是主机；
<code>G</code> (use gateway)： 需要网关转发；</p>
</li>
<li>
<p><code>Metric</code>：路由距离，到达指定网络所需的中转数。</p>
</li>
<li>
<p><code>Iface</code>: 当前路由会使用哪个接口来发送数据</p>
</li>
</ul>
<h5 id="配置静态路由-1"><a class="header" href="#配置静态路由-1">配置静态路由</a></h5>
<pre><code class="language-shell">route [add|del] [-net | -host] target [netmask Nm] [gw Gw] [[dev] If]
route add default gw 192.168.1.1
route add -net 5.0.0.0 netmask 255.0.0.0 reject # 设置到指定网络为不可达
</code></pre>
<blockquote>
<p>没有修改已有路由的命令（例如修改metric），需要先删除再添加一条。</p>
</blockquote>
<p>上述命令仅在当前运行环境中有效，要永久保存需要将其添加至文件中。可直接在在<code>/etc/rc.local</code>中添加上述命令，则开机会自动添加静态路由，但如果开机状态下重启网络服务则不会再次执行<code>/etc/rc.local</code>，导致静态路由失效。</p>
<p>另一种方式是编辑<code>/etc/sysconfig/static-routes</code>（CentOS/Fedora），该文件由网络服务自动加载。</p>
<pre><code class="language-shell">any -net 192.56.76.0 netmask 255.255.255.0 dev eth0
</code></pre>
<blockquote>
<p>由<code>any</code>开头的行将被解释为静态路由项。</p>
<blockquote>
<p>Ubuntu静态路由配置？</p>
</blockquote>
</blockquote>
<p><code>ip</code>工具包用于替换<code>route</code>等管理工具：</p>
<pre><code class="language-shell">ip route {add|del|change|append|replace} ROUTE
#  ROUTE= [TYPE] NETWORK/MASK [via [FAMILY] GW_IP] [dev DEVICE] [weight NUM]
ip route add default via 192.168.1.1 dev eth0  # 设置默认路由
</code></pre>
<p><code>TYPE</code>：路由类型，包括<code>unicast,mulitcast,broadcast,nat,local,...</code>；</p>
<p><code>FAMILY</code>：协议族：<code> inet,inet6,mpls,bridge,link</code>；</p>
<h3 id="本地网络代理-1"><a class="header" href="#本地网络代理-1">本地网络代理</a></h3>
<p>可配置系统范围（<code>/etc/environment</code>）或用户范围（<code>~/.bashrc</code>或<code>~/.profile</code>）。</p>
<pre><code class="language-shell">export http_proxy=&quot;http://USERNAME:PASSWORD@proxy.server.net:port/&quot;
export https_proxy=&quot;http://proxy.server.net:port/&quot;
export ftp_proxy=&quot;http://proxy.server.net:port/&quot;
export no_proxy=&quot;localhost, 127.0.0.1, 192.168.178.4&quot;  #*
</code></pre>
<blockquote>
<p><code>*</code>：<code>no_proxy</code>不支持通配符，如果要写一个网段，只能逐个地址列出。<a href="https://unix.stackexchange.com/questions/23452/set-a-network-range-in-the-no-proxy-environment-variable"><code>no_proxy</code>主要用于匹配域名后缀，而非IP地址（前缀）</a>。</p>
</blockquote>
<p>如果是系统范围代理，还需设置<code>/etc/sudoers.d/proxy</code>，避免环境变量被覆盖。</p>
<pre><code class="language-shell">Defaults env_keep+=&quot;http_proxy https_proxy no_proxy&quot;
</code></pre>
<h3 id="网络服务-1"><a class="header" href="#网络服务-1">网络服务</a></h3>
<pre><code class="language-sh">systemctl restart networking
</code></pre>
<h4 id="常用网络服务-1"><a class="header" href="#常用网络服务-1">常用网络服务</a></h4>
<p>远程访问</p>
<h4 id="x-window-1"><a class="header" href="#x-window-1">X-Window</a></h4>
<p><a href="https://wiki.ubuntu.org.cn/%E7%90%86%E8%A7%A3_Xwindow">https://wiki.ubuntu.org.cn/%E7%90%86%E8%A7%A3_Xwindow</a></p>
<h2 id="安全-1"><a class="header" href="#安全-1">安全</a></h2>
<h3 id="内核强制访问控制-1"><a class="header" href="#内核强制访问控制-1">内核强制访问控制</a></h3>
<p>Both SELinux and AppArmor supports the Type Enforcement security model, which is a type of mandatory access control, based on rules where <strong>subjects (processes or users) are allowed to access objects (files, directories, sockets, etc.)</strong>. </p>
<p><a href="https://www.tecmint.com/mandatory-access-control-with-selinux-or-apparmor-linux/">Implementing Mandatory Access Control with SELinux or AppArmor in Linux (tecmint.com)</a></p>
<h4 id="security-enhanced-linux-1"><a class="header" href="#security-enhanced-linux-1">Security Enhanced Linux</a></h4>
<p>SELinux支持更强的访问控制。</p>
<p>查看SELinux状态：</p>
<pre><code class="language-sh">getenforce
sestatus -v
</code></pre>
<p>临时关闭（设置成<code>permissive</code>模式，仅产生日志不进行控制）：</p>
<pre><code class="language-sh">sudo setenforce 0	# setenforce 1 =&gt; enforcing mode 
</code></pre>
<p>永久关闭：</p>
<pre><code class="language-sh"># sudo vi /etc/selinux/config
SELINUX=disabled   # SELINUX=enforcing|permissive|disabled
</code></pre>
<h5 id="selinux策略-1"><a class="header" href="#selinux策略-1">SELinux策略</a></h5>
<p>查看<code>boolean</code>策略状态：</p>
<pre><code class="language-shell">getsebool -a [se_boolean_entry]
</code></pre>
<p>设置<code>boolean</code>策略：</p>
<pre><code class="language-shell">setsebool -PV se_bool_entry value  # (1|true|on,0|false|off)
</code></pre>
<h4 id="apparmor-1"><a class="header" href="#apparmor-1">Apparmor</a></h4>
<p>AppArmor是与SELinux类似的一个访问控制系统，通过它你可以指定程序可以读、写或运行哪些文件，是否可以打开网络端口等。</p>
<p><a href="http://www.361way.com/linux-apparmor/3646.html">linux内核强制访问控制－－Apparmor - 运维之路 (361way.com)</a></p>
<p><a href="http://www.361way.com/apparmor-selinux/3648.html">AppArmor与SELinux - 运维之路 (361way.com)</a></p>
<h3 id="数字证书-1"><a class="header" href="#数字证书-1">数字证书</a></h3>
<h4 id="安装证书-1"><a class="header" href="#安装证书-1">安装证书</a></h4>
<p>系统信任证书目录位于<code>/usr/local/share/ca-certificates</code>。将证书文件置于该目录下，并将权限设置为<code>644</code>。</p>
<pre><code class="language-shell">sudo apt install ca-certificates
sudo update ca-certificates   # needs super user privilege
</code></pre>
<h4 id="生成证书和私钥-1"><a class="header" href="#生成证书和私钥-1">生成证书和私钥</a></h4>
<p>OpenSSL是一个非常有用的开源命令行工具包，可用于 <a href="https://www.ssl.com/zh-CN/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/%E4%BB%80%E4%B9%88%E6%98%AFx-509%E8%AF%81%E4%B9%A6/">X.509</a> 证书，证书签名请求（CSRs）和加密密钥。</p>
<pre><code class="language-sh">openssl req -x509 -newkey rsa:4096 -keyout key.pem -out cert.pem -days 365
openssl x509 -in cert.pem -text -noout  # 查看证书结构信息
</code></pre>
<blockquote>
<p><code>key.pem</code>为私钥；<code>cert.pem</code>为证书（包含公钥）；生成签名过程设置的密码是在使用密钥的时候使用。</p>
<p>使用私钥和证书需要输入制作时设置的密码。</p>
<p><a href="Linux/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.html#%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6">PEM格式</a>。</p>
</blockquote>
<h5 id="详细步骤-1"><a class="header" href="#详细步骤-1">详细步骤</a></h5>
<p>Create an RSA Keypair：</p>
<pre><code class="language-sh">sudo apt install openssl
openssl genrsa -des3 -passout pass:PASSWORD -out keypair.key 2048
</code></pre>
<p>Extract the Private Key：</p>
<pre><code class="language-sh">openssl rsa -passin pass:PASSWORD -in keypair.key -out private.key
</code></pre>
<p>Creating a “Certificate Signing Request” or <code>CSR</code> File：</p>
<pre><code class="language-sh">openssl req -new -key private.key -out service.csr
</code></pre>
<p>Creating the Certificate “<code>.crt</code>” File：</p>
<pre><code class="language-sh">openssl x509 -req -days 365 -in service.csr -signkey private.key -out service.crt
</code></pre>
<p>https://www.rosehosting.com/blog/how-to-generate-a-self-signed-ssl-certificate-on-linux/</p>
<p>https://www.linux.com/tutorials/creating-self-signed-ssl-certificates-apache-linux/</p>
<h3 id="ssltls-1"><a class="header" href="#ssltls-1">SSL/TLS</a></h3>
<h2 id="权限管理-1"><a class="header" href="#权限管理-1">权限管理</a></h2>
<h3 id="用户管理-1"><a class="header" href="#用户管理-1">用户管理</a></h3>
<h4 id="创建用户-1"><a class="header" href="#创建用户-1">创建用户</a></h4>
<pre><code class="language-shell">useradd -m -c &quot;FULL NAME&quot; -g GROUP USERNAME   # [lowlevel]
adduser --home DIR --shell SHELL --ingroup GROUP USERNAME 
</code></pre>
<blockquote>
<p><code>adduser</code>在Debian系发行版上重新封装了底层<code>useradd</code>命令，其他发行版上是<code>useradd</code>的别名。以下均为<code>useradd</code>选项。</p>
<p>有效用户名模式：<code>[a-z_][a-z0-9_-]*[$]?</code>，长度不超过32。</p>
<p><code>-c &quot;COMMENT&quot;</code>：通常用于设置用户名全称；</p>
<p><code>-s,--shell SHELL</code> 用户的登录shell程序，<code>/etc/default/useradd#SHELL</code>（<code>chsh</code>）。</p>
</blockquote>
<h5 id="用户目录-1"><a class="header" href="#用户目录-1">用户目录</a></h5>
<ul>
<li><code>-b,--base-dir BASE_DIR</code>：用户主目录的根目录路径，默认值为<code>/etc/default/useradd#HOME=/home</code>；</li>
<li><code>-d,--home-dir HOME_DIR</code>：用户主目录路径，默认值为<code>$BASE_DIR/USERNAME</code>；</li>
<li>使用<code>-m,--create-home</code>保证创建用户目录；<code> -M,--no-create-home</code>不创建用户目录（通常用于运行系统服务的非登录用户）；</li>
</ul>
<h5 id="用户组-1"><a class="header" href="#用户组-1">用户组</a></h5>
<ul>
<li><code>-g,--gid GROUP</code>：用户的初始登录组（<em>primary group</em>：ID或名称，必须存在）。
如果未指定该选项，默认（<code>/etc/login.defs#USERGROUPS_ENAB=yes</code>）会自动创建与用户名同名的组（等效于指定<code>-U,--create-user-group</code>选项）；如果<code>USERGROUPS_ENAB=no</code>，则新用户的主要组设置为<code>/etc/default/useradd#GROUP=100</code>。</li>
<li><code>-G,--groups groupname[,...]</code>：将用户<a href="Linux/Linux%E9%85%8D%E7%BD%AE%E5%92%8C%E7%AE%A1%E7%90%86.html#%E7%BB%84%E7%AE%A1%E7%90%86">添加至组</a>（<em>supplementary groups</em>）；</li>
</ul>
<h5 id="账户和密码有效性-1"><a class="header" href="#账户和密码有效性-1">账户和密码有效性</a></h5>
<ul>
<li><code>-f,--inactive DAYS</code>：密码过期后账户被禁用前的天数。</li>
<li><code>-e,--expiredate YYYY-MM-DD</code>：账户失效（禁用）日期，默认值为<code>/etc/default/useradd#EXPIRE=''</code>（不失效）；</li>
</ul>
<h4 id="修改用户-1"><a class="header" href="#修改用户-1">修改用户</a></h4>
<p>使用<code>usermod</code>修改用户属性（多数属性对应的选项与<code>useradd</code>相同)。</p>
<pre><code class="language-shell">usermod -a,--append -G GROUPNAME  # 将用户添加到supplementary groups
usermod -l,--login NAME # 修改登录名 
usermod -m,--move-home -d,--home HOME  # (移动)修改用户主目录
</code></pre>
<h5 id="设置账户有效期限-1"><a class="header" href="#设置账户有效期限-1">设置账户有效期限</a></h5>
<pre><code class="language-shell">usermod -e,--expiredate YYYY-MM-DD/N/-1 USER # 设置失效日期*
chage   -E,--expiredate YYYY-MM-DD/N/-1 USER  
</code></pre>
<blockquote>
<p><code>*</code>：<code>N</code>表示自1970年1月1日的天数。</p>
</blockquote>
<p>此外，<a href="Linux/Linux%E9%85%8D%E7%BD%AE%E5%92%8C%E7%AE%A1%E7%90%86.html#%E5%AF%86%E7%A0%81%E6%9C%89%E6%95%88%E6%9C%9F%E9%85%8D%E7%BD%AE">账户密码失效</a>后账户也会处于失效状态。</p>
<h5 id="设置和更新密码-1"><a class="header" href="#设置和更新密码-1">设置和更新密码</a></h5>
<p>创建用户时默认禁用密码。使用<code>passwd</code>设置和更新密码（<code>root</code>账号可修改普通用户的密码，用户忘记密码可通过<code>root</code>帐号使用<code>passwd</code>指令来处理即可）。</p>
<pre><code class="language-sh">passwd username
usermod -p,--password ENCRYPT_PASSWORD
passwd -d,--delete  # 删除(置空)用户密码
</code></pre>
<blockquote>
<p>如果<code>root</code>帐号忘记了，可以进入单人维护模式，此时系统会给予提供<code>root</code>权限的<code>bash</code>接口，再用<code>passwd</code>修改密码；或者利用Live CD开机后挂载根目录去修改<code>/etc/shadow</code>，将<code>root</code>的密码删除，重新开机后再用<code>passwd</code>设置新密码。</p>
</blockquote>
<h5 id="密码有效期配置-1"><a class="header" href="#密码有效期配置-1">密码有效期配置</a></h5>
<pre><code class="language-shell">passwd -e,--expire  # 立即使用户密码失效, 用户必须在下次登录时重设密码
passwd -x,--maxdays  DAYS USER #-&gt;chage -M 密码有效期天数(99999/-1)*
passwd -i,--inactive DAYS USER #-&gt;chage -I 密码失效后禁用账户前的天数(never)
passwd -n,--mindays  DAYS USER #-&gt;chage -m 两次修改密码之间至少相隔的天数(0)
passwd -w,--warndays DAYS USER #-&gt;chage -W 需要修改密码前向发送警告的天数(7)
</code></pre>
<blockquote>
<p><code>*</code>：<code>chage</code>的长选项与<code>passwd</code>对应长选项一致。</p>
</blockquote>
<p>显示密码状态：</p>
<pre><code class="language-shell">passwd -S &lt;user&gt;  # 使用-a代替&lt;user&gt;查看所有用户的密码状态。
# gary P 06/02/2022  0 99999 7 -1
chage -l &lt;user&gt;
# Last password change                              : Jun 02, 2022
# Password expires                                  : never
# Password inactive                                 : never
# Account expires                                   : never
# Minimum number of days between password change    : 0
# Maximum number of days between password change    : 99999
# Number of days of warning before password expires : 7
</code></pre>
<h4 id="删除用户-1"><a class="header" href="#删除用户-1">删除用户</a></h4>
<pre><code class="language-shell">userdel -f $USER     # deluser [Debian]
rm -rf /home/$USER
</code></pre>
<h4 id="查看用户信息-1"><a class="header" href="#查看用户信息-1">查看用户信息</a></h4>
<p>查系统中的<a href="Linux/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.html#%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF%E5%AD%98%E5%82%A8">用户信息</a>：</p>
<pre><code class="language-shell">/etc/passwd  # User account information.
/etc/shadow  # Secure user account information. [read by root only]
</code></pre>
<p>查看当前登录的所有用户：</p>
<pre><code class="language-sh">w
# 09:42:35 up 26 min,  3 users,  load average: 0.18, 0.12, 0.09
#USER  TTY    FROM           LOGIN@   IDLE   JCPU   PCPU WHAT
#root  pts/0  172.28.76.41   09:17    3.00s  0.13s  0.03s w
#root  pts/1  172.28.76.239  09:19   22:45   0.02s  0.02s -bash
</code></pre>
<blockquote>
<p><code>who</code>显示的信息没有<code>w</code>完整。<code>who</code>可以显示系统引导终端（<code>tty1</code>）。</p>
</blockquote>
<p>查看指定用户信息：</p>
<pre><code class="language-shell">id $USER  
# uid=1000(gary) gid=1000(gary) groups=1000(gary),...(secondary groups)
groups $USER        # 查看用户所属组
username=$(whoami)  # return user name
sudo whoami         # -&gt; root
</code></pre>
<blockquote>
<p><a href="https://linuxize.com/post/how-to-add-user-to-group-in-linux/">How to Add User to Group in Linux | Linuxize</a></p>
</blockquote>
<h3 id="组管理-1"><a class="header" href="#组管理-1">组管理</a></h3>
<pre><code class="language-shell">groupadd groupname
groupdel groupname
addgroup [options] [--gid ID] group
</code></pre>
<pre><code class="language-shell">sudo usermod -g groupname username      # change user's primary group
sudo usermod -a -G group[,...] username # add user to a secondary group
adduser user group  # add user to grpup
</code></pre>
<blockquote>
<p>If you omit the <code>-a</code> option, the user will be removed from any groups not listed after the <code>-G</code> option.</p>
</blockquote>
<pre><code class="language-shell">sudo gpasswd -d username groupname  # Remove a User From a Group
</code></pre>
<h5 id="查看组信息-1"><a class="header" href="#查看组信息-1">查看组信息</a></h5>
<pre><code class="language-shell">/etc/group   # Group account information.
/etc/gshadow # Secure group account information.
</code></pre>
<h3 id="访问权限控制-1"><a class="header" href="#访问权限控制-1">访问权限控制</a></h3>
<h4 id="访问权限-1"><a class="header" href="#访问权限-1">访问权限</a></h4>
<p>修改用户访问文件的权限：</p>
<pre><code class="language-sh">chmod [ugoa][+-=][rwxXstugo],... FILE ...
chmod OCTAL-MODE FILE ...
</code></pre>
<p><code>ugoa</code>分别代表文件所有用户，文件同组用户，其他用户和所有用户（省略则默认为<code>a</code>，umask？）；<code>+-=</code>表示增加、删除和设置权限。</p>
<p>权限模式：<code>rwxXst</code>中的一个或多个，或<code>ugo</code>中的一个</p>
<div class="table-wrapper"><table><thead><tr><th>标识</th><th>说明</th><th>标识</th><th>说明</th><th>标识</th><th>说明</th></tr></thead><tbody>
<tr><td><code>r</code></td><td>读文件</td><td><code>w</code></td><td>写文件</td><td><code>x</code></td><td>访问/执行</td></tr>
<tr><td><code>s</code></td><td>设置用户或组</td><td><code>t</code></td><td>限制删除</td><td><code>X</code></td><td>*</td></tr>
<tr><td><code>u</code></td><td>授予所有者权限</td><td><code>g</code></td><td>授予组用户权限</td><td><code>o</code></td><td>授予其他组权限</td></tr>
</tbody></table>
</div>
<blockquote>
<p><code>*</code>：<code>X</code>表示仅当目标为目录或已经具有其他用户执行权限时，才设置该目标的访问/执行权限。</p>
</blockquote>
<p><code>OCTAL-MODE</code>为1~4数字（取值范围0~7，3bit），第一位代表（设置用户ID，设置组ID和限制删除），其余三位数字分别代表<code>ugo</code>对应的<code>rwx</code>权限。</p>
<h4 id="ownership-1"><a class="header" href="#ownership-1">Ownership</a></h4>
<p>获取对象的所有者信息：</p>
<pre><code class="language-shell">ls -l /opt/360es/ | awk '{print $3,$4}'    # 根据字段位置确定
ls -l /opt/360es/ | sed -n '2,$p' | awk '{printf &quot;user=%s,group=%s\n&quot;,$3,$4}'
stat /path/file --format=&quot;user=%U group=%G&quot;
</code></pre>
<p>从外部（互联网）获取的文件（档案），其所有者信息非本机用户，因此导致本机用户无法正常访问文件，所以需要<strong>修改文件的所有者/组</strong>。</p>
<pre><code class="language-sh">chown -hR owner[:group] FILE
chgrp
</code></pre>
<blockquote>
<p><code>--dereference</code>：影响符号链接指向的文件而非符号链接；<code>-h,--no-dereference</code>相反；
<code>--from=CURRENT_OWNER:CURRENT_GROUP</code>：仅当文件的当前属性匹配才进行修改；
<code>--reference=RFILE</code>：使用<code>RFILE</code>的属性作为修改后的属性；
<code>-R</code>：递归修改。符号链接指向的文件夹的遍历规则根据以下选项决定：</p>
<ul>
<li><code>-H</code>：遍历命令行参数为符号链接锁指向的文件夹；</li>
<li><code>-L</code>：遍历所有符号链接指向的文件夹；</li>
<li><code>-P</code>：步遍历符号链接指向的文件夹（默认）。</li>
</ul>
</blockquote>
<h4 id="提升权限-1"><a class="header" href="#提升权限-1">提升权限</a></h4>
<h5 id="切换登录用户-1"><a class="header" href="#切换登录用户-1">切换登录用户</a></h5>
<pre><code class="language-sh">su - username # switch user
</code></pre>
<blockquote>
<p>不支持切换到非登录用户。</p>
</blockquote>
<h5 id="以管理员身份运行-1"><a class="header" href="#以管理员身份运行-1">以管理员身份运行</a></h5>
<pre><code class="language-shell">sudo \
    -u, --user=user \ # 指定用户执行输入的命令
    -i,--login \      # 使用指定用户登录shell
    [command]         # 运行命令（未指定则切换终端用户）
</code></pre>
<p>当前多数发行版默认禁用<code>root</code>账户，并以安装系统期间创建的账户作为管理员。管理员需要使用<code>sudo</code>命令并提供密码以暂时获得<code>root</code>账户<a href="Linux/Linux%E9%85%8D%E7%BD%AE%E5%92%8C%E7%AE%A1%E7%90%86.html#%E6%8F%90%E5%8D%87%E6%9D%83%E9%99%90">权限</a>（使用<code>sudo</code>命令创建的文件其所属用户和组为<code>root</code>）。将其他用户加入<code>sudo</code>用户组使其具有运行<code>sudo</code>的权限。如果要恢复<code>root</code>账户（不推荐），为其设置密码：</p>
<pre><code class="language-shell">sudo passwd root
</code></pre>
<h2 id="帮助文档-1"><a class="header" href="#帮助文档-1">帮助文档</a></h2>
<h5 id="linux-manual-1"><a class="header" href="#linux-manual-1">Linux Manual</a></h5>
<ol>
<li>可执行程序和Shell命令；</li>
<li>系统调用函数文档；</li>
<li>库函数文档；</li>
<li>特殊设备文件（通常位于<code>/dev</code>）；</li>
<li>系统内置文件格式和规范（如<code>/etc/passwd</code>）；</li>
<li>游戏；</li>
<li>其他，如<code>man(7)</code>；</li>
<li>系统管理命令（管理员使用）；</li>
<li>内核过程（非标准）。</li>
</ol>
<h2 id="急救模式-1"><a class="header" href="#急救模式-1">急救模式</a></h2>
<p><em><strong>emergency mode</strong></em></p>
<h3 id="进入急救模式-1"><a class="header" href="#进入急救模式-1">进入急救模式</a></h3>
<ol>
<li>
<p>GRUB系统选择界面按<code>e</code>进入启动配置项编辑模式；</p>
<pre><code class="language-shell">linux16 /vmlinuz-....   # 添加rd.break
</code></pre>
</li>
<li>
<p>按<code>Ctrl+X</code>进入急救模式。</p>
</li>
</ol>
<h3 id="修复磁盘-1"><a class="header" href="#修复磁盘-1">修复磁盘</a></h3>
<h5 id="修复xfs文件系统-1"><a class="header" href="#修复xfs文件系统-1"><a href="https://blog.csdn.net/heian_99/article/details/123380912">修复XFS文件系统</a></a></h5>
<p>由于突然断电，导致XFS文件系统数据损坏。</p>
<pre><code class="language-shell">ls -l /dev/mapper  # 找到dm-0对应的挂载点并卸载设备
umount /dev/mapper/centos-root
xfs_repair -L /dev/mapper/centos-root # 修复该设备
init 6 # 成功修复后重启设备
</code></pre>
<h2 id="参考资料-4"><a class="header" href="#参考资料-4">参考资料</a></h2>
<div class="footnote-definition" id="mount"><sup class="footnote-definition-label">1</sup>
<p><a href="https://superuser.com/questions/663213/two-distinct-mount-points-with-one-device">linux - Two distinct mount points with one device - Super User</a>.
<sup class="footnote-reference"><a href="#pid1">2</a></sup>:<a href="http://0pointer.de/blog/projects/systemd.html">Rethinking PID 1 (0pointer.de)</a>.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="linux-shell"><a class="header" href="#linux-shell">Linux Shell</a></h1>
<h2 id="shell"><a class="header" href="#shell">Shell</a></h2>
<p>Shell包括命令行Shell和图形Shell，Linux中使用的命令行Shell包括：</p>
<ul>
<li>Bourne Shell（<code>/usr/bin/sh</code>或<code>/bin/sh</code>）</li>
<li><strong>Bourne Again Shell</strong>（<code>/bin/bash</code>，<strong>常用</strong>）</li>
<li>C Shell（<code>/usr/bin/csh</code>）</li>
<li>K Shell（<code>/usr/bin/ksh</code>）</li>
<li>Shell for Root（<code>/sbin/sh</code>）</li>
<li>……</li>
</ul>
<blockquote>
<p>如今Debian和Ubuntu中，<code>/bin/sh</code>默认已经指向dash，这是一个不同于<code>bash</code>的shell，它主要是为了==执行脚本==而出现，而不是交互环境，它速度更快，但功能相比<code>bash</code>要少很多，语法严格遵守POSIX标准。</p>
</blockquote>
<pre><code class="language-shell">chsh -s /usr/bin/bash  # 切换用户默认的登录环境
</code></pre>
<p>Shell将用户输入的命令进行解释并提交系统执行，从而实现用户与系统间的交互。为了避免不必要的用户操作，Shell支持从文件自动读取命令并执行，即执行<strong>Shell Script/Shell Program</strong>。</p>
<blockquote>
<p><em>A shell is a command language interpreter which provide an interface to user to use operating system services.</em> </p>
</blockquote>
<h3 id="shell脚本文件"><a class="header" href="#shell脚本文件">Shell脚本文件</a></h3>
<p>注释：“<code>#</code>”用于注释。第一行<code>#!/bin/bash</code>声明执行这个脚本所使用的shell程序的名称。在较为特殊的程序代码部分，务必要加上批注说明。</p>
<blockquote>
<p>保持良好的编程风格，应该在每个脚本文件的头部记录文件相关信息：功能、版本信息、作者与联络方式、版权宣告方式、</p>
</blockquote>
<p>主要代码部分：如果读到一个换行符号（<code>CR</code>），就尝试开始执行该行（或该串）指令。指令、选项与参数之间的多个空白（空格、制表符、空白行）会被忽略掉。如果一行内容太多，可使用“<code>\</code>”来延伸至下一行（<code>\</code>之后不==能有包括空白在内的任何内容==）； </p>
<blockquote>
<p>Windows换行规则<code>CR LF</code>不能被正确识别。</p>
</blockquote>
<p>语句块：使用花括号“<code>{}</code>”可以将多条语句放在一起，一个语句块相当于一条语句。</p>
<h3 id="变量-7"><a class="header" href="#变量-7">变量</a></h3>
<p>变量名大小写敏感，有效字符包括字母、下划线和数字，但首字母不能是数字。<strong>变量的值为字符串</strong>。</p>
<h4 id="变量属性"><a class="header" href="#变量属性">变量属性</a></h4>
<pre><code class="language-shell">declare [option] [name=[value]]
</code></pre>
<p><code>-i</code>：使变量具有整数性质，对变量赋值时将<a href="Linux/Linux-Shell.html#%E6%95%B4%E6%95%B0%E8%BF%90%E7%AE%97">评估赋值表达式的数值结果</a>；
<code>-a/-A</code>：将一个变量声明为数组/字典；
<code>-l/-u</code>：将赋给变量的值自动转换为小写/大写；
<code>-r</code>：使变量只读；
<code>-x</code>：使变量成为环境变量（<code>export</code>）；</p>
<blockquote>
<p>使用<code>+</code>关闭相应的属性；</p>
</blockquote>
<p>输出控制：</p>
<ul>
<li>
<p><code>-p</code>：显示==变量的值和属性==；如果未指定名称，则显示所有变量的信息；</p>
<pre><code class="language-shell">declare -p        # 输出所有变量的信息
y=0; declare -p y # 输出: declare -- y=&quot;0&quot;
declare -p array  # 输出: declare -a array='([0]=&quot;1&quot; [1]=&quot;2&quot; [2]=&quot;3&quot;)'
</code></pre>
</li>
<li>
<p><code>-f/-F</code>：仅显示函数，<code>-F</code>仅显示函数名和属性；</p>
</li>
</ul>
<h4 id="赋值-6"><a class="header" href="#赋值-6">赋值</a></h4>
<p>未赋值的变量也可以使用，其值为空字符串。==字符串可以跨行表示，两行内容之间会添加空白分隔（使用“<code>\</code>”连接两行消除换行符）==。</p>
<pre><code class="language-shell">var_name=&quot;value&quot;
readonly var_name # 将变量设置为只读。
</code></pre>
<blockquote>
<p><strong>等号两边不能有空格</strong>。</p>
</blockquote>
<p>当<code>value</code>中包含空白字符时，需要使用引号<code>'</code>或<code>&quot;</code>将其包围起来，否则只能识别空白之前的内容。引号内容可以换行（两行间的空白内容以及换行符被自动替换为一个空格）。两个相邻字符串（无空分隔）视为一个字符串。</p>
<ul>
<li>
<p>==变量如果不带引号，则能触发通配符<code>*</code>和<code>?</code>匹配文件名；会消耗转移字符，<code>\a</code>实际内容为<code>a</code>。==</p>
</li>
<li>
<p>单引号中的<strong>内容不做额外解释</strong>，即双引号<code>&quot;</code>、取值运算符<code>$</code>、历史记录运算符<code>!</code>、以及转义字符<code>\</code>等都视为普通字符。</p>
</li>
<li>
<p><strong>双引号</strong>中可使用特殊字符，并使用<code>\$</code>、<code>\&quot;</code>和<code>\\</code>分别来取消<code>$</code>、<code>&quot;</code>和<code>\</code>的特殊含义，单引号视为普通字符。</p>
<blockquote>
<p>双引号中非转义字符前出现的<code>\</code>无特殊作用，例如<code>\a</code>，不会消耗转义字符，内容为<code>&quot;\a&quot;</code>。</p>
</blockquote>
</li>
</ul>
<h4 id="读取"><a class="header" href="#读取">读取</a></h4>
<p>获取变量的值，<strong>使用大括号用于帮助解释器识别变量名的边界。</strong></p>
<pre><code class="language-shell">$var_name
${var_name}abc
echo &quot;$str_name&quot;
</code></pre>
<blockquote>
<p>获取变量的值时，一定要带上<code>$</code>，否则只是使用变量名字符串。</p>
</blockquote>
<p>输出当前Shell环境中的所有变量和函数：</p>
<pre><code class="language-shell">set/declare
</code></pre>
<h5 id="命令行展开"><a class="header" href="#命令行展开">命令行展开</a></h5>
<p>Shell解释器执行语句时，会首先对语句中的变量<code>$var</code>进行值替换，然后对其中的特殊字符（如<code>*</code>，<code>~</code>）进行替换，最后根据空白将语句内容解析为<a href="Linux/Linux-Shell.html#%E5%8F%82%E6%95%B0%E5%8F%98%E9%87%8F">命令和参数序列</a>。</p>
<ul>
<li>
<p>避免特殊字符展开：将特殊字符或包含特殊字符的变量置于引号中<code>&quot;$var&quot;</code>，其中的所有字符都被视为普通字符（除转义序列外）；</p>
</li>
<li>
<p>避免包含空白的变量被展开为多个参数：同样将该变量的引用置于<code>&quot;&quot;</code>中。如<code>&quot;hello world&quot;</code>或<code>&quot;$var_with_spaces&quot;</code>；</p>
</li>
<li>
<p>如果变量的内容已经显示指定了参数边界，如<code>'arg 1' 'arg2'</code>，则命令行不要为其添加<code>&quot;&quot;</code>（否则仅相当于一个参数）；但如果该变量受上述两项限制需要<code>&quot;&quot;</code>，则使用<code>eval</code>对命令行内容执行两遍解释，从而对该变量进行两次解释（第一次执行变量替换，第二次执行参数解析）。</p>
<blockquote>
<p><a href="https://blog.csdn.net/damotiansheng/article/details/39735441">消除参数中成对的双引号（字符），并将引号之间的内容作为一个参数</a>。</p>
<pre><code class="language-shell">eval echo '&quot;abc' 'def&quot;' 'ghi'  # =&gt; echo &quot;abc def&quot; ghi  =&gt; abc def ghi
</code></pre>
<p>变量值中自带的引号只是普通字符（区别与命令行或脚本上书写的引号边界），其不能避免变量在空白处被展开。带空格的变量与其他变量拼接后再作为参数传递给其他脚本，则无法避免该变量在空格处被展开。应该单独将该变量置于引号中传递给脚本，或者使用<code>eval</code>命令对参数中包含的引号做第二次解释。</p>
<pre><code class="language-shell">x=&quot;x 'y z'&quot;
y=&quot;\&quot;a b c\&quot;&quot;
z=&quot;$y $x&quot;    # =&gt; z = [&quot;a b c&quot; x 'y z']
./script.sh $z      # ./script.sh '&quot;a' 'b' 'c&quot;' 'x' 'y' 'z'
eval./script.sh $z  # ./script.sh 'a b c' 'x' 'y z'
./script.sh &quot;$y&quot; &quot;$x&quot;  # ./script.sh '&quot;a b c&quot;' 'x 'y z'
</code></pre>
</blockquote>
</li>
</ul>
<h4 id="删除变量"><a class="header" href="#删除变量">删除变量</a></h4>
<pre><code class="language-shell">unset TEST_VAR	# clear a shell/env variable
</code></pre>
<h3 id="数据结构"><a class="header" href="#数据结构">数据结构</a></h3>
<h4 id="数组-9"><a class="header" href="#数组-9">数组</a></h4>
<p>序列由<code>()</code>包含多个元素</p>
<pre><code class="language-shell">array=('abc' 123 4.56 ...)  # declare -a array=(1 2 3)
</code></pre>
<blockquote>
<p>名为<code>@</code>的数组：脚本的所有输入参数组成的特殊的数组。</p>
</blockquote>
<p>使用从0开始的下标访问数组元素：</p>
<pre><code class="language-shell">ai=&quot;${array[i]}&quot;		# ${array}=&gt;${array[0]}
</code></pre>
<h5 id="数组与字符串转换"><a class="header" href="#数组与字符串转换">数组与字符串转换</a></h5>
<p>使用“<code>@</code>”或“<code>*</code>”获取数组所有元素，其返回结果为字符串。</p>
<pre><code class="language-shell">x=&quot;${array[@]}&quot;   # 所有元素拼接成的字符串*
cmd &quot;${array[@]}&quot; # 将数组展开到命令行，每个元素成为单独参数**
</code></pre>
<blockquote>
<p><code>*</code>：表达式添加<code>&quot;&quot;</code>后，数组元素中可以包含空白，解释器视整个数组元素内容为一个参数（类似于命令行输入<code>'abc d'</code>）；</p>
<p><code>**</code>：用于命令行时（如作为<code>for</code>循环的迭代序列或命令参数序列），Shell会首先对<code>&quot;${array[@]}&quot;</code>进行解释展开为多个参数，而赋值时则不会（否则如<code>x=1 2 3</code>这样的语句会报错）；</p>
</blockquote>
<p>将字符串转换为数组：根据展开表达式中的空格分隔数组元素</p>
<pre><code class="language-shell">array=($cat_array) 
eval array=(&quot;$cat_array&quot;) #*
</code></pre>
<blockquote>
<p><code>*</code>：如果字符串中人为定义了元素边界<code>''</code>，则使用<code>eval</code>对字符串内容再解释一次。</p>
</blockquote>
<h5 id="数组元素迭代"><a class="header" href="#数组元素迭代">数组元素迭代</a></h5>
<pre><code class="language-shell">for a in &quot;${array[@]}&quot;; do   #*
    echo $a
done   
# =&gt; 也可根据子串长度，按编号顺序迭代
for ((i=0;i&lt;${#array[@]};i++)); do echo ${array[$i]}; done
</code></pre>
<blockquote>
<p><code>*</code>：注意数组在<a href="Linux/Linux-Shell.html#%E5%BA%8F%E5%88%97%E5%B1%95%E5%BC%80%E8%BF%AD%E4%BB%A3">循环语句</a>中使用<code>&quot;...&quot;</code>，<a href="Linux/Linux-Shell.html#%E6%95%B0%E7%BB%84%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2">防止子串被空格分开</a>。</p>
</blockquote>
<p>查找序列中的元素：</p>
<pre><code class="language-shell">function arrayfind(){
    local value=$1; shift; local array=(&quot;$@&quot;); #*
    local index=-1
    for (( i=0; i&lt;${#array[@]}; i++ )); do     
        if [[ &quot;$value&quot; == ${array[$i]} ]]; then
            index=$i
            break
        fi
    done
    echo $index
}
</code></pre>
<blockquote>
<p><code>*</code>：函数无法接受数组对象作为参数，传入数组首先被扩展为多个参数，再在函数中重新拼装为数组。</p>
</blockquote>
<h5 id="子数组"><a class="header" href="#子数组">子数组</a></h5>
<p>获取子数组，第二个参数省略则获取到结束。</p>
<pre><code class="language-shell">sub_array=(${array[@]:i[:j]})
</code></pre>
<p>如果数组元素包含空格，则应该使用<code>&quot;${array[@]:i[:j]}&quot;</code>防止数组元素边界丢失，否则上述表达式将按空格为边界重新构造数组。</p>
<p>序列长度：</p>
<pre><code class="language-shell">${#array[@]}  # &lt;=&gt; ${#array[*]}
</code></pre>
<blockquote>
<p>注意：<code>${#array}</code>返回数组第一个元素（字符串）的长度。</p>
</blockquote>
<p>扩展序列，序列元素可动态增加，跳过赋值的序列元素为空。</p>
<pre><code class="language-shell">a+=(1 2)    # 不支持 (1 2)+(3 4)
array[5]=v2  # echo $array[4]  ==&gt; 输出为空
</code></pre>
<h4 id="字典-1"><a class="header" href="#字典-1">字典</a></h4>
<pre><code class="language-shell">declare -A dict  # decalre dict as a dictonary
dict[x]=1
declare -A dict=([x]=1 [y]=2 ...) 
echo dict[x]
</code></pre>
<h3 id="运行-2"><a class="header" href="#运行-2">运行</a></h3>
<p>脚本文件如果具有可读可执行权限 (<code>rx</code>)，可将其视为命令在Shell中执行：</p>
<pre><code class="language-sh">/home/gary/work.sh		# 绝对路径
./work.sh				# 相对路径（不能省略./）
work.sh					# 文件位于系统路径PATH
</code></pre>
<p>对于不具有执行权限的脚本文件，则可由解释器（<code>bash</code>）读取执行：</p>
<pre><code class="language-bash">bash /path/to/file.sh arg1, arg2,...
</code></pre>
<p>可以为运行脚本提供多个参数。通过以上各方法执行Shell脚本将会创建一个新Shell实例（进程），脚本将由新的Shell实例解释执行。==环境变量将由原有的Shell实例传递给新的Shell实例，而普通变量将不会传递==。在脚本执行过程中，<strong>新Shell中任何变量的修改都不会传递回原有的Shell</strong>。</p>
<p>利用 <code>source </code>来执行脚本：在当前Shell进程中执行脚本中的语句，而不创建新的Shell进程。如果<strong>提供额外参数</strong>，则脚本的运行的参数变量会被更新，脚本执行完后恢复原有的参数变量。==脚本执行过程中对原Shell中的变量更新有效==。</p>
<pre><code class="language-bash">source script [args] # . script
source ~/.bashrc     # Ubuntu必须在交互式Shell中运行=&gt; bash -i script.sh
</code></pre>
<blockquote>
<p>Ubuntu环境下运行<code>.bashrc</code>必须<a href="https://stackoverflow.com/a/43660876/6571140">在交互式Shell中进行</a>（运行的Shell脚本非交互环境），否则脚本直接返回。如果不屏蔽<code>.bashrc</code>中判断交互式逻辑，可将初始化内容移至其他脚本文件中并在用户脚本中使用<code>source</code>调用。</p>
<p>注意：<code>.bashrc</code>中如果有输出语句（例如<code>echo</code>），可能导致从远端执行<code>scp</code>无法正常工作（启动SSH会话会自动加载<code>.bashrc</code>，输出语句可能中断后续传输命令）。</p>
</blockquote>
<p>执行符号链接的脚本时，当前工作目录为符号链接所在目录。</p>
<h4 id="运行环境-3"><a class="header" href="#运行环境-3">运行环境</a></h4>
<p>Shell配置文件通常定义了<a href="Linux/Linux-Shell.html#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F">环境变量</a>以及初始化脚本。配置文件根据作用范围分为系统配置文件和用户配置文件。</p>
<h5 id="系统配置脚本"><a class="header" href="#系统配置脚本">系统配置脚本</a></h5>
<p><code>/etc/profile</code>为系统默认配置，在系统启动时加载。不推荐用户修改此文件，以免系统升级时造成配置丢失，应该在<code>/etc/profile.d</code>目录下创建<code>appxxx.sh</code>定义环境变量。</p>
<h5 id="系统环境变量-1"><a class="header" href="#系统环境变量-1">系统环境变量</a></h5>
<p><code>/etc/environment</code>保存了系统环境变量（如<code>PATH</code>）的赋值表达式，在==用户登录==时读取。</p>
<h5 id="用户配置文件"><a class="header" href="#用户配置文件">用户配置文件</a></h5>
<p>用户登录时，Shell会自动按序尝试加载<code>~/.bash_profile</code>、<code>~/.bash_login</code>和<code>~/.profile</code>（如果发现一个文件则不再加载后续文件）。系统默认创建的<code>~/.bash_profile</code>还会加载<code>~/.bashrc</code>，而<code>~/.bashrc</code>则会加载<code>/etc/bashrc</code><sup class="footnote-reference"><a href="#shellrc">1</a></sup>。如果希望配置仅对当前用户有效，应修改用户目录下的上述配置文件。</p>
<p>当使用SSH远程登录时，上述与Shell相关配置文件不会被加载，而是直接加载<code>~/.bashrc</code>（Ubuntu中会在<code>~/.bashrc</code>中判断Shell是否为交互式，如果非交互式跳过后续配置加载）。</p>
<h5 id="设置运行时选项"><a class="header" href="#设置运行时选项">设置运行时选项</a></h5>
<p><code>set</code>命令可以对Shell进行设置。</p>
<pre><code class="language-sh">set -x         # [-o xtrace]  按执行内容回显命令      
set -e         # [-o errexit] 命令返回非0时退出程序   
set -u         # [-o nonset]  引用未设置的变量产生错误 
set -v         # [-o verbose] 按输入内容回显命令      
set -n cmdline # [-o noexec]  读取命令输入但不执行    
set -o posix   # config to print variables only
set -o history # enable command history
</code></pre>
<blockquote>
<p>使用<code>set +opt</code>关闭选项。</p>
</blockquote>
<h5 id="环境变量-2"><a class="header" href="#环境变量-2">环境变量</a></h5>
<p><em><strong>Environmental Variable</strong></em>：<a href="https://www.digitalocean.com/community/tutorials/how-to-read-and-set-environmental-and-shell-variables-on-a-linux-vps">可以被子进程或Shell继承的变量</a>。</p>
<div class="table-wrapper"><table><thead><tr><th>变量</th><th>描述</th></tr></thead><tbody>
<tr><td><code>$PATH</code></td><td>可执行文件的搜索路径</td></tr>
<tr><td><code>$LANG</code></td><td>操作系统的语言和编码方案（例如<code>en_US.UTF-8</code>）</td></tr>
<tr><td><code>$LD_LIBRARY_PATH</code></td><td>非标准共享库的搜索路径</td></tr>
<tr><td><code>$HOME</code></td><td>用户家目录</td></tr>
</tbody></table>
</div>
<blockquote>
<p>共享库的寻找和加载是由<code>/lib/ld.so</code>实现的。<code>ld.so</code>在标准路经(<code>/lib</code>，<code>/usr/lib</code>) 中寻找共享库。Linux通用的做法是将非标准路径加入<code>/etc/ld.so.conf</code>，然后运行<code>ldconfig</code>生成<code>/etc/ld.so.cache</code>。</p>
</blockquote>
<p><em><strong>Shell Variable</strong></em>：独立为每个Shell定义的变量。</p>
<div class="table-wrapper"><table><thead><tr><th>变量</th><th>描述</th></tr></thead><tbody>
<tr><td><code>$$</code></td><td>当前进程的进程号，通常用它来生成唯一的临时文件。</td></tr>
<tr><td><code>$!</code></td><td>最后运行的==后台==进程的进程标识（<code>pid</code>）。</td></tr>
<tr><td><code>$?</code></td><td>上个命令的退出状态，或函数的返回值（可获取<code>ssh</code>远程执行命令的返回值）。</td></tr>
<tr><td><code>$LINENO</code></td><td>当前的行号（<code>sh</code>中无效，使用<code>bash</code>）</td></tr>
<tr><td><code>$-</code></td><td>==启用的Shell环境选项==。</td></tr>
</tbody></table>
</div>
<pre><code class="language-sh">env NAME=VALUE 
    [-u,--unset=NAME]
</code></pre>
<blockquote>
<p>修改（删除）环境变量。</p>
</blockquote>
<p>查看环境变量：</p>
<pre><code class="language-sh">env
printenv [ | grep PATH]
printenv NAME
</code></pre>
<p>转换普通变量为环境变量：</p>
<pre><code class="language-sh">export [-n] SHELL_VAR   # turn into env-variable / turn normal
export var=value        # define a new env-variable
set -a                  # [-o allexport] export all defined variables
</code></pre>
<h5 id="参数变量"><a class="header" href="#参数变量">参数变量</a></h5>
<p>执行程序（脚本、二进制文件）时，可以传入多个参数。</p>
<pre><code class="language-sh">./shfile.sh [arg1 arg2 ...]
</code></pre>
<blockquote>
<p>传入程序的参数变量为字符串值而非脚本中书写的字面值，变量中的转义字符不会被再被解释。</p>
</blockquote>
<p>在脚本文件内部，按以下方式获取参数信息：</p>
<div class="table-wrapper"><table><thead><tr><th>变量</th><th>描述</th></tr></thead><tbody>
<tr><td><code>$0</code>, <code>$1</code>,<code>$2</code>,...</td><td>按序号访问传入参数（<code>$0</code>为<strong>脚本名</strong>）</td></tr>
<tr><td><code>$*</code>、<code>$@</code></td><td>输入参数（不包含<code>$0</code>）组成的序列，使用<code>&quot;&quot;</code><a href="Linux/Linux-Shell.html#%E6%95%B0%E7%BB%84%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2">避免参数展开</a>。</td></tr>
<tr><td><code>&quot;$*&quot;</code></td><td>结果为一个字符串<code>'arg 1 arg 2 arg 3'</code></td></tr>
<tr><td><code>&quot;$@&quot;</code></td><td>保留原参数结构<code>'arg 1' 'arg 2' 'arg 3'</code></td></tr>
<tr><td><code>${@:m:n}</code></td><td>获取输入参数<a href="Linux/Linux-Shell.html#%E5%AD%90%E6%95%B0%E7%BB%84">序列部分内容</a>，使用<code>&quot;&quot;</code>避免原参数展开。<br />==使用<code>()</code>使返回结果仍以数组存储，否则结果会转换为字符串==。</td></tr>
<tr><td><code>$#</code></td><td>传递给脚本的参数个数，不包括脚本名称（<code>$0</code>）</td></tr>
</tbody></table>
</div>
<blockquote>
<p>命令行参数展开测试：</p>
<pre><code class="language-shell">for arg in &quot;$@&quot; ; do # &lt;-&gt; $* &quot;$*&quot; 
       echo $arg
done
</code></pre>
</blockquote>
<p><code>shift n</code>：移动输入参数起始下标，向右移动<code>$i</code>和<code>$@</code>等参数读取位置（默认<code>n=1</code>，不影响<code>$0</code>）。</p>
<p>设置参数：更新当前Shell环境得输入参数（覆盖调用时传入值）：</p>
<pre><code class="language-sh">set -- args...
eval set -- &quot;arg1 'arg 2' 'arg 3'&quot;  #* 
set -				# -x and -v options are off **
</code></pre>
<blockquote>
<p><code>*</code>：如果参数通过字符串提供且其中带字符串边界(')，则需使用<code>eval</code>避免错误空白位置参数展开。</p>
<p><code>**</code>：如果未提供参数，则将当前状态下的<code>&quot;$@&quot;</code>（如经过<code>shift</code>移位后）设置为输入参数。</p>
</blockquote>
<h5 id="隔离运行"><a class="header" href="#隔离运行">隔离运行</a></h5>
<p>使用<code>chroot</code>命令切换待执行程序的根目录，运行的程序不能访问指定根目录以外的文件，适用于做为测试环境。要在指定根目录下和真正根目录下一样运行相应的程序，需要：</p>
<img src="Linux/Linux-Shell.assets/chroot-command.jpg" alt="Lightbox" style="zoom: 67%;" />
<ul>
<li><a href="Linux/Linux%E5%8F%91%E8%A1%8C%E7%89%88.html#%E8%BD%AF%E4%BB%B6%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8yum(dnf)">在该根目录下安装对应的程序</a>，该方法将自动安装程序及其依赖包。</li>
<li>手动复制系统根目录下已可执行文件及其依赖项，需要自行确定依赖项。</li>
</ul>
<pre><code class="language-shell">chroot --userspec=USER:GROUP --groups=G_LIST NEWROOT [COMMAND [ARG]...]
</code></pre>
<p>如果未指定命令，则默认运行：<code>'${SHELL} -i'</code>。</p>
<h4 id="历史记录"><a class="header" href="#历史记录">历史记录</a></h4>
<pre><code class="language-sh">ctrl + r   # 在终端反向搜索历史命令
!!				 # 执行上一条命令
!*				 # 上一条命令的所有参数 (!:1-$)
!$				 # 上一条命令的最后一个参数 (!:N,第N个参数; !-n:$, last-but-n)
</code></pre>
<p>历史记录中最常用的命令：</p>
<pre><code class="language-sh">history | awk 'BEGIN {FS=&quot;[ \t]+|\\|&quot;} {print $3}' | \
					sort | uniq -c | sort -nr | head -n N
</code></pre>
<p>清空屏幕：<code>ctrl+l</code>。</p>
<p>复制/粘贴：<code>ctrl+shift+c/v</code>。</p>
<h2 id="运算-1"><a class="header" href="#运算-1">运算</a></h2>
<h3 id="字符串操作"><a class="header" href="#字符串操作">字符串操作</a></h3>
<pre><code class="language-sh">${#str}   # 字符串的长度，注意数组长度${#array[@]}
</code></pre>
<h5 id="查找-6"><a class="header" href="#查找-6">查找</a></h5>
<p>使用<code>grep</code>和正则表达式可以自定义查找方式，包括<code>startswith</code>，<code>endswith</code>等，在程序中可根据<a href="Linux/Linux-Shell.html#grep">返回值</a>判断是否成功匹配。</p>
<pre><code class="language-sh">grep 'hive' &lt;&lt;&lt; 'apache-hive-3.1.2-bin'
#&gt; apache-hive-3.1.2-bin
grep -Po '^(\w)+' &lt;&lt;&lt; 'spark-3.0.1-bin-hadoop3.2.tgz' # startswith
#&gt; spark
grep -Eo '(tar.gz|tgz)$' &lt;&lt;&lt; 'hadoop-3.2.1.tar.gz'  # endswith
#&gt; tar.gz
</code></pre>
<p>在条件表达式中，通过<a href="Linux/Linux-Shell.html#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%AF%94%E8%BE%83">字符串比较测试</a>也可进行查找匹配，但仅能判断是否匹配，而不能获取匹配结果；另一方面，<code>grep</code>的返回值可用于条件表达式判断是否成功匹配。</p>
<h5 id="替换-2"><a class="header" href="#替换-2">替换</a></h5>
<pre><code class="language-shell">${param:-DEFAULT}  # 如果param为空，则返回为默认值
${param-DEFAULT}   # 如果param未定义，则返回为默认值
${param:=DEFAULT}  # 如果param为空，则把它设置为默认值，并返回param的值
${param=DEFAULT}   # 如果param未定义，则把它设置为默认值，并返回param的值
# &quot;:&quot;限定判断条件变量为空，&quot;=/-&quot;决定是否为变量赋值
${param%PATERRN}   # 从param尾部删除与PATERRN最小匹配
${param%%PATERRN}  # 从param尾部删除与PATERRN最长匹配
${param#PATERRN}   # 从param头部删除与PATERRN最小匹配
${param##PATERRN}  # 从param头部删除与PATERRN最长匹配
</code></pre>
<blockquote>
<p><a href="https://handerfly.github.io/shell/2019/04/03/shell%E7%BC%96%E7%A8%8B%E5%86%92%E5%8F%B7%E5%8A%A0-%E7%AD%89%E5%8F%B7-%E5%8A%A0%E5%8F%B7-%E5%87%8F%E5%8F%B7-%E9%97%AE%E5%8F%B7/">shell 编程：冒号 后面跟 等号，加号，减号，问号的意义 - 笨鸟教程的博客 | BY BenderFly (handerfly.github.io)</a></p>
</blockquote>
<p>使用<code>sed</code>和正则表达式可以很容易实现字符串内容的修改：</p>
<pre><code class="language-sh">sed -n 's/ /\*/p' &lt;&lt;&lt; 'hello world'  # 替换匹配内容
#&gt; hello*world
sed -E 's/.(tar.gz|tgz)$//' &lt;&lt;&lt; 'hadoop-3.2.1.tar.gz'   # 删除后缀
#&gt; hadoop-3.2.1
</code></pre>
<h5 id="拼接-5"><a class="header" href="#拼接-5">拼接</a></h5>
<pre><code class="language-sh">str3=$str1$str2
</code></pre>
<blockquote>
<p>拼接变量的值，由于变量的值为字符串，因此实际等效于字符串拼接。</p>
</blockquote>
<p>拼接文件内容：</p>
<pre><code class="language-shell">STR=''  
for line in $(cat filename); do 
  line=$(sed -E 's/#.*//' &lt;&lt;&lt; $line)    # edit the line           
  STR=&quot;$STR $line&quot;
done
</code></pre>
<h5 id="获取子串"><a class="header" href="#获取子串">获取子串</a></h5>
<p>按索引（<code>0-based</code> index）获取：</p>
<pre><code class="language-sh">sub_str=${str:START:LENGTH}		# ${string:start=0:length=${#str}}
</code></pre>
<p>使用正则表达式（捕获组）获取匹配子串：</p>
<pre><code class="language-sh">ps -ef | sed -nE '100s/^[a-zA-Z0-9\+]+ +([0-9]+).*/\1/p'  # 获取pid
#&gt; 184289
</code></pre>
<p>使用分隔符拆分字符串并获取子串：</p>
<pre><code class="language-sh">read -a cmd_args &lt;&lt;&lt; &quot;sudo apt update&quot;      # 将拆分结果存入数组（分隔符$IFS，默认为空白）
</code></pre>
<p>仅获取拆分后的某个子串：</p>
<pre><code class="language-shell">ps -ef | sed -n '10p' | awk '{print $2}'           # use awk
cut -d &quot;;&quot; -f 1 &lt;&lt;&lt; &quot;bla@some.com;john@home.com&quot;   # use cut
</code></pre>
<blockquote>
<p><code>awk</code>将连续多个分隔符视为一个分隔符；<code>cut</code>将连续分隔符之间视为空字符串。</p>
</blockquote>
<p><code>xargs</code>将管道或标准输入（stdin）数据转换成命令行参数。</p>
<pre><code class="language-sh">xargs  # https://www.runoob.com/linux/linux-comm-xargs.html
local_home=${local_home%'/'}   # trim the trailing '/'
</code></pre>
<h3 id="整数运算"><a class="header" href="#整数运算">整数运算</a></h3>
<h5 id="declare"><a class="header" href="#declare"><a href="Linux/Linux-Shell.html#%E8%AE%BE%E7%BD%AE%E5%8F%98%E9%87%8F%E5%B1%9E%E6%80%A7">declare</a></a></h5>
<pre><code class="language-shell">declare -i n
n=7/3              # echo $n =&gt; 2 : 非四舍五入（舍去小数）
n=n+1              # 计算表达式中无须使用$对变量求值
</code></pre>
<h5 id="expr"><a class="header" href="#expr">expr</a></h5>
<p><code>expr</code>将参数解释为表达式并进行评估，输出计算结果。表达式中操作符和操作数需要使用空白分开，可以包含简单四则==整数==运算（<code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>）、求余（<code>%</code>）、逻辑运算（<code>|</code>、<code>&amp;</code>、<code>=</code>、<code>&gt;</code>、<code>&gt;=</code>、<code>&lt;</code>、<code>&lt;=</code>、<code>!=</code>）。乘号(<code>*</code>)前边必须加反斜杠(<code>\</code>)避免通配符展开。</p>
<pre><code class="language-sh">R=$(expr $a + $b – 20 \* $c / $d + $e % 10)
</code></pre>
<h5 id="let"><a class="header" href="#let">==let==</a></h5>
<p><code>let</code>表达式中不能包含空格，且变量名无需添加<code>$</code>，<code>let</code>会对表达式进行解释和计算。</p>
<pre><code class="language-shell">let z=5
let z=z+1   # &lt;=&gt; let z=$z+1
</code></pre>
<h5 id="bash算术运算"><a class="header" href="#bash算术运算">bash算术运算</a></h5>
<pre><code class="language-sh">((a = $b + 10))   # 对空格没有要求
</code></pre>
<h3 id="日期和时间-3"><a class="header" href="#日期和时间-3">日期和时间</a></h3>
<p><a href="Linux/Linux%E9%85%8D%E7%BD%AE%E5%92%8C%E7%AE%A1%E7%90%86.html#%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4"><code>date</code>命令</a>可以对表示时间的变量进行增加(<code>+</code>)/减少(<code>-</code>)操作。</p>
<pre><code class="language-sh">iter_date=$(date +%Y%m%d -d &quot;$iter_date + 1 year&quot;)
</code></pre>
<blockquote>
<p>输入<code>$iter_date</code>为空时，默认为当前日期时间</p>
</blockquote>
<h5 id="计算时间差"><a class="header" href="#计算时间差">计算时间差</a></h5>
<p>利用<a href="Linux/Linux%E9%85%8D%E7%BD%AE%E5%92%8C%E7%AE%A1%E7%90%86.html#%E8%8E%B7%E5%8F%96%E6%97%A5%E6%9C%9F%E5%AD%97%E6%AE%B5">时间戳</a>计算时间差。</p>
<pre><code class="language-shell">let DIFF=($(date +%s -d 20210131)-$(date +%s -d 20210101))  # diff of seconds
let t_minutes=t_elapse/60
let t_seconds=t_elapse%60
</code></pre>
<h3 id="条件表达式"><a class="header" href="#条件表达式">条件表达式</a></h3>
<p>语法：使用<code>[ expr ]</code>定义条件表达式。表达式返回值<code>0</code>表示<code>true</code>，<code>1</code>表示<code>false</code>。</p>
<p>注意在中括号内的变量，最好都以双引号括号起来（避免空字符串以及带空白的字符串展开造成语法错误）；常数也最好都以单或双引号括号起来。</p>
<blockquote>
<p><code>[</code> 是条件表达式的命令名，其后的内容作为其参数展开，因此<code>[]</code>、运算符、变量之间必须以空格分隔，而展开后带空格的变量也需要使用引号保证参数的完整性。<code>&lt;</code>、<code>&gt;</code>、<code>&amp;&amp;</code>、<code>||</code>、<code>()</code>等特殊字符作为Shell的命令，是不能作为参数的，因此不能直接出现在条件表达式中（使用转义字符<code>\</code>）。</p>
</blockquote>
<p>表达式中仅允许使用以下定义的运算符对变量进行测试，而使用其他命令将会出错。</p>
<h4 id="数值比较"><a class="header" href="#数值比较">数值比较</a></h4>
<p><code>-eq</code>（<code>==</code>）、<code>-ne</code>（<code>!=</code>）、<code>-gt</code>（<code>&gt;</code>）、<code>-lt</code>（<code>&lt;</code>）、<code>-ge</code>（<code>&gt;=</code>）、<code>-le</code>（<code>&lt;=</code>），只支持数值比较。</p>
<pre><code class="language-sh">[ $a -eq $b ]
</code></pre>
<blockquote>
<p>由于<code>&gt;</code>、<code>&lt;</code>为特殊字符不能作为关系运算符，使用命令选项表示关系运算符。</p>
</blockquote>
<h4 id="逻辑运算-2"><a class="header" href="#逻辑运算-2">逻辑运算</a></h4>
<pre><code class="language-sh">[ ! expr1 ]		# logical not
[ $a -o $b ]	# logical or
[ $a -a $b ]	# logical and
[ -r $1 ] &amp;&amp; [ -s $1 ]
</code></pre>
<h4 id="字符串比较"><a class="header" href="#字符串比较">字符串比较</a></h4>
<p>字符串运算符：<code>=</code>、<code>!=</code>；</p>
<pre><code class="language-shell">[ $str1 != $str2 ]	# 字符串比较
[ -z &quot;$str&quot; ]	# true(0) if str is zero-length
[ -n &quot;$str&quot; ]  # true(0) if str is non-zero-length
</code></pre>
<blockquote>
<p><code>-n</code>参数需要使用<code>&quot;&quot;</code>括起来，否则对空字符串的计算结果不正确。</p>
</blockquote>
<h4 id="文件测试"><a class="header" href="#文件测试">文件测试</a></h4>
<pre><code class="language-sh">[ -dfrwxse file ]	
</code></pre>
<p><code>-e</code>：文件是否存在；<code>-d</code>：目录；<code>-f</code>：普通文件；<code>-r</code>：读权限；<code>-w</code>：写权限；<code>-x</code>：访问/执行权限；<code>-s</code>：文件是否为空。</p>
<h4 id="robust-condition-expression"><a class="header" href="#robust-condition-expression">Robust Condition Expression</a></h4>
<p>相比于<code>[]</code>，<code>[[]]</code>提高了条件语句的健壮性和可用性，具体地，<code>[[]]</code>可以==处理空字符串以及带空格的字符串==，因此不用对<strong>变量取值</strong>（<code>$var</code>）增加额外的引号。</p>
<blockquote>
<p>需要在<code>bash</code>环境中使用<code>[[]]</code>。</p>
</blockquote>
<ul>
<li>
<p>使用<code>&amp;&amp;</code>、<code>||</code>作为逻辑运算符</p>
<pre><code class="language-sh">[[ expr1 &amp;&amp; expr2 ]]	# logical and
[[ expr1 || expr2 ]]	# logical or
</code></pre>
</li>
<li>
<p>支持使用<code>&lt;</code>，<code>&gt;</code>，<code>==</code>，<code>&gt;</code>，<code>&lt;</code>，<code>!=</code>做字符串比较；</p>
</li>
<li>
<p><code>=~</code>运算符，用于正则表达式匹配（==正则表达式模式不能加引号==）；</p>
<pre><code class="language-sh">[[ $answer =~ ^y(es)?$ ]]; echo $?  #*
</code></pre>
</li>
<li>
<p>通配符<code>*</code>、<code>?</code>匹配（模式表达式不能带引号，否则视为普通字符串）；</p>
<pre><code class="language-sh">[[ $ANSWER = y* ]]; echo $?			# start with
</code></pre>
</li>
</ul>
<h5 id="优先级-2"><a class="header" href="#优先级-2">优先级</a></h5>
<p>在<code>[[]]</code>表达式中，使用<code>()</code>保证优先级。</p>
<h2 id="流程控制-8"><a class="header" href="#流程控制-8">流程控制</a></h2>
<p>不存在块作用域：语句块中定义的变量在语句块结束后仍有效（因为不存在变量声明语句）。</p>
<p>==流程控制语句块可以嵌套==。</p>
<p>==语句块内容不能为空，否则有语法错误==。</p>
<h3 id="函数-8"><a class="header" href="#函数-8">函数</a></h3>
<p>在脚本中可将一组常用操作定义为函数。函数的定义必须出现在调用之前，不存在前向声明。</p>
<pre><code class="language-sh">function fun_name(){	# function keyword is optional
  statements;
  return n;				# optional
}
</code></pre>
<h5 id="函数输入参数"><a class="header" href="#函数输入参数">函数输入参数</a></h5>
<p>函数没有显式定义参数，<a href="Linux/Linux-Shell.html#%E5%8F%82%E6%95%B0%E5%8F%98%E9%87%8F">参数传入规则</a>与脚本一致，即在函数内部参数变量<code>$1,...</code>将被更新未调用函数时传递的参数，其中<code>$0</code>==仍为调用脚本名==。函数执行完返回调用程序后，参数变量将恢复到调用程序之前的状态。</p>
<h5 id="函数返回值"><a class="header" href="#函数返回值">函数返回值</a></h5>
<p>返回值代表函数的执行状态，不表示函数的输出内容。因此，使用 <code>return</code>返回<strong>整数值</strong>（通常<code>&lt;128</code>）；如果不加<code>return</code>语句，将以最后一条命令的返回值作为函数的返回值。</p>
<h5 id="函数输出"><a class="header" href="#函数输出">函数输出</a></h5>
<p>函数应该向<strong>标准输出</strong>发送输出数据（如<code>echo &quot;output&quot;</code>），从而使调用程序可通过<code>$(func args)</code>捕获到输出内容。同时，应该向<strong>标准错误输出</strong>（<code>command &gt;&amp;2</code>）发送预计行为外的输出（如错误信息、日志信息等），以保证调用程序获得预期的输出内容（或在出现异常的情况下获得空内容）。调用程序如果未捕获输出结果且未做重定向，则标准输出和标准错误输出通常都会打印到控制台。</p>
<h5 id="函数内的变量作用域"><a class="header" href="#函数内的变量作用域">函数内的变量作用域</a></h5>
<p>函数中的变量作用域与<code>source script.sh</code>（当前Shell执行）相似：</p>
<ul>
<li>
<p>==函数可以访问被执行脚本所在Shell环境中的变量==。</p>
</li>
<li>
<p>==函数中声明的变量默认为<code>global</code>作用域，即在函数调用返回后仍然有效==。</p>
<ul>
<li>==如果函数调用是在<code>$(...)</code>中而非当前Shell，则函数中定义的变量离开<code>$(...)</code>语句后无效==。</li>
</ul>
</li>
<li>
<p>使用<code>local</code>关键字在函数内部声明局部变量。如果局部变量与全局变量名字相同，则在局部变量的作用域内，局部变量将覆盖全局变量。==局部变量仅具有函数范围生命周期==。</p>
</li>
</ul>
<h3 id="语句连接和语句块"><a class="header" href="#语句连接和语句块">语句连接和语句块</a></h3>
<p><code>&amp;&amp;</code>：如果第一条命令执行成功（返回0）则执行<code>&amp;&amp;</code>后续命令；</p>
<p><code>;</code>：用于连接两条命令，无论第一条是否执行成功，都继续执行后续命令。在交互环境下执行命令时，前一条命令中的==赋值语句==设置的变量仅限当前命令使用，当前命令执行完后恢复设置前的值；在脚本中编写同样的命令则不会被重置。这个特性方便临时设置分隔符等变量。</p>
<pre><code class="language-shell">IFS=:; read host path &lt;&lt;&lt; 'user@host:downloads/'; echo IFS=$IFS; 
</code></pre>
<blockquote>
<p>上述命令在交互终端中运行时，打印<code>IFS</code>为空；在脚本中执行（<code>bash -c</code>）则打印<code>:</code>。仅对赋值语句有效，通过<code>read</code>赋值的变量的值在下一语句执行后仍然保留。</p>
</blockquote>
<h3 id="条件-5"><a class="header" href="#条件-5">条件</a></h3>
<pre><code class="language-sh">if cond_expr1 ; then 
	statements
elif cond_expr2 ; then		# elif 可选
	statements
else						# else 可选
	statements
fi
</code></pre>
<p><code>cond_expr1</code>为<a href="Linux/Linux-Shell.html#_%E6%9D%A1%E4%BB%B6%E8%A1%A8%E8%BE%BE%E5%BC%8F">条件表达式</a>。<code>then</code>可以和<code>condition</code>置于一行，但需要在<code>condition</code>和<code>then</code>之间添加“<code>;</code>”。</p>
<pre><code class="language-sh">case $variable in		# swith-case
	pattern1 [|pattern11...] ) 
		statements 
		;;
	pattern2 [|pattern22...] ) 
		statements 
		;;
	......
	*)
  	;;
esac
</code></pre>
<blockquote>
<p><code>pattern</code>表示匹配模式字符串，不需要添加引号。</p>
<p>多种模式可以使用“|”合并为一类。使用“)”表示模式说明的结束，使用“;;（双分号）”表示一个模式行的结束。</p>
</blockquote>
<p>只执行一个匹配行，即使其后有更精确的匹配。</p>
<p>模式语句支持正则表达式。</p>
<p>模式可使用通配符，因此可以使用“<code>*</code>”作为默认模式。当所有的匹配都不成功时，才执行“<code>*</code>”对应的命令。通配符扩展在引号中不起作用。</p>
<h3 id="循环-8"><a class="header" href="#循环-8">循环</a></h3>
<h4 id="迭代-5"><a class="header" href="#迭代-5">迭代</a></h4>
<p>基于数值的迭代：</p>
<pre><code class="language-shell">for ((i=0;i&lt;len;i++)); do  # 控制语句不需要使用$i和$len, 但过程语句需要$i
	echo $i
done
</code></pre>
<p>遍历基于空格分割的字符串序列：</p>
<pre><code class="language-sh">for v in v1 v2 v3 ...; do
	statements
done
</code></pre>
<p>==<code>v1 v2 v3...</code>是由空格分隔的字符串==。</p>
<h5 id="序列展开迭代"><a class="header" href="#序列展开迭代">序列展开迭代</a></h5>
<p>可由<a href="Linux/Linux-Shell.html#%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E8%BF%AD%E4%BB%A3">序列</a>转换<code>v in ${array[@]}</code>得到迭代元素。如果序列元素本身包含空白，则要使用<code>v in &quot;${array[@]}&quot;</code>，防止元素被分割。</p>
<p>命令行参数展开（<code>*</code>），将被替换为所有匹配文件名构成的可迭代对象。</p>
<pre><code class="language-shell">for s in ./*.sh; do echo $s; done   # 文件名包含空格不会被中断
</code></pre>
<h4 id="条件循环"><a class="header" href="#条件循环">条件循环</a></h4>
<pre><code class="language-sh">while condition ; do
	statements
done 
until condition ; do
	statements
done
</code></pre>
<h3 id="其他-3"><a class="header" href="#其他-3">其他</a></h3>
<p><code>break</code>：跳出循环（<code>case</code>语句使用<code>;;</code>终止分支，不需要使用<code>break</code>）；</p>
<p><code>continue</code>：跳过本次循环的剩余内容；</p>
<p><code>return</code>：用于函数的返回（或使用<code>source/shell</code>调用的脚本的返回），并提供返回值。</p>
<p><code>exit</code>：用于脚本提前退出并提供返回值。</p>
<h2 id="输入输出-8"><a class="header" href="#输入输出-8">输入输出</a></h2>
<h3 id="标准输入输出-6"><a class="header" href="#标准输入输出-6">标准输入输出</a></h3>
<h5 id="输出"><a class="header" href="#输出">输出</a></h5>
<pre><code class="language-sh">echo -n -e $var
echo `expr`
echo $var1 $var2   
</code></pre>
<blockquote>
<p><code>-n</code>：不输出换行；
<code>-e</code>：确保输出内容启用==转义字符==（例如<code>\n, \t</code>）；</p>
</blockquote>
<p>C语言风格输出函数：</p>
<pre><code class="language-sh">printf &quot;%10s %08d %-10.2f\n&quot; hello 8 9.9
printf '%s\n' A-{1..5}  # 自动展开并迭代1到5的序列
printf -v outstr FORMAT ARGS  # 将格式化输出存储到变量中。
</code></pre>
<p>获取命令的==标准输出==（非返回值，返回值为<code>$?</code>）。错误输出不会被<code>$()</code>捕获，仍正常输出（到终端）。</p>
<pre><code class="language-sh">result=$(cmd.sh args)   # assign the output string to result
result=`cmd.sh args`
</code></pre>
<h5 id="输入-1"><a class="header" href="#输入-1">输入</a></h5>
<p><code>read</code>从标准输入==读取一行==内容。可将文件或标准输出重定向至<code>read</code>。</p>
<pre><code class="language-shell">read -a array -d delim prompt -r ... [vars ...]
</code></pre>
<p>如果提供了一个或多个位置参数变量，则==使用分隔符<code>$IFS</code>分割读取内容==，并将分隔后的内容依次存入位置参数；如果没有位置参数变量，则将读取内容存入<code>$REPLY</code>中。</p>
<blockquote>
<p><code>read</code>如何从子shell中返回变量到父进程？</p>
</blockquote>
<p>参数：
<code>-a array</code>：将分割后的内容按顺序存入数组；
<code>-d delim</code>：将<strong>行结束符</strong>设置为<code>delim</code>的第一个字符（后续字符无效）而不是以换行结束；将行结束符置空将读取整个文件的内容。
<code>-e</code>：使用<code>readline</code>读取一行内容（可自动补全文件名等）；
<code>-n nchars</code>：读取最多<code>nchars</code>个字符后结束（不用等到换行），仍支持分隔符；<code>-N</code>忽略分隔符；
<code>-p prompt</code>：输入内容前的提示信息；
<code>-r</code>：忽略字符串中的转义字符（<code>\</code>）；
<code>-s</code>：不在终端上显示输入内容（用于==输入密码==）；Enter结束输入但不会产生换行作用；需要在程序中执行换行。
<code>-t timeout</code>：设置读取超时时间（用于交互式界面）；</p>
<p>从标准输入<strong>读取多行内容</strong>：直到输入一行内容为<code>&quot;EOF&quot;</code>终止，也可以使用<code>ctrl+D</code>结束输入标准输入流。</p>
<pre><code class="language-shell">text=$(cat &lt;&lt; EOF)
</code></pre>
<h4 id="重定向-1"><a class="header" href="#重定向-1">重定向</a></h4>
<p>Linux程序通常使用标准输入/输出与用户或系统交互。</p>
<ul>
<li>编写程序时，默认仅需要处理标准输入输出，在不必要的情况下不额外打开文件，以简化程序逻辑。</li>
<li>调用程序时，通过重定向命令使用文件数据流代替标准输入输出；</li>
</ul>
<h5 id="重定向语法"><a class="header" href="#重定向语法">重定向语法</a></h5>
<div class="table-wrapper"><table><thead><tr><th>语法</th><th>说明</th></tr></thead><tbody>
<tr><td><code>command &lt; filename</code></td><td>使用文件代替标准输入。</td></tr>
<tr><td><code>command &gt;&amp;2</code></td><td>将命令的输出定向到错误输出。</td></tr>
<tr><td><code>command &lt;&lt;[-] end_word</code></td><td>从标准输入读取内容，直到一行仅包含<code>end_word</code>；<br/><code>-</code>去除内容开始前的<code>tab</code>制表符。</td></tr>
<tr><td><code>command &lt;&lt;&lt; args</code></td><td>使用命令行参数代替标准输入。</td></tr>
<tr><td><code>command &gt; filename</code></td><td>使用文件代替标准输出（<code>&gt;&gt;</code>追加模式）。</td></tr>
<tr><td><code>command 2&gt; filename</code></td><td>使用文件代替标准错误输出（<code>2&gt;&gt;</code>追加模式）。</td></tr>
<tr><td><code>command &gt; filename 2&gt;&amp;1</code><br /><code>command 2&gt; filename 1&gt;&amp;2</code></td><td>将标准输出和标准错误输出都定向到指定文件。<br />（<code>&gt;&gt;</code>或<code>2&gt;&gt;</code>追加模式）</td></tr>
</tbody></table>
</div>
<blockquote>
<p><code>2&gt;&amp;1</code>表示将标准错误输出再定向到标准输出。</p>
</blockquote>
<p>https://www.gnu.org/software/bash/manual/html_node/Redirections.html</p>
<p>示例：</p>
<pre><code class="language-sh">command &gt; /dev/null 2&gt;&amp;1	# 将标准输出和错误输出丢弃
</code></pre>
<h5 id="清空文件"><a class="header" href="#清空文件">清空文件</a></h5>
<pre><code class="language-sh">&gt; FILENAME                # =&gt; &gt; FILENAME =&gt; true &gt; FILENAME
cat /dev/null &gt; FILENAME  # =&gt; cp /dev/null FILENAME
truncate -s 0 FILENAME
</code></pre>
<p>不要尝试将一个文件读出的同时再写回当前文件（<code>cat file &gt; file</code>），因为此命令在执行前会为输出流清空当前文件。</p>
<h4 id="管道-1"><a class="header" href="#管道-1">管道</a></h4>
<p>管道用于连接两个命令，<strong>将上一个命令的标准输出作为下一个命令的标准输入</strong>。示例如下：</p>
<pre><code class="language-sh">ps -ef | grep 'apache' | grep -v grep
</code></pre>
<p>将错误输出流传入管道：</p>
<pre><code class="language-sh">command | 2&gt;&amp;1 grep 'something'
</code></pre>
<h3 id="文件输入输出"><a class="header" href="#文件输入输出">文件输入输出</a></h3>
<pre><code class="language-shell">text=$(cat txtfile)
</code></pre>
<p>除了使用文件名读取文件内容外，使用重定向语法也可以使程序读取文件内容代替默认的标准输入。</p>
<p><code>head/tail</code>用于过滤部分数据：</p>
<pre><code class="language-shell">head -n,--lines=[-]N FILE # 输出前N行内容，-表示除去最后N行的内容
tail -f,--follow FILE
     -n,--lines=[+]N  # 输出文件最后N行，+表示从第N行开始输出
     --pid=PID        # with -f, terminate after process PID dies   
</code></pre>
<p><code>more</code>：键入用<code>〈space〉</code>键显示后续内容，显示当前查看的百分比。
<code>pg</code>：分屏显示文件的内容，按<code>&lt;enter&gt;</code>键显示下一屏的内容。</p>
<h4 id="按行读写和处理文件"><a class="header" href="#按行读写和处理文件">按行读写和处理文件</a></h4>
<p>使用循环读取文件中每一行的内容：将<code>while</code>语句块视为一条语句，可使用“<code>|</code>”接收前置命令的输出或使用“<code>&lt;,&gt;</code>”等 来重定向标准输入/输出输入到文件，那么<code>while</code>语句块中的所有命令将使用重定向后的输入输出。</p>
<pre><code class="language-sh"># read name=value pairs from file
lines=()
while IFS='=' read name ...; do  # 如果读整行则指定一个变量(IFS='')
   echo $name $value;            
   # process line
   lines+=($name)                # 将文件内容保存到数组
done &lt; src_file                  # default: from stand input 
</code></pre>
<blockquote>
<p><code>IFS=</code>默认以空白为分隔符（将自动截断输入的前后空白内容）。</p>
<p>需要注意，如果使用文件重定向，但循环过程中存在交互输入，则交互输入内容也会从文件中获取，这可能是不希望的行为。因此需要首先==将文件内容读取序列==中，然后再使用<code>for</code>循环迭代并获取用户的输入。</p>
<p>如果需要对读入的每一行分别进行处理输出（如替换修改等，可使用<code>grep/sed/awk</code>等工具）。当如果需要处理的内容与上下文相关，则需要自定义处理逻辑。</p>
</blockquote>
<h5 id="将文件内容构造为序列"><a class="header" href="#将文件内容构造为序列">将文件内容构造为序列</a></h5>
<p><code>mapfile</code>和<code>readarray</code>可简化上述读取操作。</p>
<pre><code class="language-shell">mapfile -t lines &lt; file.txt   # ==&gt; readarray 
# 默认分隔符为所有空白，这里将分隔符设置为换行，因此按行拆分为序列
IFS=$'\r\n' GLOBIGNORE='*' command eval  'XYZ=($(cat /etc/passwd))'
IFS=$'\n' read -d '' -r -a lines &lt; /etc/passwd 
</code></pre>
<blockquote>
<p>如果使用<code>for</code>语句读取文件输入（使用<code>cat, sed</code>等），需要注意==文件内容将会被拼接为一个整体，并按空格分离进行迭代==。</p>
<pre><code class="language-shell">for pkg in $(sed -E 's/#.*//' all_conda.pkgs); do echo $pkg; done
</code></pre>
</blockquote>
<h5 id="将序列内容写入文件"><a class="header" href="#将序列内容写入文件">将序列内容写入文件</a></h5>
<p>将整个命令的标准输出定向到文件，避免重复打开文件。</p>
<pre><code class="language-shell">for line in &quot;${text_array[@]}&quot;; do
	echo $line   
done &gt; text.txt
for ((i=0;i&lt;${#text_array[@]};i++)); do  
	echo &quot;$i: ${text_array[i]}&quot;
done &gt; text.txt
</code></pre>
<h2 id="进程"><a class="header" href="#进程">进程</a></h2>
<h3 id="创建进程-5"><a class="header" href="#创建进程-5">创建进程</a></h3>
<p>Shell执行命令时创建子进程（子Shell，进程号<code>$!</code>），并等待子进程结束。如果要立即返回则使用<code>&amp;</code>使子进程与Shell分离。</p>
<pre><code class="language-sh">./script.sh args &gt; tmp.log 2&gt;&amp;1 &amp;
</code></pre>
<p>子进程分离后，其标准输入输出仍然绑定在原Shell，因此需要进行重定向。也可以使用<code>nohup</code>自动进行重定向，输出内容到<code>nohup.out</code>中。</p>
<pre><code class="language-sh">nohup ./script.sh args &amp;
</code></pre>
<h3 id="信号处理"><a class="header" href="#信号处理">信号处理</a></h3>
<p>通常，当子进程在执行时，<code>bash</code>会忽略所有信号。</p>
<pre><code class="language-sh">#!/bin/bash 
term_handler() { 
  echo &quot;Caught SIGTERM signal!&quot; 
  kill -TERM &quot;$child&quot; 2&gt;/dev/null
}
trap term_handler SIGTERM
echo &quot;Doing some initial work...&quot;;
/bin/start/main/server --nodaemon &amp;
child=$! 		# get Process ID
wait &quot;$child&quot;	# wait child to end or any signals
</code></pre>
<blockquote>
<p><code>term_handler='-'</code>默认处理方式；<code>term_handler=''</code>忽略信号。</p>
</blockquote>
<h3 id="调度"><a class="header" href="#调度">调度</a></h3>
<p>休眠</p>
<pre><code class="language-sh">sleep 100  # seconds
</code></pre>
<h2 id="调试程序"><a class="header" href="#调试程序">调试程序</a></h2>
<p><a href="https://opensource.com/article/22/7/print-stack-trace-bash-scripts?check_logged_in=1">Fix bugs in Bash scripts by printing a stack trace | Opensource.com</a></p>
<pre><code class="language-shell">set -E     # the error trap is inherited throughout the script
trap 'ERRO_LINENO=$LINENO' ERR # traps commands that exit with a non-zero code
trap '_failure' EXIT
</code></pre>
<pre><code class="language-shell">_failure() {
  ERR_CODE=$? # capture last command exit code
  set +xv # turns off debug logging, just in case
  if [[  $- =~ e &amp;&amp; ${ERR_CODE} != 0 ]]
  then
      # only log stack trace if requested (set -e)
      # and last command failed
      echo
      echo &quot;========= CATASTROPHIC COMMAND FAIL =========&quot;
      echo
      echo &quot;SCRIPT EXITED ON ERROR CODE: ${ERR_CODE}&quot;
      echo
      LEN=${#BASH_LINENO[@]}
      for (( INDEX=0; INDEX&lt;$LEN-1; INDEX++ ))
      do
          echo '---'
          echo &quot;FILE: $(basename ${BASH_SOURCE[${INDEX}+1]})&quot;
          echo &quot;  FUNCTION: ${FUNCNAME[${INDEX}+1]}&quot;
          if [[ ${INDEX} &gt; 0 ]]
          then
           # commands in stack trace
              echo &quot;  COMMAND: ${FUNCNAME[${INDEX}]}&quot;
              echo &quot;  LINE: ${BASH_LINENO[${INDEX}]}&quot;
          else
              # command that failed
              echo &quot;  COMMAND: ${BASH_COMMAND}&quot;
              echo &quot;  LINE: ${ERRO_LINENO}&quot;
          fi
      done
      echo
      echo &quot;======= END CATASTROPHIC COMMAND FAIL =======&quot;
      echo
  fi
}
</code></pre>
<p>The following built-in shell values are used to build the stack trace:</p>
<ol>
<li><code>BASH_SOURCE</code>: Array of filenames where each command was called back to the main script.</li>
<li><code>FUNCNAME</code>: Array of function names matching each file in <code>BASH_SOURCE</code>.</li>
<li><code>BASH_LINENO</code>: Array of line numbers per file matching <code>BASH_SOURCE</code>.</li>
<li><code>BASH_COMMAND</code>: Last command executed with flags and arguments.</li>
</ol>
<h2 id="应用-1"><a class="header" href="#应用-1">应用</a></h2>
<h3 id="选项参数设置"><a class="header" href="#选项参数设置">选项参数设置</a></h3>
<p><a href="https://stackoverflow.com/questions/192249/how-do-i-parse-command-line-arguments-in-bash">选项参数解析</a>：<code>getopt</code>是标准的参数处理程序，可以处理长、短选项参数以及位置参数。将<code>arguments</code>中的选项参数和位置参数使用<code>&quot;--&quot;</code>分离开，任意位置的非选项参数全部移至<code>&quot;--&quot;</code>之后。</p>
<pre><code class="language-shell">getopt --longoptions longopts \ # 长选项
       --options shortopts \    # 短选项
       --name progname \ # 解析参数出错时显示的程序名(通常为当前脚本名&quot;$0&quot;)
       arguments...      # 带解析的参数列表(通常为$@)
</code></pre>
<p><code>OPTIONS</code>和<code>LONGOPTS</code>不能包含空格。==如果某类选项为空，仍需要传递空字符串<code>&quot;&quot;</code>作为相应的参数==，否则解析选项参数不正确。</p>
<h4 id="参数处理程序"><a class="header" href="#参数处理程序">参数处理程序</a></h4>
<p>将命令行输入参数中的选项参数与位置参数分离并处理，提供给后续程序使用。</p>
<pre><code class="language-sh">SHORT=dfo:v
LONGS=debug,force,output:,verbose        
! PARSED=$(getopt --options=$SHORT --longoptions=$LONGS --name &quot;$0&quot; -- &quot;$@&quot;) #*
if [ ${PIPESTATUS[0]} -ne 0 ]; then  # [ $? -ne 0 ]
    exit 2
fi
eval set -- &quot;$PARSED&quot;  #**
while true; do
    case &quot;$1&quot; in
        -d|--debug)
        	OPT_DEBUG='--debug'
            ;;
        -o|--output)
        	OUTPUT=$2
            shift
            ;;
        --)
            shift
            break # break the while loop
            ;;
        *)
            echo &quot;Programming error&quot;
            exit 3
            ;;
    esac
    shift
done
</code></pre>
<blockquote>
<p><code>*</code>：<code>&quot;$@&quot;</code>防止<a href="Linux/Linux-Shell.html#%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B1%95%E5%BC%80">包含空格的原有参数被展开为多个参数</a>，<code>!</code><a href="https://stackoverflow.com/a/29754866/6571140">忽略命令执行错误并继续执行</a>（如果未设置<code>set -o errexit</code>则无需添加，直接检查<code>$0</code>而非<code>$PIPESTATUS</code>）。</p>
<p><code>**</code>：正确处理解析后带空格的参数，如<code>-d --source 'test 1' -- 'test 2'</code>。其中的<code>'</code>是字符串中的普通字符而非参数边界，如果直接书写<code>$PARSED</code>，则会导致命令行按其值的空白展开得到<code>'test</code>，<code>1'</code>这样的参数，破坏原有参数结构。<a href="Linux/Linux-Shell.html#%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B1%95%E5%BC%80">通过添加<code>&quot;&quot;</code>以及使用<code>eval</code>可将解析后的参数中的<code>'</code>重新解释为参数边界</a>。</p>
</blockquote>
<p>执行脚本：如果选项的值带有空格，可使用引号将选项括起来，防止空格后内容被展开<a href="Linux/Linux-Shell.html#%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B1%95%E5%BC%80">解释为独立参数</a>。</p>
<pre><code class="language-sh">./script.sh --option=&quot;sip REGEXP 10.12.20.4[5-9]&quot;
</code></pre>
<p>如果脚本还具有子命令，则在调用上述处理参数前首先处理并消耗固定的子命令参数。</p>
<pre><code class="language-shell">if [[ $1 == &quot;command&quot; ]]; then
    shift
    set -            #*
    sub_process &quot;$@&quot; #**
fi
</code></pre>
<blockquote>
<p><code>*</code>：消耗子命令参数后，重设<a href="Linux/Linux-Shell.html#%E5%8F%82%E6%95%B0%E5%8F%98%E9%87%8F">参数变量</a>。</p>
<p><code>**</code>：可以将该子命令的参数处理程序及功能代码写在当前<code>if</code>语句块中，或者将其封装为单独函数（<a href="Linux/Linux-Shell.html#%E5%87%BD%E6%95%B0%E8%BE%93%E5%85%A5%E5%8F%82%E6%95%B0">函数支持参数传递</a>）。</p>
</blockquote>
<h5 id="固定参数检测逻辑"><a class="header" href="#固定参数检测逻辑">固定参数检测逻辑</a></h5>
<p>以下命令不做替换，仅检测参数是否为空已决定程序是否继续执行，适用于处理固定参数。</p>
<pre><code class="language-shell">param=${param:?MESSAGE}
</code></pre>
<p>如果<code>param</code>为空，则向标准错误输出信息，并退出脚本。</p>
<h3 id="文本处理"><a class="header" href="#文本处理">文本处理</a></h3>
<p>文本处理工具<code>grep</code>，<code>sed</code>，<code>awk</code>对比：</p>
<ul>
<li>三者均可以通过正则表达式对输入行进行筛选；</li>
<li><code>grep</code>仅用于查找匹配模式，并返回匹配行（或匹配模式部分）；</li>
<li><code>sed</code>还可以对匹配行进行编辑（替换），并进行上下文相关的修改，==通过替换操作可提取文本中的正则表达式捕获内容==；</li>
<li><code>awk</code>更适合格式化文本，对文本进行较复杂格式处理（如分割字段并格式化）。</li>
</ul>
<h4 id="grep"><a class="header" href="#grep">grep</a></h4>
<p>从文件读取行并执行正则表达式匹配。返回值：<code>0</code>匹配到模式；<code>1</code>未匹配到模式。</p>
<pre><code class="language-shell">grep  [option] PATTERN [file1  file2  …]
</code></pre>
<blockquote>
<p><code>-</code>作为文件名代表标准输入；使用管道输入则无需提供文件输入参数。</p>
</blockquote>
<p><a href="Linux/../%E7%AC%94%E8%AE%B0/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.html#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%B1%BB%E5%9E%8B"><strong>正则表达式类型</strong></a>：<code>-G,--basic-regexp</code>，<code>-E,--extended-regexp </code>，<code>-P,--perl-regexp</code>。<code>-P</code>支持<code>\d,\w</code>等字符集合；此外，<code>grep</code>支持预定义的命名字符集合（<a href="Linux/../%E7%AC%94%E8%AE%B0/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.html#grep">这些与实现相关，仅在<code>grep</code>中可用</a>）。</p>
<h5 id="匹配模式pattern"><a class="header" href="#匹配模式pattern">匹配模式(pattern)</a></h5>
<div class="table-wrapper"><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody>
<tr><td><code>-e,--regexp=PATTERN</code></td><td>使用<code>PATTERN</code>进行匹配。<br/>由于<code>PATTERN</code>直接提供在命令行，该选项可以省略。<br/>该选项可以用于提供多个匹配模式，而命令行中只能提供一个。</td></tr>
<tr><td><code>-f,--file=FILE</code></td><td>从文件<code>FILE</code>中读取<code>PATTERN</code>。</td></tr>
<tr><td><code>-i,--ignore-case</code></td><td>忽略大小写</td></tr>
<tr><td><code>-w,--word-regexp</code></td><td>匹配整个单词</td></tr>
<tr><td><code>-x,--line-regexp</code></td><td>匹配整行</td></tr>
</tbody></table>
</div>
<h5 id="执行控制"><a class="header" href="#执行控制">执行控制</a></h5>
<div class="table-wrapper"><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody>
<tr><td><code>-m,--max-count=NUM</code></td><td>在<code>NUM</code>次匹配之后停止</td></tr>
<tr><td><code>--binary-files=TYPE</code></td><td>文件类型：<code>binary</code>，<code>text</code>或<code>without-match</code></td></tr>
<tr><td><code>-a, --text</code><br/><code>--binary-file=text</code></td><td></td></tr>
<tr><td><code>-I</code><br/><code>--binary-file=without-match</code></td><td>表示不查找二进制文件。</td></tr>
<tr><td><code>-d,--directories=ACTION</code></td><td>如何处理文件夹：<code>read</code>，<code>recurse</code>，<code>skip</code></td></tr>
<tr><td><code>-r, --recursive</code></td><td><code>--directories=recurse</code></td></tr>
<tr><td><code>-R</code></td><td>递归，但不追踪符号链接。</td></tr>
<tr><td><code>-D,-devices=ACTION</code></td><td>如何处devices，FIFOs和socket：<code>read</code>，<code>skip</code></td></tr>
<tr><td><code>--include=FILE_PATTERN</code></td><td>搜索文件的文件名需要匹配<code>FILE_PATTERN</code>，<br/><code>FILE_PATTERN</code>可以包括通配符“<code>*</code>”“<code>?</code>”。</td></tr>
<tr><td><code>--exclude=FILE_PATTERN</code></td><td>排除文件名与<code>FILE_PATTERN</code>匹配的文件。</td></tr>
<tr><td><code>--exclude-from=FILE</code></td><td>跳过与<code>FILE</code>中的模式匹配的文件</td></tr>
<tr><td><code>--exclude-dir=PATTERN</code></td><td>跳过与<code>PATTERN</code>匹配的文件夹</td></tr>
<tr><td><code>-v, --inver-match</code></td><td>选择没有匹配的行</td></tr>
</tbody></table>
</div>
<h5 id="输出控制"><a class="header" href="#输出控制">输出控制</a></h5>
<div class="table-wrapper"><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody>
<tr><td><code>-b,--byte-offset</code></td><td>在输出的匹配行前添加匹配行相对文件起始位置的字节数。</td></tr>
<tr><td><code>-n,--line-number</code></td><td>在输出的匹配行前添加行号</td></tr>
<tr><td><code>-H,--with-filename</code> <br/><code>-h,--no-filename</code></td><td>在输出的匹配行前添加文件名<br/>（从起始位置开始的相对路径，默认）。<code>-h</code>不输出文件名。</td></tr>
<tr><td><code>-o, --only-matching</code></td><td>==只输出匹配部分==</td></tr>
<tr><td><code>-q, --quiet, --silent</code></td><td>不输出普通消息</td></tr>
<tr><td><code>-s, --no-message</code></td><td>不输出错误消息（要输出其他消息）</td></tr>
<tr><td><code>-L,--files-without-match</code></td><td>仅输出没有发生匹配的文件的文件名。</td></tr>
<tr><td><code>-l,--files-with-matches</code></td><td>仅输出发生匹配的文件的文件名<br/>（从起始位置开始的相对路径）。</td></tr>
<tr><td><code>-c, --count</code></td><td>仅输出一个文件中匹配的行数。</td></tr>
<tr><td><code>-B, --before-context=N</code></td><td>输出匹配行及其之前的N行内容</td></tr>
<tr><td><code>-A, --after-context=N</code></td><td>输出匹配行及其之后的<code>N</code>行内容</td></tr>
<tr><td><code>-C, --context=&lt;NUM&gt;</code><br/><code>-&lt;NUM&gt;</code></td><td>输出匹配行及其前后的<code>NUM</code>行内容</td></tr>
<tr><td><code>--color[=WHEN] </code><br/><code>--colour[=WHEN]</code></td><td>使用颜色高亮匹配内容，<code>WHEN='always','never', 'auto'</code>。</td></tr>
</tbody></table>
</div>
<h4 id="sed"><a class="header" href="#sed">sed</a></h4>
<blockquote>
<p><em><strong>stream editor</strong></em> for filtering and transforming text. (<code>info sed</code>)</p>
</blockquote>
<p><code>sed</code>一次处理一行内容，把当前行存储在称为“<strong>模式空间</strong>”（pattern space）临时缓冲区中，接着用<code>sed</code>命令处理模式空间中的内容；处理完成后将结果发送到输出流并清空模式空间，再继续处理下一行内容直到文件输入结束。<strong>保持空间</strong>（hold space）用于保存一些内容，在整个循环执行过程中不会被自动清空。</p>
<pre><code class="language-sh">sed [options] [script] input-files
</code></pre>
<p><code>-E,-r,--regexp-extended</code>：在脚本中==使用扩展的正则表达式==(ERE)而非基本正则表达式(BRE)，由于<code>/</code>在sed表达式中用于脚本命令的分隔符，因此是特殊字符，对于普通的<code>/</code>字符需要添加转义<code>\</code>，或使用<code>\%REGEXP%</code>设置分隔符（<code>%</code>可以为任意字符）。</p>
<blockquote>
<p>不支持<a href="Linux/">字符集合</a><code>\d</code>、<code>\w</code>等。</p>
</blockquote>
<p><strong>脚本</strong><code>script</code>：处理一行内容<code>sed</code><a href="Linux/Linux-Shell.html#sed%E8%84%9A%E6%9C%AC%E8%AF%AD%E5%8F%A5">脚本语句</a>。如果没有指定<code>-e,-f</code>选项，则<code>sed</code>使用第一个非选项参数作为脚本，其他参数作为输入文件；<code>-e,-f</code>选项可组合使用也可出现多次，最终的命令脚本是所有选项提供的脚本的组合；</p>
<blockquote>
<p><code>-e,--expression=script</code>：要执行的命令；
<code>-f,--file=script-file</code>：从文件中读取命令；</p>
</blockquote>
<p><code>script</code>参数中使用<code>;</code>分隔多个命令；文件中的命令使用换行分隔；</p>
<p><strong>输入输出</strong>：如果未指定输入文件，或输入文件为<code>-</code>，则<code>sed</code>使用标准输入流作为输入，也可以接收管道作为输入；<code>sed</code>使用标准输出流输出，可将输出重定向到文件（<strong>注意不要将输出重定向到输入文件，这样会先清空输入文件内容</strong>，应该使用<code>--in-place[=BACKUP_SUFFIX]</code>选项更新源文件）。</p>
<pre><code class="language-sh">sed 's/hello/world/' input.txt &gt; output.txt 
cat input.txt | sed 's/hello/world' - &gt; output.txt
</code></pre>
<p><code>sed</code>默认输出所有输入内容（除了被<code>d</code>命令删除的内容）。使用<code>-n</code>抑制输出后，仅输出命令指定的内容（例如使用<code>p</code>命令输出指定的行）。</p>
<pre><code class="language-sh">ps -ef | sed -n '1p;10p;$p' file.txt   # 仅输出第1、10行和最后一行
</code></pre>
<p><code>-s,--separate</code>：将多个文件视为独立的流，而非一个单独的长输入流；
<code>-i,--inplace[=SUFFIX]</code>：修改原始文件（inplace）；具体操作是先将输出保存到一个临时文件，结束处理时用临时替换原始文件。如果提供<code>SUFFIX</code>则将原始文件重命名为以<code>SUFFIX</code>结尾的备份文件。如果<code>SUFFIX</code>包含<code>*</code>，则将<code>*</code>替换为原始文件名，从而实现添加前缀（或路径名）。==由于<code>-i</code>是对原文修改，因此慎用<code>-n</code>选项，否则导致原文内容被误删除==；
<code>--follow-symlinks</code>：仅在<code>-i</code>指定时有效，修改符号链接最终指向的文件；
<code>-n,--silent,--quiet</code>：抑制自动输出；
<code>-l,--line-length=N</code>：指定输出自动换行的长度，默认值为70；</p>
<p><strong>返回值</strong>：<code>0</code>成功；<code>1</code>无效命令；<code>2</code>某个文件无法打开；<code>4</code>输入输出错误；使用命令<code>q</code>或<code>Q</code>自定义返回值<code>Q42</code>。</p>
<h5 id="sed脚本语句"><a class="header" href="#sed脚本语句">sed脚本语句</a></h5>
<p><code>sed</code>脚本语句的语法：<code>[addr]{X[/options/];Y[/opts/];...}</code>。</p>
<p><code>X,Y,...</code>代表单字符的<code>sed</code>命令；<code>addr</code>为行地址；<code>options</code>为某些命令的选项。</p>
<p>一条语句中包含一个行地址，但可包含多条命令构成命令组。如果只有一条命令则可以省略<code>{}</code>。</p>
<blockquote>
<p>如果没有使用<code>{}</code>，则<code>;</code>后的命令属于下一条语句（没有行地址，默认匹配全部文本）。</p>
</blockquote>
<h6 id="行地址"><a class="header" href="#行地址">行地址</a></h6>
<p>使用数值表示单独的行（从1开始，<code>$</code>表示最后一行），使用<code>N1,N2</code>指定连续的行区间；使用<code>start~step</code>来指定每隔若干行取一行执行；==未指定行地址则默认对所有行执行命令==；可以使用正则表达式<code>/pattern/</code>来匹配目标行：</p>
<pre><code class="language-sh">ps -ef | sed -n '2,$/p'  # 跳过第一行
sed '/apple/s/hello/world/' input &gt; output # edit on line contain 'apple'
</code></pre>
<blockquote>
<p>无论是数字或正则表达式表示的行地址，取补集即：<code>'/REGEXP/!cmd'</code>。</p>
</blockquote>
<div class="table-wrapper"><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody>
<tr><td><code>aTEXT</code>, <code>a TEXT</code></td><td>在一行后插入文本</td></tr>
<tr><td><code>cTEXT</code>, <code>c TEXT</code></td><td>替换文本</td></tr>
<tr><td><code>iTEXT</code>, <code>i TEXT</code></td><td>在一行前插入文本</td></tr>
<tr><td><code>p,P,l</code></td><td>打印模式空间（一行），<code>-P</code>打印到出现换行符；</td></tr>
<tr><td><code>d</code></td><td>删除模式空间，进入下一次循环；<br/><code>-D</code>删除换行符之前内容，并重新开始当前循环<br/>（没有换行符则进入下一循环）；</td></tr>
<tr><td><code>n</code></td><td>非安静模式下，输出当前模式空间内容，<br/>在任何情况下，用下一行内容替换当前模式空间内容<br />（下一行内容被消耗不会再被下一个循环读取）</td></tr>
<tr><td><code>z</code></td><td>清空模式空间（空字符串，仍占一行）</td></tr>
<tr><td><code>F</code></td><td>将前行所属的文件名作为一行插入当前行之前</td></tr>
<tr><td><code>g,G</code></td><td>用保持空间的内容替换模式空间的内容；<code>G</code>为追加模式</td></tr>
<tr><td><code>h,H</code></td><td>使用模式空间内容替换保持空间的内容；<code>H</code>为追加模式</td></tr>
<tr><td><code>x</code></td><td>交换模式空间和保持空间的内容</td></tr>
<tr><td><code>s/REGEXP/REPLACE/[FLAGS]</code></td><td>==替换匹配行的匹配内容==</td></tr>
<tr><td><code>y/src/dst/</code></td><td>将模式空间中属于<code>src</code>集合中的字符用<code>dst</code>集合中的相应字符代替</td></tr>
</tbody></table>
</div>
<blockquote>
<p><code>'a', 'c', 'i'</code>命令之后内容为插入的文本，因此不能在其后使用<code>;</code>连接其他命令。这些命令只能放在脚本最后或使用换行符分隔其他命令（命令行输入一条命令后换行继续输入另一条命令）。</p>
<pre><code class="language-sh">$ seq 2 | sed '1a Hello
&gt; 2d'
</code></pre>
<p>替换模式：使用源空间内容替换目标空间内容；</p>
<p>追加模式：在目标空间的内容基础上拼接一个换行符(<code>newline</code>)以及源空间的内容；</p>
</blockquote>
<p><code>-n</code>命令常用于处理每隔<code>N</code>行执行的操作；</p>
<pre><code class="language-sh">seq 6 | sed '0~3s/./x/'  # 等效于 sed 'n;n;s/./x'
</code></pre>
<h6 id="s命令substitute"><a class="header" href="#s命令substitute"><code>s</code>命令（substitute）</a></h6>
<p><code>s</code>命令可添加的选项（<code>FLAG</code>）：</p>
<p><code>g</code>：==替换所有匹配，而不仅是首个匹配==；
<code>p</code>：如果发生替换，则输出替换后的模式空间；未发生替换则不输出内容；未添加该选项时，根据<code>-n</code>选项（抑制自动输出）确定是否输出当前行（可能发生替换）的内容。
<code>w FILENAME</code>：如果发生替换，则将结果输出到文件，使用<code>/dev/stderr</code>和<code>/dev/stdout</code>表示标准输出流；
<code>i,I</code>：大小写不敏感的匹配；</p>
<p>当使用==扩展正则表达式==（<code>-E</code>）时，<code>REPLACE</code>中的特殊字符需要添加<code>\</code>转义为普通字符。</p>
<p><code>\</code>、<code>&amp;</code>、空格和换行（换行为<code>\n</code>）。对于非转义字符，使用<code>\c</code>等效于直接使用该字符。
使用<code>\N</code>（<code>N=1~9</code>）表示第N个捕获（位于正则表达式中<code>(</code>和<code>)</code>之间的内容），用<code>&amp;</code>表示整个匹配（即实现在原文内容前后插入内容）；
<code>\L</code>：将替换内容变换为小写字母直到<code>\U</code>或<code>\E</code>；<code>\l</code>将后续第一个字符变为小写；
<code>\U</code>：将替换内容变换为大写字母直到<code>\L</code>或<code>\E</code>；<code>\u</code>将后续第一个字符变为大写；</p>
<blockquote>
<p>大小写替换范围作用在一个匹配结果之内，每个匹配结果独立执行大小写替换；</p>
</blockquote>
<h4 id="awkgawk"><a class="header" href="#awkgawk">awk/gawk</a></h4>
<blockquote>
<p>gawk - pattern scanning and processing language.</p>
</blockquote>
<h5 id="基本用法"><a class="header" href="#基本用法">基本用法</a></h5>
<pre><code class="language-sh">awk '{[pattern] action}' {filenames} 
</code></pre>
<blockquote>
<p><code>awk</code>的命令语句只能用单引号<code>''</code>，避免shell展开其中的参数（例如<code>$1</code>）。</p>
</blockquote>
<p>输出：</p>
<pre><code class="language-sh">awk '{print $1,$4}' &lt;&lt;&lt; 'this is a string' # 每行按空格或TAB分割，输出文本中的1、4项
awk '{printf &quot;%-8s %-10s\n&quot;,$1,$4}' &lt;&lt;&lt; 'this is a string' # 格式化输出
</code></pre>
<blockquote>
<p><code>printf</code>的格式声明和参数之间使用<code>,</code>分隔（可包含空格）。</p>
</blockquote>
<p>设置分隔符：</p>
<pre><code class="language-sh">awk -F, '{print $1,$2}'   log.txt  # 使用&quot;,&quot;分割
awk 'BEGIN{FS=&quot;,&quot;} {print $1,$2}' log.txt
# 使用多个分隔符：先使用空格分割，然后对分割结果再使用&quot;,&quot;分割，[]不是分隔符的一部分
awk -F '[ ,]'  '{print $1,$2,$5}' log.txt  
</code></pre>
<p>设置变量：</p>
<pre><code class="language-sh">awk -va=1 '{print $1,$1+a}' log.txt   # set a=1
</code></pre>
<p>调用脚本：</p>
<pre><code class="language-sh">awk [options] -f program-file [--] file ...
awk [options] [--] program-text file ...
</code></pre>
<h5 id="运算符-17"><a class="header" href="#运算符-17">运算符</a></h5>
<h5 id="内置变量"><a class="header" href="#内置变量">内置变量</a></h5>
<p><code>$NF</code>：字符串的最后一列；</p>
<p>https://www.runoob.com/linux/linux-comm-awk.html</p>
<h5 id="过滤-1"><a class="header" href="#过滤-1">过滤</a></h5>
<p>过滤：</p>
<pre><code class="language-sh">awk '$1&gt;2' log.txt
awk '$1==2 {print $1,$3}' log.txt 
awk '$1&gt;2 &amp;&amp; $2==&quot;Are&quot; {print $1,$2,$3}' log.txt
</code></pre>
<p>可使用正则表达式过滤行。对整行进行过滤，<code>/REGEXP/</code>是模式。</p>
<pre><code class="language-shell">awk '/re/ ' log.txt                      # 输出包含 &quot;re&quot; 的行 ==&gt; grep 're' &lt; log.txt
awk '!/th/ {print $2,$4}' log.txt        # 取反匹配       
awk 'BEGIN{IGNORECASE=1} /this/' log.txt # 忽略大小写
</code></pre>
<p>或根据分割后的字段进行过滤，<code>~</code>表示模式开始：</p>
<pre><code class="language-sh">awk '$2 ~ /th/ {print $2,$4}' log.txt    # 第二列包含 &quot;th&quot;
awk '$2 !~ /th/ {print $2,$4}' log.txt   # 取反匹配
</code></pre>
<h5 id="awk脚本"><a class="header" href="#awk脚本">awk脚本</a></h5>
<pre><code class="language-sh">#!/bin/awk -f
BEGIN{} #运行前
{} #运行中：处理每一行
END{} #运行后
</code></pre>
<h5 id="awk参考资料"><a class="header" href="#awk参考资料">awk参考资料</a></h5>
<ol>
<li>
<p><a href="Linux/./cheat_sheet_gnuawk_v3.pdf">GNU awk Cheat Sheet</a></p>
</li>
<li>
<p><a href="Linux/./gawk.pdf">GAWK: Effective AWK Programming</a></p>
</li>
</ol>
<h4 id="全文处理"><a class="header" href="#全文处理">全文处理</a></h4>
<h5 id="按行排序"><a class="header" href="#按行排序">按行排序</a></h5>
<pre><code class="language-shell">sort [OPTIONS] FILES...
sort &lt;&lt; EOF            # 对键入内容按行进行排序
cmd_output | sort      # 对命令输出内容按行排序 &lt;== 
</code></pre>
<ul>
<li><code>-b, --ignore-leading-blanks</code>：忽略起始空白；</li>
<li><code>-f, --ignore-case</code>：忽略大小写；</li>
<li><code>-r, --reverse</code>：反向排序；</li>
<li><code>-o, --output=FILE</code>：输出文件。</li>
</ul>
<h5 id="去重"><a class="header" href="#去重">去重</a></h5>
<p>检测连续的重复记录（可能需要先进行排序），默认输出去除重复记录的结果。</p>
<pre><code class="language-shell">uniq INPUT           
cmd_output | unique
</code></pre>
<p>以标准输入或文件作为输入，并输出到标准输出或文件。选项：</p>
<ul>
<li><code>-c, --count</code>：在每一行前添加出现次数；</li>
<li><code>-d, --repeated</code>：仅打印重复行（只保留一条记录）；</li>
<li><code>-u, --unique</code>：仅打印不重复的行；</li>
</ul>
<h2 id="参考文献-8"><a class="header" href="#参考文献-8">参考文献</a></h2>
<div class="footnote-definition" id="shellmath"><sup class="footnote-definition-label">2</sup>
<p>Math in Shell Scripts, http://faculty.salina.k-state.edu/tim/unix_sg/bash/math.html</p>
</div>
<div class="footnote-definition" id="shellrc"><sup class="footnote-definition-label">1</sup>
<p><a href="https://stackoverflow.com/questions/18186929/what-are-the-differences-between-a-login-shell-and-interactive-shell">What are the differences between a login shell and interactive shell?</a></p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="linux-发行版"><a class="header" href="#linux-发行版">Linux 发行版</a></h1>
<h2 id="ubuntu"><a class="header" href="#ubuntu">Ubuntu</a></h2>
<h3 id="安装系统"><a class="header" href="#安装系统">安装系统</a></h3>
<p>系统版本：</p>
<ul>
<li>Server：默认无桌面环境；在编译时优化了某些选项；支持多处理器对称技术和NUMA；服务器版本的内核时钟频率由桌面的100hz转为1khz（<a href="https://blog.csdn.net/dearbaba_8520/article/details/80563812">参考</a>）。</li>
</ul>
<p>Ubuntu默认采用的文件系统格式为<code>ext4</code>，默认除根目录和<code>/boot</code>外，不会为其他目录挂载分区。</p>
<h3 id="软件管理-2"><a class="header" href="#软件管理-2">软件管理</a></h3>
<h4 id="软件源配置-1"><a class="header" href="#软件源配置-1">软件源配置</a></h4>
<p>添加镜像站点加速。国内的站点包括：</p>
<ul>
<li>阿里云：https://developer.aliyun.com/mirror/ubuntu</li>
<li>清华：https://mirrors.tuna.tsinghua.edu.cn/ubuntu（<em><code>Certificate verification failed</code></em>）</li>
<li>中科大：https://mirrors.ustc.edu.cn/ubuntu</li>
<li>网易：http://mirrors.163.com/ubuntu</li>
</ul>
<blockquote>
<p>安装服务器版本过程中，可以设置镜像站点。</p>
</blockquote>
<p>编辑软件源配置文件：</p>
<pre><code class="language-shell">sudo vi /etc/apt/sources.list
</code></pre>
<blockquote>
<p>修改配置文件中的站点为<a href="https://mirrors.tuna.tsinghua.edu.cn/help/ubuntu/">镜像站点</a>。</p>
</blockquote>
<p>更新软件源信息：</p>
<pre><code class="language-shell">sudo apt update
</code></pre>
<p>如果需要使用代理访问网络，则设置<code>/etc/apt/apt.conf.d/00aptproxy</code>（<code>apt</code>不适用系统代理环境变量）：</p>
<pre><code class="language-shell">Acquire::http::proxy &quot;http://[&lt;domain\user&gt;:&lt;password&gt;@]&lt;yourproxyserver&gt;:&lt;Port&gt;&quot;;
Acquire::https::proxy &quot;http://[&lt;domain\user&gt;:&lt;password&gt;@]&lt;yourproxyserver&gt;:&lt;Port&gt;&quot;;
Acquire::ftp::proxy &quot;http://[&lt;domain\user&gt;:&lt;password&gt;@]&lt;yourproxyserver&gt;:&lt;Port&gt;&quot;;
</code></pre>
<blockquote>
<p>如果代理需要认证，则需要配置用户名和密码<code>[&lt;domain\user&gt;:&lt;password&gt;@]</code>。</p>
</blockquote>
<h5 id="常见问题-4"><a class="header" href="#常见问题-4">常见问题</a></h5>
<ol>
<li>
<p><em><code>Certificate verification failed</code></em>：（容器）使用<code>https</code>协议需要<code>ca-certificates</code>。</p>
<p>使用基于<code>http</code>的镜像源。或者<a href="Linux/Linux%E5%8F%91%E8%A1%8C%E7%89%88.html#%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85%E8%BD%AF%E4%BB%B6%E5%8C%85">手动下载安装</a><code>ca-certificates</code>及其依赖文件。</p>
</li>
</ol>
<h4 id="软件管理工具"><a class="header" href="#软件管理工具">软件管理工具</a></h4>
<h5 id="apt-get"><a class="header" href="#apt-get">apt-get</a></h5>
<p><code>apt-get</code>是其他APT工具的后端，如<code>aptitude</code>，<code>synaptic</code>和<code>wajig</code>。</p>
<pre><code class="language-shell">apt-get update    # 从软件源同步软件包索引
        upgrade   # 升级软件包到最新版本
        dist-upgrade  # 系统重大升级(可能移除某些软件包)
        install|reinstall PKG[=version] --download-only
        remove|purge PKG       # purge还移除配置文件
        autoremove             # 移除系统中不需要的软件包
        download PKG[=version] # 下载软件包到当前目录
                               # 不能指定下载位置
        clean|autoclean        # 清理本地仓库，autoclean清理不再使用的缓存文件
apt-get changelog  # 获取软件包的改动历史
</code></pre>
<p><code>remove</code>将保留用户做过修改的配置文件（以防以外卸载导致用户配置丢失），而<code>purge</code>将移除所有相关文件（包括之前卸载过的软件，用户主目录下的文件除外）。==手动删除<code>remove</code>保留的配置文件可能导致重装软件出现问题。==</p>
<blockquote>
<p><code>install --reinstall =&gt; reinstall</code>；
<code>remove --purge =&gt; purge</code></p>
</blockquote>
<p>选项：</p>
<ul>
<li><code>-a,--host-architecture=architecture</code>：</li>
</ul>
<h5 id="apt-cache"><a class="header" href="#apt-cache">apt-cache</a></h5>
<p>查询APT缓存。</p>
<pre><code class="language-shell">apt-cahce gencaches       # 生成缓存，其他命令如需要会调用
          stats           # 显示缓存统计信息
          search   REGEX
              -f,--full       # 列出所有版本的信息
              -n,--names-only # 仅搜索包名
          pkgnames PREFIX # 显示匹配前缀的包名
          showpkg  PKG    # 显示软件包信息
          show     PKG    # 显示软件包信息(更多详情)
              -a,--all-versions # 显示所有可用版本
          showsrc  PKG    # 显示软件源码包(必须source.list中配置源码源)          
          depends  PKG    # 显示依赖信息(包括冲突包)
              --recurse   # 递归解析依赖    
</code></pre>
<h5 id="apt"><a class="header" href="#apt">apt</a></h5>
<p><code>apt</code>封装了<code>apt-get</code>、<code>apt-cache</code>等后端工具的常用命令，并对选项默认值做了部分改动。</p>
<h6 id="查找软件"><a class="header" href="#查找软件">查找软件</a></h6>
<pre><code class="language-shell">sudo apt search PACKAGE  # -&gt; apt-cache search
sudo apt list PACKAGE [--installed]  # 列出（已安装）软件包信息*
sudo apt show PACKAGE  # 列出软件包详细信息（list --full）
</code></pre>
<blockquote>
<p><code>PACKAGE</code>支持POSIX正则表达式（不支持<code>\d</code>等）。</p>
</blockquote>
<h6 id="安装卸载软件"><a class="header" href="#安装卸载软件">安装/卸载软件</a></h6>
<pre><code class="language-shell">sudo apt install PACKAGE	    # 安装软件包
sudo apt remove|purge PACKAGE	# 移除软件包
sudo apt autoremove				   
</code></pre>
<p>安装桌面环境的交互命令：</p>
<pre><code class="language-shell">sudo apt install tasksel -y
sudo tasksel
</code></pre>
<pre><code class="language-shell">sudo apt install ./&lt;file&gt;.deb
</code></pre>
<h5 id="软件升级"><a class="header" href="#软件升级">软件升级</a></h5>
<blockquote>
<p>安装操作系统后首先对系统进行升级。</p>
</blockquote>
<pre><code class="language-shell">sudo apt list --upgradable	# 列出所有可升级软件包的信息
sudo apt upgrade			      # 升级软件包，更新系统
sudo apt full-upgrade
</code></pre>
<h5 id="长期支持版升级"><a class="header" href="#长期支持版升级">长期支持版升级</a></h5>
<pre><code class="language-sh">sudo apt update &amp;&amp; sudo apt upgrade &amp;&amp; sudo apt dist-upgrade
sudo apt install update-manager-core
# edit /etc/update-manager/release-upgrades
Prompt=lts  # normal  
sudo do-release-upgrade 
     # -d upgrade to development release*
</code></pre>
<blockquote>
<p><code>*</code>：<em>The new LTS release isn’t made available to <code>do-release-upgrade</code> until its first <strong>point release</strong> (e.g., <code>22.04.1</code>, usually comes a few months after the initial release date). If you don’t see an available release, add the <code>-d</code> option to upgrade to the <strong>development</strong> release.</em> </p>
</blockquote>
<h5 id="离线安装软件包"><a class="header" href="#离线安装软件包">离线安装软件包</a></h5>
<p><strong>下载离线安装包到指定位置</strong>：<code>apt-get</code>可以将包下载到当前目录。</p>
<pre><code class="language-shell">app=mysql-server
depends=$(apt-cache depends --recurse --no-recommends --no-suggests --no-conflicts --no-breaks --no-replaces --no-enhances $app| grep &quot;^\w&quot; | sort -u)
apt-get download $depends
</code></pre>
<p><code>dpkg-scanpackages</code>扫描目录（包括子目录）并创建<strong>包索引文件<code>Packages.gz</code></strong>（给<code>apt</code>等工具查找和安装包使用）。</p>
<pre><code class="language-shell"># sudo apt install dpkg-dev  # &lt;== dpkg-scanpackages
cd /path/to/repository  
dpkg-scanpackages [--OPTS] . [OVERRIDE_FILE PATH_PREFIX] &gt; Packages
gzip -9c Packages &gt; Packages.gz #*
</code></pre>
<blockquote>
<p><code>*</code>：如果通过<code>file://</code>访问仓库，则使用<code>Packages</code>，如果通过<code>http://</code>等方式，则使用的文件需要压缩为<code>*.xz,*.bz2,*.gz</code>。</p>
<p><code>-m</code>：输出内容中包括包的所有版本（包括重复内容）；</p>
<p><code>path-prefix</code>：添加到输出内容的<code>Filename</code>字段；等效于<code>PACKAGE_APTH</code>前添加前缀；<code>OVERRIDE_FILE</code>包含包的附加信息（可选，或设置为<code>/dev/null</code>）。</p>
</blockquote>
<p>创建本地源</p>
<pre><code class="language-shell">vi /etc/apt/sources.list.d/local.list
deb [trusted=yes] file:/home/user/download/packages/ ./ # 本地文件*
deb [trusted=yes] http://local-server/debs/amd64/ ./    # HTTP服务=&gt; /var/www/debs/amd64
sudo apt-get update
</code></pre>
<blockquote>
<p>源声明中，第一列为包类型（软件包或源代码包），第二列固定参数为仓库URL，第三列为发行版名称（通常本地源使用<code>./</code>代替），后两者组成索引文件<code>Packages</code>或<code>Packages.gz</code>所在目录。索引文件声明了软件包相对于索引文件的位置，因此进行迁移部署时，应该保持扫描包时软件包与索引文件的相对位置不变。</p>
</blockquote>
<p>使用<code>apt</code>等工具搜索安装软件。</p>
<blockquote>
<pre><code class="language-shell">sudo dpkg -i *  # 不推荐直接安装目录下的所有包，可能有兼容性问题
sudo dpkg --configure -a
</code></pre>
</blockquote>
<h5 id="软件文件缺损"><a class="header" href="#软件文件缺损">软件文件缺损</a></h5>
<h3 id="软件中心"><a class="header" href="#软件中心">软件中心</a></h3>
<p>遇到软件中心安装程序长时间不能完成或无响应</p>
<ol>
<li>
<p>使用以下命令找到root的<code>dpkg</code>进程</p>
<pre><code class="language-shell">ps -af | grep dpkg
</code></pre>
</li>
<li>
<p>使用以下命令杀死该进程</p>
<pre><code class="language-shell">sudo kill -9 PID
</code></pre>
</li>
<li>
<p>然后可以继续安装软件</p>
</li>
</ol>
<h5 id="ppa"><a class="header" href="#ppa">PPA</a></h5>
<p>从软件源移除PPA：</p>
<pre><code class="language-shell">sudo ls /etc/apt/sources.list.d		#列出PPA名称
sudo rm -i /etc/apt/sources.list.d/PPA_Name.list #移除指定的PPA
</code></pre>
<h3 id="网络接口配置"><a class="header" href="#网络接口配置">网络接口配置</a></h3>
<p>Ubuntu使用<code>netplan</code>，其配置文件：<code>/etc/netplan/50-cloud-init.yaml</code>（或<code>00-installer-config.yaml</code>）</p>
<p>示例：</p>
<pre><code class="language-yaml">network:
	renderer: networkd	# NetworkManager for desktop system
    ethernets:
     	eth0:			# WAN interface
        dhcp4: true
      eth1:			# LAN interface
        addresses:	# static IP configuration
        - 192.168.1.100/24
        dhcp4: false
        gateway4: 192.168.1.1
        nameservers: # DNS servers
          addresses: 
          - 223.5.5.5
          - 223.6.6.6 
        search: []
    version: 2
</code></pre>
<p>将<code>dhcp4</code>设置为<code>true</code>时，也可以人工设置部分参数，DHCP服务仅更新未设置的网络参数，如默认网关（影响路由表中默认路由信息生成）。</p>
<blockquote>
<p>使用静态配置时，如果更新了网关，可能路由表中的条目没有及时更新，导致网络不可用。此时可使用DHCP动态刷新默认路由。</p>
<p><code>dhcp=true</code>时，如果设置了IP地址，则此时接口同时具有动态和静态IP地址。</p>
</blockquote>
<p>网络配置：https://ubuntu.com/server/docs/network-configuration。</p>
<h3 id="防火墙ufw"><a class="header" href="#防火墙ufw">防火墙ufw</a></h3>
<p><code>ufw</code>（<em><strong>Uncomplicated Firewall</strong></em>）为Ubuntu中的<a href="Linux/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.html#%E5%86%85%E6%A0%B8%E9%98%B2%E7%81%AB%E5%A2%99">防火墙</a>用户程序，其简化了<code>iptables</code>直接操作表链的命令。</p>
<pre><code class="language-shell">ufw enable|disable|reload       # enable重载防火墙并开机自启
ufw reset --force               # 重置防火墙到安装状态，--force不确认直接执行
ufw logging on|off|LEVEL        # 日志级别：off,low,medium,high,full（默认&quot;low&quot;）
</code></pre>
<blockquote>
<p><code>ufw</code>需要管理员权限（<code>sudo</code>）运行。使用<code>--dry-run</code>查看命令产生的修改，但不应用修改；即使不提供该选项，<code>ufw</code>默认也会在应用规则前提示用户要执行的操作。</p>
<p>输出信息中<code>Anywhere</code>表示<code>any</code>和<code>0.0.0.0/0</code>；。</p>
</blockquote>
<p><code>ufw</code>在启用时会首先清空防火墙规则表（以保证状态一致性），这可能导致已有连接中断（如果默认策略为拒绝）。<code>ufw</code>支持在启用前添加规则，即<code>sudo ufw allow 22/tcp &amp;&amp; ufw enable</code>。该规则仍然会在启用防火墙时被清空，但防火墙在启用后相应端口的连接会保持。防火墙启用后，添加或删除规则不会再次清空规则表。</p>
<h4 id="防火墙状态"><a class="header" href="#防火墙状态">防火墙状态</a></h4>
<pre><code class="language-shell">ufw status [numbered|verbose]   # 查看防火墙状态及ufw管理的规则
</code></pre>
<p>查看防火墙统计信息：</p>
<pre><code class="language-shell">ufw show raw|builtins|before-rules|user-rules|after-rules|logging-rules|listening|added
</code></pre>
<h4 id="规则配置"><a class="header" href="#规则配置">规则配置</a></h4>
<h5 id="设置默认规则"><a class="header" href="#设置默认规则">设置默认规则</a></h5>
<pre><code class="language-shell">ufw default allow|deny|reject [incoming|outgoing|routed] # 默认规则
</code></pre>
<h5 id="设置收发规则"><a class="header" href="#设置收发规则">设置收发规则</a></h5>
<pre><code class="language-shell">ufw allow|deny|reject|limit [in|out] [PORT[/PROTO]|APPNAME] [comment COMMENT] # 简洁模式
ufw allow|deny|reject|limit \  # 完整命令模式
	[in|out] [on INTERFACE]  \  # 方向和接口
	[from SRC] [TO DEST] \      # IP地址：any表示所有地址，10.0.0.0/8表示网段
	[PORT[/PROTO]|APPNAME] \    # 端口协议(默认tcp和udp)|服务，80,443,8080:8090指定多个(连续)端口
	[comment COMMENT]           # 规则说明
# ufw allow 53; ufw allow 25/tcp;  ufw allow smtp; ufw allow in http comment &quot;web service&quot;
</code></pre>
<blockquote>
<p>IPv6地址<code>2001:db8::/32</code>（在<code> /etc/default/ufw</code>中启用IPv6防火墙）；如果设置规则时未指定IP地址且启用IPv6，则添加规则时将同时添加两条规则。</p>
<p>其他协议包括：<code>ah/esp/gre</code>（未指定端口时有效）；<code>ipv6/igmp</code>（未指定端口且指定IPv4地址）。</p>
</blockquote>
<p><code>limit</code>用于限制会话速率（防止暴力破解登录攻击，<code>ufw limit ssh/tcp</code>）。</p>
<p>上述命令默认将规则添加到规则列表末尾。</p>
<pre><code class="language-shell">ufw insert NUM RULE   # 插入规则到指定编号位置（原有规则编号自动更新）
ufw prepend RULE      # 将已添加的规则置顶
</code></pre>
<blockquote>
<p><code>NUM</code>的值不能比现有规则编号大，因此要在规则列表末端添加规则就不提供<code>insert NUM</code>命令。==IPv6规则默认在所有IPv4规则之后==（虽然编号是连续的，但实际是两张独立的表），因此指定<code>NUM</code>时，其值必须在对应的IP协议规则编号范围内。</p>
</blockquote>
<p>删除规则：</p>
<pre><code class="language-shell">ufw delete RULE|NUM     # 删除指定规则或对应编号规则
</code></pre>
<blockquote>
<p><code>RULE</code>同时匹配IPv4和IPv6规则时，将同时删除两条规则；删除规则时可不指定规则的说明。</p>
</blockquote>
<h5 id="设置路由规则"><a class="header" href="#设置路由规则">设置路由规则</a></h5>
<p>路由规则在收发规则语句前增加<code>route</code>关键字，以处理目的地址非本机的数据包。路由规则可同时指定<code>in/out</code>及其接口。</p>
<pre><code class="language-shell">ufw route ACTION RULE
</code></pre>
<blockquote>
<p>启用路由功能需<a href="Linux/Linux%E9%85%8D%E7%BD%AE%E5%92%8C%E7%AE%A1%E7%90%86.html#%E8%BD%AC%E5%8F%91%E5%8A%9F%E8%83%BD">开启IP转发功能</a>，然后重启<code>ufw</code>。</p>
</blockquote>
<h5 id="应用配置"><a class="header" href="#应用配置">应用配置</a></h5>
<p>在配置规则时，可使用应用名称代替端口协议配置。应用配置文件位于<code>/etc/ufw/applications.d</code> （<code>/etc/services</code>）。</p>
<pre><code class="language-ini">[SomeService]
title=Some title
description=Some description
ports=12/udp|34|56,78:90/tcp
</code></pre>
<pre><code class="language-shell">ufw app list  # 列出已配置的应用名称，应用名为配置文件中节标题(SomeService)
ufw app update &lt;name&gt;|all  # 更新应用相关的防火墙规则
</code></pre>
<h3 id="桌面环境"><a class="header" href="#桌面环境">桌面环境</a></h3>
<h4 id="字体-2"><a class="header" href="#字体-2">字体</a></h4>
<h5 id="安装中文字体"><a class="header" href="#安装中文字体">安装中文字体</a></h5>
<pre><code class="language-sh">sudo apt-get install ttf-wqy-microhei  	#文泉驿-微米黑
sudo apt-get install ttf-wqy-zenhei  	#文泉驿-正黑
sudo apt-get install xfonts-wqy 		#文泉驿-点阵宋体
</code></pre>
<h5 id="列出系统字体"><a class="header" href="#列出系统字体">列出系统字体</a></h5>
<pre><code class="language-sh">fc-list: lang=zh # list fonts
</code></pre>
<h3 id="elementary-os"><a class="header" href="#elementary-os">Elementary OS</a></h3>
<p>Elementary OS基于Ubuntu。</p>
<h3 id="常见问题-5"><a class="header" href="#常见问题-5">常见问题</a></h3>
<ol>
<li>
<p>启动黑屏/花屏</p>
<p>更新显卡驱动程序（NVIDIA/ASPEED/...）。</p>
</li>
<li>
<p>欢迎屏幕之前有字符界面</p>
<p>更新grub设置。</p>
<pre><code class="language-shell">sudo vi /boot/grub/grub.cfg
# add quiet splash nomodeset
sudo update-grub
</code></pre>
<p><strong>问题</strong>：系统无法在初始化阶段获得屏幕信息，导致进入欢迎界面以及登陆后的分辨率过低。</p>
</li>
<li>
<p>中文乱码</p>
<ul>
<li>
<p>没有安装中文支持</p>
</li>
<li>
<p>没有中文字体</p>
</li>
<li>
<p>控制台不支持中文</p>
</li>
</ul>
</li>
</ol>
<h2 id="kali-linux"><a class="header" href="#kali-linux">Kali Linux</a></h2>
<pre><code class="language-shell"># edit /etc/apt/sources.list
deb https://mirrors.tuna.tsinghua.edu.cn/kali kali-rolling main non-free contrib
sudo apt install kali-linux-default
</code></pre>
<p>https://www.kali.org/docs/general-use/metapackages/</p>
<h5 id="kaili-on-wsl2"><a class="header" href="#kaili-on-wsl2">Kaili on WSL2*</a></h5>
<p><a href="https://www.kali.org/docs/wsl/win-kex/">Win-KeX</a> provides a Kali Desktop Experience for WSL.</p>
<pre><code class="language-shell">sudo apt install -y kali-win-kex
# Run in Kali
kex --win -s       # start in Window mode with sound support
kex --esm --ip -s  # start in Enhanced Session Mode
kex --sl -s        # start in Seamless mode with sound support
</code></pre>
<h2 id="fedoracentosrhel"><a class="header" href="#fedoracentosrhel">Fedora/CentOS/RHEL</a></h2>
<h3 id="安装-5"><a class="header" href="#安装-5">安装</a></h3>
<p>CentOS/RHEL采用图形界面配置安装过程，在安装界面可配置工作站、服务器和带图形界面的服务器等多种安装方案（VMWare中选择简易安装将进入无人值守安装，默认安装带图形界面的服务器版本，无法进行自定义。可通过鼠标键盘选择界面中的配置项以中断自动安装过程）。</p>
<img src="Linux/Linux发行版.assets/image-20200901092403396.png" alt="image-20200901092403396" style="zoom: 67%;" />
<p>软件环境配置：</p>
<img src="Linux/Linux发行版.assets/image-20200901093253141.png" alt="image-20200901093253141" style="zoom:67%;" />
<p>CentOS支持远程Web管理（Cockpit，默认端口9090（<code>websm</code>）)。<img src="Linux/" alt="" /></p>
<h5 id="磁盘分区"><a class="header" href="#磁盘分区">磁盘分区</a></h5>
<p>CentOS自动分区得到的根目录空间较小（<code>/</code>目录最多分配50GiB），默认文件系统类型为LVM/XFS。XFS不支持文件系统扩容/缩容，因此若选择XFS，必须在安装系统时根据需求规划好<a href="Linux/Linux%E9%85%8D%E7%BD%AE%E5%92%8C%E7%AE%A1%E7%90%86.html">分区方案</a>。</p>
<img src="Linux/Linux发行版.assets/image-20210914154908159.png" alt="image-20210914154908159" style="zoom: 67%;" />
<h3 id="软件管理-3"><a class="header" href="#软件管理-3">软件管理</a></h3>
<p>所有发行版可使用命令工具<code>dnf/yum</code>从软件源下载安装软件，桌面版可使用软件中心检查和安装更新。使用<code>dnf/yum/rpm</code>可以从本地软件包安装软件。</p>
<h4 id="软件包管理器yumdnf"><a class="header" href="#软件包管理器yumdnf">软件包管理器yum(dnf)</a></h4>
<blockquote>
<p><code>dnf</code>(<em>Dandified YUM</em>)是<code>yum</code>(<em>Yellow dog Updater, Modified</em>)的下一个版本。</p>
</blockquote>
<pre><code class="language-shell">yum clean                # 清除本地仓库缓存数据
dnf history
</code></pre>
<h5 id="查找-7"><a class="header" href="#查找-7">查找</a></h5>
<pre><code class="language-shell">yum repolist [all]               # 列出可用仓库, all包括未启用仓库
yum-config-manager --enable &lt;repo-name&gt;
yum search &lt;keyword&gt;             # 按关键字搜索软件包
yum list [installed] [PACKAGE]   # 列出(已安装)软件包信息：包名|版本|源
yum info [installed] PACKAGE     # 查看(已安装)软件包的信息
yum --showduplicates list httpd  # 列出软件包的不同版本
</code></pre>
<blockquote>
<p>软件安装源对应<code>*.repo</code>文件的节名称，其中以<code>@anaconda</code>开头的为系统预装软件，软件源为<code>installed</code>为安装系统后手动安装的软件（通过软件源或RPM包）。</p>
</blockquote>
<h5 id="安装和更新"><a class="header" href="#安装和更新">安装和更新</a></h5>
<pre><code class="language-shell">yum --installroot NEWROOT --releasever=/ install PACKAGE[-ver] 
    --enablerepo=&lt;reponame&gt;  # 即时启用软件仓库(支持通配符)
    --disablerepo=&lt;reponame&gt;
yum reinstall            # 重新安装
yum check-update         # 检查可用更新
yum update [PACKAGE]
</code></pre>
<p>如果未指定<code>installroot</code>选项，则默认安装根目录为<code>/</code>，否则使用指定的根目录（<a href="https://linuxhint.com/install-package-to-a-specific-directory-using-yum/">需要同时指定<code>--releasever=/</code>，否则报错</a>），<code>yum</code>会==在指定位置创建完整的根文件树==并安装指定软件及其依赖项。每个根目录下安装的软件是相互独立的，即检查依赖项时在当前根目录下查找依赖项的安装记录（查找已安装软件时也可指定<code>installroot</code>选项，从而查找指定安装根目录下的软件）。</p>
<blockquote>
<p>创建基本的运行环境：</p>
<pre><code class="language-shell">yum --installroot=/root/tmproot/ --releasever=/ install bash coreutils grep
</code></pre>
<p>创建新的根目录时使用的是真实系统的软件仓库设置；在已创建的根目录下继续安装软件将使用该根目录下的仓库配置<code>/NEWROOT/etc/yum.repos.d</code>。如果要使用真实系统中的仓库源配置，将相应文件复制到上述目录。</p>
</blockquote>
<h5 id="卸载"><a class="header" href="#卸载">卸载</a></h5>
<pre><code class="language-shell">yum remove &lt;package&gt;
yum autoremove [&lt;package&gt;]  # 移除不再使用的依赖包
</code></pre>
<p>清理不再维护的软件</p>
<pre><code class="language-shell">dnf install remove-retired-packages
remove-retired-packages
</code></pre>
<p>清理过时的软件，以下命令列出的软件可能不再需要，可检查并移除相应软件。</p>
<pre><code class="language-shell">PKGS=$(dnf repoquery --unsatisfied)  # 不满足依赖的软件(通常为空)
PKGS=$(dnf repoquery --duplicates)   # 具有重复版本的软件
PKGS=$(dnf list extras)              # 不在仓库中的软件
</code></pre>
<p>使用以下脚本清理旧版本内核</p>
<pre><code class="language-shell">old_kernels=($(dnf repoquery --installonly --latest-limit=-1 -q))
dnf remove &quot;${old_kernels[@]}&quot;
</code></pre>
<h5 id="fedora系统升级"><a class="header" href="#fedora系统升级">Fedora系统升级</a></h5>
<pre><code class="language-shell">dnf upgrade --refresh
dnf install dnf-plugin-system-upgrade
dnf system-upgrade download --releasever=36  # 官方仅支持跨两个版本升级
dnf system-upgrade reboot
</code></pre>
<p>合并配置文件</p>
<pre><code class="language-shell">dnf install rpmconf
rpmconf -a  # 
</code></pre>
<p>清理失效的符号连接：</p>
<pre><code class="language-shell">dnf install symlinks
symlinks -r /usr | grep dangling  # 检查列出的失效链接文件
symlinks -r -d /usr  # 删除失效链接文件
</code></pre>
<h5 id="安装-6"><a class="header" href="#安装-6">安装</a></h5>
<h5 id="中文字体"><a class="header" href="#中文字体">中文字体</a></h5>
<pre><code class="language-shell">yum groupinstall Fonts
</code></pre>
<h4 id="软件源配置-2"><a class="header" href="#软件源配置-2">软件源配置</a></h4>
<h5 id="fedora"><a class="header" href="#fedora">Fedora</a></h5>
<p>Fedora/CentOS 默认使用 <a href="https://zh.fedoracommunity.org/2018/04/05/fedora-secures-package-delivery.html">Metalink</a> 给出推荐的镜像列表，保证用户使用的镜像仓库足够新，并且能够尽快拿到安全更新，从而提供更好的安全性。所以通常情况下使用默认配置即可，无需更改配置文件。</p>
<blockquote>
<p>由于 Metalink 需要从国外的 Fedora 项目服务器上获取元信息，所以对于校园内网、无国外访问等特殊情况，metalink 并不适用，此时可以将<code>/etc/yum.repos.d</code>目录下的文件<code>fedora.repo</code>、<code>fedora-updates.repo</code>、<code>fedora-modular.repo</code>和<code>fedora-updates-modular.repo</code>中的<code>metalink</code>注释掉，并将<code>baseurl</code>的域名改为国内镜像站点。</p>
<ul>
<li><code>https://mirrors.aliyun.com/fedora/</code></li>
<li><code>https://mirrors.tuna.tsinghua.edu.cn/fedora</code></li>
</ul>
<pre><code class="language-shell">baseurl=MIRROR_SITE/releases/$releasever/Everything/$basearch/os/
</code></pre>
<p>由于Fedora发行节奏较快，部分镜像源通常仅保留最近若干个版本的仓库数据（由于<a href="http://archives.fedoraproject.org/pub/archive/fedora/">主站点对旧版本进行归档</a>）。如果进行软件安装或升级时，发现无法获取仓库元数据（<code>repodata.xml</code>），则需要更换为Metalink自动寻找仍支持当前系统版本的软件源，稍后尝试对系统进行升级。</p>
</blockquote>
<h5 id="centos"><a class="header" href="#centos">CentOS</a></h5>
<p>默认启用的软件源包括：<code>Base</code>、<code>AppStream</code>、<code>Extras</code>。</p>
<pre><code class="language-shell">sudo cp /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.bak
</code></pre>
<p>编辑<code>/etc/yum.repos.d/CentOS-Base.repo</code>文件，在<code>mirrorlist=</code>开头行前面加<code>#</code>注释掉；并将<code>baseurl=</code>开头行取消注释，把该行内的域名（例如<code>mirror.centos.org</code>）替换为 ``https://mirrors.tuna.tsinghua.edu.cn/`。</p>
<pre><code class="language-shell">sudo yum makecache   # 生成缓存软件包元数据
</code></pre>
<h5 id="epel"><a class="header" href="#epel">epel</a></h5>
<p>EPEL(<em>Extra Packages for Enterprise Linux</em>)是由Fedora Special Interest Group维护的Enterprise Linux（RHEL/CentOS）中经常用到的包。首先安装<code>epel-release</code>，生成<code>epel.repo</code>。</p>
<pre><code class="language-shell">yum install epel-release
</code></pre>
<blockquote>
<p>EPEL不适用于Fedora，Fedora源中已经包含了大部分EPEL中的包。</p>
</blockquote>
<p>如果需要使用epel镜像源，在安装上述包后，修改其中的<code>baseurl</code>。</p>
<h5 id="redhat"><a class="header" href="#redhat">redhat</a></h5>
<p>RHEL安装后系统中没有配置仓库，需要通过<code>subscription-manager</code>将系统注册到RedHat的订阅（需要现在<a href="https://developers.redhat.com/register">RedHat开发者网站注册</a>开发者账号并更新<a href="https://access.redhat.com/management/subscriptions">订阅</a>）。</p>
<pre><code class="language-shell">subscription-manager register    # 在当前系统登录，输入开发者网站用户名和密码
subscription-manager attach      # 将当前系统绑定到账户的订阅
subscription-manager list|status # 列出当前系统信息和订阅信息
subscription-manager repos       # 列出系统使用的仓库=&gt;yum repolist
subscription-manager repos --enable rhel-xxx-rpms # 启用仓库(yum-config-manage)
</code></pre>
<blockquote>
<p><code>subscription-manager-gui</code>是图形界面版本。</p>
<p>由于网络原因，<code>subscription.rhsm.redhat.com</code>的IP可能无法获取，尝试更改DNS配置并通过<code>ping</code>获取正确IP，手动更新<code>/etc/hosts</code>文件。</p>
</blockquote>
<h5 id="使用nexus代理"><a class="header" href="#使用nexus代理"><a href="Linux/../%E5%BA%94%E7%94%A8%E8%BD%AF%E4%BB%B6/%E7%BD%91%E7%BB%9C%E6%9C%8D%E5%8A%A1%E8%BD%AF%E4%BB%B6.html#centos-yum%E4%BB%A3%E7%90%86">使用nexus代理</a></a></h5>
<pre><code class="language-ini">[CentOS]
name=centos
baseurl=http://localhost:8081/repository/proxy-centos/7/os/x86_64
enabled=1
gpgcheck=0
# baseurl=http://localhost:8081/repository/proxy-centos/7/extras/x86_64
# baseurl=http://localhost:8081/repository/proxy-centos/7/updates/x86_64
# baseurl=http://localhost:8081/repository/proxy-epel/7/x86_64
</code></pre>
<p>注意：通常镜像站点包含一系列<code>repo</code>，<code>baseurl</code>路径是可以找到<code>repodata</code>的目录。</p>
<h4 id="离线安装软件"><a class="header" href="#离线安装软件">离线安装软件</a></h4>
<p><strong>软件包</strong>：使用浏览器从软件官网或从使用<code>dnf/yum</code>从软件源下载<code>rpm</code>软件包。<code>alien</code>可以将<code>deb</code>包转换为<code>rpm</code>包，但不一定成功。</p>
<pre><code class="language-shell">yum whatprovides */lspci  # 查看命令所在的包
yum install yum-utils        # provide yumdownloader, repoquery, repotrack
</code></pre>
<pre><code class="language-shell">yum install --installroot /tmproot --releasever=/ \
            --downloadonly --downloaddir=DLDIR &lt;package&gt;  # 已安装的依赖包不会下载
yumdownloader [yum_options]    \  # 与yum download等效
    --resolve                  \  # 解析并下载依赖包（已安装的包不会下载）
    --destdir=prefix           \  # defaults to current directory
    --archlist=x86_64,noarch -x '*i686'   \  # 系统架构, 排除兼容包
    #--urls                    \  # 仅列出要下载包的URL而不下载
    package_name                  # 要下载的软件包
</code></pre>
<p>由于已安装的依赖包不会被下载，因此我们可以使用全新系统进行下载，或者<a href="Linux/Linux%E5%8F%91%E8%A1%8C%E7%89%88.html#%E5%AE%89%E8%A3%85%E5%92%8C%E6%9B%B4%E6%96%B0">使用<code>yum</code>制作一个只包括预装软件的操作系统环境</a>。如果没有基础环境，也可以通过以下方式解析和下载软件及其依赖包。</p>
<p>如果目标系统版本低于下载包的系统版本，则需要使用<code>repoquery/repotrack</code>下载所有依赖项（包括系统库）进行升级。</p>
<pre><code class="language-shell">repoquery --archlist=x86_64,noarch \  
    -f \                     # 查询提供当前文件的包*
    --requires \             # 列出依赖项 &lt;=&gt; -R
    --resolve \              # 将依赖项解析为对应的包名
    --recursive \            # 递归解析依赖项
    #--list \                # 列出包中包含的文件
    #--installed \           # 仅查询已安装的包
    package_name | xargs -r yumdownloader [options]
</code></pre>
<blockquote>
<p><code>*</code>：根据帮助文档，该选项的值为指定包中应该包含的文件名；实际上，如果缺少该选项，会导致命令行提供的包名对应的包不会被返回（仅返回依赖项），因此需要添加该选项（无需提供值）。</p>
</blockquote>
<pre><code class="language-shell">repotrack --arch=x86_64 \ # 默认当前架构*
          -p,--download_path=DIR \
          -u,--url  \   # 列举要下载的内容
          packages...     # 递归下载软件及其依赖安装包（包括系统预装库）
</code></pre>
<blockquote>
<p><code>*</code>：<code>x_86</code>架构会自动下载兼容<code>i686</code>和<code>noarch</code>包。为了排除<code>i686</code>包，可先列举下载内容并过滤，再使用<code>yumdownloader</code>进行下载（类似于上述使用<code>repoquery</code>下载方法）。</p>
<p><a href="https://bugzilla.redhat.com/show_bug.cgi?id=1045871">1045871 – yumdownloader --archlist=x86_64 downloads i686 on x86_64 (redhat.com)</a></p>
<p>通常<code>repotrack</code>用于下载包及其依赖项，<code>repoquery</code>用于查询相关信息（类似于<code>rpm -q*</code>）。</p>
</blockquote>
<p>使用软件包安装/移除软件：</p>
<pre><code class="language-shell">yum install &lt;package&gt;.rpm       # 兼容localinstall命令，可自动检查安装本地依赖包
rpm -ivh --force --upgrade &lt;package&gt;.rpm  # -i =&gt; --install, --force=&gt;强制重新安装, --upgrade升级安装
rpm -e,--erase &lt;package&gt;.rpm    # remove installation
rpm -q  &lt;package&gt;               # print Name.Version.Release
rpm -qa                         # query all packages
rpm -ql[p][v] &lt;package&gt;         # contents at install location/oackage file
</code></pre>
<blockquote>
<p>RPM选项：</p>
<p><code>-q,--query</code> to specify it as a query command
<code>-l,--list</code> to list the files in the package,
<code>-p,--package</code> 查询/验证包文件中的内容，未提供则查询/验证以安装内容;
<code>-v</code> (verbose) provides additional information (permissions, owner, etc.)</p>
</blockquote>
<h5 id="构建本地软件仓库"><a class="header" href="#构建本地软件仓库">构建本地软件仓库</a></h5>
<p>安装带依赖项的软件包：配置本地软件源，将软件包放置于本地目录。</p>
<ul>
<li>
<p>首先安装在系统中安装<code>createrepo</code>；</p>
</li>
<li>
<p>在软件包所在目录下执行。</p>
<pre><code class="language-shell">createrepo --update --output=repodir path/to/packages
</code></pre>
<blockquote>
<p>默认输出到软件包所在目录，软件包路径相对<code>repodir</code>指定，保证下载软件时路径正确。</p>
</blockquote>
</li>
<li>
<p>在<code>/etc/yum.repos.d</code>创建一个本地源的配置文件：</p>
<pre><code class="language-shell">[local]
name=My Awesome Repo
baseurl=file:///path/to/repodir
enabled=1   # &quot;enabled&quot; not &quot;enable&quot;
gpgcheck=0
</code></pre>
</li>
</ul>
<p>将系统内置的在线软件源禁用或将配置移到备份位置。</p>
<ul>
<li>
<p>使用<code>yum install</code>命令安装相应软件包。</p>
<pre><code class="language-shell">yum clean all   # package-cleanup --cleandupes &lt;== yum-utils
yum makecache   # 载入本地源的元数据
</code></pre>
<p>如果系统中存在卸载残留的依赖包，可能导致新安装的包产生依赖冲突，因此需要执行<code>clean</code>命令。</p>
</li>
</ul>
<pre><code class="language-shell">yum install alien
alien -r &lt;package&gt;.deb
</code></pre>
<h4 id="桌面软件"><a class="header" href="#桌面软件">桌面软件</a></h4>
<h5 id="中文输入法"><a class="header" href="#中文输入法">中文输入法</a></h5>
<p>应用程序/系统工具/设置/区域和语言/输入源/（+号，汉语（中国））/添加 “汉语(Intelligent Pinyin)”</p>
<h5 id="坚果云"><a class="header" href="#坚果云">坚果云</a></h5>
<p>需要使用管理员权限从终端安装。</p>
<pre><code class="language-shell">rpm -ivh nutstore.rpm
</code></pre>
<h3 id="构建rpm软件包"><a class="header" href="#构建rpm软件包">构建RPM软件包</a></h3>
<p>安装RPM构建工具：</p>
<pre><code class="language-shell">yum install rpmdevtools
</code></pre>
<p>创建和编辑打包声明文件：</p>
<pre><code class="language-shell">rpmdev-setuptree # mkdir -pv ~/rpmbuild/{BUILD,RPMS,SOURCES,SPECS,SRPMS}
cd ~/rpmbuild/SPECS
rpmdev-newspec &lt;appname&gt;   # 生成&lt;appname&gt;.spec
</code></pre>
<h4 id="编写打包声明文件"><a class="header" href="#编写打包声明文件"><a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/html/rpm_packaging_guide/packaging-software#rpm-macros_rpm-packages">编写打包声明文件</a></a></h4>
<p>打包声明文件通过头部定义了包的元数据，并按阶段定义了打包、部署等过程。每个阶段以<code>%STAGE</code>声明开始，如果某个阶段无操作，则可省略该阶段的声明。</p>
<h5 id="声明元数据"><a class="header" href="#声明元数据">声明元数据</a></h5>
<div class="table-wrapper"><table><thead><tr><th>字段名称</th><th>说明</th></tr></thead><tbody>
<tr><td><code>Name</code></td><td>软件包名，也是打包声明文件名</td></tr>
<tr><td><code>Version</code></td><td>版本号：与上游源文件版本对应</td></tr>
<tr><td><code>Release</code></td><td>发行号：与系统发行号保持一致<code>1%{?dist}</code>根据需要==调整==</td></tr>
<tr><td><code>Summary</code></td><td>软件包的简要描述信息，详细信息在<code>%description</code>中</td></tr>
<tr><td><code>License</code></td><td>许可类型，如：<code>GPLv3+, Apache, BSD, MIT,...</code></td></tr>
<tr><td><code>URL</code></td><td>开发者的网站地址</td></tr>
<tr><td><code>Packager</code></td><td>软件包维护者信息</td></tr>
<tr><td><code>Group</code></td><td>软件分类，如<code>Development/IDE</code></td></tr>
<tr><td><code>Source0</code></td><td>源归档文件路径：位于编译目录<code>SOURCES</code>下或网络资源；<br/>可声明多个源<code>Source1,Source2,...</code></td></tr>
<tr><td><code>BuildArch</code></td><td>编译和打包输出的架构，如：<br/><code>noarch, x86_64, aarch64,...</code></td></tr>
<tr><td><code>Provides</code></td><td>软件安装后在目标系统中提供的项</td></tr>
<tr><td><code>AutoReqProv</code><br/><code>AutoReq</code><br/><code>AutoProv</code></td><td><code>yes</code>：自动发现软件包内容所需依赖和软件包提供内容；<code>no</code>禁用。<br />如果开启自动发现，还可设置<a href="https://docs.fedoraproject.org/en-US/packaging-guidelines/AutoProvidesAndRequiresFiltering/">过滤规则</a>。</td></tr>
<tr><td><code>Requires</code></td><td>软件安装时检查目标系统依赖项，可进一步指定安装和卸载阶段的脚本依赖，<br />例如：<code>Requires(pre)</code></td></tr>
<tr><td><code>BuildRequires</code></td><td>打包时检查当前系统的依赖项</td></tr>
<tr><td><code>Conflicts</code></td><td>软件安装时检查目标系统冲突项</td></tr>
</tbody></table>
</div>
<p>RPM包的名称由<code>Name-Version-Release</code>构成。</p>
<p>依赖和提供内容发现过滤规则（使用正则表达式）：</p>
<pre><code class="language-shell">%global __requires_exclude_from PATH_PATTERN  # 排除扫描文件
%global __provides_exclude_from PATH_PATTERN
%global __provides_exclude PATH_PATTERN  # 排除发现的结果
%global __requires_exclude PATH_PATTERN
%description
</code></pre>
<p>由于<code>rpmbuild</code>和正则表达式都会处理<code>\</code>转义序列，因此文件中对特殊符号转义需要使用<code>\\</code>（特别地，对<code>\</code>转义需要使用<code>\\\\</code>）。</p>
<h5 id="条件语句块"><a class="header" href="#条件语句块">条件语句块</a></h5>
<p>条件语句块可使用的命令包括：<code>%ifarch/ifnarch,%elifarch</code>、<code>%ifos/ifnos,%elifos</code>、<code>%if,%elif</code>，所有条件命令可附加<code>%else</code>，所有语句块以<code>%endif</code>结束。<code>%else, %endif</code>后不可包含其他文本。</p>
<pre><code class="language-shell">%ifarch s390 s390x
BuildRequires: s390utils-devel
%endif
%if %{defined with_foo} &amp;&amp; %{undefined with_bar}
%if &quot;%{optimize_flags}&quot; != &quot;none&quot;
%if 0%{?fedora} &gt; 10 || 0%{?rhel} &gt; 7
</code></pre>
<h5 id="打包-1"><a class="header" href="#打包-1">打包</a></h5>
<p>打包过程包括准备（<code>%prep</code>）、编译（<code>%build</code>）、封装（<code>%install</code>）、清理（<code>%clean</code>）和测试。</p>
<ul>
<li>
<p><code>%prep</code>：将<code>Source0</code>等定义的源归档文件（格式<code>.tar</code>、<code>.tar.gz</code>或<code>.tgz</code>等）释放到编译工作目录<code>%{_builddir}</code>（<code>rpmbuild/BUILD</code>），用于编译和封装。</p>
<p>该过程主要使用<code>%setup</code>指令定义源归档文件的释放行为，默认过程为：进入<strong>编译根目录</strong>，删除已有的软件包<strong>编译工作目录</strong>，释放源归档文件<code>Source0</code>，切换到软件包编译工作目录。</p>
<pre><code class="language-shell">cd /root/rpmbuild/BUILD   # %{_builddir}
rm -rf package-name-1.7.0
/usr/bin/tar -xvvf /root/rpmbuild/SOURCES/package-name-1.7.0.tar
cd package-name-1.7.0
</code></pre>
<p>该过程假定软件包编译工作目录（默认为<code>%{name}-%{version}</code>）和归档文件的根目录一致，否则上述释放过程完成后将无法切换到编译工作目录。解决该问题的两个途径：1) 打包源文件时保证根目录为上述默认值；2) 修改编译工作目录名<code>%setup -n build-name</code>，与归档文件根目录一致。</p>
<p>如果<code>Source0</code>没有唯一根目录，则首先使用<code>%setup -c</code>创建编译工作目录并切换到该目录下，使得<code>Source0</code>的所有内容释放到该目录下；<code>-c</code>可以和<code>-n</code>共同使用以创建指定的编译工作目录。</p>
<blockquote>
<pre><code class="language-shell">cd /root/rpmbuild/BUILD   # %setup -c -n build-name
rm -rf build-name
/usr/bin/mkdir -p build-name
cd build-name
/usr/bin/tar -xvvf /root/rpmbuild/SOURCES/package-name-1.7.0.tar
</code></pre>
</blockquote>
<p>对于有多个源档案文件存在的情况下，声明了<code>%setup</code>指令则默认自动根据指令释放<code>Source0</code>（添加<code>-T</code>选项禁止自动释放，除了第一条<code>%setup</code>指令外，其他都应该添加<code>-T</code>防止重复释放），其他源档案文件则需要添加额外<code>%setup</code>指令。</p>
<ul>
<li>
<p>如果<code>SourceN</code>的根目录与编译工作目录相同或者需要将<code>SourceN</code>置于编译工作目录同级（例如外部依赖项），则应该在进入编译工作目录前释放，因此指令为：<code>%setup -D -T -b N</code>。其中，<code>-D</code>防止删除前面已经释放的文件。</p>
<blockquote>
<pre><code class="language-shell">cd /root/rpmbuild/BUILD
# rm -rf package-name-1.7.0   # %setup -D
</code></pre>
</blockquote>
</li>
<li>
<p>如果<code>SourceN</code>是编译工作目录下的部分内容，则应该在进入编译工作目录后释放，因此指令为：<code>%setup -D -T -a N</code>。</p>
</li>
</ul>
<p><a href="https://rpm-packaging-guide.github.io/">使用<code>-q</code>减少释放过程中的输出信息</a>。</p>
</li>
<li>
<p><code>%build</code>：执行编译命令并输出编译结果到编译目录下。对于已经在外部编译完成的软件则跳过此阶段。</p>
</li>
<li>
<p><code>%install</code>：将准备和编译阶段生成的文件，根据需要添加到RPM包的根目录<code>%{buildroot}</code>（该目录模拟目标系统的根目录）。这些文件将在部署阶段被安装到目标系统中。</p>
</li>
<li>
<p><code>%clean</code>：编写命令，清理<code>rpmbuild</code>工作目录下释放的源文件以及编译输出文件（默认不清理，可为构建命令指定<code>--clean</code>选项，在完成打包后自动清理工作目录）；</p>
</li>
<li>
<p><code>%check</code>：编写命令测试RPM包。</p>
</li>
</ul>
<h5 id="部署软件包"><a class="header" href="#部署软件包">部署软件包</a></h5>
<p><a href="http://ftp.rpm.org/max-rpm/s1-rpm-inside-files-list-directives.html"><code>%files</code></a>：从RPM包的根目录下，复制指定文件/目录到目标系统上的相同位置并设置相应文件的属性；</p>
<ul>
<li><code>%attr(0744,root,root) /usr/local/bin/*</code>：安装并设置指定内容的属性（<code>744</code>对于用户具有读写和执行/访问权限，对于用户组或其他用户仅有读权限）；</li>
<li><code>defattr(644,apache,apache[,755])</code>：设置安装文件和目录的默认权限（无需设置则使用<code>-</code>代替）和所有者；相比于<code>attr</code>增加了目录权限设置参数（文件的执行劝降和目录的访问权限不相同）。</li>
<li><code>%license LICENSE</code>：安装并声明指定内容为许可文件；</li>
<li><code>%doc doc/*.html</code>：安装并声明指定内容为软件的文档；</li>
<li><code>%config(noreplace) %{_sysconfdir}/%{name}/%{name}.conf</code>：安装并声明指定内容为配置文件。如果配置文件在本地被修改过，且新旧版软件包中配置文件发生变更，则声明<code>noreplace</code>会将新版本的配置文件另存为<code>.rpmnew</code>；反之将修改过的本地文件另存为<code>.rpmsave</code>。如果新旧版软件包中配置文件未发生变更，则不会更新配置文件。对于未被<code>%config</code>声明的文件，将直接被覆盖。</li>
<li><code>/opt/appname</code>：将RPM中的其他指定内容安装到目标系统；注意RPM包提供的内容都需要通过<code>%files</code>声明（否则打包过程认为安装与打包不一致）。</li>
<li><code>%exlcude /path/file</code>：从已声明内容中排除文件，支持使用通配符。==即使后面再添加相应的文件声明，被排除内容也不会被安装==。</li>
</ul>
<p>推荐：**RPM仅包含普通文件构成的树形结构。**RPM包的安装过程经过<code>%files</code>声明的文件，能够被包管理器记录并实现自动卸载，RPM包也能检测到用户是否对这些文件进行过修改。</p>
<blockquote>
<p>如果RPM在安装过程中释放的文件未经声明（例如通过<code>%post</code>脚本释放压缩包或执行其中的程序产生新文件），那么包管理器在卸载软件时无法处理这些文件。除非能够由<code>%post</code>和<code>%postun</code>流程管理这些文件的清理，否则不应该包含这些内容。由于第三方安装包的释放内容往往难以确定，如果这些包没有相应的卸载方法，则不应该在安装过程中调用，否则无法在卸载阶段完成该包的清理工作。</p>
</blockquote>
<p>问题：</p>
<ul>
<li><code>rpmbuild warning file listed twice</code>：通常需要声明整个目录作为安装内容，并且详细指定其中部分内容的权限、类型等，因此导致部分内容被重复声明。此告警信息只是提示作用，对打包结果无影响。</li>
</ul>
<h5 id="安装和卸载脚本"><a class="header" href="#安装和卸载脚本">安装和卸载脚本</a></h5>
<p>安装和卸载脚本用于对系统进行配置和清理，按过程按顺序分为以下阶段，每个阶段包含一段Shell脚本<sup class="footnote-reference"><a href="#rpm-scriplets">1</a></sup>。</p>
<p>安装软件包前（几乎没有软件包安装需要在安装前进行配置）：<code>%pretrans</code>、<code>%triggerprein</code>、<code>%pre</code><sup class="footnote-reference"><a href="#rpm-scripts">2</a></sup>。</p>
<p>安装软件包后：</p>
<ul>
<li><code>%post</code>：RPM包中数据复制完成后执行的命令（例如启动服务、动态生成配置文件等）；该环境下仅加载系统基本的环境变量，需要手动定义环境变量或导入相应的脚本。通常<code>%postun</code>与之成对出现，以保证清理安装内容，恢复安装前的系统配置和状态。</li>
<li><code>%triggerin</code>：如果该软件包触发安装依赖包，则首先执行依赖包的对应脚本。</li>
</ul>
<p>卸载软件包前：</p>
<ul>
<li><code>%triggerun</code>：如果卸载<strong>旧版本</strong>软件包触发卸载依赖包，则首先执行当前软件包的对应脚本。</li>
<li><code>%preun</code>：卸载<strong>旧版本</strong>软件包前的处理。</li>
</ul>
<p>卸载软件包后：</p>
<ul>
<li><code>%postun</code>：<a href="https://opensource.com/article/18/9/how-build-rpm-packages">卸载<strong>旧版本</strong>软件时清理<code>%post</code>阶段产生的文件</a>，<code>%files</code>阶段安装的文件将在卸载时自动删除。</li>
<li><code>%triggerpostun</code>：如果卸载<strong>旧版本</strong>软件包触发卸载依赖包，则首先执行当前软件包的对应脚本。</li>
<li><code>%postrans</code>：</li>
</ul>
<p>脚本通过传入参数<code>$1</code>判断是<strong>安装</strong>、<strong>升级</strong>或卸载：</p>
<div class="table-wrapper"><table><thead><tr><th>stage</th><th>install</th><th>upgrade</th><th>uninstall</th></tr></thead><tbody>
<tr><td><code>%pretrans</code></td><td><code>$1 == 1</code></td><td><code>$1 -gt 1</code></td><td>(N/A)</td></tr>
<tr><td><code>%pre</code></td><td><code>$1 == 1</code></td><td><code>$1 -gt 1</code></td><td>(N/A)</td></tr>
<tr><td><code>%post</code></td><td><code>$1 == 1</code></td><td><code>$1 -gt 1</code></td><td>(N/A)</td></tr>
<tr><td><code>%preun</code></td><td>(N/A)</td><td><code>$1 == 1</code></td><td><code>$1 == 0</code></td></tr>
<tr><td><code>%postun</code></td><td>(N/A)</td><td><code>$1 == 1</code></td><td><code>$1 == 0</code></td></tr>
<tr><td><code>%posttrans</code></td><td><code>$1 == 1</code></td><td><code>$1 == 1</code></td><td>(N/A)</td></tr>
</tbody></table>
</div>
<p>脚本的最后命令退出状态如果非0，则后续阶段不会执行。因此除非是严重错误导致安装无法继续，应该在每个脚本最后添加<code>exit 0</code>。</p>
<blockquote>
<ul>
<li><a href="https://docs.fedoraproject.org/en-US/packaging-guidelines/Scriptlets/#_saving_state_between_scriptlets">Saving state between scriptlets</a>.</li>
<li><a href="https://docs.fedoraproject.org/en-US/packaging-guidelines/Scriptlets/#_systemd">Systemd services</a>.</li>
<li><a href="https://docs.fedoraproject.org/en-US/packaging-guidelines/UsersAndGroups/">Users and Groups Guidelines</a>.</li>
</ul>
</blockquote>
<p><strong>其他</strong></p>
<ul>
<li>
<p><code>%description</code>：完整的RPM包描述信息文本。</p>
</li>
<li>
<p><code>%changelog</code>：RPM包的变更记录。每条记录第一行（以<code>*</code>开头）为变更记录的元数据，包括日期、作者、邮箱、和版本号，后续为变更信息列表（以<code>-</code>开头）。</p>
<pre><code class="language-shell">%changelog
* Tue May 31 2016 Adam Miller &lt;maxamillion@fedoraproject.org&gt; - 0.1-1
- First bello package
- Example second item in the changelog for version-release 0.1-1
</code></pre>
</li>
</ul>
<h4 id="在声明文件中使用宏变量"><a class="header" href="#在声明文件中使用宏变量">在声明文件中使用宏变量</a></h4>
<p>使用<a href="https://docs.fedoraproject.org/en-US/packaging-guidelines/RPMMacros/">宏变量</a>可替代声明文件中的配置信息，从而保证文件中使用配置的一致性。</p>
<p>宏变量包括：</p>
<ul>
<li>
<p><strong>预定义</strong>：使用<code>rpm</code>或<code>rpmbuild</code>命令时，通过<code>--define</code>选项定义宏变量。</p>
<pre><code class="language-shell">rpm --define &quot;MACRO some_value&quot; --eval %{MACRO}
</code></pre>
<p><code>rpmbuild</code>命令在解析声明文件时会使用宏变量进行替换。</p>
</li>
<li>
<p><strong>基于配置文件元数据</strong>：声明文件中的元数据，如<code>Name, Version, Release</code>等，会生成对应元数据名的小写形式（<code>name,version,release...</code>）的宏变量及对应的环境变量（<code>RPM_PACKAGE_NAME, RPM_PACKAGE_VERSION, RPM_PACKAGE_RELEASE</code>），可在后续声明中使用。</p>
</li>
<li>
<p><strong>内置宏变量</strong>：关于打包过程的环境变量：</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">macro</th><th>env</th><th style="text-align: left">definition</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>%{_buildrootdir}</code></td><td></td><td style="text-align: left"><code>%{_topdir}/BUILDROOT</code></td></tr>
<tr><td style="text-align: left"><code>%{buildroot}</code></td><td><code>$RPM_BUILD_ROOT</code><br/><em><code>$RPM_ROOT_DIR</code></em></td><td style="text-align: left"><code>%{_buildrootdir}/%{name}-%{version}-%{release}.%{_arch}</code></td></tr>
<tr><td style="text-align: left"><code>%{_topdir}</code></td><td></td><td style="text-align: left"><code>%{getenv:HOME}/rpmbuild</code></td></tr>
<tr><td style="text-align: left"><code>%{_builddir}</code></td><td><code>$RPM_BUILD_DIR</code></td><td style="text-align: left"><code>%{_topdir}/BUILD</code></td></tr>
<tr><td style="text-align: left"><code>%{_rpmdir}</code></td><td></td><td style="text-align: left"><code>%{_topdir}/RPMS</code></td></tr>
<tr><td style="text-align: left"><code>%{_sourcedir}</code></td><td><code>$RPM_SOURCE_DIR</code></td><td style="text-align: left"><code>%{_topdir}/SOURCES</code></td></tr>
<tr><td style="text-align: left"><code>%{_specdir}</code></td><td></td><td style="text-align: left"><code>%{_topdir}/SPECS</code></td></tr>
<tr><td style="text-align: left"><code>%{_srcrpmdir}</code></td><td></td><td style="text-align: left"><code>%{_topdir}/SRPMS</code></td></tr>
</tbody></table>
</div>
<p>关于路径的宏变量：</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">macro</th><th style="text-align: left">definition</th><th style="text-align: left">default</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>%{_sysconfdir}</code></td><td style="text-align: left"><code>/etc</code></td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left"><code>%{_prefix}</code></td><td style="text-align: left"><code>/usr</code></td><td style="text-align: left"><code>/app</code> for flatpak builds</td></tr>
<tr><td style="text-align: left"><code>%{_exec_prefix}</code></td><td style="text-align: left"><code>%{_prefix}</code></td><td style="text-align: left"><code>/usr</code></td></tr>
<tr><td style="text-align: left"><code>%{_includedir}</code></td><td style="text-align: left"><code>%{_prefix}/include</code></td><td style="text-align: left"><code>/usr/include</code></td></tr>
<tr><td style="text-align: left"><code>%{_bindir}</code></td><td style="text-align: left"><code>%{_exec_prefix}/bin</code></td><td style="text-align: left"><code>/usr/bin</code></td></tr>
<tr><td style="text-align: left"><code>%{_libdir}</code></td><td style="text-align: left"><code>%{_exec_prefix}/%{_lib}</code></td><td style="text-align: left"><code>/usr/%{_lib}</code></td></tr>
<tr><td style="text-align: left"><code>%{_libexecdir}</code></td><td style="text-align: left"><code>%{_exec_prefix}/libexec</code></td><td style="text-align: left"><code>/usr/libexec</code></td></tr>
<tr><td style="text-align: left"><code>%{_sbindir}</code></td><td style="text-align: left"><code>%{_exec_prefix}/sbin</code></td><td style="text-align: left"><code>/usr/sbin</code></td></tr>
<tr><td style="text-align: left"><code>%{_datarootdir}</code></td><td style="text-align: left"><code>%{_prefix}/share</code></td><td style="text-align: left"><code>/usr/share</code></td></tr>
<tr><td style="text-align: left"><code>%{_datadir}</code></td><td style="text-align: left"><code>%{_datarootdir}</code></td><td style="text-align: left"><code>/usr/share</code></td></tr>
<tr><td style="text-align: left"><code>%{_infodir}</code></td><td style="text-align: left"><code>%{_datarootdir}/info</code></td><td style="text-align: left"><code>/usr/share/info</code></td></tr>
<tr><td style="text-align: left"><code>%{_mandir}</code></td><td style="text-align: left"><code>%{_datarootdir}/man</code></td><td style="text-align: left"><code>/usr/share/man</code></td></tr>
<tr><td style="text-align: left"><code>%{_docdir}</code></td><td style="text-align: left"><code>%{_datadir}/doc</code></td><td style="text-align: left"><code>/usr/share/doc</code></td></tr>
<tr><td style="text-align: left"><code>%{_rundir}</code></td><td style="text-align: left"><code>/run</code></td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left"><code>%{_localstatedir}</code></td><td style="text-align: left"><code>/var</code></td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left"><code>%{_sharedstatedir}</code></td><td style="text-align: left"><code>/var/lib</code></td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left"><code>%{_lib}</code></td><td style="text-align: left"><code>/lib64</code></td><td style="text-align: left"><code>/lib</code> on 32bit platforms</td></tr>
<tr><td style="text-align: left"><code>%{_tmppath}</code></td><td style="text-align: left"><code>%{_var}/tmp</code></td><td style="text-align: left"><code>/var/tmp</code></td></tr>
</tbody></table>
</div></li>
</ul>
<h4 id="打包方法"><a class="header" href="#打包方法">打包方法</a></h4>
<p><a href="http://ftp.rpm.org/max-rpm/ch-rpm-b-command.html">执行编译和打包</a>：</p>
<pre><code class="language-shell">rpmbuild -b[bas] \
  --clean \                            # 清理构建路径
  --sign  \                            # 添加数字签名using PGP
  --buildroot &lt;buildroot&gt; \            # 在&lt;buildroot&gt;执行%install定义的命令
  --buildarch &lt;arch&gt; \                 # override BuildArch
  --define &quot;_topdir $(pwd)/rpmbuild&quot; \ # 指定工作目录
  &lt;appname&gt;.spec
# Output =&gt; {Name}-{Version}-{Release}.rpm
</code></pre>
<p><code>rpmdev-setuptree</code>在用户主目录下创建工作目录，如果要在其他位置进行打包，将创建的目录移动到其他位置，同时在打包命令中指定<code>&quot;_topdir&quot;</code>或在打包声明文件中指定<code>%_topdir </code>的值。</p>
<p><code>-b</code>选项的值限定打包过程所执行的阶段，在编写声明文件时，可根据情况选择执行阶段，从而加快测试打包过程。</p>
<ul>
<li>
<p><code>p</code>：<code>%prep</code>；</p>
</li>
<li>
<p><code>c</code>：<code>%prep, %build</code>；</p>
<p>仅显示执行过程，移除命令输出，方便调试打包过程：</p>
<pre><code class="language-shell">rpmbuild -bc --define &quot;_topdir $(pwd)/rpmbuild&quot; \
         rpmbuild/SPECS/package-name.spec | grep -E &quot;^(\+|E)&quot;
</code></pre>
</li>
<li>
<p><code>i</code>：<code>%prep, %build, %install, %check</code>，不打包；</p>
</li>
<li>
<p><code>b</code>：<code>%prep, %build, %install, %check</code>，打包可执行程序；</p>
</li>
<li>
<p><code>a</code>：<code>%prep, %build, %install, %check</code>，打包可执行程序和源代码；</p>
</li>
</ul>
<h5 id="打包过程中的自动编译"><a class="header" href="#打包过程中的自动编译">打包过程中的自动编译</a></h5>
<p>在<code>%install</code>结束阶段，打包工具会检查安装内容，对于某些可编译内容（如Python脚本），打包工具默认会自动调用编译工具进行编译。可在该阶段的定义中显式声明<code>exit 0</code>以结束该阶段从而禁用后续的自动检查和编译。如果开启该功能，则需要设置正确的编译工具（防止利用系统默认工具或找不到相应工具）。</p>
<pre><code class="language-shell">/usr/bin/rpmbuild -bb --define &quot;_python_override ${PYTHON_PATH}&quot;  # build commmand
%define __python %{_python_override}/python   # in sepcfile
</code></pre>
<h5 id="软件包内容"><a class="header" href="#软件包内容">软件包内容</a></h5>
<blockquote>
<p>RPM package consists of the <code>cpio</code> archive. The files in <code>buildroot</code> are later put into a <code>cpio</code> archive, which becomes the main part of the RPM. When RPM is installed on the end user’s system, these files are extracted in the <code>root</code> directory, preserving the correct hierarchy.</p>
</blockquote>
<p>查看软件包内容：</p>
<pre><code class="language-shell">rpm -qlpv &lt;pakagename&gt;.rpm  # contents of package file
</code></pre>
<blockquote>
<p><code>v</code>列出文件属性，不指定则只列出文件名。</p>
</blockquote>
<p>提取软件包内容：</p>
<pre><code class="language-shell">rpm2cpio ./&lt;packagename&gt;.rpm | cpio -idmv
</code></pre>
<blockquote>
<p><code>-i</code> extract the files from the archive,
<code>-d</code> create the leading directories where needed, 
<code>-m</code> preserve the file modification times when creating files.
<code>-v</code> (verbose) list the files processed.</p>
</blockquote>
<p><a href="https://blog.packagecloud.io/eng/2015/10/13/inspect-extract-contents-rpm-packages/">Inspecting and extracting RPM package contents - Packagecloud Blog</a></p>
<h5 id="跨平台打包"><a class="header" href="#跨平台打包">跨平台打包</a></h5>
<p>问题：<a href="https://utcc.utoronto.ca/%7Ecks/space/blog/linux/RPMCrossBuildIssues">Why building RPMs for a different architecture is a hard problem</a>。</p>
<h3 id="防火墙配置"><a class="header" href="#防火墙配置">防火墙配置</a></h3>
<p>Fedora/CentOS使用<code>firewalld</code>/<code>firewall-cmd</code>作为防火墙应用程序，其中<code>firewall-cmd</code>为用户接口，<code>firewalld</code>与内核（<code>netfilter</code>）交互。</p>
<img src="Linux/Linux发行版.assets/image-20210524125029766.png" alt="image-20210524125029766" style="zoom: 40%;" />
<h5 id="防火墙运行管理"><a class="header" href="#防火墙运行管理">防火墙运行管理</a></h5>
<p><code>firewalld</code>作为系统服务，由<code>systemd</code>托管，使用<code>systemctl</code>进行管理。</p>
<pre><code class="language-shell">firewall-cmd --state           # firewalld的状态==&gt;systemctl status firewalld
firewall-cmd --reload          # 不中断服务的重新加载，更新防火墙规则
firewall-cmd --complete-reload # 中断所有连接的重新加载
firewall-cmd --runtime-to-permanent  # 将当前防火墙的规则永久保存
firewall-cmd --check-config          # 检查配置正确性
</code></pre>
<p>选项：</p>
<p><code>--permanent</code>：使规则永久生效（当前并未生效，须适用<code>--reload</code>命令重新加载规则）；反之，防火墙重新加载后规则失效（适用<code>--runtime-to-permanent</code>命令保存）。某些非定义规则的命令必须使用<code>--permanent</code>。</p>
<h4 id="预定义信息"><a class="header" href="#预定义信息">预定义信息</a></h4>
<h5 id="区域"><a class="header" href="#区域">区域</a></h5>
<p>区域是==防火墙控制范围的逻辑划分==，可将本机的网络接口、远程的IP地址等绑定到区域（<code>--add-interface, --add-source</code>），==其相关流量控制由相应区域的规则决定==。未绑定区域的网络实体的控制逻辑由默认(<code>active</code>)区域中的规则确定。区域信息由<code>NetworkManager </code>管理，而非<code>firewalld</code>。</p>
<blockquote>
<p><em>==Zones are predefined sets of rules==. Network interfaces and sources can be assigned to a zone.</em></p>
</blockquote>
<pre><code class="language-shell">firewall-cmd --get-zones                    # 查看支持的区域
firewall-cmd --get-active-zones             # 查看区域信息
</code></pre>
<p>预定义的区域（存储于<code>/usr/lib/firewalld/zones/</code>）及其默认配置：</p>
<ul>
<li><code>drop</code>：拒绝所有外来请求，没有通知消息；</li>
<li><code>block</code>：拒绝所有外部链接请求并发送ICMP消息，仅允许系统内部发起的连接；</li>
<li><code>dmz</code>：<em>Only selected incoming connections are accepted.</em></li>
<li><code>external</code>：<em>do not trust others on the network. external networks with masquerading enabled, especially for routers. Only selected incoming connections are accepted.</em></li>
<li><code>public</code>：<em>do not trust others on the network. Only selected incoming connections are accepted.</em></li>
<li><code>home,internal,work</code>：<em>mostly trust the others on the network. Only selected incoming connections are accepted.</em></li>
<li><code>trusted</code>：允许所有连接。</li>
</ul>
<blockquote>
<p>其他区域：<code>FedoraServer, FedoraWorkstation,nm-shared, libvirt</code>。可使用<code>--new-zone,--new-zone-from-file,--delete-zone</code>自定义区域。</p>
</blockquote>
<p>区域设置和地址绑定：</p>
<pre><code class="language-shell">firewall-cmd --set-default-zone=&lt;ZoneName&gt;  # 设置默认区域=&gt;get-default-zone
firewall-cmd --zone=&lt;ZoneName&gt; --add-interface=eth0       # 绑定本机网络接口
firewall-cmd --zone=&lt;ZoneName&gt; --change-interface=enp03s  # 修改接口所属区域
firewall-cmd --zone=&lt;ZoneName&gt; \         # 绑定源地址到区域=&gt;--remove-source
             --add-source=&lt;source&gt;[/&lt;mask&gt;]|&lt;MAC&gt;|ipset:&lt;ipset&gt; 
firewall-cmd --get-zone-of-interface=enp1s0 # 查看指定接口所属区域
</code></pre>
<p>未指定区域则命令的目标为默认区域。</p>
<h5 id="地址集合ipset"><a class="header" href="#地址集合ipset">地址集合（IPSet）</a></h5>
<p>获取地址集合以及预定义的类型：</p>
<pre><code class="language-shell">firewall-cmd --get-ipsets
sudo firewall-cmd --get-ipset-types
</code></pre>
<p>定义地址集合（必须重启才能生效）：</p>
<pre><code class="language-shell">firewall-cmd --permanent --new-ipset=local --type=hash:net # MUST --permanent
firewall-cmd --permanent --ipset=local --add-entry=172.28.76.41 # =&gt; 192.168.1.0/24
# --add-entries-from-file, --remove-entries-from-file, --remove-entry
firewall-cmd --reload  # 需重新加载才生效
</code></pre>
<blockquote>
<p><code>--add-entry</code>：如果定义的<code>ipset</code>还未加载，则必须添加<code>--permanent</code>选项，否则无法在当前加载信息中找到相应的<code>ipset</code>。</p>
</blockquote>
<p>获取IP地址集合的信息：</p>
<pre><code class="language-shell">firewall-cmd --info-ipset=local
firewall-cmd --ipset=local --get-entries  # 仅返回地址
</code></pre>
<h5 id="服务-2"><a class="header" href="#服务-2">服务</a></h5>
<p>自定义服务：</p>
<pre><code class="language-shell">firewall-cmd --new-service=ssh     # 创建新的服务/--new-service-from-file
firewall-cmd --delete-service=ssh  # 删除定义的服务
firewall-cmd --service=&lt;service&gt; \
             --set-short         \ # 设置服务信息/--get-short
             --set-description   \
             --add-port=1024[-10000]/tcp  # --query-port, --remove-port
firewall-cmd --get-services       # 显示已定义的服务,已内置标准服务。
firewall-cmd --info-service=ssh
firewall-cmd --path-service=ssh   # 显示ssh配置文件的路径
</code></pre>
<h4 id="防火墙规则"><a class="header" href="#防火墙规则">防火墙规则</a></h4>
<p>查看防火墙规则：防火墙规则是关联到区域的。</p>
<pre><code class="language-shell">firewall-cmd --zone=public \  # 默认为active的区域
             --list-ports \   # 查看打开的端口
             --list-all       # 所有信息
firewall-cmd --list-all-zones 
</code></pre>
<h5 id="基于端口的规则"><a class="header" href="#基于端口的规则">基于端口的规则</a></h5>
<pre><code class="language-shell">firewall-cmd --permanent --zone=&lt;zone&gt; \
             --add-port=8080/tcp \ # protocl=&lt;tcp|udp|sctp|dccp&gt;
             --remove-port=8080/tcp \
             --add-source-port=10000-65535 \ # --remove-source-port
             --set-target=&lt;target&gt;           # 防火墙动作(默认为accept)
</code></pre>
<blockquote>
<p><code>--timeout=600</code>：临时设置规则，时限到后规则失效。<code>target</code>表示匹配规则后防火墙的<a href="Linux/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.html#%E5%8A%A8%E4%BD%9C%EF%BC%88target%EF%BC%89">动作</a>。</p>
</blockquote>
<p>基于服务的规则：</p>
<pre><code class="language-shell">firewall-cmd --add-service=smtp   # 将服务添加到允许列表
             --remove-service=smtp
firewall-cmd --list-services      # 显示允许访问的服务
</code></pre>
<h5 id="复杂规则"><a class="header" href="#复杂规则">复杂规则</a></h5>
<p>规则中的条件包含了：协议族、地址、端口和传输层协议等。</p>
<pre><code class="language-shell">firewall-cmd --add-rich-rule='rule family=ipv4 source ipset=local port port=8501-9000 protocol=tcp accept'
firewall-cmd --direct -add-rule \ # 直接模式：使用iptables语法
   ipv4 filter INPUT 0 -p tcp --dport 9000 -j ACCEPT  
</code></pre>
<h5 id="端口转发"><a class="header" href="#端口转发"><a href="Linux/Linux%E9%85%8D%E7%BD%AE%E5%92%8C%E7%AE%A1%E7%90%86.html#%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91">端口转发</a></a></h5>
<pre><code class="language-shell">firewall-cmd --add-forward-port=\                       # --query-forward
	port=80:proto=tcp[:toaddr=192.168.0.1][:toport=8080] # --remove-forward
</code></pre>
<p>默认规则：</p>
<pre><code class="language-shell">firewall-cmd --panic-on     # 拒绝所有包
firewall-cmd --panic-off    # 取消拒绝状态
firewall-cmd --query-panic  # 查看是否默认拒绝
</code></pre>
<h5 id="防火墙日志"><a class="header" href="#防火墙日志">防火墙日志</a></h5>
<pre><code class="language-shell">firewall-cmd --get-log-denied  # 获取记录被拒绝的日志
</code></pre>
<p>https://www.tecmint.com/start-stop-disable-enable-firewalld-iptables-firewall/</p>
<p><a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/html/security_guide/sec-setting_and_controlling_ip_sets_using_firewalld">5.12. Setting and Controlling IP sets using firewalld Red Hat Enterprise Linux 7 | Red Hat Customer Portal</a></p>
<p><a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/html/security_guide/sec-viewing_current_status_and_settings_of_firewalld">5.3. Viewing the Current Status and Settings of firewalld Red Hat Enterprise Linux 7 | Red Hat Customer Portal</a></p>
<p><a href="https://www.liquidweb.com/kb/an-introduction-to-firewalld/">Firewalld Cheat Sheet | Liquid Web Knowledge Base</a></p>
<p><a href="https://ipset.netfilter.org/features.html">IP sets (netfilter.org)</a></p>
<p><a href="https://jingyan.baidu.com/article/f96699bb7adf11c94f3c1b4b.html">CentOS7忘记root密码</a></p>
<h2 id="wsl"><a class="header" href="#wsl">WSL</a></h2>
<p><a href="Linux/../%E6%9C%8D%E5%8A%A1%E5%99%A8/%E8%99%9A%E6%8B%9F%E5%8C%96.html#Window_Sub-system_of_Linux" title="WSL">WSL</a>是基于Windows Hype-V虚拟化技术的Linux发行版。</p>
<h2 id="参考资料-5"><a class="header" href="#参考资料-5">参考资料</a></h2>
<ol>
<li><a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/">Product Documentation for Red Hat Enterprise Linux 7 - Red Hat Customer Portal</a>
<ul>
<li><a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/html/security_guide/sec-using_firewalls#sec-Getting_started_with_firewalld">Chapter 5. Using Firewalls Red Hat Enterprise Linux 7 | Red Hat Customer Portal</a></li>
</ul>
</li>
</ol>
<div class="footnote-definition" id="ubuntu-release"><sup class="footnote-definition-label">3</sup>
<p><a href="https://ubuntu.com/about/release-cycle">Ubuntu release cycle | Ubuntu</a>
<sup class="footnote-reference"><a href="#rpm-scriplets">1</a></sup>: <a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/html/rpm_packaging_guide/advanced-topics#epoch-scriplets-and-triggers_advanced-topics">Epoch, Scriptlets and Triggers, Red Hat Enterprise Linux 7 RPM Packaging Guide</a>.
<sup class="footnote-reference"><a href="#rpm-scripts">2</a></sup>: <a href="https://ftp.osuosl.org/pub/rpm/max-rpm/s1-rpm-inside-scripts.html#S3-RPM-INSIDE-PRE-SCRIPT">Scripts: RPM's Workhorse, <strong>Maximum RPM: Taking the RPM Package Manager to the Limit</strong>, Chapter 13. Inside the Spec File</a>.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="操作系统原理"><a class="header" href="#操作系统原理">操作系统原理</a></h1>
<h2 id="存储设备"><a class="header" href="#存储设备">存储设备</a></h2>
<h3 id="磁盘分区-1"><a class="header" href="#磁盘分区-1">磁盘分区</a></h3>
<p>MBR最多有四个主分区，使用扩展分区和逻辑分区最多可以划分15个分区，单个分区最大2TB。 </p>
<p>GPT是UEFI标准的一部分，最多提供128个分区，使用GUID来识别每个磁盘和分区。与MBR存在单一故障 点不同，GPT 提供分区表信息的冗余。主GPT位于磁盘头部，而备份副本(次要GPT)位于磁盘尾部。GPT 使用校验和来检测GPT头和分区表中的错误与损坏。</p>
<h3 id="磁盘阵列"><a class="header" href="#磁盘阵列">磁盘阵列</a></h3>
<p>RAID 0：<em>breaking up data into chunks and striping it across the available disks. This means that each disk contains a portion of the data and that multiple disks will be referenced when retrieving information.</em></p>
<p>RAID 1：<em>mirroring data across all available disks.</em></p>
<p>RAID 5：<code>N</code> strips + <code>1</code> parity</p>
<p>RAID 6：<code>N</code> strips + <code>2</code> parity</p>
<p>RAID10：RAID 0 + RAID 1</p>
<h3 id="文件系统-6"><a class="header" href="#文件系统-6">文件系统</a></h3>
<h4 id="文件系统类型"><a class="header" href="#文件系统类型">文件系统类型</a></h4>
<h5 id="vfat"><a class="header" href="#vfat">vfat</a></h5>
<h5 id="ext4"><a class="header" href="#ext4">ext4</a></h5>
<h5 id="btrfs"><a class="header" href="#btrfs">btrfs</a></h5>
<h5 id="xfs"><a class="header" href="#xfs">xfs</a></h5>
<p>无法调整已有分区。</p>
<h5 id="tmpfs"><a class="header" href="#tmpfs">tmpfs</a></h5>
<p>https://www.kernel.org/doc/html/latest/filesystems/tmpfs.html</p>
<h5 id="devtmpfs"><a class="header" href="#devtmpfs">devtmpfs</a></h5>
<h4 id="linux目录树"><a class="header" href="#linux目录树">Linux目录树</a></h4>
<div class="table-wrapper"><table><thead><tr><th>目录</th><th>简介</th><th>用途</th></tr></thead><tbody>
<tr><td><code>/home</code></td><td>用户主目录</td><td>用户个人文件、用户配置文件</td></tr>
<tr><td><code>/root</code></td><td>超级管理员目录</td><td>保留</td></tr>
<tr><td><code>/usr</code></td><td>系统资源</td><td><strong>U</strong>nix <strong>S</strong>ystem <strong>R</strong>esources</td></tr>
<tr><td><code>/usr/bin</code></td><td><strong>binary</strong></td><td>可执行程序（<code>/bin</code>）</td></tr>
<tr><td><code>/usr/sbin</code></td><td><strong>system binary</strong></td><td>系统配置、维护和管理相关可执行程序<br />（<code>/sbin</code>）</td></tr>
<tr><td><code>/usr/lib[xx]</code></td><td><strong>library</strong></td><td>库文件（<code>/lib[xx]</code>），<br/><code>/bin</code>和<code>/sbin</code>中的可执行程序共享的库文件</td></tr>
<tr><td><code>/usr/local</code></td><td></td><td>==自编译或第三方程序==</td></tr>
<tr><td><code>/usr/src</code></td><td></td><td>内核源代码、头文件和文档</td></tr>
<tr><td><code>/usr/include</code></td><td></td><td>用于编译用户空间源代码的头文件</td></tr>
<tr><td><code>/usr/share</code></td><td></td><td>与系统架构无关的共享文件</td></tr>
<tr><td><code>/opt</code></td><td><strong>optional</strong></td><td>==第三方系统软件==</td></tr>
<tr><td><code>/etc</code></td><td></td><td>系统范围配置文件</td></tr>
<tr><td><code>/media</code></td><td></td><td>自动挂载的外部可移动设备（取代<code>/cdrom</code>）</td></tr>
<tr><td><code>/mnt</code></td><td><strong>mount</strong></td><td>手动挂载外部设备的位置</td></tr>
<tr><td><code>/dev</code></td><td><strong>device</strong></td><td>通过其中的文件访问设备</td></tr>
<tr><td><code>/dev/sda</code></td><td></td><td>硬盘</td></tr>
<tr><td><code>/dev/sda1</code></td><td></td><td>硬盘分区</td></tr>
<tr><td><code>/dev/lp0</code></td><td></td><td>打印机</td></tr>
<tr><td><code>/dev/mem</code></td><td></td><td>内存</td></tr>
<tr><td><code>/dev/tty</code></td><td></td><td>终端</td></tr>
<tr><td><code>/boot</code></td><td><strong>boot loader</strong></td><td><code>vmlinuz, grub</code></td></tr>
<tr><td><code>/sys</code></td><td></td><td>与内核交互的虚拟文件系统；系统与组件信息</td></tr>
<tr><td><code>/proc</code></td><td><strong>process</strong></td><td>虚拟文件系统：系统进程和资源信息</td></tr>
<tr><td><code>/run</code></td><td></td><td>系统启动早期守护进程的运行数据</td></tr>
<tr><td><code>/srv</code></td><td><strong>service</strong></td><td>服务数据</td></tr>
<tr><td><code>/var</code></td><td><strong>variables</strong></td><td>系统运行时可变数据，例如系统日志、缓存、临时文件</td></tr>
<tr><td><code>/var/log</code></td><td></td><td>系统和应用日志</td></tr>
<tr><td><code>/tmp</code></td><td><strong>temporary</strong></td><td>临时文件（重启系统时清空）</td></tr>
<tr><td><code>/snap</code></td><td><strong>snap packages</strong>*</td><td></td></tr>
</tbody></table>
</div>
<blockquote>
<p>*：<em>snap packages do not depend on any other packages, dependencies, or libraries. They are bundled with everything they need for proper functioning, and completely isolated from the rest of the system.</em></p>
</blockquote>
<p><a href="https://medium.com/swlh/linux-file-system-101-894141449257">Linux File System 101. Linux file system follows a tree-like… | by Saeed Mohajeryami | The Startup | Medium</a></p>
<p>单独挂载分区到某些目录：<a href="https://unix.stackexchange.com/questions/685/why-put-things-other-than-home-to-a-separate-partition/812">linux - Why put things other than /home to a separate partition? - Unix &amp; Linux Stack Exchange</a></p>
<h3 id="权限"><a class="header" href="#权限">权限</a></h3>
<p>文件可以设置三种权限：</p>
<ol>
<li>
<p>读(<code>r</code>)权限：可读取文件的内容；对于目录则是列举其中的内容；</p>
</li>
<li>
<p>写(<code>w</code>)权限：可修改文件的内容；对于目录则是创建或删除其中的文件；</p>
</li>
<li>
<p>执行(<code>x</code>)权限：对普通文件，文件内容可被装入内存直接运行或逐条解释执行；对于目录，则是可以读其中文件。</p>
</li>
</ol>
<p>文件的用户分为三组：<code>owner</code>（所有者）、<code>group</code>（文件所在的用户组中的其他用户）、其他用户。文件在创建时被给定所有者（通常是当前用户）和用户组（文件所在的目录的用户组）；每组中都包含了<code>rwx</code>三种权限声明。不同的文件系统还可能具有其他一些权限，例如ACL，可压缩，可修改等。</p>
<h4 id="权限描述"><a class="header" href="#权限描述">权限描述</a></h4>
<p>新创建的文件及目录的缺省权限<code>umask</code>分别为：</p>
<ul>
<li>
<p>文件：<code>-rw-r--r-- 644</code>；</p>
</li>
<li>
<p>目录：<code>drwxr-xr-x 755</code>；</p>
</li>
</ul>
<h2 id="操作系统的启动"><a class="header" href="#操作系统的启动">操作系统的启动</a></h2>
<p>操作系统的启动分为两个阶段：</p>
<ul>
<li><strong>引导</strong>阶段开始于打开电源开关，结束于内核初始化完成和 <code>systemd</code>进程成功运行。</li>
<li><strong>启动</strong>阶段接管剩余工作，直到操作系统进入可操作状态。</li>
</ul>
<h3 id="引导boot"><a class="header" href="#引导boot">引导（boot）</a></h3>
<ol>
<li>
<p>BIOS上电自检：检验电脑硬件基本功能是否正常。</p>
<p>自检成功后，BIOS产生一个中断<code>INT 13H</code>，指向某个接入的可引导设备的引导扇区。它所找到的包含有效的引导记录（主引导记录，MBR）的第一个引导扇区将被装载到内存中，并且<strong>控制权也将从BIOS转移到引导扇区代码</strong>。</p>
<p>引导扇区是引导加载器的第一阶段。大多数 Linux 发行版本使用的引导加载器有三种：GRUB、GRUB2 和 LILO。GRUB2 是最新的，也是相对于其他老的同类程序使用最广泛的。</p>
</li>
<li>
<p>GRUB2（GRand Unified BootLoader，Version 2）</p>
<p>寻找操作系统内核并加载其到内存的程序。</p>
<ul>
<li>
<p>阶段1：执行引导代码（引导镜像，<code>boot.img</code>）。</p>
<p>引导代码必须非常小，因为它必须连同<strong>分区表</strong>放到硬盘的第一个 512 字节的扇区中，其中不包含设备的分区信息。由于引导记录必须非常的小，不能理解文件系统结构，因此阶段 1 的唯一功能就是定位并加载阶段1.5的代码，且该段代码必须位于<strong>引导记录与设备第一个分区之间的位置</strong>。</p>
</li>
<li>
<p>阶段1.5：执行文件系统驱动程序</p>
<p>在第一个分区的开始位置（扇区63）和MBR（扇区 0）之间有 62 个 512 字节的扇区（共 31744 字节），用于存储阶段1.5的代码镜像<code>core.img</code>文件。</p>
<p>该空间足够容纳一些通用的<strong>文件系统驱动程序</strong>，如EXT、FAT、NTFS等。因此GRUB2的阶段2能够放在EXT文件系统内（<code>/boot/grub</code>，但不能放在逻辑卷内）。</p>
</li>
<li>
<p>阶段2：定位和加载 Linux 内核到内存，并转移控制权到内核</p>
<p>内核的相关文件位于 <code>/boot</code>目录下（其文件名均带有前缀 vmlinuz），以一种自解压的压缩格式存储以节省空间。</p>
<pre><code class="language-sh">ls -la vmlinuz*
</code></pre>
</li>
</ul>
<p>GRUB2 通过 <code>/boot/grub/grub.cfg</code> 进行配置。该配置文件通常是利用工具自动生成的（ 例如在Ubuntu中，<code>grub-update</code>基于<code>/etc/default/grub</code>生成配置文件）。</p>
</li>
<li>
<p>内核</p>
<p>内核加载到内存后，首先必须从压缩格式解压自身。</p>
<p>内核自解压完成后，则加载 <code>systemd</code>进程，并转移控制权到 <code>systemd</code>，结束引导过程。</p>
</li>
</ol>
<h3 id="启动startup"><a class="header" href="#启动startup">启动（startup）</a></h3>
<p>引导过程结束后，Linux 内核和 <code>systemd </code>处于运行状态，但是由于没有其他任何程序在执行，故其不能执行任何有关用户的功能性任务。</p>
<p><code>systemd</code>是所有进程的父进程（代替旧式<code>init</code>程序），其功能包括：</p>
<ol>
<li>
<p>挂载文件系统</p>
<p><code>systemd</code>挂载在<code>/etc/fstab</code> 中配置的文件系统，包括内存交换文件或分区。</p>
</li>
<li>
<p>决定系统启动的目标态</p>
<p><a href="https://linux.cn/article-8807-1.html?pr">目标态（target）对应旧式的运行级别（runlevel）</a>，包括<code>graphical.target</code>（桌面系统，对应<code>runlevel 5</code>）、<code>multi-user.target</code>（服务器系统，对应<code>runlevel 3</code>）。</p>
<p>根据配置文件<code>/etc/systemd/system/default.target</code>决定系统应该进入的目标态，<code>default.target</code>是一个链接文件，通常链接到描述文件<code>graphical.target</code>或<code>multi-user.target</code>。</p>
<p>每个目标态有一个在其配置文件中描述的<strong>依赖集</strong>，<code>systemd</code>需要首先启动其所需依赖。<code>systemd</code>也会查看老式的systemV init目录中是否存在相关启动文件，若存在，则<code>systemd</code>根据这些配置文件的内容启动对应的服务。</p>
<p><img src="Linux/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.assets/systemd-boot.jpg" alt="图 1：systemd 的启动流程" /></p>
</li>
</ol>
<h2 id="用户管理-2"><a class="header" href="#用户管理-2">用户管理</a></h2>
<h3 id="用户"><a class="header" href="#用户">用户</a></h3>
<h3 id="群组"><a class="header" href="#群组">群组</a></h3>
<p><em>The Primary group – When a user creates a file, the file’s group is set to the user’s primary group.</em></p>
<p><em>Secondary or supplementary group - Useful when you want to grant certain file permissions to a set of users who are members of the group.</em></p>
<p><em>Each user can belong to exactly one primary group and zero or more secondary groups.</em></p>
<p><em>Only root or users with</em> <code>sudo</code> <em>access can add a user to a group.</em></p>
<h3 id="用户信息存储"><a class="header" href="#用户信息存储">用户信息存储</a></h3>
<p>群组ID（Group ID，<code>GID</code>）</p>
<p>帐号信息存储在<code>/etc/passwd </code>文件中，每一行代表一个帐号，每行包含7部分内容：</p>
<pre><code>用户名：密码(x)：UID：GID：用户信息说明：家目录：shell
</code></pre>
<p><code>UID</code>为用户编号（User ID），其分配规则为：</p>
<ul>
<li>
<p>0：系统管理员；</p>
</li>
<li>
<p>1～499：系统帐号；</p>
</li>
<li>
<p>500～65535：一般用户。</p>
</li>
</ul>
<p>账户信息中的密码使用“<code>x</code>”代替，没有任何密码。</p>
<p>密码信息储存在<code>/etc/shadow</code>文件中，密码以加密后的密文存储。</p>
<pre><code class="language-sh">用户名：经过加密的密码：密码改动的日期：密码不可被改动的天数：密码需要重新更改的天数：密码更改前进行提示的天数：密码过期后的宽限时间：帐号失效时间：保留
</code></pre>
<p>群组信息存储在<code>/etc/group</code>中，每一行代表一个群组，分为4个字段：</p>
<pre><code>组名：群组密码（x）：GID：此群组包含的用户名称
</code></pre>
<p>用户名用&quot;<code>,</code>&quot;隔开，不能有额外的空格。</p>
<p>在<code>/etc/passwd</code>中的<code>GID</code>是用户的<strong>初始群组</strong>，当用户登入系统后，就拥有了这个群组的权限。使用<code>groups</code>命令查看用户支持的群组，第一个输出的群组即为<strong>有效群组</strong>，在创建新文件时，档案的群组属性就是有效群组。使用<code>newfrp</code>切换有效群组，这时会在原本的shell中重新启动一个shell，其中用户的有效群组就是切换后的。当退出新的shell后，有效群组就恢复了。</p>
<p>群组管理员信息保存在<code>/etc/shadow</code>中，</p>
<pre><code class="language-sh">组名：密码：群管理员帐号：群包含的用户帐号
</code></pre>
<blockquote>
<p>密码栏开头为“！”表示无合法密码，所以无群组管理员。</p>
</blockquote>
<p>群组管理员可以将帐号加入自己管理的群组中，而不许要<code>root</code>来进行管理，减少了<code>root</code>的工作量。现在由于有<code>sudo</code>命令，所以群管理员已经很少使用了。</p>
<h5 id="有效身份与真实身份"><a class="header" href="#有效身份与真实身份">有效身份与真实身份</a></h5>
<h3 id="用户登录过程"><a class="header" href="#用户登录过程">用户登录过程</a></h3>
<p>用户输入用户名和密码后，系统在<code>/etc/passwd</code>里面寻找帐号。如果没有则跳出；如果有，则将对应的<code>UID</code>和<code>GID</code>一起读出来，另外该帐号的家目录和shell设定也一并读出。</p>
<p>核对密码，系统进入<code>/etc/shadow</code>找到对应帐号与<code>UID</code>，然后核对输入的密码和里面的（加密）密码是否相同。</p>
<p>如果密码正确，那么就启动用户的shell环境。</p>
<h2 id="进程-1"><a class="header" href="#进程-1">进程</a></h2>
<p>每个会话（session）拥有一个或者多个进程组（process group），每个进程组拥有一个或多个进程（process）。会话中的第一个进程就是这个会话的领导（session leader），会话标识（session id）就用它的进程标识（process id）。</p>
<h3 id="用户态和内核态"><a class="header" href="#用户态和内核态">用户态和内核态</a></h3>
<h3 id="同步原语"><a class="header" href="#同步原语">同步原语</a></h3>
<h5 id="非递归锁"><a class="header" href="#非递归锁">非递归锁</a></h5>
<p><em><strong>non-recursive lock</strong></em>：当一个进程获取到一个非递归锁后，尝试获取该锁的其他进程将阻塞直到该锁被释放。</p>
<blockquote>
<p><em><a href="https://www.gnu.org/software/libc/manual/html_node/File-Locks.html">Locks</a> are <strong>associated with processes</strong>. A process can only have one kind of lock set for each byte of a given file. When any file descriptor for that file is closed by the process, all of the locks that process holds on that file are released, even if the locks were made using other descriptors that remain open. Likewise, ==locks are released when a process exits==, and are ==not inherited by child processes== created using fork (see Creating a Process).</em></p>
</blockquote>
<h5 id="递归锁"><a class="header" href="#递归锁">递归锁</a></h5>
<p><em><strong>recursive lock</strong></em>：同一个进程可多次获取一个递归锁，但也需要释放同样多次数。</p>
<h5 id="信号量"><a class="header" href="#信号量">信号量</a></h5>
<p><em><strong>semaphore</strong></em>：</p>
<h2 id="网络-1"><a class="header" href="#网络-1">网络</a></h2>
<h3 id="内核防火墙"><a class="header" href="#内核防火墙">内核防火墙</a></h3>
<p><code>netfilter/iptables</code>组成Linux中的包过滤防火墙，完成数据包过滤、修改、重定向和网络地址转换等功能。<code>netfilter</code>位于内核空间，<code>iptables</code>位于用户空间。<code>iptables</code>将用户的安全设定执行到安全框架<code>netfilter</code>中。</p>
<p><img src="Linux/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.assets/Netfilter-packet-flow.svg" alt="netfilter" /></p>
<p>By Jan Engelhardt - Own work, Origin SVG PNG, CC BY-SA 3.0, https://commons.wikimedia.org/w/index.php?curid=8575254</p>
<h5 id="处理位置-链"><a class="header" href="#处理位置-链">处理位置-链</a></h5>
<p>网络层对分组处理可分为五个模块（Chain，链）。每个链上设置了一系列规则，匹配规则的数据包按对应的处理方式进行处理。</p>
<ul>
<li><code>PREROUTING</code>：</li>
<li><code>FORWARD</code>：</li>
<li><code>POSTROUTING</code>：</li>
<li><code>INPUT</code>：</li>
<li><code>OUTPUT</code>：</li>
</ul>
<h5 id="处理方式-表"><a class="header" href="#处理方式-表">处理方式-表</a></h5>
<p>每个链按对分组的处理方式将相应地规则归入表中，按<strong>处理优先级</strong>由高到低依次为：</p>
<ul>
<li><code>raw</code>：</li>
<li><code>mangle</code>：解析并修改报文；</li>
<li><code>nat</code>：网络地址转换；</li>
<li><code>filter</code>：过滤数据包；</li>
<li><code>security</code>*（SELinux）。</li>
</ul>
<p>每个表由默认策略（policy）和若干条规则（rule）组成，如果没有任何规则与数据包匹配，则按默认策略处理数据包。</p>
<p>根据数据包的转递场景，某些链中不完全包含四类表，具体情况如下：</p>
<div class="table-wrapper"><table><thead><tr><th></th><th style="text-align: center"><code>PREROUTING</code></th><th style="text-align: center"><code>FORWARD</code></th><th style="text-align: center"><code>POSTROUTING</code></th><th style="text-align: center"><code>INPUT</code></th><th style="text-align: center"><code>OUTPUT</code></th></tr></thead><tbody>
<tr><td><code>raw</code></td><td style="text-align: center">√</td><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: center">√</td></tr>
<tr><td><code>mangle</code></td><td style="text-align: center">√</td><td style="text-align: center">√</td><td style="text-align: center">√</td><td style="text-align: center">√</td><td style="text-align: center">√</td></tr>
<tr><td><code>nat</code></td><td style="text-align: center">√</td><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: center">〇</td><td style="text-align: center">√</td></tr>
<tr><td><code>filter</code></td><td style="text-align: center"></td><td style="text-align: center">√</td><td style="text-align: center">√</td><td style="text-align: center">√</td><td style="text-align: center">√</td></tr>
<tr><td><code>security</code></td><td style="text-align: center"></td><td style="text-align: center">√</td><td style="text-align: center"></td><td style="text-align: center">√</td><td style="text-align: center">√</td></tr>
</tbody></table>
</div>
<p><img src="Linux/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.assets/021217_0051_6.png" alt="iptables概念" /></p>
<h5 id="匹配条件"><a class="header" href="#匹配条件">匹配条件</a></h5>
<p>根据指定的<a href="Linux/Linux%E9%85%8D%E7%BD%AE%E5%92%8C%E7%AE%A1%E7%90%86.html#%E5%8C%85%E5%8C%B9%E9%85%8D%E6%9D%A1%E4%BB%B6">匹配条件</a>来尝试匹配每个流经此处的包，并由指定的动作进行处理。</p>
<h5 id="动作target"><a class="header" href="#动作target">动作（target）</a></h5>
<ul>
<li>
<p><code>ACCEPT</code>：允许数据包通过。</p>
</li>
<li>
<p><code>DROP</code>：直接丢弃数据包，不给任何回应信息。</p>
</li>
<li>
<p><code>REJECT</code>：拒绝数据包通过，必要时会给数据发送端一个响应的信息，客户端刚请求就会收到拒绝的信息。</p>
</li>
<li>
<p><code>SNAT</code>：源地址转换，解决内网用户用同一个公网地址访问外部服务的问题。</p>
</li>
<li>
<p><code>MASQUERADE</code>：是<code>SNAT</code>的一种特殊形式，适用于动态的、临时会变的IP地址上。</p>
</li>
<li>
<p><code>DNAT</code>：目标地址转换，外部请求或响应进入内网时执行。</p>
</li>
<li>
<p><code>REDIRECT</code>：在本机做端口映射。</p>
</li>
<li>
<p><code>LOG</code>：在<code>/var/log/messages</code>文件中记录日志信息，然后将数据包传递给下一条规则，也就是说除了记录以外不对数据包做任何其他操作，仍然让下一条规则去匹配。</p>
</li>
</ul>
<h5 id="匹配顺序"><a class="header" href="#匹配顺序">匹配顺序</a></h5>
<p>一个表格中的规则，如果一条规则被匹配上，则后续规则不再匹配；反之，继续匹配剩下的规则。</p>
<p><strong>在没有顺序要求的情况下</strong>（匹配范围有包含关系的情况），匹配频率高的规则应该放在前面，以减少规则检查次数。</p>
<h4 id="自定义链-2"><a class="header" href="#自定义链-2">自定义链</a></h4>
<p>将符合同一规则的所有规则合并写入自定义链中，由默认链根据规则引用自定义链进行处理。自定义链还可以进一步引用其他自定义链。</p>
<p>使用自定义链等效于将原来的一级规则匹配变换成了多级匹配。同时，将具有公共部分的规则合并到自定义链中有助于简化规则管理。</p>
<h3 id="nat-2"><a class="header" href="#nat-2">NAT</a></h3>
<p>当网络内部主机的报文经过路由器时，路由器会维护一张NAT表，表中记录了报文来自于哪个内部主机的哪个进程（内部主机IP+端口）。</p>
<img src="Linux/操作系统原理.assets/051517_1411_1.png" alt="SNAT" style="zoom:80%;" />
<p><strong>SNAT</strong>：当报文经过路由器时，路由器会将报文的内部主机源IP替换为路由器的IP地址，把源端口也映射为某个端口，NAT表会把这种对应关系记录下来。外部主机收到报文时，源IP与源端口显示的都是路由的IP与端口。当外部网络中的主机进行回应时，外部主机将响应报文发送给路由器，路由器根据NAT表中的映射，将响应报文中的目标IP与目标端口再改为内部主机的IP与端口号，然后再将响应报文发送给内部网络中的主机。整个过程中，外部主机都不知道内部主机的IP地址，内部主机还能与外部主机通讯，于是起到了隐藏网络内主机IP的作用。还能够让局域网内的主机共享公网IP，让使用私网IP的主机能够访问互联网。</p>
<p><strong>DNAT</strong>：会话开始时使用DNAT，如公网中的客户端通过路由器向内网中的服务器发起请求，路由器将“目标IP+端口”映射到“内网IP+端口”。</p>
<h3 id="lvs"><a class="header" href="#lvs">LVS</a></h3>
<p>Linux Virtual Server</p>
<p>LVS由两部分组成，<code>ipvs</code>与<code>ipvsadm</code>。</p>
<ul>
<li>
<p><code>ipvsadm</code>：LVS管理工具，管理员通过<code>ipvsadm</code>定义或管理集群规则。</p>
</li>
<li>
<p><code>ipvs</code>：LVS核心实现，根据定义好的集群规则进行工作。<code>ipvs</code>作为<code>netfilter</code>的模块存在。</p>
</li>
</ul>
<img src="Linux/操作系统原理.assets/070617_0124_4.png" alt="ipvs" style="zoom:80%;" />
<h4 id="lvs-nat"><a class="header" href="#lvs-nat">LVS-NAT</a></h4>
<p>LVS主机作为内网中服务器集群的代理，通过NAT将来自客户端的请求转发给服务器集群。LVS通过调度模块<code>ipvs</code>来调节转发给集群各服务器的负载。</p>
<p><img src="Linux/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.assets/070617_0124_2.png" alt="LVS-NAT" /></p>
<p><code>VIP</code>：公网IP，客户端实际访问的IP；</p>
<p><code>RIP</code>：集群中服务器的内网IP；</p>
<p><code>DIP</code>：LVS主机链接集群的接口分配的内网IP。</p>
<h2 id="输入输出-9"><a class="header" href="#输入输出-9">输入输出</a></h2>
<h3 id="tcp-socket"><a class="header" href="#tcp-socket">TCP Socket</a></h3>
<h4 id="connect-and-accept"><a class="header" href="#connect-and-accept">Connect and Accept</a></h4>
<p>The <code>connect</code> and <code>accept</code> function  the <em>three-hand-shake</em> procedure.</p>
<p><code>accept</code> will peak one connection request from the backlog queue, which has finished three-hand-shake procedure.</p>
<blockquote>
<p><a href="http://blog.csdn.net/tennysonsky/article/details/45622395">三次握手</a>的过程是由内核完成，不是<code>connect/connect</code>完成.</p>
<p>https://www.cnblogs.com/pengyusong/p/6434788.html</p>
</blockquote>
<blockquote>
<p>调用*<a href="http://linux.die.net/man/2/listen">listen</a>*系统调用时，socket状态会变为<strong>LISTEN</strong>，此时需要为这个socket指定一个<strong>backlog</strong>。backlog通常被用来指定队列能容下的链接的个数。</p>
<p>在TCP建立连接的三路握手过程中，连接需要先经历<strong>SYN RECEIVED</strong>状态才能到达最终的<strong>ESTABLISHED</strong>状态，处于<strong>ESTABLISHED</strong>状态的连接才能被*<a href="http://linux.die.net/man/2/accept">accept</a>*系统调用返回给应用。正因为如此，TCP/IP协议栈通常有两种实现backlog queue的策略：</p>
<ol>
<li>使用一个队列，其大小由<em>listen</em>系统调用的<em>backlog</em>参数决定。当服务器收到<strong>SYN数据包</strong>后，会发送<strong>SYN/ACK数据包</strong>给客户端并将该连接入队列；当服务器收到客户端的ACK确认数据包后，连接状态变为<strong>ESTABLISHED</strong>，该连接可以被应用程序使用。这意味着这个队列会包含<strong>SYN RECEIVED</strong>和<strong>ESTABLISHED</strong>两种状态的连接，只是只有处于<strong>ESTABLISHED</strong>状态的连接才会返回给用户程序中的<em>accept</em>系统调用。</li>
<li>使用两个队列，一个<strong>SYN 队列</strong>（或者说是未完成连接队列）和一个<strong>accept 队列</strong>（或者说是连接完成队列）。处于<strong>SYN RECEIVED</strong>状态的连接会被添加到SYN队列，然后，当这一连接状态变为<strong>ESTABLISHED</strong>后，其被移至accept队列。<code>accept系统调用只会从accept队列中消耗连接</code>。在这种策略中，<em>listen</em>系统调用的<em>backlog</em>参数决定的是<strong>accept 队列</strong>的大小。</li>
</ol>
<p>https://harveyqing.gitbooks.io/python-read-and-write/content/python_advance/how_to_use_linux_epoll.html</p>
</blockquote>
<h3 id="任务调度模式"><a class="header" href="#任务调度模式">任务调度模式</a></h3>
<p><img src="Linux/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.assets/figure1.gif" alt="Simplified Matrix of Basic Linux I/O Models" /></p>
<h5 id="io密集型和cpu密集型任务"><a class="header" href="#io密集型和cpu密集型任务">IO密集型和CPU密集型任务</a></h5>
<h5 id="同步和异步"><a class="header" href="#同步和异步">同步和异步</a></h5>
<p>根据用户程序与内核的交互方式，进程的运行方式可分为同步和异步：</p>
<ul>
<li>同步：用户程序向内核发起操作请求，并从内核空间中获取数据；</li>
<li>异步：用户程序向内核发起操作请求，内核完成请求后将数据写入用户空间（通过信号处理函数或回调函数写入用户空间提前分配的内存）。</li>
</ul>
<h5 id="阻塞和非阻塞"><a class="header" href="#阻塞和非阻塞">阻塞和非阻塞</a></h5>
<p>阻塞：用户程序等待内核操作结束；以输入为例，<code>read</code>系列方法将尝试读取指定字节数据、或读取直到指定字符（例如换行<code>\n</code>或文件结束<code>EOF</code>）。默认模式下，如果输入流还未满足返回条件，则方法将被阻塞。</p>
<p>非阻塞：用户不等待内核操作结束，而是立即返回内核操作的状态。</p>
<h4 id="同步阻塞模式"><a class="header" href="#同步阻塞模式">同步阻塞模式</a></h4>
<blockquote>
<p><em>The application blocks until the system call is complete. The calling application consumes no CPU and simply awaits the response, so it is efficient from a processing perspective.</em></p>
<p><em>the read/write task is multiplexed with other work in the kernel.</em></p>
</blockquote>
<h4 id="同步非阻塞模式"><a class="header" href="#同步非阻塞模式">同步非阻塞模式</a></h4>
<p>可读取的数据量不确定，可能会频繁从内核读取少量数据，增加上下文切换开销。</p>
<blockquote>
<p><em>low data throughput due to frequent system call with context switch.</em></p>
</blockquote>
<h4 id="异步阻塞通知模式"><a class="header" href="#异步阻塞通知模式">异步阻塞通知模式</a></h4>
<blockquote>
<p><strong>IO多路复用</strong>：<em>non-blocking I/O with <strong>asynchronous blocking</strong> notifications</em>。</p>
<p>==不存在“异步阻塞IO”的模式==：如果用户程序阻塞等待内核操作完成，则“异步阻塞IO”与同步阻塞IO对于计算任务调度是相同效果，区别仅在于读取数据的方式。</p>
</blockquote>
<p>在同步IO模式下，若用户程序阻塞于一个IO操作，而此时其它文件已经准备好操作，则进程无法转去操作其他文件，导致进程的运行效率降低（CPU的利用率）。因此，应该将所有进行IO操作的文件进行统一管理，通过查询文件读写状态获取可操作的文件，并执行相应的操作。只要存在可执行的IO操作，则进程不会出现空闲状态，从而提高进程运行效率。</p>
<p>Linux提供了<code>select</code>、<code>poll</code>、<code>epoll</code>接口监听文件描述符状态变化信息。<code>select</code>需要用户程序对发生状态变化的文件查询其发生的事件，而<code>poll</code>、<code>epoll</code>则由内核来设置文件描述符发生的事件。</p>
<p>监听接口是<strong>异步阻塞</strong>模式（<em>依赖于内核<a href="Linux/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.html#%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B">事件通知</a></em>），直到存在文件描述符准备就绪。在该模式下，任何内核操作都应该立即返回结果而非发生阻塞（非阻塞IO模式），否则令监听机制失效（阻塞在内核操作处，而非阻塞在监听接口处）。</p>
<blockquote>
<p><code>select</code> <em>call can provide notification for many descriptors. A convenient model for asynchronous notification, <a href="Linux/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.html#%E5%90%8C%E6%AD%A5%E9%9D%9E%E9%98%BB%E5%A1%9E%E6%A8%A1%E5%BC%8F">not advised for</a> high-performance I/O.</em> </p>
</blockquote>
<h4 id="异步非阻塞模式"><a class="header" href="#异步非阻塞模式">异步非阻塞模式</a></h4>
<h5 id="多线程模型"><a class="header" href="#多线程模型">多线程模型</a></h5>
<h5 id="线程池模型"><a class="header" href="#线程池模型">线程池模型</a></h5>
<h5 id="事件驱动模型"><a class="header" href="#事件驱动模型">事件驱动模型</a></h5>
<h4 id="参考文献-9"><a class="header" href="#参考文献-9">参考文献</a></h4>
<ol>
<li>Boost application performance using asynchronous I/O, Learn when and how to use the POSIX AIO API. https://developer.ibm.com/technologies/linux/articles/l-async/</li>
<li></li>
</ol>
<h3 id="套接字"><a class="header" href="#套接字">套接字</a></h3>
<p>对于套接字而言，<code>accept()</code>函数会一直阻塞，直到有来自客户端的连接；<code>recv()</code>函数会一直阻塞，直到接收到了客户端的数据（或者没有更多的可接收数据）；<code>send()</code>函数也会一直阻塞，直到发送给客户端的数据已经准备好了。</p>
<p><strong>多线程（进程）阻塞模型</strong>：程序主线程包含了监听<code>socket</code>，这个监听<code>socket</code>接受来自众多客户端的连接；每当一个客户端连接进来时，将新创建的<code>socket</code>交给另外一个线程，由这个线程与客户端进行通信。因为每个线程只会与一个客户端通信，因此一个线程的阻塞并不会影响其它工作线程。使用多线程的阻塞<code>socket</code>写的代码逻辑上很简单直接，但这种模型<a href="http://www.virtualdub.org/blog/pivot/entry.php?id=62">有一些缺点</a>，比如多线程的数据同步和单CPU多线程的低效。</p>
<p><strong>异步套接字</strong>：对异步socket的操作会立即返回成功或失败，程序可以通过返回来决定后续操作。因为异步socket是非阻塞的，所以不需要用多线程，所有任务可能都在一个线程中完成。</p>
<p><strong>异步多线程模型</strong>：主线程负责网络，其它线程处理阻塞任务；</p>
<h2 id="安全-2"><a class="header" href="#安全-2">安全</a></h2>
<h3 id="数字证书-2"><a class="header" href="#数字证书-2">数字证书</a></h3>
<p>PEM (originally “<strong>P</strong>rivacy <strong>E</strong>nhanced <strong>M</strong>ail”) is the most common format for <a href="https://www.ssl.com/faqs/what-is-an-x-509-certificate/">X.509</a> certificates, CSRs, and cryptographic keys. A PEM file is a text file containing one or more items in Base64 ASCII encoding, each with plain-text headers and footers (e.g. <code>-----BEGIN CERTIFICATE-----</code> and <code>-----END CERTIFICATE-----</code>). A single PEM file could contain an end-entity certificate, a private key, or multiple certificates forming a complete chain of trust. Most certificate files downloaded from SSL.com will be in PEM format.</p>
<p><a href="https://www.ssl.com/guide/pem-der-crt-and-cer-x-509-encodings-and-conversions/">PEM files</a> are usually seen with the extensions <code>.crt</code>, <code>.pem</code>, <code>.cer</code>, and <code>.key</code> (for private keys), but you may also see them with different extensions. For example, the SSL.com CA bundle file available from the download table in a certificate order has the extension <code>.ca-bundle</code>.</p>
<h2 id="binary文件"><a class="header" href="#binary文件">Binary文件</a></h2>
<blockquote>
<p>All ELF binaries need to have a few things in place in order for them to be interpreted by the Linux kernel properly. As with Windows EXEs, there’s a structure to the header that defines the overall layout of the binary.</p>
</blockquote>
<pre><code class="language-shell">readelf -a elf_file
# -h --file-header       Display the ELF file header
# -l --program-headers   Display the program headers
# -S --section-headers   Display the sections' header
# -s --syms              Display the symbol table
# --dyn-syms             Display the dynamic symbol table
</code></pre>
<div class="table-wrapper"><table><thead><tr><th>工具</th><th>命令</th><th>说明</th></tr></thead><tbody>
<tr><td><code>hexdump</code></td><td><code>hexdump -C execfile</code></td><td>查看文件的十六进制编码</td></tr>
<tr><td></td><td><code>objdump -d execfile</code></td><td></td></tr>
<tr><td><code>readelf</code></td><td><code>readelf -aW file</code></td><td>查看ELF二进制文件结构</td></tr>
<tr><td></td><td><code>strip execfile</code></td><td></td></tr>
</tbody></table>
</div>
<blockquote>
<p><code>strip</code> reads a binary file, and removes a lot of the extra debug and compiler info that isn’t needed. </p>
</blockquote>
<h3 id="动态链接库"><a class="header" href="#动态链接库">动态链接库</a></h3>
<p>查看可执行程序的动态链接库依赖信息</p>
<pre><code class="language-shell">ldd -v /usr/bin/bash                 # -v 递归显示依赖关系(默认列出所有直接和简介依赖项)
ldd /usr/bin/bash | awk '{print $1}' # 提取输出信息中的依赖项信息
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="windows配置管理"><a class="header" href="#windows配置管理">Windows配置管理</a></h1>
<h2 id="安装-7"><a class="header" href="#安装-7">安装</a></h2>
<p>磁盘初始化，如果回收磁盘空间重新初始化，则会创建单独的启动分区。</p>
<h3 id="uefi"><a class="header" href="#uefi">UEFI</a></h3>
<p>以UEFI模式安装系统，启动设备需要使用FAT32文件系统。</p>
<p>问题：无法为安装介质加载驱动程序</p>
<p>切换到USB2.0接口。</p>
<h2 id="管理工具"><a class="header" href="#管理工具">管理工具</a></h2>
<p><a href="Windows/./Windows%20Shell.html#WMI%E5%92%8CCIM">WMI and CIM</a></p>
<h3 id="远程访问"><a class="header" href="#远程访问">远程访问</a></h3>
<p>通过会话访问远程主机并执行命令。在目标机器上启用PowerShell远程会话：</p>
<pre><code class="language-powershell">Enable-PSRemoting  # 以管理员身份运行，网络类型“专用”
</code></pre>
<blockquote>
<p><em>由于此计算机上的网络连接类型之一设置为公用，因此 WinRM 防火墙例外将不运行。 将网络连接类型更改为域或专用，然后再次尝试。</em></p>
</blockquote>
<pre><code class="language-powershell">$Cred = Get-Credential    # 弹出对话框选择账号并输入密码
Enter-PSSession -ComputerName dc01 -Credential $Cred #建立远程登录会话
Exit-PSSession
</code></pre>
<blockquote>
<p>错误：使用 winrm.cmd 配置 <code>TrustedHosts</code>。</p>
</blockquote>
<pre><code class="language-powershell">Invoke-Command -ComputerName dc01, sql02, web01 {Get-Service -Name W32time} -Credential $Cred

$Session = New-PSSession -ComputerName dc01, sql02, web01 -Credential $Cred
Invoke-Command -Session $Session {(Get-Service -Name W32time).start()}
Invoke-Command -Session $Session {Get-Service -Name W32time}
Get-PSSession | Remove-PSSession  # close established sessions
</code></pre>
<h2 id="硬件"><a class="header" href="#硬件">硬件</a></h2>
<h3 id="主板"><a class="header" href="#主板">主板</a></h3>
<pre><code class="language-powershell">wmic baseboard get Manufacturer,Model,Name,PartNumber,serialnumber
</code></pre>
<h3 id="cpu-3"><a class="header" href="#cpu-3">CPU</a></h3>
<pre><code class="language-powershell">wmic cpu
</code></pre>
<h3 id="gpu"><a class="header" href="#gpu">GPU</a></h3>
<pre><code class="language-powershell">dxdiag
nvidia-smi
</code></pre>
<h3 id="bios"><a class="header" href="#bios">BIOS</a></h3>
<pre><code class="language-powershell">wmic BIOS get name,version,serialnumber
Get-WmiObject -Class Win32_Bios | Format-List -Property *
</code></pre>
<blockquote>
<p><code>serialnumber</code>为主机序列号。</p>
</blockquote>
<h3 id="内存-3"><a class="header" href="#内存-3">内存</a></h3>
<pre><code class="language-powershell">wmic MemoryChip get BankLabel,Capacity,MemoryType,TypeDetail,Speed,Tag
</code></pre>
<p>虚拟内存配置：如果系统物理内存足够大，可选择关闭系统分页文件：<code>pagefile.sys</code>，<code>swapfile.sys</code>以节省磁盘空间。</p>
<h3 id="磁盘-1"><a class="header" href="#磁盘-1">磁盘</a></h3>
<p>列出物理磁盘信息：</p>
<pre><code class="language-powershell">wmic diskdrive list brief   # DeviceID as disks path
wmic diskdrive get Name,Model,InterfaceType,MediaType,SerialNumber,Size,Status
wmic PARTITION
wmic VOLUME
</code></pre>
<blockquote>
<p>可查看型号（<code>Model</code>）、序列号（<code>SerialNumber</code>）。</p>
</blockquote>
<pre><code class="language-bash">diskpart		# 启动磁盘管理交互环境
</code></pre>
<p>在交互环境中可执行的命令（通过<code>help</code>查看）：</p>
<div class="table-wrapper"><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody>
<tr><td>`list disk</td><td>partition</td></tr>
<tr><td>`select disk</td><td>parition</td></tr>
<tr><td><code>rescan</code></td><td>重新扫描计算机，查找磁盘和卷</td></tr>
<tr><td><code>clean</code></td><td>从磁盘清除配置信息或所有信息。</td></tr>
<tr><td><code>compact</code></td><td>尝试减少文件的物理大小。</td></tr>
<tr><td><code>convert</code></td><td>在不同的磁盘格式之间转换。</td></tr>
<tr><td><code>create</code></td><td>创建卷、分区或虚拟磁盘。</td></tr>
<tr><td><code>format</code></td><td>格式化卷或分区</td></tr>
<tr><td><code>shrink</code></td><td>减小选定卷。</td></tr>
<tr><td><code>remove</code></td><td>删除驱动器号或装载点分配。</td></tr>
<tr><td><code>delete</code></td><td>删除对象。</td></tr>
<tr><td><code>exit</code></td><td>退出<code>diskpart</code>。</td></tr>
</tbody></table>
</div>
<h5 id="磁盘分区类型"><a class="header" href="#磁盘分区类型">磁盘分区类型</a></h5>
<p>如果在MBR分区类型的磁盘上安装了</p>
<p><code>mbr2gpt</code>可将MBR分区类型的磁盘转换为GPT分区类型，而无需移动磁盘上的数据。</p>
<pre><code class="language-powershell">mbr2gpt /validate        # 验证选定磁盘可进行转换操作（未指定磁盘则使用安装系统的磁盘）
        /convert /disk:N # 验证并执行转换操作
        /allowFullOS     # 使该命令可用于完整Windows环境（默认仅用于PE环境，推荐）
</code></pre>
<p>打开高级启动模式：“<code>设置-&gt;更新和安全-&gt;恢复-&gt;高级启动-&gt;立即重新启动</code>”（或按住<code>Shift</code>键点击重启按钮）；在启动选项中选择：<code>疑难解答-&gt;高级选项-&gt;命令行</code>，然后重新启动电脑，执行上述命令。</p>
<h3 id="电源管理"><a class="header" href="#电源管理">电源管理</a></h3>
<pre><code class="language-powershell">powercfg /a      # 睡眠状态
powercfg -H OFF  # 关闭休眠模式(删除系统磁盘下的hyberfi.sys文件)
# /LIST、/L          列出所有电源方案。
</code></pre>
<h3 id="网络接口"><a class="header" href="#网络接口">网络接口</a></h3>
<pre><code class="language-powershell">wmic nic get AdapterType,Name,MACAddress,Speed,NetConnectionStatus
</code></pre>
<h2 id="系统管理"><a class="header" href="#系统管理">系统管理</a></h2>
<h3 id="系统信息-4"><a class="header" href="#系统信息-4">系统信息</a></h3>
<pre><code class="language-sh">systeminfo	# 输出系统信息[CLI]
msinfo32    # 系统信息[GUI]
ver         # [cmd]查看系统版本
winver      # [GUI]查看系统版本对话框
wmic COMPUTERSYSTEM
wmic OS
Get-ComputerInfo -Property &quot;*version&quot;
Get-WmiObject -Class Win32_ClassName | Format-List -Property '*'
</code></pre>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/cimwin32prov/computer-system-hardware-classes?redirectedfrom=MSDN">Computer System Hardware Classes - Win32 apps | Microsoft Docs</a></p>
<p><a href="https://docs.microsoft.com/en-us/previous-versions//aa392727(v=vs.85)">Operating System Classes (Windows) | Microsoft Docs</a></p>
<p><a href="https://docs.microsoft.com/en-us/powershell/scripting/samples/collecting-information-about-computers?view=powershell-7.2">Collecting Information About Computers - PowerShell | Microsoft Docs</a></p>
<h5 id="系统启动信息"><a class="header" href="#系统启动信息">系统启动信息</a></h5>
<p>启动配置数据存储编辑器：</p>
<pre><code class="language-powershell">bcdedit /delete {uuid}
</code></pre>
<blockquote>
<p>单独运行 &quot;<code>bcdedit</code>&quot; 等同于运行 &quot;<code>bcdedit /enum ACTIVE</code>&quot;(列出激活的启动项)。</p>
</blockquote>
<h3 id="注册表"><a class="header" href="#注册表">注册表</a></h3>
<p><a href="https://docs.microsoft.com/en-us/powershell/scripting/samples/working-with-registry-entries?view=powershell-7.2">Working with Registry Entries - PowerShell | Microsoft Docs</a></p>
<p><a href="https://docs.microsoft.com/en-us/powershell/scripting/samples/working-with-registry-keys?view=powershell-7.2">Working with Registry Keys - PowerShell | Microsoft Docs</a></p>
<h2 id="文件管理-3"><a class="header" href="#文件管理-3">文件管理</a></h2>
<pre><code class="language-powershell">Set-Location [-Path] path # &gt;&gt; cd, chdir
</code></pre>
<blockquote>
<p>切换当前目录。</p>
</blockquote>
<h5 id="读取目录"><a class="header" href="#读取目录">读取目录</a></h5>
<pre><code class="language-powershell">Get-ChildItem -Recursive -Path *.txt  # &gt;&gt; dir
</code></pre>
<h5 id="创建文件"><a class="header" href="#创建文件">创建文件</a></h5>
<pre><code class="language-powershell">New-Item -ItemType &quot;file&quot; -Path . -Name &quot;testfile1.txt&quot; -Value &quot;This is a text string.&quot;
New-Item -ItemType &quot;directory&quot; -Path &quot;c:\&quot; -Name &quot;logfiles&quot; # -&gt; mkdir
</code></pre>
<h5 id="链接文件"><a class="header" href="#链接文件">链接文件</a></h5>
<p>硬链接(<em>Hard link</em>)==只能用于文件==，且不能跨磁盘使用。多个硬链接可以指向同一个文件，并且删除一个硬链接或原始文件，其他硬链接仍然可以访问。删除软链接(<em>Symbolic link</em>)不会影响原始文件，但删除原始文件会使软链接失效。</p>
<blockquote>
<p><strong>权限</strong>：创建符号链接需要有“<code>SeCreateSymbolicLinkPrivilege</code>”用户权利，administrators 组成员默认具有此权利。 这个权利可以在“<code>本地安全策略（secpol.msc）\本地策略\用户权利分配</code>”中设置。</p>
</blockquote>
<pre><code class="language-powershell">New-Item -ItemType SymbolicLink -Path &quot;Link&quot; -Target &quot;Target&quot;
</code></pre>
<p><code>-ItemType SymbolicLink|Junction|HardLink</code>：
<code>-Path</code>：符号链接文件的路径；
<code>-Target</code>：符号链接的目标路径；
<code>-Force</code>：覆盖已有文件。</p>
<blockquote>
<p>cmd:</p>
<pre><code class="language-powershell">mklink {/D|/H|/J} Link Target
</code></pre>
<p><code>/D</code>：创建目录符号链接(symbolic link)，默认为文件符号链接。
<code>/H</code>：创建硬链接(hard link)而非符号链接，目标文件必须位于同一磁盘分区（卷）。
<code>/J</code>：创建目录联接(junction)，目录必须位于本地。
<code>Link</code>指定新的符号链接名称，<code>Target</code>指定新链接引用的路径 (相对或绝对)。</p>
<p>Adobe Reader保存文件时，可能会先删除原有文件，再创建新文件，由此使得指向原文件的硬链接与新文件不同。</p>
</blockquote>
<h5 id="查看文件链接"><a class="header" href="#查看文件链接">查看文件链接</a></h5>
<pre><code class="language-shell">dir path -recurse -force | ?{$_.LinkType} | select FullName,LinkType,Target
</code></pre>
<blockquote>
<p><code>dir-&gt;Get-ChildItem</code></p>
</blockquote>
<h5 id="复制移动文件"><a class="header" href="#复制移动文件">复制移动文件</a></h5>
<pre><code class="language-powershell">del filename  % 删除文件。
dir
rmdir
move
</code></pre>
<pre><code class="language-powershell">Move-Item -Path C:\test.txt -Destination E:\Temp\tst.txt  # move file
Move-Item -Path C:\Temp -Destination C:\Logs # move folder
Move-Item -Path .\*.txt -Destination C:\Logs # wildcard
</code></pre>
<h3 id="查找-8"><a class="header" href="#查找-8">查找</a></h3>
<h4 id="查找可执行程序"><a class="header" href="#查找可执行程序">查找可执行程序</a></h4>
<pre><code class="language-powershell">Get-Command dotnet  # [gcm]   -&gt; &quot;where&quot; in cmd
#CommandType     Name          Version    Source
#-----------     ----          -------    ------
#Application     dotnet.exe    5.0.152... C:\Program Files\dotnet\dotnet.exe
</code></pre>
<h2 id="应用管理"><a class="header" href="#应用管理">应用管理</a></h2>
<p>https://dev.to/bowmanjd/chocolatey-vs-scoop-package-managers-for-windows-2kik</p>
<p><a href="https://docs.microsoft.com/en-us/powershell/scripting/samples/working-with-software-installations?view=powershell-7.2">Working with Software Installations - PowerShell | Microsoft Docs</a></p>
<pre><code class="language-powershell">Get-CimInstance -Class Win32_Product | Select-Object -Property Name,Vendor,Version
</code></pre>
<h3 id="离线安装-1"><a class="header" href="#离线安装-1">离线安装</a></h3>
<h4 id="appx包"><a class="header" href="#appx包">appx包</a></h4>
<h5 id="获取appx包"><a class="header" href="#获取appx包">获取appx包</a></h5>
<p>包括<code>AppxBundle</code>和<code>appx</code>包，其中<code>AppxBundle</code>是多个<code>appx</code>包的合集。</p>
<ol>
<li>软件发布者在GitHub等网站提供<code>appx</code>包的下载（某些可能为将依赖项打包）；</li>
<li>从应用商店获取应用的分享链接，然后在<a href="https://store.rg-adguard.net/">Microsoft Store - Generation Project</a>查找并下载应用的<code>appx</code>包及其依赖包。</li>
</ol>
<h5 id="安装-8"><a class="header" href="#安装-8">安装</a></h5>
<p>以管理员身份使用PowerShell命令提供安装选项：</p>
<pre><code class="language-powershell">Add-AppxPackage FILENAME.appx
</code></pre>
<blockquote>
<p>双击软件包即也可执行安装。但<strong>离线安装程序无法启动，提示找不到启动文件</strong>：可能是由于安装位置<code>C:\Program Files\WindowsApps</code>没有访问权限。由于以上两种文件格式都是以<code>zip</code>格式封装，因此可以提取其中的<code>appx</code>包内容并手动安装到用户提供目录下。</p>
<p>安装如果出现证书无法被信任的问题，需要将<code>appx</code>包所带证书（通过“属性/数字签名”查看）安装到本机的证书目录下（选择“受信任的<code>xxx</code>”）。</p>
</blockquote>
<h3 id="winget"><a class="header" href="#winget">winget</a></h3>
<pre><code class="language-powershell">winget list [-q QUERY] # 显示已安装软件列表（包括非winget安装）
       --id ID
       --name NAME
       --source SOURCE  # -s 使用指定的源查找程序包
       --count          # -n 显示不超过指定数量的结果 
       --exact          # -e 使用精确匹配
winget list &gt; winget.installed.txt   # 在cmd中执行避免乱码
</code></pre>
<blockquote>
<p>即使非<code>winget</code>安装，如果在相应软件源发现匹配软件，仍会显示相应的源（<code>msstore/winget</code>）。</p>
</blockquote>
<pre><code class="language-powershell">winget search PACKAGE --source SOURCE
winget show PACKAGE --source SOURCE  # 显示软件的详细信息
winget search &gt; winget.repo.txt      # 在cmd中执行避免乱码
</code></pre>
<blockquote>
<p>当<code>show</code>发现多个匹配时，会提示用户提供更精确的包名或限定源。</p>
</blockquote>
<pre><code class="language-powershell">winget install &lt;package&gt; --source msstore
       upgrade
       uninstall
winget export --output FILE --source SOURCE
       import --import-file FILE
</code></pre>
<pre><code class="language-powershell">winget source list \         # 列出源的名称和URL
              --name winget  # 列出指定源的详细信息 
winget settings  # 打开设置文件进行编辑
</code></pre>
<h3 id="chocolatey"><a class="header" href="#chocolatey">Chocolatey</a></h3>
<h5 id="配置"><a class="header" href="#配置">配置</a></h5>
<pre><code class="language-bash">choco source [list]								# 列出软件源
choco source add -n=REPONAME -s=url
choco source enable/disable/remove -n=REPONAME
choco config [list]								# 列出配置信息
choco config get [--name] CONFIG_NAME
choco config set [--name] CONFIG_NAME --value VALUE
</code></pre>
<h5 id="搜索软件"><a class="header" href="#搜索软件">搜索软件</a></h5>
<pre><code class="language-sh">choco list/find/search openjdk[--exact --verbose]
choco list/find/search &lt;appname&gt; --local-only # 查找已安装应用
choco info pkgname
</code></pre>
<h5 id="更新-2"><a class="header" href="#更新-2">更新</a></h5>
<pre><code class="language-powershell">choco upgrade &lt;appname&gt;|all --except=&quot;appname,...&quot; # 升级应用
choco outdated   # 列出可更新软件 upgrade all --noop
choco pin &lt;package_name&gt;  # 固定软件版本
</code></pre>
<h5 id="安装卸载"><a class="header" href="#安装卸载">安装卸载</a></h5>
<pre><code class="language-powershell">choco install &lt;appname&gt;	
choco uninstall &lt;appname&gt;
</code></pre>
<h4 id="搭建本地软件仓库"><a class="header" href="#搭建本地软件仓库">搭建本地软件仓库</a></h4>
<h5 id="使用nexus代理-1"><a class="header" href="#使用nexus代理-1">使用Nexus代理</a></h5>
<p>仅代理Chocolaty安装脚本信息（<code>nuget</code>），软件的安装文件仍然需要访问官方资源。因此该代理只是提高对软件仓库的查询速度，而不能离线部署。</p>
<pre><code class="language-shell">Name=chocolatey
Format=nuget
URL=http://172.28.76.100:8081/repository/chocolatey/
Protocl=&quot;NuGet V2&quot;
Remote=https://chocolatey.org/api/v2/
</code></pre>
<p><a href="https://docs.chocolatey.org/en-us/features/host-packages">Chocolatey Software Docs | Host packages internally</a></p>
<h3 id="scoop"><a class="header" href="#scoop">Scoop</a></h3>
<p>如果没有管理员权限，则采用Scoop更加合适。</p>
<pre><code class="language-powershell"># Enable execution of PowerShell scripts
Set-ExecutionPolicy AllSigned
Set-ExecutionPolicy RemoteSigned -scope CurrentUser
Invoke-Expression (
	New-Object System.Net.WebClient).DownloadString('https://get.scoop.sh')
# or shorter: iwr -useb get.scoop.sh | iex
</code></pre>
<pre><code class="language-powershell">scoop search [&lt;app&gt;]   # 省略app名称将列出仓库中所有可用软件
scoop info &lt;app&gt; # 显示软件信息（含必要配置说明）
scoop install|uninstall &lt;app&gt;
scoop list
scoop status   # 检查软件是否有新版本
scoop hold|unhold &lt;app&gt;  # 停用/启用更新 
scoop update [&lt;app&gt;]  # 更新scoop或指定软件
scoop cleanup *  # 清理所有旧版软件, 清理指定软件, 清理过期的安装包
scoop cleanup &lt;app&gt;
</code></pre>
<blockquote>
<p>安装的软件在<code>~\scoop\apps</code>目录下。</p>
</blockquote>
<h5 id="软件源"><a class="header" href="#软件源">软件源</a></h5>
<p><a href="https://rasa.github.io/scoop-directory/by-apps">Scoop buckets by number of apps | scoop-directory (rasa.github.io)</a></p>
<pre><code class="language-powershell">scoop bucket add|list|known|rm &lt;bucket&gt;
</code></pre>
<h5 id="下载-1"><a class="header" href="#下载-1">下载</a></h5>
<p>利用<code>aria2</code>加速下载：</p>
<pre><code class="language-powershell">scoop install aria2
scoop config aria2-enabled true                   # default: true
scoop config aria2-retry-wait 8                   # default: 2
scoop config aria2-split 8                        # default: 5
scoop config aria2-max-connection-per-server 8    # default: 5
scoop config aria2-min-split-size 2M              # default: 5M
</code></pre>
<p>添加库 versions, 可以安装其他（落后的)版本：</p>
<pre><code class="language-powershell">scoop bucket add versions
scoop install python@3.7.7
</code></pre>
<h3 id="msys2"><a class="header" href="#msys2">MSYS2</a></h3>
<blockquote>
<p><em>Software Distribution and Building Platform for Windows.</em></p>
<ul>
<li>
<p>Terminal: <code>mintty</code>、<code>bash</code>；</p>
</li>
<li>
<p>CLI tools：<code>git</code>、<code>tar</code>、<code>awk</code>；</p>
</li>
<li>
<p>Develop tools：GCC, mingw-w64, CPython, CMake, Meson, OpenSSL, FFmpeg, Rust, Ruby。</p>
<p><img src="Windows/assets/msys-environment.png" alt="image-20221020132233008" /></p>
<p><a href="https://www.msys2.org/docs/environments/">Environments - MSYS2</a></p>
</li>
<li>
<p>package management：<code> Pacman</code>（Arch Linux）</p>
</li>
</ul>
</blockquote>
<p><a href="https://www.msys2.org/docs/what-is-msys2/">What is MSYS2? - MSYS2</a></p>
<pre><code class="language-powershell">winget install msys2.msys2
</code></pre>
<pre><code class="language-shell">用法:  pacman &lt;操作&gt; [...]
操作:
    pacman {-h --help}
    pacman {-V --version}
    pacman {-D --database} &lt;选项&gt; &lt;软件包&gt;
    pacman {-F --files}    [选项] [文件]
    pacman {-Q --query}    [选项] [软件包]
    pacman {-R --remove}   [选项] &lt;软件包&gt;
    pacman {-S --sync}     [选项] [软件包]
    pacman {-T --deptest}  [选项] [软件包]
    pacman {-U --upgrade}  [选项] &lt;文件&gt;
</code></pre>
<p>MSYS2提供模拟文件系统，其物理位置为MSYS2安装目录（可直接从物理系统访问其中内容）。</p>
<pre><code class="language-shell">df -hT /home/gary/
# 文件系统       类型   容量   已用  可用   已用% 挂载点
# C:/msys64     ntfs  931G  221G  711G   24%  /
</code></pre>
<h3 id="office"><a class="header" href="#office">Office</a></h3>
<p>安装office部署工具（Office Deployment Tool）。</p>
<p>配置文件（<code>configuration.xml</code>）</p>
<pre><code class="language-powershell">&lt;Configuration&gt;
  &lt;Add OfficeClientEdition=&quot;64&quot; Channel=&quot;Monthly&quot;&gt; &lt;!--PerpetualVL2019--&gt;
    &lt;Product ID=&quot;HomeStudent2019Retail&quot;&gt;  
    &lt;!-- ProPlus2019Volume|VisioPro2019Volume... --&gt;
      &lt;Language ID=&quot;zh-cn&quot; /&gt;
    &lt;/Product&gt;
  &lt;/Add&gt;
  &lt;!--  &lt;RemoveMSI All=&quot;True&quot; /&gt; --&gt;
  &lt;!--  &lt;Display Level=&quot;None&quot; AcceptEULA=&quot;TRUE&quot; /&gt;  --&gt;
  &lt;!--  &lt;Property Name=&quot;AUTOACTIVATE&quot; Value=&quot;1&quot; /&gt;  --&gt;
&lt;/Configuration&gt;
</code></pre>
<p><a href="https://docs.microsoft.com/en-us/office365/troubleshoot/installation/product-ids-supported-office-deployment-click-to-run">Product IDs that are supported by the Office Deployment Tool for Click-to-Run - Office 365 | Microsoft Docs</a></p>
<p>下载安装文件：</p>
<pre><code class="language-powershell">setup /download configuration.xml   # run in cmd
</code></pre>
<p>安装应用：</p>
<pre><code class="language-powershell">setup /configure configuration.xml  # run in cmd  
</code></pre>
<p>https://docs.microsoft.com/en-us/deployoffice/office2019/deploy.</p>
<h5 id="激活office"><a class="header" href="#激活office">激活Office</a></h5>
<pre><code class="language-sh"># 查看激活状态
cscript &quot;C:\Program Files\Microsoft Office\Office16\OSPP.VBS&quot; /dstatus 
# 移除key
cscript &quot;C:\Program Files\Microsoft Office\Office16\OSPP.VBS&quot; /unpkey:F6YYT
</code></pre>
<h3 id="rdp"><a class="header" href="#rdp">RDP</a></h3>
<h4 id="rdpwrap"><a class="header" href="#rdpwrap">RDPWrap</a></h4>
<p>https://raw.githubusercontent.com/sebaxakerhtc/rdpwrap.ini/master/rdpwrap.ini</p>
<h3 id="vmware-workstation"><a class="header" href="#vmware-workstation">VMWare Workstation</a></h3>
<p>VM16 Pro：<code>ZF3R0-FHED2-M80TY-8QYGC-NPKYF</code></p>
<h2 id="进程管理-3"><a class="header" href="#进程管理-3">进程管理</a></h2>
<p>查看进程信息：</p>
<pre><code class="language-powershell">tasklist /V /FI &quot;ImageName eq winlogon.exe&quot;
</code></pre>
<blockquote>
<p><code>/V</code>：显示更多信息</p>
<p><code>/FI</code>：设置过滤条件（不区分大小写）。筛选器包括：<code>Status</code>（运行状态）、<code>ImageName</code>（程序名称）、<code>Pid</code>（进程号）等等（查看<code>tasklist /?</code>）。</p>
</blockquote>
<pre><code class="language-powershell">wmic process 
</code></pre>
<blockquote>
<p><code>wmic</code>可以获得包括命令行信息在内的详细信息。</p>
</blockquote>
<pre><code class="language-powershell">Get-Process [-Name] [firefox, powershell]	# alias as ps
Get-Process DataExchangeHost -Module # need admin privilage
Get-Process WindowsTerminal -FileVersionInfo
</code></pre>
<p><a href="https://docs.microsoft.com/en-us/powershell/scripting/samples/managing-processes-with-process-cmdlets?view=powershell-7.2">Managing Processes with Process Cmdlets - PowerShell | Microsoft Docs</a></p>
<p>获取当前进程信息？</p>
<h3 id="创建进程-6"><a class="header" href="#创建进程-6">创建进程</a></h3>
<p>直接在当前终端中运行可执行程序，程序将在前台运行。</p>
<h4 id="新进程与终端分离"><a class="header" href="#新进程与终端分离">新进程与终端分离</a></h4>
<p><code>Start-Process</code>在新的进程中运行<strong>可执行文件</strong>（类似Linux <code>exec</code>）。</p>
<ul>
<li>
<p>如果指定<code>-NoNewWindow</code>，则直接在当前Shell中创建新进程，并与当前Shell分离（<em>输入输出默认仍在当前终端，除非添加重定向选项</em>）。</p>
</li>
<li>
<p>反之，首先新建一个Shell进程（桌面环境弹出控制台界面），并在新的Shell环境中运行可执行程序。可执行程序同样与Shell环境分离，因此新的Shell环境在执行启动命令后即退出。</p>
</li>
<li>
<p>在脚本中调用<code>Start-Process</code>和上述情况一致，执行脚本仅在当前Shell进程中创建一个子Shell环境。</p>
</li>
<li>
<p>如果出现新终端窗口不退出的情况（后台任务未成功与终端分离，使用<strong>Terminal</strong>作为默认终端时可能出现），可添加<code>-WindowStyle Hidden</code>（不能与<code>-NoNewWindow</code>同时使用）手动隐藏终端。</p>
<blockquote>
<p>如果直接从图形界面启动脚本，并使用<code>-NoNewWindow</code>，导致后台进程无法启动。因为系统分配的终端没有被阻塞执行完脚本内容后直接退出。使用<code>-NoNewWindow</code>会使在当前Shell环境的后台进程也退出。</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>非Windows平台上子进程<strong>总是</strong>连接到父进程终端，可以使用<code>Start-Process nohup</code>命令脱离父终端。</p>
</blockquote>
<pre><code class="language-powershell">Start-Process -FilePath command \  # -&gt; start*
              -ArgumentList ('-jar',&quot;$jEdit&quot;, '-settings=&quot;$JEditSettings&quot;')\ 
              -WorkingDirectory path \
              -RedirectStandardInput  &quot;source_file&quot;
              -RedirectStandardOutput &quot;$JEditLogs\console.out&quot; \
              -RedirectStandardError &quot;$JEditLogs\console.err&quot;  \
              -PassThru            # 返回进程对象
              -Verb [RunAs|Print|Open]  # 
$processOptions = @{...}
Start-Process $processOptions
</code></pre>
<blockquote>
<p><code>*</code>：<code>start</code>是<code>Start-Process</code>的别名，与<code>cmd</code>命令用法有区别。</p>
<pre><code class="language-powershell">start &quot;&quot; &quot;Notepad.exe&quot;  # [cmd] 脱离终端，start命令处理引号中的参数
</code></pre>
</blockquote>
<h5 id="进程启动方式"><a class="header" href="#进程启动方式">进程启动方式</a></h5>
<p>通过<code>-Verb</code>选项指定<code>-FilePath</code>传递的进程或文件的启动方式（如以管理员运行），通过以下命令查看可执行程序(如<code>PowerShell.exe</code>)可用的启动方式：</p>
<pre><code class="language-powershell">startExe = New-Object System.Diagnostics.ProcessStartInfo -Args PowerShell.exe
startExe.verbs  # -&gt; open/runas/runasuser
</code></pre>
<h4 id="从图形界面启动新进程"><a class="header" href="#从图形界面启动新进程">从图形界面启动新进程</a></h4>
<p>对于从图形界面点击脚本，其打开方式默认为终端，因此系统会首先为其创建一个Shell环境再执行程序，类似于调用<code>Start-Process powershell.exe -ArgumentList ('xxx.ps1')</code>，因此还是会弹出临时终端。</p>
<p>对于从图形界面点击<code>.exe</code>程序，则系统直接新建进程（中间不涉及创建Shell环境）。</p>
<h3 id="启动powershell任务"><a class="header" href="#启动powershell任务">启动PowerShell任务</a></h3>
<p><code>Start-Job</code>用于运行PowerShell脚本(<code>-FilePath</code>/<code>-LiteralPath</code>)或命令（<code>-ScriptBlock</code>）。</p>
<pre><code class="language-powershell">$job=Start-Job -Name PShellJob -ScriptBlock { Get-Process -Name pwsh } `
               -InitializationScript {Import-Module MapFunctions} `
               -InputObject &quot;C:\Servers.txt&quot; `   # $input
               -ArgumentList powershell, pwsh, notepad ` # 逗号分隔参数列表或数组对象$args
               -WorkingDirectory C:\Test\Scripts  # PS7 $PWD
Get-Process -Name pwsh &amp;
Receive-Job -Id $job.Id # -Keep保留已获取的输出结果。
Get-Job  # 获取当前会话启动的后台任务，可查看任务状态。
Stop-Job/Remove-Job 
</code></pre>
<blockquote>
<p>PowerShell Core 6.0+支持使用<code>&amp;</code>使启动的进程与当前终端脱离（<code>Start-Job</code>的语法糖）。</p>
</blockquote>
<p>任务类型：</p>
<ul>
<li><code>RemoteJob</code>：运行在远程会话中的任务；</li>
<li><code>BackgroundJob</code>：运行在独立进程中的任务；</li>
<li><code>PSTaskJob</code>或 <code>ThreadJob</code>运行在当前进程的独立线程中的任务。</li>
</ul>
<p><code>Invoke-Command</code>支持在本机或远程执行任务。</p>
<pre><code class="language-powershell">$s = New-PSSession -ComputerName Server02 -Credential Domain01\User01
Invoke-Command -ComputerName HostName 
               -FilePath ScriptPath
               -ScriptBlock $command
               -PSSession $s  # 在指定的PS会话中执行命令
               -InDisconnectedSession
               -AsJob # 运行为后台任务(-&gt;Start-Job)
</code></pre>
<p><a href="https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/invoke-command?view=powershell-7.2&amp;viewFallbackFrom=powershell-6">Invoke-Command (Microsoft.PowerShell.Core) - PowerShell | Microsoft Learn</a></p>
<h3 id="服务管理"><a class="header" href="#服务管理">服务管理</a></h3>
<p><a href="https://docs.microsoft.com/en-us/powershell/scripting/samples/managing-services?view=powershell-7.2">Managing Services - PowerShell | Microsoft Docs</a></p>
<h2 id="网络管理-2"><a class="header" href="#网络管理-2">网络管理</a></h2>
<p><a href="https://docs.microsoft.com/en-us/powershell/scripting/samples/performing-networking-tasks?view=powershell-7.2">Performing Networking Tasks - PowerShell | Microsoft Docs</a></p>
<h3 id="网络连接信息"><a class="header" href="#网络连接信息">网络连接信息</a></h3>
<p>显示网络信息：</p>
<pre><code class="language-powershell">netstat 
</code></pre>
<p>连接信息：</p>
<blockquote>
<p><code>-a</code>：显示所有连接（包括地址<code>0.0.0.0</code>）和侦听端口。</p>
<p><code>-b</code>：显示进程对应的可执行程序。</p>
<p><code>-n</code>：以数字形式显示地址和端口号。</p>
<p><code>-p PROTOCOL</code>：显示指定协议的连接，包括：TCP、UDP、TCPv6和UDPv6。</p>
</blockquote>
<p>路由信息：</p>
<p><code>-r</code>：路由信息；</p>
<p>统计信息：</p>
<blockquote>
<p><code>-s</code>：显示 IP、IPv6、ICMP、ICMPv6、TCP、TCPv6、UDP 和 UDPv6 的统计信息；</p>
<p><code>-e</code>：显示以太网统计信息。</p>
</blockquote>
<h5 id="arp"><a class="header" href="#arp">arp</a></h5>
<pre><code class="language-powershell">arp -agv
</code></pre>
<h5 id="ip"><a class="header" href="#ip">ip</a></h5>
<pre><code class="language-powershell">ipconfig
ping
tracert
</code></pre>
<h3 id="网络配置"><a class="header" href="#网络配置">网络配置</a></h3>
<pre><code class="language-powershell">netsh.exe  COMMAND       # netstat help
netsh.exe  -f ScriptFile
# COMMAND
# interface              - 更改网络接口配置。
# lan/wlan/bridge        - 更改有线/无线局域网/网桥配置
# firewall/advfirewall   - 更改防火墙(高级)配置
# winsock                - 更改套接字配置。
# dhcpclient/dnsclient   - 更改DHCP/DNS客户端配置。
# ipsec/http/winhttp/rpc - 更改IPSec/http/RPC配置。
# dump                   - 显示一个配置脚本。
# exec                   - 运行一个脚本文件。
# set                    - 更新配置设置。
# show                   - 显示信息。
# delete                 - 在项目列表上删除一个配置项目。
</code></pre>
<blockquote>
<p>远程管理选项：<code>[-r RemoteMachine] [-u [DomainName\]UserName] [-p Password | *]</code>。</p>
</blockquote>
<pre><code class="language-shell">netsh interface portproxy show [all|v4tov4|v4tov6|v6tov4|v6tov6]
</code></pre>
<h4 id="网络共享"><a class="header" href="#网络共享">网络共享</a></h4>
<h5 id="权限-1"><a class="header" href="#权限-1">权限</a></h5>
<h3 id="网络访问问题"><a class="header" href="#网络访问问题">网络访问问题</a></h3>
<h5 id="网络连接"><a class="header" href="#网络连接">网络连接</a></h5>
<p><strong>问题</strong>：Windows网络连接显无法连接网络，实际可以上网？</p>
<p><strong>原因</strong>：DNS服务器导致系统的网络探测服务无法正常工作，修改DNS服务器。</p>
<h5 id="网络发现问题"><a class="header" href="#网络发现问题">网络发现问题</a></h5>
<p>问题：在网络中无法查看开启共享的机器。</p>
<p>原因：目标机器相关服务可能未运行（<code>Function Discovery Provider Host</code>和<code>Function Discovery Resource Publication</code>服务）。</p>
<h5 id="共享权限"><a class="header" href="#共享权限">共享权限</a></h5>
<p>访问共享目录的用户（例如everyone）需要同时有本地文件系统的访问权限和共享目录的访问权限。</p>
<h5 id="共享安全问题"><a class="header" href="#共享安全问题">共享安全问题</a></h5>
<p>Windows 10：<code>0x80070035 找不到网络路径</code>。</p>
<pre><code class="language-powershell">[HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\LanmanWorkstation\Parameters]
&quot;AllowInsecureGuestAuth&quot;=dword:00000001
</code></pre>
<p><a href="https://blog.csdn.net/weivnuo/article/details/80934241?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.nonecase&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.nonecase">windows 10 0x80070035 找不到网络路径_SOESC.COM-CSDN博客_0x80070035</a></p>
<h4 id="uwp应用的网络代理"><a class="header" href="#uwp应用的网络代理">UWP应用的网络代理</a></h4>
<p>UWP应用（包括Microsoft Store）运行在沙箱环境中，其网络访问与物理机隔离（总是通过本地环回地址转发给物理机），因此无法使用物理机配置的网络代理。</p>
<h5 id="解除应用的本地环回限制"><a class="header" href="#解除应用的本地环回限制">解除应用的本地环回限制</a></h5>
<p>以应用商店程序为例：</p>
<ul>
<li>
<p>基于UWP应用可执行文件的所在路径（通过任务管理器找到可执行文件，查看其属性可找到其位置），确定UWP应用包名<code>Microsoft.WindowsStore_22207.1401.9.0_x64__8wekyb3d8bbwe</code>。</p>
</li>
<li>
<p>通过UWP包名中的App名称<code>WindowsStore</code>，在注册表中查找应用对应的安全标识符SID（<code>Mappings</code>条目下的名称）或系列名称(<code>Moniker</code>)</p>
<pre><code class="language-ini">[HKEY_CURRENT_USER\SOFTWARE\Classes\Local Settings\Software\Microsoft\Windows\CurrentVersion\AppContainer\Mappings\S-1-15-2-1609473798-1231923017-684268153-4268514328-882773646-2760585773-1760938157]
&quot;DisplayName&quot;=&quot;Microsoft Store&quot;
&quot;Moniker&quot;=&quot;microsoft.windowsstore_8wekyb3d8bbwe&quot;
</code></pre>
</li>
<li>
<p>使用<code>CheckNetisolation</code>程序，传入SID或系列名称解除本地环回限制。</p>
<pre><code class="language-powershell">CheckNetIsolation.exe loopbackexempt -a/-d -p=$SID -n=$Moniker # 添加/移除例外项
CheckNetIsolation.exe LoopbackExempt -s # 列出已解除的列表
</code></pre>
</li>
</ul>
<h5 id="修改系统winhttp代理规则"><a class="header" href="#修改系统winhttp代理规则">修改系统WinHttp代理规则</a></h5>
<pre><code class="language-powershell">netsh winhttp import proxy source=ie  # 使用系统设置中配置的代理服务器
netsh winhttp show proxy              # 查看当前配置
</code></pre>
<p><a href="https://learn.microsoft.com/en-us/windows/win32/winhttp/winhttp-start-page">Windows HTTP Services - Win32 apps | Microsoft Learn</a></p>
<h3 id="虚拟网络"><a class="header" href="#虚拟网络">虚拟网络</a></h3>
<h4 id="vmware虚拟网络"><a class="header" href="#vmware虚拟网络"><a href="Windows/../%E6%9C%8D%E5%8A%A1%E5%99%A8/%E8%99%9A%E6%8B%9F%E5%8C%96.html#%E8%99%9A%E6%8B%9F%E7%BD%91%E7%BB%9C">VMWare虚拟网络</a></a></h4>
<h4 id="wsl虚拟网络"><a class="header" href="#wsl虚拟网络"><a href="Windows/../%E6%9C%8D%E5%8A%A1%E5%99%A8/%E8%99%9A%E6%8B%9F%E5%8C%96.html#WSL%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE">WSL</a>虚拟网络</a></h4>
<ol>
<li>
<p>在Windows主机上通过<code>localhost</code>可访问WSL开放的服务；</p>
<blockquote>
<p>使用<code>127.0.0.1</code>不能访问WSL的服务。</p>
</blockquote>
</li>
<li>
<p>WSL和Windows主机连接到内置的Hyper-V虚拟网络，因此可使用同一网段的IP地址互相访问；</p>
<blockquote>
<p>通过Windows主机的网络管理可以找到Windows主机在虚拟网络中的地址；WSL中<code>/etc/resolv.conf</code>记载了Windows主机的IP地址（作为WSL的域名服务）；</p>
<p>WSL的<code>/etc/hosts</code>也记录了Windows中手动配置的域名。</p>
</blockquote>
</li>
<li>
<p>局域网访问WSL服务：WSL服务需要绑定到虚拟网卡IP地址而非本地环回地址，WSL中开放的端口会通过Windows主机的<code>wslhost.exe</code>进行端口转发（默认仅监听WSL2的<code>localhost</code>，需要使用以下脚本添加监听地址，或使用<a href="https://github.com/CzBiX/WSLHostPatcher">WSL Host Patcher</a>自动监听并转发WSL2中打开的端口）。同时，确保Windows防火墙策略允许外部IP访问<code>wslhost.exe</code>应用。</p>
<pre><code class="language-powershell"># 1. Get IP Address of WSL 2 machine
# 2. Remove previous port forwarding rules
netsh interface portproxy delete v4tov4 
    listenport=$host_port listenaddress=$host_addr ...
# 3. Add port Forwarding rules
netsh interface portproxy add v4tov4 
    listenport=$host_port listenaddress=$host_addr  # (0.0.0.0)
    connectport=$wsl_port connectaddress=$wsl_addr 
</code></pre>
<p><a href="https://github.com/microsoft/WSL/issues/4150">WSL 2 NIC Bridge mode 🖧 (Has TCP Workaround🔨)</a></p>
</li>
</ol>
<h4 id="docker-on-wsl2"><a class="header" href="#docker-on-wsl2"><a href="Windows/../%E6%9C%8D%E5%8A%A1%E5%99%A8/%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92.html#%E5%9C%B0%E5%9D%80%E7%AB%AF%E5%8F%A3%E6%98%A0%E5%B0%84">Docker</a> on WSL2</a></h4>
<p><strong>通过VMWare NAT网络连接的VM<code>-&gt;</code>本地Docker服务</strong>：VM需要使用本地主机的物理地址（而非主机在虚拟机子网中的地址）访问Docker服务。虽然Docker已经将Docker服务端口映射到物理端口，但其绑定的IP地址实际不包含虚拟网卡地址（如VMWare虚拟网卡）。因此，VM中发起的请求必须经过源NAT，以访问主机物理地址上的服务。</p>
<h2 id="用户管理-3"><a class="header" href="#用户管理-3">用户管理</a></h2>
<pre><code class="language-powershell">whoami /UPN     # User Principal Name (域用户)
       /FQDN    # Fully Qualified Differentiable Name (域用户)
       /LOGONID # 当前用户的登录ID (S-1-5-5-0-28587288)
whoami /USER    # 显示用户名与安全标识符 (SID)
       /GROUPS  # 用户所属组名称、类型、SID 和属性。
       /CLAIMS  # 当前用户的声明
       /PRIV    # 当前用户的安全特权
       /ALL
       [/FO format] # format=TABL(default)|LIST|CSV
       [/NH]    #
</code></pre>
<h2 id="安全-3"><a class="header" href="#安全-3">安全</a></h2>
<h3 id="证书管理"><a class="header" href="#证书管理">证书管理</a></h3>
<p>通过Windows“运行”对话框（<code>Win+R</code>启动）打开证书管理工具：</p>
<ul>
<li><code>certmgr.msc</code>：当前用户证书管理；</li>
<li><code>certlm.msc</code>：本地计算机证书管理（需要管理员权限）；</li>
</ul>
<h5 id="安装证书-2"><a class="header" href="#安装证书-2">安装证书</a></h5>
<p>点击证书文件进行安装，可选择存储位置为当前用户或本地计算机（需要管理员权限）。</p>
<p>再证书管理工具中，可通过拖拽更改证书所属路径。</p>
<h5 id="证书类型"><a class="header" href="#证书类型">证书类型</a></h5>
<div class="table-wrapper"><table><thead><tr><th>类型</th><th>标识符</th></tr></thead><tbody>
<tr><td>个人</td><td><code>My</code></td></tr>
<tr><td>==中间证书颁发机构==</td><td><code>CA</code></td></tr>
<tr><td>==第三方根证书颁发机构==</td><td><code>AuthRoot</code></td></tr>
<tr><td>==受信任的根证书颁发机构==</td><td><code>Root</code></td></tr>
<tr><td>企业信任</td><td><code>Trust</code></td></tr>
<tr><td>受信任的发布者</td><td><code>TrustedPublisher</code></td></tr>
<tr><td>受信任的封装应用安装颁发机构</td><td><code>TrustedAppRoot</code>+</td></tr>
<tr><td>受信任的设备</td><td><code>TrustedDevices</code>*+</td></tr>
<tr><td>受信任人</td><td><code>TrustedPeople</code>*</td></tr>
<tr><td>其他人</td><td><code>ADDRESSBOOK</code></td></tr>
<tr><td>智能卡受信任的根</td><td><code>SmartCardRoot</code>*</td></tr>
<tr><td>客户端身份验证颁发者</td><td><code>ClientAuthIssuer</code>*</td></tr>
<tr><td>Active Directory 用户对象</td><td><code>UserDS</code>*</td></tr>
<tr><td>-</td><td><code>AAD Token Issuer</code>*+</td></tr>
<tr><td>证书注册申请</td><td><code>REQUEST</code>*</td></tr>
<tr><td>不信任的证书</td><td><code>Disallowed</code>*</td></tr>
<tr><td>测试版根目录</td><td><code>TestSignRoot</code>+</td></tr>
<tr><td>预览版根</td><td><code>FlightRoot</code>+</td></tr>
<tr><td>远程桌面</td><td><code>Remote Desktop</code>+</td></tr>
<tr><td>-</td><td><code>WindowsServerUpdateServices</code>*+</td></tr>
<tr><td>-</td><td><code>eSIM Certification Authorities</code>+</td></tr>
<tr><td>-</td><td><code>Windows Live ID Token Issuer</code>+</td></tr>
<tr><td>-</td><td><code>Homegroup Machine Certificates</code>*+</td></tr>
<tr><td>-</td><td><code>Local NonRemovable Certificates</code>*</td></tr>
<tr><td>-</td><td><code>MSIEHistoryJournal</code>*</td></tr>
</tbody></table>
</div>
<blockquote>
<p><code>*</code>通常为空目录。</p>
<p><code>+</code>本地计算机目录下才有的类型。</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="windows配置管理-1"><a class="header" href="#windows配置管理-1">Windows配置管理</a></h1>
<h2 id="安装-9"><a class="header" href="#安装-9">安装</a></h2>
<p>磁盘初始化，如果回收磁盘空间重新初始化，则会创建单独的启动分区。</p>
<h3 id="uefi-1"><a class="header" href="#uefi-1">UEFI</a></h3>
<p>以UEFI模式安装系统，启动设备需要使用FAT32文件系统。</p>
<p>问题：无法为安装介质加载驱动程序</p>
<p>切换到USB2.0接口。</p>
<h2 id="管理工具-1"><a class="header" href="#管理工具-1">管理工具</a></h2>
<p><a href="Windows/./Windows%20Shell.html#WMI%E5%92%8CCIM">WMI and CIM</a></p>
<h3 id="远程访问-1"><a class="header" href="#远程访问-1">远程访问</a></h3>
<p>通过会话访问远程主机并执行命令。在目标机器上启用PowerShell远程会话：</p>
<pre><code class="language-powershell">Enable-PSRemoting  # 以管理员身份运行，网络类型“专用”
</code></pre>
<blockquote>
<p><em>由于此计算机上的网络连接类型之一设置为公用，因此 WinRM 防火墙例外将不运行。 将网络连接类型更改为域或专用，然后再次尝试。</em></p>
</blockquote>
<pre><code class="language-powershell">$Cred = Get-Credential    # 弹出对话框选择账号并输入密码
Enter-PSSession -ComputerName dc01 -Credential $Cred #建立远程登录会话
Exit-PSSession
</code></pre>
<blockquote>
<p>错误：使用 winrm.cmd 配置 <code>TrustedHosts</code>。</p>
</blockquote>
<pre><code class="language-powershell">Invoke-Command -ComputerName dc01, sql02, web01 {Get-Service -Name W32time} -Credential $Cred

$Session = New-PSSession -ComputerName dc01, sql02, web01 -Credential $Cred
Invoke-Command -Session $Session {(Get-Service -Name W32time).start()}
Invoke-Command -Session $Session {Get-Service -Name W32time}
Get-PSSession | Remove-PSSession  # close established sessions
</code></pre>
<h2 id="硬件-1"><a class="header" href="#硬件-1">硬件</a></h2>
<h3 id="主板-1"><a class="header" href="#主板-1">主板</a></h3>
<pre><code class="language-powershell">wmic baseboard get Manufacturer,Model,Name,PartNumber,serialnumber
</code></pre>
<h3 id="cpu-4"><a class="header" href="#cpu-4">CPU</a></h3>
<pre><code class="language-powershell">wmic cpu
</code></pre>
<h3 id="gpu-1"><a class="header" href="#gpu-1">GPU</a></h3>
<pre><code class="language-powershell">dxdiag
nvidia-smi
</code></pre>
<h3 id="bios-1"><a class="header" href="#bios-1">BIOS</a></h3>
<pre><code class="language-powershell">wmic BIOS get name,version,serialnumber
Get-WmiObject -Class Win32_Bios | Format-List -Property *
</code></pre>
<blockquote>
<p><code>serialnumber</code>为主机序列号。</p>
</blockquote>
<h3 id="内存-4"><a class="header" href="#内存-4">内存</a></h3>
<pre><code class="language-powershell">wmic MemoryChip get BankLabel,Capacity,MemoryType,TypeDetail,Speed,Tag
</code></pre>
<p>虚拟内存配置：如果系统物理内存足够大，可选择关闭系统分页文件：<code>pagefile.sys</code>，<code>swapfile.sys</code>以节省磁盘空间。</p>
<h3 id="磁盘-2"><a class="header" href="#磁盘-2">磁盘</a></h3>
<p>列出物理磁盘信息：</p>
<pre><code class="language-powershell">wmic diskdrive list brief   # DeviceID as disks path
wmic diskdrive get Name,Model,InterfaceType,MediaType,SerialNumber,Size,Status
wmic PARTITION
wmic VOLUME
</code></pre>
<blockquote>
<p>可查看型号（<code>Model</code>）、序列号（<code>SerialNumber</code>）。</p>
</blockquote>
<pre><code class="language-bash">diskpart		# 启动磁盘管理交互环境
</code></pre>
<p>在交互环境中可执行的命令（通过<code>help</code>查看）：</p>
<div class="table-wrapper"><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody>
<tr><td>`list disk</td><td>partition</td></tr>
<tr><td>`select disk</td><td>parition</td></tr>
<tr><td><code>rescan</code></td><td>重新扫描计算机，查找磁盘和卷</td></tr>
<tr><td><code>clean</code></td><td>从磁盘清除配置信息或所有信息。</td></tr>
<tr><td><code>compact</code></td><td>尝试减少文件的物理大小。</td></tr>
<tr><td><code>convert</code></td><td>在不同的磁盘格式之间转换。</td></tr>
<tr><td><code>create</code></td><td>创建卷、分区或虚拟磁盘。</td></tr>
<tr><td><code>format</code></td><td>格式化卷或分区</td></tr>
<tr><td><code>shrink</code></td><td>减小选定卷。</td></tr>
<tr><td><code>remove</code></td><td>删除驱动器号或装载点分配。</td></tr>
<tr><td><code>delete</code></td><td>删除对象。</td></tr>
<tr><td><code>exit</code></td><td>退出<code>diskpart</code>。</td></tr>
</tbody></table>
</div>
<h5 id="磁盘分区类型-1"><a class="header" href="#磁盘分区类型-1">磁盘分区类型</a></h5>
<p>如果在MBR分区类型的磁盘上安装了</p>
<p><code>mbr2gpt</code>可将MBR分区类型的磁盘转换为GPT分区类型，而无需移动磁盘上的数据。</p>
<pre><code class="language-powershell">mbr2gpt /validate        # 验证选定磁盘可进行转换操作（未指定磁盘则使用安装系统的磁盘）
        /convert /disk:N # 验证并执行转换操作
        /allowFullOS     # 使该命令可用于完整Windows环境（默认仅用于PE环境，推荐）
</code></pre>
<p>打开高级启动模式：“<code>设置-&gt;更新和安全-&gt;恢复-&gt;高级启动-&gt;立即重新启动</code>”（或按住<code>Shift</code>键点击重启按钮）；在启动选项中选择：<code>疑难解答-&gt;高级选项-&gt;命令行</code>，然后重新启动电脑，执行上述命令。</p>
<h3 id="电源管理-1"><a class="header" href="#电源管理-1">电源管理</a></h3>
<pre><code class="language-powershell">powercfg /a      # 睡眠状态
powercfg -H OFF  # 关闭休眠模式(删除系统磁盘下的hyberfi.sys文件)
# /LIST、/L          列出所有电源方案。
</code></pre>
<h3 id="网络接口-1"><a class="header" href="#网络接口-1">网络接口</a></h3>
<pre><code class="language-powershell">wmic nic get AdapterType,Name,MACAddress,Speed,NetConnectionStatus
</code></pre>
<h2 id="系统管理-1"><a class="header" href="#系统管理-1">系统管理</a></h2>
<h3 id="系统信息-5"><a class="header" href="#系统信息-5">系统信息</a></h3>
<pre><code class="language-sh">systeminfo	# 输出系统信息[CLI]
msinfo32    # 系统信息[GUI]
ver         # [cmd]查看系统版本
winver      # [GUI]查看系统版本对话框
wmic COMPUTERSYSTEM
wmic OS
Get-ComputerInfo -Property &quot;*version&quot;
Get-WmiObject -Class Win32_ClassName | Format-List -Property '*'
</code></pre>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/cimwin32prov/computer-system-hardware-classes?redirectedfrom=MSDN">Computer System Hardware Classes - Win32 apps | Microsoft Docs</a></p>
<p><a href="https://docs.microsoft.com/en-us/previous-versions//aa392727(v=vs.85)">Operating System Classes (Windows) | Microsoft Docs</a></p>
<p><a href="https://docs.microsoft.com/en-us/powershell/scripting/samples/collecting-information-about-computers?view=powershell-7.2">Collecting Information About Computers - PowerShell | Microsoft Docs</a></p>
<h5 id="系统启动信息-1"><a class="header" href="#系统启动信息-1">系统启动信息</a></h5>
<p>启动配置数据存储编辑器：</p>
<pre><code class="language-powershell">bcdedit /delete {uuid}
</code></pre>
<blockquote>
<p>单独运行 &quot;<code>bcdedit</code>&quot; 等同于运行 &quot;<code>bcdedit /enum ACTIVE</code>&quot;(列出激活的启动项)。</p>
</blockquote>
<h3 id="注册表-1"><a class="header" href="#注册表-1">注册表</a></h3>
<p><a href="https://docs.microsoft.com/en-us/powershell/scripting/samples/working-with-registry-entries?view=powershell-7.2">Working with Registry Entries - PowerShell | Microsoft Docs</a></p>
<p><a href="https://docs.microsoft.com/en-us/powershell/scripting/samples/working-with-registry-keys?view=powershell-7.2">Working with Registry Keys - PowerShell | Microsoft Docs</a></p>
<h2 id="文件管理-4"><a class="header" href="#文件管理-4">文件管理</a></h2>
<pre><code class="language-powershell">Set-Location [-Path] path # &gt;&gt; cd, chdir
</code></pre>
<blockquote>
<p>切换当前目录。</p>
</blockquote>
<h5 id="读取目录-1"><a class="header" href="#读取目录-1">读取目录</a></h5>
<pre><code class="language-powershell">Get-ChildItem -Recursive -Path *.txt  # &gt;&gt; dir
</code></pre>
<h5 id="创建文件-1"><a class="header" href="#创建文件-1">创建文件</a></h5>
<pre><code class="language-powershell">New-Item -ItemType &quot;file&quot; -Path . -Name &quot;testfile1.txt&quot; -Value &quot;This is a text string.&quot;
New-Item -ItemType &quot;directory&quot; -Path &quot;c:\&quot; -Name &quot;logfiles&quot; # -&gt; mkdir
</code></pre>
<h5 id="链接文件-1"><a class="header" href="#链接文件-1">链接文件</a></h5>
<p>硬链接(<em>Hard link</em>)==只能用于文件==，且不能跨磁盘使用。多个硬链接可以指向同一个文件，并且删除一个硬链接或原始文件，其他硬链接仍然可以访问。删除软链接(<em>Symbolic link</em>)不会影响原始文件，但删除原始文件会使软链接失效。</p>
<blockquote>
<p><strong>权限</strong>：创建符号链接需要有“<code>SeCreateSymbolicLinkPrivilege</code>”用户权利，administrators 组成员默认具有此权利。 这个权利可以在“<code>本地安全策略（secpol.msc）\本地策略\用户权利分配</code>”中设置。</p>
</blockquote>
<pre><code class="language-powershell">New-Item -ItemType SymbolicLink -Path &quot;Link&quot; -Target &quot;Target&quot;
</code></pre>
<p><code>-ItemType SymbolicLink|Junction|HardLink</code>：
<code>-Path</code>：符号链接文件的路径；
<code>-Target</code>：符号链接的目标路径；
<code>-Force</code>：覆盖已有文件。</p>
<blockquote>
<p>cmd:</p>
<pre><code class="language-powershell">mklink {/D|/H|/J} Link Target
</code></pre>
<p><code>/D</code>：创建目录符号链接(symbolic link)，默认为文件符号链接。
<code>/H</code>：创建硬链接(hard link)而非符号链接，目标文件必须位于同一磁盘分区（卷）。
<code>/J</code>：创建目录联接(junction)，目录必须位于本地。
<code>Link</code>指定新的符号链接名称，<code>Target</code>指定新链接引用的路径 (相对或绝对)。</p>
<p>Adobe Reader保存文件时，可能会先删除原有文件，再创建新文件，由此使得指向原文件的硬链接与新文件不同。</p>
</blockquote>
<h5 id="查看文件链接-1"><a class="header" href="#查看文件链接-1">查看文件链接</a></h5>
<pre><code class="language-shell">dir path -recurse -force | ?{$_.LinkType} | select FullName,LinkType,Target
</code></pre>
<blockquote>
<p><code>dir-&gt;Get-ChildItem</code></p>
</blockquote>
<h5 id="复制移动文件-1"><a class="header" href="#复制移动文件-1">复制移动文件</a></h5>
<pre><code class="language-powershell">del filename  % 删除文件。
dir
rmdir
move
</code></pre>
<pre><code class="language-powershell">Move-Item -Path C:\test.txt -Destination E:\Temp\tst.txt  # move file
Move-Item -Path C:\Temp -Destination C:\Logs # move folder
Move-Item -Path .\*.txt -Destination C:\Logs # wildcard
</code></pre>
<h3 id="查找-9"><a class="header" href="#查找-9">查找</a></h3>
<h4 id="查找可执行程序-1"><a class="header" href="#查找可执行程序-1">查找可执行程序</a></h4>
<pre><code class="language-powershell">Get-Command dotnet  # [gcm]   -&gt; &quot;where&quot; in cmd
#CommandType     Name          Version    Source
#-----------     ----          -------    ------
#Application     dotnet.exe    5.0.152... C:\Program Files\dotnet\dotnet.exe
</code></pre>
<h2 id="应用管理-1"><a class="header" href="#应用管理-1">应用管理</a></h2>
<p>https://dev.to/bowmanjd/chocolatey-vs-scoop-package-managers-for-windows-2kik</p>
<p><a href="https://docs.microsoft.com/en-us/powershell/scripting/samples/working-with-software-installations?view=powershell-7.2">Working with Software Installations - PowerShell | Microsoft Docs</a></p>
<pre><code class="language-powershell">Get-CimInstance -Class Win32_Product | Select-Object -Property Name,Vendor,Version
</code></pre>
<h3 id="离线安装-2"><a class="header" href="#离线安装-2">离线安装</a></h3>
<h4 id="appx包-1"><a class="header" href="#appx包-1">appx包</a></h4>
<h5 id="获取appx包-1"><a class="header" href="#获取appx包-1">获取appx包</a></h5>
<p>包括<code>AppxBundle</code>和<code>appx</code>包，其中<code>AppxBundle</code>是多个<code>appx</code>包的合集。</p>
<ol>
<li>软件发布者在GitHub等网站提供<code>appx</code>包的下载（某些可能为将依赖项打包）；</li>
<li>从应用商店获取应用的分享链接，然后在<a href="https://store.rg-adguard.net/">Microsoft Store - Generation Project</a>查找并下载应用的<code>appx</code>包及其依赖包。</li>
</ol>
<h5 id="安装-10"><a class="header" href="#安装-10">安装</a></h5>
<p>以管理员身份使用PowerShell命令提供安装选项：</p>
<pre><code class="language-powershell">Add-AppxPackage FILENAME.appx
</code></pre>
<blockquote>
<p>双击软件包即也可执行安装。但<strong>离线安装程序无法启动，提示找不到启动文件</strong>：可能是由于安装位置<code>C:\Program Files\WindowsApps</code>没有访问权限。由于以上两种文件格式都是以<code>zip</code>格式封装，因此可以提取其中的<code>appx</code>包内容并手动安装到用户提供目录下。</p>
<p>安装如果出现证书无法被信任的问题，需要将<code>appx</code>包所带证书（通过“属性/数字签名”查看）安装到本机的证书目录下（选择“受信任的<code>xxx</code>”）。</p>
</blockquote>
<h3 id="winget-1"><a class="header" href="#winget-1">winget</a></h3>
<pre><code class="language-powershell">winget list [-q QUERY] # 显示已安装软件列表（包括非winget安装）
       --id ID
       --name NAME
       --source SOURCE  # -s 使用指定的源查找程序包
       --count          # -n 显示不超过指定数量的结果 
       --exact          # -e 使用精确匹配
winget list &gt; winget.installed.txt   # 在cmd中执行避免乱码
</code></pre>
<blockquote>
<p>即使非<code>winget</code>安装，如果在相应软件源发现匹配软件，仍会显示相应的源（<code>msstore/winget</code>）。</p>
</blockquote>
<pre><code class="language-powershell">winget search PACKAGE --source SOURCE
winget show PACKAGE --source SOURCE  # 显示软件的详细信息
winget search &gt; winget.repo.txt      # 在cmd中执行避免乱码
</code></pre>
<blockquote>
<p>当<code>show</code>发现多个匹配时，会提示用户提供更精确的包名或限定源。</p>
</blockquote>
<pre><code class="language-powershell">winget install &lt;package&gt; --source msstore
       upgrade
       uninstall
winget export --output FILE --source SOURCE
       import --import-file FILE
</code></pre>
<pre><code class="language-powershell">winget source list \         # 列出源的名称和URL
              --name winget  # 列出指定源的详细信息 
winget settings  # 打开设置文件进行编辑
</code></pre>
<h3 id="chocolatey-1"><a class="header" href="#chocolatey-1">Chocolatey</a></h3>
<h5 id="配置-1"><a class="header" href="#配置-1">配置</a></h5>
<pre><code class="language-bash">choco source [list]								# 列出软件源
choco source add -n=REPONAME -s=url
choco source enable/disable/remove -n=REPONAME
choco config [list]								# 列出配置信息
choco config get [--name] CONFIG_NAME
choco config set [--name] CONFIG_NAME --value VALUE
</code></pre>
<h5 id="搜索软件-1"><a class="header" href="#搜索软件-1">搜索软件</a></h5>
<pre><code class="language-sh">choco list/find/search openjdk[--exact --verbose]
choco list/find/search &lt;appname&gt; --local-only # 查找已安装应用
choco info pkgname
</code></pre>
<h5 id="更新-3"><a class="header" href="#更新-3">更新</a></h5>
<pre><code class="language-powershell">choco upgrade &lt;appname&gt;|all --except=&quot;appname,...&quot; # 升级应用
choco outdated   # 列出可更新软件 upgrade all --noop
choco pin &lt;package_name&gt;  # 固定软件版本
</code></pre>
<h5 id="安装卸载-1"><a class="header" href="#安装卸载-1">安装卸载</a></h5>
<pre><code class="language-powershell">choco install &lt;appname&gt;	
choco uninstall &lt;appname&gt;
</code></pre>
<h4 id="搭建本地软件仓库-1"><a class="header" href="#搭建本地软件仓库-1">搭建本地软件仓库</a></h4>
<h5 id="使用nexus代理-2"><a class="header" href="#使用nexus代理-2">使用Nexus代理</a></h5>
<p>仅代理Chocolaty安装脚本信息（<code>nuget</code>），软件的安装文件仍然需要访问官方资源。因此该代理只是提高对软件仓库的查询速度，而不能离线部署。</p>
<pre><code class="language-shell">Name=chocolatey
Format=nuget
URL=http://172.28.76.100:8081/repository/chocolatey/
Protocl=&quot;NuGet V2&quot;
Remote=https://chocolatey.org/api/v2/
</code></pre>
<p><a href="https://docs.chocolatey.org/en-us/features/host-packages">Chocolatey Software Docs | Host packages internally</a></p>
<h3 id="scoop-1"><a class="header" href="#scoop-1">Scoop</a></h3>
<p>如果没有管理员权限，则采用Scoop更加合适。</p>
<pre><code class="language-powershell"># Enable execution of PowerShell scripts
Set-ExecutionPolicy AllSigned
Set-ExecutionPolicy RemoteSigned -scope CurrentUser
Invoke-Expression (
	New-Object System.Net.WebClient).DownloadString('https://get.scoop.sh')
# or shorter: iwr -useb get.scoop.sh | iex
</code></pre>
<pre><code class="language-powershell">scoop search [&lt;app&gt;]   # 省略app名称将列出仓库中所有可用软件
scoop info &lt;app&gt; # 显示软件信息（含必要配置说明）
scoop install|uninstall &lt;app&gt;
scoop list
scoop status   # 检查软件是否有新版本
scoop hold|unhold &lt;app&gt;  # 停用/启用更新 
scoop update [&lt;app&gt;]  # 更新scoop或指定软件
scoop cleanup *  # 清理所有旧版软件, 清理指定软件, 清理过期的安装包
scoop cleanup &lt;app&gt;
</code></pre>
<blockquote>
<p>安装的软件在<code>~\scoop\apps</code>目录下。</p>
</blockquote>
<h5 id="软件源-1"><a class="header" href="#软件源-1">软件源</a></h5>
<p><a href="https://rasa.github.io/scoop-directory/by-apps">Scoop buckets by number of apps | scoop-directory (rasa.github.io)</a></p>
<pre><code class="language-powershell">scoop bucket add|list|known|rm &lt;bucket&gt;
</code></pre>
<h5 id="下载-2"><a class="header" href="#下载-2">下载</a></h5>
<p>利用<code>aria2</code>加速下载：</p>
<pre><code class="language-powershell">scoop install aria2
scoop config aria2-enabled true                   # default: true
scoop config aria2-retry-wait 8                   # default: 2
scoop config aria2-split 8                        # default: 5
scoop config aria2-max-connection-per-server 8    # default: 5
scoop config aria2-min-split-size 2M              # default: 5M
</code></pre>
<p>添加库 versions, 可以安装其他（落后的)版本：</p>
<pre><code class="language-powershell">scoop bucket add versions
scoop install python@3.7.7
</code></pre>
<h3 id="msys2-1"><a class="header" href="#msys2-1">MSYS2</a></h3>
<blockquote>
<p><em>Software Distribution and Building Platform for Windows.</em></p>
<ul>
<li>
<p>Terminal: <code>mintty</code>、<code>bash</code>；</p>
</li>
<li>
<p>CLI tools：<code>git</code>、<code>tar</code>、<code>awk</code>；</p>
</li>
<li>
<p>Develop tools：GCC, mingw-w64, CPython, CMake, Meson, OpenSSL, FFmpeg, Rust, Ruby。</p>
<p><img src="Windows/assets/msys-environment.png" alt="image-20221020132233008" /></p>
<p><a href="https://www.msys2.org/docs/environments/">Environments - MSYS2</a></p>
</li>
<li>
<p>package management：<code> Pacman</code>（Arch Linux）</p>
</li>
</ul>
</blockquote>
<p><a href="https://www.msys2.org/docs/what-is-msys2/">What is MSYS2? - MSYS2</a></p>
<pre><code class="language-powershell">winget install msys2.msys2
</code></pre>
<pre><code class="language-shell">用法:  pacman &lt;操作&gt; [...]
操作:
    pacman {-h --help}
    pacman {-V --version}
    pacman {-D --database} &lt;选项&gt; &lt;软件包&gt;
    pacman {-F --files}    [选项] [文件]
    pacman {-Q --query}    [选项] [软件包]
    pacman {-R --remove}   [选项] &lt;软件包&gt;
    pacman {-S --sync}     [选项] [软件包]
    pacman {-T --deptest}  [选项] [软件包]
    pacman {-U --upgrade}  [选项] &lt;文件&gt;
</code></pre>
<p>MSYS2提供模拟文件系统，其物理位置为MSYS2安装目录（可直接从物理系统访问其中内容）。</p>
<pre><code class="language-shell">df -hT /home/gary/
# 文件系统       类型   容量   已用  可用   已用% 挂载点
# C:/msys64     ntfs  931G  221G  711G   24%  /
</code></pre>
<h3 id="office-1"><a class="header" href="#office-1">Office</a></h3>
<p>安装office部署工具（Office Deployment Tool）。</p>
<p>配置文件（<code>configuration.xml</code>）</p>
<pre><code class="language-powershell">&lt;Configuration&gt;
  &lt;Add OfficeClientEdition=&quot;64&quot; Channel=&quot;Monthly&quot;&gt; &lt;!--PerpetualVL2019--&gt;
    &lt;Product ID=&quot;HomeStudent2019Retail&quot;&gt;  
    &lt;!-- ProPlus2019Volume|VisioPro2019Volume... --&gt;
      &lt;Language ID=&quot;zh-cn&quot; /&gt;
    &lt;/Product&gt;
  &lt;/Add&gt;
  &lt;!--  &lt;RemoveMSI All=&quot;True&quot; /&gt; --&gt;
  &lt;!--  &lt;Display Level=&quot;None&quot; AcceptEULA=&quot;TRUE&quot; /&gt;  --&gt;
  &lt;!--  &lt;Property Name=&quot;AUTOACTIVATE&quot; Value=&quot;1&quot; /&gt;  --&gt;
&lt;/Configuration&gt;
</code></pre>
<p><a href="https://docs.microsoft.com/en-us/office365/troubleshoot/installation/product-ids-supported-office-deployment-click-to-run">Product IDs that are supported by the Office Deployment Tool for Click-to-Run - Office 365 | Microsoft Docs</a></p>
<p>下载安装文件：</p>
<pre><code class="language-powershell">setup /download configuration.xml   # run in cmd
</code></pre>
<p>安装应用：</p>
<pre><code class="language-powershell">setup /configure configuration.xml  # run in cmd  
</code></pre>
<p>https://docs.microsoft.com/en-us/deployoffice/office2019/deploy.</p>
<h5 id="激活office-1"><a class="header" href="#激活office-1">激活Office</a></h5>
<pre><code class="language-sh"># 查看激活状态
cscript &quot;C:\Program Files\Microsoft Office\Office16\OSPP.VBS&quot; /dstatus 
# 移除key
cscript &quot;C:\Program Files\Microsoft Office\Office16\OSPP.VBS&quot; /unpkey:F6YYT
</code></pre>
<h3 id="rdp-1"><a class="header" href="#rdp-1">RDP</a></h3>
<h4 id="rdpwrap-1"><a class="header" href="#rdpwrap-1">RDPWrap</a></h4>
<p>https://raw.githubusercontent.com/sebaxakerhtc/rdpwrap.ini/master/rdpwrap.ini</p>
<h3 id="vmware-workstation-1"><a class="header" href="#vmware-workstation-1">VMWare Workstation</a></h3>
<p>VM16 Pro：<code>ZF3R0-FHED2-M80TY-8QYGC-NPKYF</code></p>
<h2 id="进程管理-4"><a class="header" href="#进程管理-4">进程管理</a></h2>
<p>查看进程信息：</p>
<pre><code class="language-powershell">tasklist /V /FI &quot;ImageName eq winlogon.exe&quot;
</code></pre>
<blockquote>
<p><code>/V</code>：显示更多信息</p>
<p><code>/FI</code>：设置过滤条件（不区分大小写）。筛选器包括：<code>Status</code>（运行状态）、<code>ImageName</code>（程序名称）、<code>Pid</code>（进程号）等等（查看<code>tasklist /?</code>）。</p>
</blockquote>
<pre><code class="language-powershell">wmic process 
</code></pre>
<blockquote>
<p><code>wmic</code>可以获得包括命令行信息在内的详细信息。</p>
</blockquote>
<pre><code class="language-powershell">Get-Process [-Name] [firefox, powershell]	# alias as ps
Get-Process DataExchangeHost -Module # need admin privilage
Get-Process WindowsTerminal -FileVersionInfo
</code></pre>
<p><a href="https://docs.microsoft.com/en-us/powershell/scripting/samples/managing-processes-with-process-cmdlets?view=powershell-7.2">Managing Processes with Process Cmdlets - PowerShell | Microsoft Docs</a></p>
<p>获取当前进程信息？</p>
<h3 id="创建进程-7"><a class="header" href="#创建进程-7">创建进程</a></h3>
<p>直接在当前终端中运行可执行程序，程序将在前台运行。</p>
<h4 id="新进程与终端分离-1"><a class="header" href="#新进程与终端分离-1">新进程与终端分离</a></h4>
<p><code>Start-Process</code>在新的进程中运行<strong>可执行文件</strong>（类似Linux <code>exec</code>）。</p>
<ul>
<li>
<p>如果指定<code>-NoNewWindow</code>，则直接在当前Shell中创建新进程，并与当前Shell分离（<em>输入输出默认仍在当前终端，除非添加重定向选项</em>）。</p>
</li>
<li>
<p>反之，首先新建一个Shell进程（桌面环境弹出控制台界面），并在新的Shell环境中运行可执行程序。可执行程序同样与Shell环境分离，因此新的Shell环境在执行启动命令后即退出。</p>
</li>
<li>
<p>在脚本中调用<code>Start-Process</code>和上述情况一致，执行脚本仅在当前Shell进程中创建一个子Shell环境。</p>
</li>
<li>
<p>如果出现新终端窗口不退出的情况（后台任务未成功与终端分离，使用<strong>Terminal</strong>作为默认终端时可能出现），可添加<code>-WindowStyle Hidden</code>（不能与<code>-NoNewWindow</code>同时使用）手动隐藏终端。</p>
<blockquote>
<p>如果直接从图形界面启动脚本，并使用<code>-NoNewWindow</code>，导致后台进程无法启动。因为系统分配的终端没有被阻塞执行完脚本内容后直接退出。使用<code>-NoNewWindow</code>会使在当前Shell环境的后台进程也退出。</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>非Windows平台上子进程<strong>总是</strong>连接到父进程终端，可以使用<code>Start-Process nohup</code>命令脱离父终端。</p>
</blockquote>
<pre><code class="language-powershell">Start-Process -FilePath command \  # -&gt; start*
              -ArgumentList ('-jar',&quot;$jEdit&quot;, '-settings=&quot;$JEditSettings&quot;')\ 
              -WorkingDirectory path \
              -RedirectStandardInput  &quot;source_file&quot;
              -RedirectStandardOutput &quot;$JEditLogs\console.out&quot; \
              -RedirectStandardError &quot;$JEditLogs\console.err&quot;  \
              -PassThru            # 返回进程对象
              -Verb [RunAs|Print|Open]  # 
$processOptions = @{...}
Start-Process $processOptions
</code></pre>
<blockquote>
<p><code>*</code>：<code>start</code>是<code>Start-Process</code>的别名，与<code>cmd</code>命令用法有区别。</p>
<pre><code class="language-powershell">start &quot;&quot; &quot;Notepad.exe&quot;  # [cmd] 脱离终端，start命令处理引号中的参数
</code></pre>
</blockquote>
<h5 id="进程启动方式-1"><a class="header" href="#进程启动方式-1">进程启动方式</a></h5>
<p>通过<code>-Verb</code>选项指定<code>-FilePath</code>传递的进程或文件的启动方式（如以管理员运行），通过以下命令查看可执行程序(如<code>PowerShell.exe</code>)可用的启动方式：</p>
<pre><code class="language-powershell">startExe = New-Object System.Diagnostics.ProcessStartInfo -Args PowerShell.exe
startExe.verbs  # -&gt; open/runas/runasuser
</code></pre>
<h4 id="从图形界面启动新进程-1"><a class="header" href="#从图形界面启动新进程-1">从图形界面启动新进程</a></h4>
<p>对于从图形界面点击脚本，其打开方式默认为终端，因此系统会首先为其创建一个Shell环境再执行程序，类似于调用<code>Start-Process powershell.exe -ArgumentList ('xxx.ps1')</code>，因此还是会弹出临时终端。</p>
<p>对于从图形界面点击<code>.exe</code>程序，则系统直接新建进程（中间不涉及创建Shell环境）。</p>
<h3 id="启动powershell任务-1"><a class="header" href="#启动powershell任务-1">启动PowerShell任务</a></h3>
<p><code>Start-Job</code>用于运行PowerShell脚本(<code>-FilePath</code>/<code>-LiteralPath</code>)或命令（<code>-ScriptBlock</code>）。</p>
<pre><code class="language-powershell">$job=Start-Job -Name PShellJob -ScriptBlock { Get-Process -Name pwsh } `
               -InitializationScript {Import-Module MapFunctions} `
               -InputObject &quot;C:\Servers.txt&quot; `   # $input
               -ArgumentList powershell, pwsh, notepad ` # 逗号分隔参数列表或数组对象$args
               -WorkingDirectory C:\Test\Scripts  # PS7 $PWD
Get-Process -Name pwsh &amp;
Receive-Job -Id $job.Id # -Keep保留已获取的输出结果。
Get-Job  # 获取当前会话启动的后台任务，可查看任务状态。
Stop-Job/Remove-Job 
</code></pre>
<blockquote>
<p>PowerShell Core 6.0+支持使用<code>&amp;</code>使启动的进程与当前终端脱离（<code>Start-Job</code>的语法糖）。</p>
</blockquote>
<p>任务类型：</p>
<ul>
<li><code>RemoteJob</code>：运行在远程会话中的任务；</li>
<li><code>BackgroundJob</code>：运行在独立进程中的任务；</li>
<li><code>PSTaskJob</code>或 <code>ThreadJob</code>运行在当前进程的独立线程中的任务。</li>
</ul>
<p><code>Invoke-Command</code>支持在本机或远程执行任务。</p>
<pre><code class="language-powershell">$s = New-PSSession -ComputerName Server02 -Credential Domain01\User01
Invoke-Command -ComputerName HostName 
               -FilePath ScriptPath
               -ScriptBlock $command
               -PSSession $s  # 在指定的PS会话中执行命令
               -InDisconnectedSession
               -AsJob # 运行为后台任务(-&gt;Start-Job)
</code></pre>
<p><a href="https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/invoke-command?view=powershell-7.2&amp;viewFallbackFrom=powershell-6">Invoke-Command (Microsoft.PowerShell.Core) - PowerShell | Microsoft Learn</a></p>
<h3 id="服务管理-1"><a class="header" href="#服务管理-1">服务管理</a></h3>
<p><a href="https://docs.microsoft.com/en-us/powershell/scripting/samples/managing-services?view=powershell-7.2">Managing Services - PowerShell | Microsoft Docs</a></p>
<h2 id="网络管理-3"><a class="header" href="#网络管理-3">网络管理</a></h2>
<p><a href="https://docs.microsoft.com/en-us/powershell/scripting/samples/performing-networking-tasks?view=powershell-7.2">Performing Networking Tasks - PowerShell | Microsoft Docs</a></p>
<h3 id="网络连接信息-1"><a class="header" href="#网络连接信息-1">网络连接信息</a></h3>
<p>显示网络信息：</p>
<pre><code class="language-powershell">netstat 
</code></pre>
<p>连接信息：</p>
<blockquote>
<p><code>-a</code>：显示所有连接（包括地址<code>0.0.0.0</code>）和侦听端口。</p>
<p><code>-b</code>：显示进程对应的可执行程序。</p>
<p><code>-n</code>：以数字形式显示地址和端口号。</p>
<p><code>-p PROTOCOL</code>：显示指定协议的连接，包括：TCP、UDP、TCPv6和UDPv6。</p>
</blockquote>
<p>路由信息：</p>
<p><code>-r</code>：路由信息；</p>
<p>统计信息：</p>
<blockquote>
<p><code>-s</code>：显示 IP、IPv6、ICMP、ICMPv6、TCP、TCPv6、UDP 和 UDPv6 的统计信息；</p>
<p><code>-e</code>：显示以太网统计信息。</p>
</blockquote>
<h5 id="arp-1"><a class="header" href="#arp-1">arp</a></h5>
<pre><code class="language-powershell">arp -agv
</code></pre>
<h5 id="ip-1"><a class="header" href="#ip-1">ip</a></h5>
<pre><code class="language-powershell">ipconfig
ping
tracert
</code></pre>
<h3 id="网络配置-1"><a class="header" href="#网络配置-1">网络配置</a></h3>
<pre><code class="language-powershell">netsh.exe  COMMAND       # netstat help
netsh.exe  -f ScriptFile
# COMMAND
# interface              - 更改网络接口配置。
# lan/wlan/bridge        - 更改有线/无线局域网/网桥配置
# firewall/advfirewall   - 更改防火墙(高级)配置
# winsock                - 更改套接字配置。
# dhcpclient/dnsclient   - 更改DHCP/DNS客户端配置。
# ipsec/http/winhttp/rpc - 更改IPSec/http/RPC配置。
# dump                   - 显示一个配置脚本。
# exec                   - 运行一个脚本文件。
# set                    - 更新配置设置。
# show                   - 显示信息。
# delete                 - 在项目列表上删除一个配置项目。
</code></pre>
<blockquote>
<p>远程管理选项：<code>[-r RemoteMachine] [-u [DomainName\]UserName] [-p Password | *]</code>。</p>
</blockquote>
<pre><code class="language-shell">netsh interface portproxy show [all|v4tov4|v4tov6|v6tov4|v6tov6]
</code></pre>
<h4 id="网络共享-1"><a class="header" href="#网络共享-1">网络共享</a></h4>
<h5 id="权限-2"><a class="header" href="#权限-2">权限</a></h5>
<h3 id="网络访问问题-1"><a class="header" href="#网络访问问题-1">网络访问问题</a></h3>
<h5 id="网络连接-1"><a class="header" href="#网络连接-1">网络连接</a></h5>
<p><strong>问题</strong>：Windows网络连接显无法连接网络，实际可以上网？</p>
<p><strong>原因</strong>：DNS服务器导致系统的网络探测服务无法正常工作，修改DNS服务器。</p>
<h5 id="网络发现问题-1"><a class="header" href="#网络发现问题-1">网络发现问题</a></h5>
<p>问题：在网络中无法查看开启共享的机器。</p>
<p>原因：目标机器相关服务可能未运行（<code>Function Discovery Provider Host</code>和<code>Function Discovery Resource Publication</code>服务）。</p>
<h5 id="共享权限-1"><a class="header" href="#共享权限-1">共享权限</a></h5>
<p>访问共享目录的用户（例如everyone）需要同时有本地文件系统的访问权限和共享目录的访问权限。</p>
<h5 id="共享安全问题-1"><a class="header" href="#共享安全问题-1">共享安全问题</a></h5>
<p>Windows 10：<code>0x80070035 找不到网络路径</code>。</p>
<pre><code class="language-powershell">[HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\LanmanWorkstation\Parameters]
&quot;AllowInsecureGuestAuth&quot;=dword:00000001
</code></pre>
<p><a href="https://blog.csdn.net/weivnuo/article/details/80934241?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.nonecase&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.nonecase">windows 10 0x80070035 找不到网络路径_SOESC.COM-CSDN博客_0x80070035</a></p>
<h4 id="uwp应用的网络代理-1"><a class="header" href="#uwp应用的网络代理-1">UWP应用的网络代理</a></h4>
<p>UWP应用（包括Microsoft Store）运行在沙箱环境中，其网络访问与物理机隔离（总是通过本地环回地址转发给物理机），因此无法使用物理机配置的网络代理。</p>
<h5 id="解除应用的本地环回限制-1"><a class="header" href="#解除应用的本地环回限制-1">解除应用的本地环回限制</a></h5>
<p>以应用商店程序为例：</p>
<ul>
<li>
<p>基于UWP应用可执行文件的所在路径（通过任务管理器找到可执行文件，查看其属性可找到其位置），确定UWP应用包名<code>Microsoft.WindowsStore_22207.1401.9.0_x64__8wekyb3d8bbwe</code>。</p>
</li>
<li>
<p>通过UWP包名中的App名称<code>WindowsStore</code>，在注册表中查找应用对应的安全标识符SID（<code>Mappings</code>条目下的名称）或系列名称(<code>Moniker</code>)</p>
<pre><code class="language-ini">[HKEY_CURRENT_USER\SOFTWARE\Classes\Local Settings\Software\Microsoft\Windows\CurrentVersion\AppContainer\Mappings\S-1-15-2-1609473798-1231923017-684268153-4268514328-882773646-2760585773-1760938157]
&quot;DisplayName&quot;=&quot;Microsoft Store&quot;
&quot;Moniker&quot;=&quot;microsoft.windowsstore_8wekyb3d8bbwe&quot;
</code></pre>
</li>
<li>
<p>使用<code>CheckNetisolation</code>程序，传入SID或系列名称解除本地环回限制。</p>
<pre><code class="language-powershell">CheckNetIsolation.exe loopbackexempt -a/-d -p=$SID -n=$Moniker # 添加/移除例外项
CheckNetIsolation.exe LoopbackExempt -s # 列出已解除的列表
</code></pre>
</li>
</ul>
<h5 id="修改系统winhttp代理规则-1"><a class="header" href="#修改系统winhttp代理规则-1">修改系统WinHttp代理规则</a></h5>
<pre><code class="language-powershell">netsh winhttp import proxy source=ie  # 使用系统设置中配置的代理服务器
netsh winhttp show proxy              # 查看当前配置
</code></pre>
<p><a href="https://learn.microsoft.com/en-us/windows/win32/winhttp/winhttp-start-page">Windows HTTP Services - Win32 apps | Microsoft Learn</a></p>
<h3 id="虚拟网络-1"><a class="header" href="#虚拟网络-1">虚拟网络</a></h3>
<h4 id="vmware虚拟网络-1"><a class="header" href="#vmware虚拟网络-1"><a href="Windows/../%E6%9C%8D%E5%8A%A1%E5%99%A8/%E8%99%9A%E6%8B%9F%E5%8C%96.html#%E8%99%9A%E6%8B%9F%E7%BD%91%E7%BB%9C">VMWare虚拟网络</a></a></h4>
<h4 id="wsl虚拟网络-1"><a class="header" href="#wsl虚拟网络-1"><a href="Windows/../%E6%9C%8D%E5%8A%A1%E5%99%A8/%E8%99%9A%E6%8B%9F%E5%8C%96.html#WSL%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE">WSL</a>虚拟网络</a></h4>
<ol>
<li>
<p>在Windows主机上通过<code>localhost</code>可访问WSL开放的服务；</p>
<blockquote>
<p>使用<code>127.0.0.1</code>不能访问WSL的服务。</p>
</blockquote>
</li>
<li>
<p>WSL和Windows主机连接到内置的Hyper-V虚拟网络，因此可使用同一网段的IP地址互相访问；</p>
<blockquote>
<p>通过Windows主机的网络管理可以找到Windows主机在虚拟网络中的地址；WSL中<code>/etc/resolv.conf</code>记载了Windows主机的IP地址（作为WSL的域名服务）；</p>
<p>WSL的<code>/etc/hosts</code>也记录了Windows中手动配置的域名。</p>
</blockquote>
</li>
<li>
<p>局域网访问WSL服务：WSL服务需要绑定到虚拟网卡IP地址而非本地环回地址，WSL中开放的端口会通过Windows主机的<code>wslhost.exe</code>进行端口转发（默认仅监听WSL2的<code>localhost</code>，需要使用以下脚本添加监听地址，或使用<a href="https://github.com/CzBiX/WSLHostPatcher">WSL Host Patcher</a>自动监听并转发WSL2中打开的端口）。同时，确保Windows防火墙策略允许外部IP访问<code>wslhost.exe</code>应用。</p>
<pre><code class="language-powershell"># 1. Get IP Address of WSL 2 machine
# 2. Remove previous port forwarding rules
netsh interface portproxy delete v4tov4 
    listenport=$host_port listenaddress=$host_addr ...
# 3. Add port Forwarding rules
netsh interface portproxy add v4tov4 
    listenport=$host_port listenaddress=$host_addr  # (0.0.0.0)
    connectport=$wsl_port connectaddress=$wsl_addr 
</code></pre>
<p><a href="https://github.com/microsoft/WSL/issues/4150">WSL 2 NIC Bridge mode 🖧 (Has TCP Workaround🔨)</a></p>
</li>
</ol>
<h4 id="docker-on-wsl2-1"><a class="header" href="#docker-on-wsl2-1"><a href="Windows/../%E6%9C%8D%E5%8A%A1%E5%99%A8/%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92.html#%E5%9C%B0%E5%9D%80%E7%AB%AF%E5%8F%A3%E6%98%A0%E5%B0%84">Docker</a> on WSL2</a></h4>
<p><strong>通过VMWare NAT网络连接的VM<code>-&gt;</code>本地Docker服务</strong>：VM需要使用本地主机的物理地址（而非主机在虚拟机子网中的地址）访问Docker服务。虽然Docker已经将Docker服务端口映射到物理端口，但其绑定的IP地址实际不包含虚拟网卡地址（如VMWare虚拟网卡）。因此，VM中发起的请求必须经过源NAT，以访问主机物理地址上的服务。</p>
<h2 id="用户管理-4"><a class="header" href="#用户管理-4">用户管理</a></h2>
<pre><code class="language-powershell">whoami /UPN     # User Principal Name (域用户)
       /FQDN    # Fully Qualified Differentiable Name (域用户)
       /LOGONID # 当前用户的登录ID (S-1-5-5-0-28587288)
whoami /USER    # 显示用户名与安全标识符 (SID)
       /GROUPS  # 用户所属组名称、类型、SID 和属性。
       /CLAIMS  # 当前用户的声明
       /PRIV    # 当前用户的安全特权
       /ALL
       [/FO format] # format=TABL(default)|LIST|CSV
       [/NH]    #
</code></pre>
<h2 id="安全-4"><a class="header" href="#安全-4">安全</a></h2>
<h3 id="证书管理-1"><a class="header" href="#证书管理-1">证书管理</a></h3>
<p>通过Windows“运行”对话框（<code>Win+R</code>启动）打开证书管理工具：</p>
<ul>
<li><code>certmgr.msc</code>：当前用户证书管理；</li>
<li><code>certlm.msc</code>：本地计算机证书管理（需要管理员权限）；</li>
</ul>
<h5 id="安装证书-3"><a class="header" href="#安装证书-3">安装证书</a></h5>
<p>点击证书文件进行安装，可选择存储位置为当前用户或本地计算机（需要管理员权限）。</p>
<p>再证书管理工具中，可通过拖拽更改证书所属路径。</p>
<h5 id="证书类型-1"><a class="header" href="#证书类型-1">证书类型</a></h5>
<div class="table-wrapper"><table><thead><tr><th>类型</th><th>标识符</th></tr></thead><tbody>
<tr><td>个人</td><td><code>My</code></td></tr>
<tr><td>==中间证书颁发机构==</td><td><code>CA</code></td></tr>
<tr><td>==第三方根证书颁发机构==</td><td><code>AuthRoot</code></td></tr>
<tr><td>==受信任的根证书颁发机构==</td><td><code>Root</code></td></tr>
<tr><td>企业信任</td><td><code>Trust</code></td></tr>
<tr><td>受信任的发布者</td><td><code>TrustedPublisher</code></td></tr>
<tr><td>受信任的封装应用安装颁发机构</td><td><code>TrustedAppRoot</code>+</td></tr>
<tr><td>受信任的设备</td><td><code>TrustedDevices</code>*+</td></tr>
<tr><td>受信任人</td><td><code>TrustedPeople</code>*</td></tr>
<tr><td>其他人</td><td><code>ADDRESSBOOK</code></td></tr>
<tr><td>智能卡受信任的根</td><td><code>SmartCardRoot</code>*</td></tr>
<tr><td>客户端身份验证颁发者</td><td><code>ClientAuthIssuer</code>*</td></tr>
<tr><td>Active Directory 用户对象</td><td><code>UserDS</code>*</td></tr>
<tr><td>-</td><td><code>AAD Token Issuer</code>*+</td></tr>
<tr><td>证书注册申请</td><td><code>REQUEST</code>*</td></tr>
<tr><td>不信任的证书</td><td><code>Disallowed</code>*</td></tr>
<tr><td>测试版根目录</td><td><code>TestSignRoot</code>+</td></tr>
<tr><td>预览版根</td><td><code>FlightRoot</code>+</td></tr>
<tr><td>远程桌面</td><td><code>Remote Desktop</code>+</td></tr>
<tr><td>-</td><td><code>WindowsServerUpdateServices</code>*+</td></tr>
<tr><td>-</td><td><code>eSIM Certification Authorities</code>+</td></tr>
<tr><td>-</td><td><code>Windows Live ID Token Issuer</code>+</td></tr>
<tr><td>-</td><td><code>Homegroup Machine Certificates</code>*+</td></tr>
<tr><td>-</td><td><code>Local NonRemovable Certificates</code>*</td></tr>
<tr><td>-</td><td><code>MSIEHistoryJournal</code>*</td></tr>
</tbody></table>
</div>
<blockquote>
<p><code>*</code>通常为空目录。</p>
<p><code>+</code>本地计算机目录下才有的类型。</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="windows-powershell"><a class="header" href="#windows-powershell">Windows PowerShell<img src="Windows/Windows Shell.assets/powershell.png" alt="powershell deep learning" align="right" style="zoom: 33%;float:right" /></a></h1>
<blockquote>
<p>PowerShell is built on .NET:</p>
<ul>
<li><em>Windows PowerShell 5.1 is built on top of the .NET Framework v4.5.</em></li>
<li><em>PowerShell is an open source project built on .NET Core.</em></li>
</ul>
</blockquote>
<h2 id="安装-11"><a class="header" href="#安装-11">安装</a></h2>
<h5 id="windows-4"><a class="header" href="#windows-4">Windows</a></h5>
<p>以下为安装PowerShell 7.x的方法（Windows内置PowerShell 5.1，PowerShell 7.x可与之并存）。</p>
<ol>
<li>
<p><code>msi</code>安装，<a href="https://github.com/PowerShell/PowerShell/releases/">下载安装包</a>点击执行或运行以下命令：</p>
<pre><code class="language-powershell">msiexec.exe /package PowerShell-7.2.4-win-x64.msi /quiet \
    USE_MU=1 ENABLE_MU=1 # 通过Windows Update自动更新PowerShell
</code></pre>
</li>
<li>
<p><code>winget</code>安装：</p>
<pre><code class="language-powershell">winget install Microsoft.PowerShell
</code></pre>
</li>
<li>
<p>安装为<a href="Windows/../CSharp.NET/dotnet%E5%BC%80%E5%8F%91.html#NET%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7"><code>.NET</code>全局工具</a>：</p>
<pre><code class="language-powershell">dotnet tool install|update --global PowerShell # [Admin] 安装PowerShell 7.x
</code></pre>
</li>
<li>
<p>通过应用商店安装（<a href="https://docs.microsoft.com/en-us/powershell/scripting/install/installing-powershell-on-windows?view=powershell-7.2#known-limitations">有运行权限限制</a>）。</p>
</li>
</ol>
<h5 id="linux-2"><a class="header" href="#linux-2">Linux</a></h5>
<ol>
<li>
<p>从软件源安装</p>
<pre><code class="language-shell">sudo apt install -y wget apt-transport-https software-properties-common
wget -q &quot;https://packages.microsoft.com/config/ubuntu/$(lsb_release -rs)/packages-microsoft-prod.deb&quot;
sudo dpkg -i packages-microsoft-prod.deb # Register the repository GPG keys
sudo apt update &amp;&amp; sudo apt install -y powershell
</code></pre>
</li>
<li>
<p>直接从<a href="https://github.com/PowerShell/PowerShell/releases/">发布页面下载</a>软件包安装。</p>
</li>
</ol>
<p>安装相关路径：</p>
<ul>
<li><code>$PSHOME=/opt/microsoft/powershell/7/</code>；</li>
<li>用户配置文件：<code>~/.config/powershell/profile.ps1</code>；</li>
<li>用户模块目录：<code>~/.local/share/powershell/Modules</code>；</li>
</ul>
<h3 id="powershell命令"><a class="header" href="#powershell命令">PowerShell命令</a></h3>
<p>PowerShell命令命名规则为<code>Verb-Noun</code>（动词-名词）形式。</p>
<h4 id="探索powershell命令"><a class="header" href="#探索powershell命令">探索PowerShell命令</a></h4>
<ul>
<li>
<p><code>Get-Verb</code>：获取命令库中多数命令的开头动词（有助于用户使用命令）；</p>
</li>
<li>
<p><code>Get-Command</code>：返回所有已安装的命令。也可以添加参数以过滤列举内容（参数支持通配符<code>*</code>）：</p>
<pre><code class="language-powershell">Get-Command -Name|Verb|Noun &lt;cmdlet&gt; \            # 按名称/动词/名词匹配
            -CommandType Cmdlet, Function, Alias  # 按命令类型匹配
            -Module &lt;module&gt;                      # 按模块匹配
            -ParameterType Process                # 根据命令接受的主要参数的类型筛选
Get-Command Get-Process -Syntax # 获取命令语法
</code></pre>
</li>
<li>
<p><code>Get-Alias</code>：获取命令别名的信息。</p>
<pre><code class="language-powershell">Get-Alias -Definition Get-Command,Get-Member # 获取别名
Get-Alias ls,dir                             # 获取全名
</code></pre>
<blockquote>
<p>在脚本中尽量使用全名而非别名，以增强可读性。</p>
</blockquote>
</li>
<li>
<p><code>Get-Member</code>：对输出对象进行操作，并返回<a href="Windows/Windows%20Shell.html#%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7">对象的属性和方法</a>（<em>可根据参数过滤</em>）。</p>
<pre><code class="language-powershell">$s = Get-Service -Name w32time
$s | Get-Member  # 返回对象的类型，及其包含属性的方法的名称、类型和定义
</code></pre>
</li>
<li>
<p><code>Get-Help &lt;cmdlet-name&gt;</code>：获取命令的<a href="Windows/Windows%20Shell.html#%E6%96%87%E6%A1%A3">文档信息</a>。</p>
</li>
</ul>
<h4 id="模块管理"><a class="header" href="#模块管理">模块管理</a></h4>
<h5 id="包管理模块"><a class="header" href="#包管理模块">包管理模块</a></h5>
<p><code>PowerShellGet</code>用于查找、安装、更新和发布模块、脚本等内容。</p>
<blockquote>
<p>错误：<em>A parameter cannot be found that matches parameter name <code>AllowPrerelease</code>.</em>：检查是否安装/导入<code>PowershellGet</code>模块。</p>
</blockquote>
<p>安装/更新<code>PowerShellGet</code>的两种方法：</p>
<ol>
<li>
<p>安装<code>Nuget</code>将自动安装<code>PowerShellGet</code>；</p>
<pre><code class="language-powershell">Install-PackageProvider -Name NuGet -Force # with Admin
</code></pre>
</li>
<li>
<p>直接安装<code>PowerShellGet</code>；</p>
<pre><code class="language-powershell">Install-Module -Name PowerShellGet -AllowClobber -Force
</code></pre>
</li>
</ol>
<h5 id="安装模块"><a class="header" href="#安装模块">安装模块</a></h5>
<pre><code class="language-powershell">Install-Module [-Name] &lt;ModuleName*&gt; 
  -Scope CurrentUser|AllUsers   # AllUsers needs Admin previllege
  -AllowPrerelease 
  -WhatIf
  -MinimumVersion 2.0.1 # -RequiredVersion -MaximumVersion
  -Force         # 安装同名不同版本模块
  -AllowClobber  # 覆盖同名模块  
Update-Module # 参数与Instal-Module相似
Uninstall-Module [-Name] &lt;ModuleName&gt;
</code></pre>
<p>安装模块前可以先进行搜索。首先查找本地是否已安装相应模块：</p>
<pre><code class="language-powershell">Get-Module -ListAvailable [-Name &lt;ModuleName&gt;]  # 从当前当前会话查找模块
</code></pre>
<blockquote>
<p><code>-ListAvailable</code>：列出指定模块的所有本地安装版本（可能包含系统内置版本和用户安装版本）。</p>
</blockquote>
<p>如果本地不存在指定模块，可查找<a href="https://www.powershellgallery.com/">Nuget仓库</a>（可使用Nexus搭建镜像仓库）。</p>
<pre><code class="language-powershell">Find-Module -Name &lt;ModuleName&gt;  # -&gt; PSRepositoryItemInfo
</code></pre>
<blockquote>
<p>如果本地存在指定模块，找到的模块会被加载到当前会话。</p>
</blockquote>
<pre><code class="language-powershell">Find-Command -Name &lt;CmdName&gt; -ModuleName &lt;ModName&gt; # -&gt; PSGetCommandInfo
	-AllowPrerelease 
	-RequiredVersion  # -MinimumVersion -MaximumVersion
</code></pre>
<p><code>Find-Module</code>，<code>Find-Command</code>的返回的结果可以传递给<code>Install-Module</code>执行安装。</p>
<h5 id="导入模块-2"><a class="header" href="#导入模块-2">导入模块</a></h5>
<p>位于<code>$env:PSModulePath</code>路径下加模块会自动被加载。其他模块，在命令行或脚本中执行导入：</p>
<pre><code class="language-powershell">Import-Module [-Name] &lt;ModuleName&gt;
$m = Get-Module -ListAvailable PowershellGet, Dism
Import-Module -ModuleInfo $m
Import-Module -Name c:\ps-test\modules\test -Verbose
</code></pre>
<p><a href="https://docs.microsoft.com/zh-cn/powershell/module/microsoft.powershell.core/import-module?view=powershell-7.1">Import-Module</a>。</p>
<h5 id="离线手工安装模块"><a class="header" href="#离线手工安装模块">离线手工安装模块</a></h5>
<p>可以从<a href="https://www.powershellgallery.com/packages/">PowerShell Gallery</a>下载模块的<code>nupkg</code>包。<code>.nupkg</code>以<code>zip</code>格式封装了模块数据以及NuGet相关的描述数据（非模块本身的数据）。NuGet相关数据包括：</p>
<ul>
<li><code>_rels/</code>：包含模块的依赖声明（<code>.rels</code>文件）；</li>
<li><code>package/</code>：NuGet相关数据；</li>
<li><code>[Content_Types].xml</code>：描述扩展模块如何与NuGet共同使用；</li>
<li><code>&lt;name&gt;.nuspec</code>：包的元数据。</li>
</ul>
<p>手工安装：将<code>.nupkg</code>中非NuGet相关数据解压到<code>$env:PSModulePath</code>中的一个路径下，并仅以包名命名该模块的文件夹<sup class="footnote-reference"><a href="#nuget">1</a></sup>。</p>
<h4 id="文档-2"><a class="header" href="#文档-2">文档</a></h4>
<p>PowerShell文档介绍了PowerShell的cmdlet、函数、脚本及模块，并解释了PowerShell 语言的元素等概念。在命令行中使用<code>Get-Help cmdlet</code>来显示帮助主题。</p>
<pre><code class="language-powershell">Get-Help cmdname -examples|detailed|full|online
help cmdname   # =&gt; Get-Help cmdname | more
help Get-Command -Full | Out-GridView  # 在独立的文档查看器中查看帮助文档
</code></pre>
<blockquote>
<p>如果本地没有帮助文件，<code>Get-Help</code> 会显示自动生成的有关 cmdlet、函数及脚本的帮助。</p>
<p><code>help</code>不是<code>Get-Help</code>的别名：每次仅显示一页内容，需要手动翻页。</p>
<p><code>Get-Help</code>会搜索与<code>cmdname</code>匹配的相关命令（类似于<code>Get-Command</code>），<code>cmdname</code>可包含通配符（==如果前后未添加<code>*</code>，则在名称中间添加<code>*</code>是无效的通配符==）。因此，当查找结果多于一条，将显示结果列表；反之显示查找结果的详细信息。</p>
</blockquote>
<p>获取命令的参数信息：</p>
<pre><code class="language-powershell">help cmdname -Parameter &lt;ParameterName&gt;
</code></pre>
<h5 id="获取本地文档"><a class="header" href="#获取本地文档">获取本地文档</a></h5>
<p>PowerShell 中默认不包含帮助文件，但可以联机查看帮助主题，或使用 <code>Update-Help cmdlet</code>将帮助文件下载到本地或在网站发布更新的时候更新本地文档。</p>
<blockquote>
<p><a href="https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/update-help?view=powershell-7.1">Update-Help (Microsoft.PowerShell.Core) - PowerShell | Microsoft Docs</a>。</p>
</blockquote>
<pre><code class="language-powershell">Update-Help \
	[-UICulture en-US,zh-CN]   # 指定文档语言
	[-Module Microsoft.PowerShell*] # 更新指定模块的文档（默认更新所有已安装的模块）
	-SourcePath path   # Save-Help
</code></pre>
<h3 id="开发环境-5"><a class="header" href="#开发环境-5">开发环境</a></h3>
<p><a href="https://docs.microsoft.com/en-us/powershell/scripting/dev-cross-plat/vscode/using-vscode?view=powershell-7.2#debugging-with-visual-studio-code">Debugging with Visual Studio Code</a></p>
<h2 id="变量-8"><a class="header" href="#变量-8">变量</a></h2>
<blockquote>
<p><em>PowerShell accepts and returns <strong>.NET objects</strong>, rather than text.</em></p>
</blockquote>
<p>设置变量：</p>
<pre><code class="language-powershell">$JAVA_HOME=&quot;C:\tools\java&quot;
Set-Variable -Name 'JAVA_HOME' -Value 'C:\tools\java'  # -&gt; set*
</code></pre>
<blockquote>
<p><code>*</code>：<code>set</code>是<code>Set-Variable</code>的别名，与<code>cmd</code>的变量设置<a href="Windows/Windows%20Shell.html#%E5%AE%9A%E4%B9%89console%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F">命令<code>set</code></a>无关。</p>
</blockquote>
<p>==变量名不区分大小写==。</p>
<p>输出变量：</p>
<pre><code class="language-powershell">$JAVA_HOME            # =&gt; echo $JAVA_HOME
$JAVA_HOME.ToUpper()  # 调用变量对象的属性或方法
$v=Get-Variable -Name 'JAVA_HOME'  # get (Name,Value) object
$v.Value
</code></pre>
<h3 id="数据类型-4"><a class="header" href="#数据类型-4">数据类型</a></h3>
<h4 id="空值"><a class="header" href="#空值">空值</a></h4>
<p><a href="https://docs.microsoft.com/en-us/powershell/scripting/learn/deep-dives/everything-about-null?view=powershell-7.2">Everything you wanted to know about $null - PowerShell | Microsoft Docs</a></p>
<h4 id="字符串-6"><a class="header" href="#字符串-6">字符串</a></h4>
<p>字符串需要使用<code>''</code>或<code>&quot;&quot;</code>进行表示，否则相应内容将被视为shell命令。==字符串使用<code>+</code>拼接==。</p>
<p><a href="https://docs.microsoft.com/en-us/powershell/scripting/learn/deep-dives/everything-about-string-substitutions?view=powershell-7.2">Everything you wanted to know about variable substitution in strings - PowerShell | Microsoft Docs</a></p>
<h5 id="裁剪字符串"><a class="header" href="#裁剪字符串">裁剪字符串</a></h5>
<pre><code class="language-powershell">str.Trim()          # TrimEnd/TrimStart
str.Trim(&quot;a&quot;, &quot; &quot;)  # 可指定多个裁剪模式(单个字符)
</code></pre>
<blockquote>
<p>返回新的对象。</p>
</blockquote>
<h5 id="分割字符串"><a class="header" href="#分割字符串">分割字符串</a></h5>
<pre><code class="language-powershell">$array=&quot;abcdefghi&quot;.split(&quot;de&quot;)  # -&gt; -split运算符
</code></pre>
<h4 id="数组-10"><a class="header" href="#数组-10">数组</a></h4>
<p>许多命令（如<code>Get-Process</code>）的返回值都是一个数组。手动构造数组方法：</p>
<pre><code class="language-powershell">$data=@('Zero','One','Two','Three')  # 空数组 $data = @()
$data=('Zero','One','Two','Three')   # =&gt; $data = 'Zero','One','Two','Three'
</code></pre>
<blockquote>
<p>数组元素可换行声明，此时两行间的元素不需要通过<code>,</code>分隔。</p>
</blockquote>
<p>通过迭代构造数组：</p>
<pre><code class="language-powershell">$array = 1..5 | ForEach-Object { &quot;ATX-SQL-$PSItem&quot; }
$array = foreach ( $node in (1..5)){ &quot;ATX-SQL-$node&quot; }
</code></pre>
<p>数组默认类型为<code>[PSObject[]]</code>，即其元素都继承自<code>PSObject</code>。在创建数组时可指定严格的类型限制：</p>
<pre><code class="language-powershell">[int[]] $numbers = 1,2,3
</code></pre>
<p>预分配内存的数组：</p>
<pre><code class="language-powershell">$data = [Object[]]::new(4)
</code></pre>
<p>嵌套数组：</p>
<pre><code class="language-powershell">$data = @(
    @(1,2,3),  # 嵌套数组元素换行时仍需&quot;,&quot;分隔
    @(4,5,6),
    @(7,8,9)
)
$data[1][2]  # -&gt; 6
</code></pre>
<p>多维数组：</p>
<pre><code class="language-powershell">[string[,]]$rank2 = [string[,]]::New(3,2)
</code></pre>
<h5 id="数组属性"><a class="header" href="#数组属性">数组属性</a></h5>
<pre><code class="language-powershell">Write-Output -NoEnumerate $data | Get-Member # 获取数组的属性和方法
$data | Get-Member  # 获取数组元素的属性和方法
</code></pre>
<pre><code class="language-shell">$data.Count  # 数组元素数量 =&gt; $data.Length
$data.Rank   # 数组维数
</code></pre>
<blockquote>
<p>不仅数组可以获取长度，标量对象也可（返回1），空数组长度为0（特别地<code>$null.count-&gt;0</code>，注意区别）。</p>
</blockquote>
<h5 id="访问元素"><a class="header" href="#访问元素">访问元素</a></h5>
<pre><code class="language-shell">$data[i]      # 0-based index
$data[0,2,3]  # 获取子数组（可添加重复编号以生成重复元素）
$data[1..3]   # 切片(区间可反向，即&quot;3..1:&quot;)
$data[-1]     # 负索引
$data[i,-j]   # =&gt; [i,i-1,...0,-1,...-j] (与Python负索引语义不同)
</code></pre>
<blockquote>
<p>访问不在数组长度范围内元素将返回<code>$null</code>而非产生异常。</p>
<p><code>i..j</code>将自动生成一个整数数组。</p>
</blockquote>
<p>访问数组元素属性（链式调用）：</p>
<pre><code class="language-shell">$data[0].PropName
$data.PropName   # 返回所有元素的PropName返回值组成的新数组
</code></pre>
<h5 id="更新数组"><a class="header" href="#更新数组">更新数组</a></h5>
<pre><code class="language-powershell">$data[2] = 'dos'  # 索引编号超过数组长度将产生异常
$data.Clear()     # 重置数组元素的值为默认值
</code></pre>
<h5 id="迭代数组"><a class="header" href="#迭代数组">迭代数组</a></h5>
<pre><code class="language-powershell">$data.foreach({&quot;Item [$PSItem]&quot;})          # =&gt; $data.foreach{&quot;Item [$PSItem]&quot;}
$data | ForEach-Object {&quot;Item: [$PSItem]&quot;} # $PSItem =&gt; $_
foreach ( $node in $data ){ &quot;Item: [$node]&quot; }
for ( $index = 0; $index -lt $data.count; $index++){
    &quot;Item: [{0}]&quot; -f $data[$index]
}
switch( $data ) {...}  # 对数组每个元素执行分支判断
</code></pre>
<p>当数组元素类型为值类型时，使用<code>for</code>语句块可在迭代数组时对其进行更新。反之，如果为引用类型，则其他迭代语句也可对数组元素的属性进行更改。</p>
<blockquote>
<p><code>ForEach-Object -Parallel</code>[7.x]：管道并行。</p>
</blockquote>
<h5 id="数组对象运算"><a class="header" href="#数组对象运算">数组对象运算</a></h5>
<p>数组对象运算都将产生新的数组对象。</p>
<ol>
<li>
<p>字符串拼接：使用连接符将数组内容拼接为一个字符串对象。</p>
<pre><code class="language-powershell">$data -join '-' 
</code></pre>
</li>
<li>
<p>替换：</p>
<pre><code class="language-powershell">$data -replace 'ATX','LAX'  # 对数组每个元素执行替换
</code></pre>
</li>
<li>
<p>查找：返回<code>True|False</code>。<code>-contains, -notcontains</code>，<code>-in, -notin</code></p>
<pre><code class="language-powershell">$data -contains 'green'  # =&gt; 'green' -in $data
</code></pre>
</li>
<li>
<p>比较或匹配过滤（<code>-eq</code>, <code>-ne</code>, <code>-match</code>）：数组与对象比较返回匹配对象（或子数组）：</p>
<pre><code class="language-powershell">$data -eq 'green'
$servers -match 'SQL' # =&gt; $servers | Select-String SQL
</code></pre>
<blockquote>
<p>判断数组对象是否为<code>$null</code>，应该使用<code>$null -eq $array</code>避免上述语法对数组的<code>$null</code>值的筛选。</p>
</blockquote>
</li>
<li>
<p>追加：</p>
<pre><code class="language-powershell">$data = $data + 'four'  # $data += 'four'
</code></pre>
</li>
<li>
<p>拼接：</p>
<pre><code class="language-powershell">$array=$array1+$array2
$array = $array * 3    # 复制并拼接(使用这种方法可构造初始值为固定值的数组)
</code></pre>
</li>
</ol>
<h5 id="数组过滤"><a class="header" href="#数组过滤">数组过滤</a></h5>
<p>基于数组元素或元素属性的值过滤元素。如果数组元素本身就是字符串对象，则直接在迭代语句中使用<code>$_</code>。</p>
<pre><code class="language-shell">$data | Where-Object {$_.Name -eq w32time}
$data.Where({$_.FirstName -eq 'Kevin'})   # 使用成员函数
$data | Select-Object -First 3
</code></pre>
<h5 id="分组统计"><a class="header" href="#分组统计">分组统计</a></h5>
<pre><code class="language-powershell">$data | Group-Object -Property ModuleName | 
        Sort-Object -Property Count -Descending
</code></pre>
<h4 id="字典hashtable"><a class="header" href="#字典hashtable">字典（hashtable）</a></h4>
<pre><code class="language-powershell">$hashtable = @{}
$hashtable['key'] = $value 
</code></pre>
<p>字典可传递给命令，以代替逐个传递命令行参数，方便动态构造传入参数。</p>
<p><a href="https://docs.microsoft.com/en-us/powershell/scripting/learn/deep-dives/everything-about-hashtable?view=powershell-7.2">Everything you wanted to know about hashtables - PowerShell | Microsoft Docs</a></p>
<h3 id="运算符-18"><a class="header" href="#运算符-18">运算符</a></h3>
<p>具有相同优先级的运算符从左到右依次计算。例外：赋值运算符、类型转换运算符、和取反运算符（<code>!</code>，<code>-not</code>，<code>-bnot</code>）从有至左计算。</p>
<p>可以使用<code>()</code>来显式限定优先计算的部分表达式。</p>
<p>运算符优先级从高到低<sup class="footnote-reference"><a href="#preced">2</a></sup>：</p>
<ul>
<li>
<p><code>$(), @(), (), @{}</code></p>
</li>
<li>
<p><code>. ?.</code> (member access)</p>
</li>
<li>
<p><code>::</code> (static)</p>
</li>
<li>
<p><code>[0] ?[0]</code> (index operator)</p>
</li>
<li>
<p><code>[int]</code> (cast operators)</p>
<pre><code class="language-powershell">[datetime]$birthday = &quot;1/10/66&quot;   # 将birthday转换为datetime类型
</code></pre>
</li>
<li>
<p><code>-split</code> (unary)</p>
</li>
<li>
<p><code>-join</code> (unary)</p>
</li>
<li>
<p><code>,</code> (comma operator)</p>
</li>
<li>
<p><code>++ --</code>：自增运算符，支持前置或后置。</p>
</li>
<li>
<p><code>! -not</code>：逻辑取反运算。</p>
</li>
<li>
<p><code>..</code> (range operator)</p>
</li>
<li>
<p><code>-f</code> (format operator)</p>
<pre><code class="language-powershell">&quot;{0:N2} - {1}&quot; -f 10 1.5
</code></pre>
</li>
<li>
<p><code>-</code> (unary/negative)</p>
</li>
<li>
<p><code>* / %</code></p>
</li>
<li>
<p><code>+ -</code></p>
</li>
<li>
<p>以下命令具有同等优先级：</p>
<ul>
<li>
<p><code>-split -join</code> (binary)：分割字符串（合并见数组运算）。</p>
<pre><code class="language-powershell">$array=&quot;abcdefghi&quot; -split &quot;de&quot; # -&gt; $array=&quot;abcdefghi&quot;.split(&quot;de&quot;)
</code></pre>
</li>
<li>
<p><code>-is -isnot</code>：判断是否为.Net Framework类型。</p>
<pre><code class="language-powershell">42 –is [int]
</code></pre>
</li>
<li>
<p><code>-as</code>：类型转换。</p>
<pre><code class="language-powershell">$a = 42 –as [String]
</code></pre>
</li>
<li>
<p><code>-eq -ne -gt -ge -lt -le</code>：比较运算符。涉及字符串比较的运算符默认为大小写不敏感的，带前缀<code>c</code>的运算符（<code>-ceq</code>）为大小写敏感的（具有同等优先级）。</p>
<blockquote>
<p>不支持<code>==,!=,&gt;,&lt;=,&lt;,&lt;=</code>。</p>
</blockquote>
</li>
<li>
<p><code>-match -notmatch</code>：正则表达式匹配，返回是否匹配；</p>
</li>
<li>
<p><code>-like -notlike</code>：通配符匹配；</p>
</li>
<li>
<p><code>-in -notIn</code>，<code>-contains -notContains</code></p>
</li>
<li>
<p><code>-replace</code>：字符串替换。</p>
<pre><code class="language-powershell">&quot;abcde&quot; -replace &quot;bc&quot;, &quot;TEST&quot;  # replace bc with TEST
# aTESTde
</code></pre>
</li>
</ul>
</li>
<li>
<p><code>-band -bnot -bor -bxor -shr -shl</code>：位运算，<code>-shl, -shr</code>（移位）。</p>
</li>
<li>
<p><code>-and -or -xor</code>：逻辑运算。</p>
</li>
<li>
<p>以下命令非真正的运算符而是PowerShell命令语法的一部分，在命令解释执行过程中具有最低优先级。</p>
<ul>
<li>
<p><code>.</code> (dot-source)</p>
</li>
<li>
<p><code>&amp;</code> (call)</p>
</li>
<li>
<p><code>? &lt;if-true&gt; : &lt;if-false&gt;</code> (Ternary operator)</p>
</li>
<li>
<p><code>??</code> (null-coalese operator)</p>
</li>
<li>
<p><code>|</code> (pipeline operator)</p>
</li>
<li>
<p><code>&gt; &gt;&gt; 2&gt; 2&gt;&gt; 2&gt;&amp;1</code></p>
</li>
<li>
<p><code>&amp;&amp; ||</code> (pipeline chain operators)</p>
</li>
<li>
<p><code>= += -= *= /= %= ??=</code>：赋值运算符。</p>
<pre><code class="language-powershell">$result=$a*$b
</code></pre>
</li>
</ul>
</li>
</ul>
<h3 id="容器类型-2"><a class="header" href="#容器类型-2">容器类型</a></h3>
<p>数组定义后无法增加元素，PowerShell可调用多种.NET容器类型以解决此问题。</p>
<h4 id="arraylist-1"><a class="header" href="#arraylist-1">ArrayList</a></h4>
<pre><code class="language-powershell">$myarray = [System.Collections.ArrayList]::new()
[void]$myArray.Add('Value')   # [void] to suppress return value.
</code></pre>
<h4 id="list-3"><a class="header" href="#list-3">List</a></h4>
<p><code> ArrayList</code>不支持泛型，因此类似于数组默认存储<code>PSObject</code>元素。<code>List</code>类型支持泛型（类似于数组声明时限定类型）：</p>
<pre><code class="language-powershell">$mylist = [System.Collections.Generic.List[int]]::new()
$mylist = [System.Collections.Generic.List[int]]@(1,2,3) # 将数组转换为List
</code></pre>
<blockquote>
<p>对于类型元素多样的情况，也可使用<code>PSObject</code>作为类型参数。</p>
</blockquote>
<p><code>List</code>和<code>ArrayList</code>都支持元素的的增加和删除。</p>
<pre><code class="language-powershell">[void]$myList.Remove(&quot;Two&quot;)      # -&gt; True|False: if element is found
[void]$drives.Remove($drives[2]) # remove reference type
</code></pre>
<h4 id="stringbuilder-1"><a class="header" href="#stringbuilder-1">StringBuilder</a></h4>
<p>https://powershellexplained.com/2017-11-20-Powershell-StringBuilder/</p>
<h4 id="其他容器类型"><a class="header" href="#其他容器类型">其他容器类型</a></h4>
<p><a href="https://gist.github.com/kevinblumenfeld/4a698dbc90272a336ed9367b11d91f1c">Types.md (github.com)</a></p>
<h3 id="时间日期-2"><a class="header" href="#时间日期-2">时间日期</a></h3>
<pre><code class="language-powershell">date=Get-Date \
	-Format &quot;dddd MM/dd/yyyy HH:mm K&quot; \  # 返回个格式化字符串。
   -UFormat &quot;%A %m/%d/%Y %R %Z&quot; \
	-DisplayHint Date \  # 仅显示日期
	-Year 2020 -Month 12 -Day 31 \ # 用户初始化
</code></pre>
<pre><code class="language-powershell"> | Specifier | Definition |
 | --- | --- |
 | `dddd` | Day of the week - full name |
 | `MM` | Month number |
 | `dd` | Day of the month - 2 digits |
 | `yyyy` | Year in 4-digit format |
 | `HH:mm` | Time in 24-hour format -no seconds |
 | `K` | Time zone offset from Universal Time Coordinate (UTC) |
 
 | Specifier | Definition |
 | --- | --- |
 | `%A` | Day of the week - full name |
 | `%m` | Month number |
 | `%d` | Day of the month - 2 digits |
 | `%Y` | Year in 4-digit format |
 | `%R` | Time in 24-hour format -no seconds |
 | `%Z` | Time zone offset from Universal Time Coordinate (UTC) |
</code></pre>
<p>.NET format specifiers (/dotnet/standard/ba
se-types/custom-date-and-time-format-strings?view=netframework-4.8)</p>
<pre><code class="language-powershell">date.DayOfYear
$timelabel = Get-Date -Format 'yyyy-MM-ddTHHmmss'
New-Item -Path C:\Test\$timelabel -Type Directory
</code></pre>
<h3 id="内置变量-1"><a class="header" href="#内置变量-1">内置变量</a></h3>
<pre><code class="language-powershell">$PSVersionTable   # Powershell版本信息
$PROFILE          # Powershell配置文件路径
</code></pre>
<h3 id="对象"><a class="header" href="#对象">对象</a></h3>
<p>使用<code>Get-Noun</code>方法获取对象，其中<code>None</code>代表对象类型。</p>
<h4 id="对象成员"><a class="header" href="#对象成员">对象成员</a></h4>
<p>获取对象类型，及其成员属性/方法信息。</p>
<pre><code class="language-powershell">$Obj | Get-Member
$Obj | Get-Member -MemberType {Method|Property...} -Name name
</code></pre>
<p><code>Get-Member</code>仅显示默认显示的成员。如果要显示所有成员，可使用<code>Select-Object</code>筛选对象属性<strong>值</strong>，返回仅包含指定属性（模式）的对象。</p>
<pre><code class="language-powershell">$Obj | Select-Object -Property {*|FriendlyName,Issuer}
                     -ExpandProperty SerialNumber  # 将返回值转换为字符串而非对象
</code></pre>
<blockquote>
<p><code>*</code>获取对象所有属性，反之给出要获取的属性名列表（可包含通配符）。</p>
<p>如果管道输入一个序列，则返回每个对象的属性值。</p>
</blockquote>
<h5 id="对象方法"><a class="header" href="#对象方法">对象方法</a></h5>
<p>对象方法通常用于修改对象。</p>
<h5 id="访问对象属性"><a class="header" href="#访问对象属性">访问对象属性</a></h5>
<pre><code class="language-powershell">$x=$myObject.PropertyName
</code></pre>
<p>动态访问对象的属性：</p>
<pre><code class="language-powershell">$PROP = 'Name'
$myObject.$PROP   # $myObject.&quot;Name&quot; =&gt; $myObject.Name
</code></pre>
<h4 id="providers"><a class="header" href="#providers">Providers</a></h4>
<p>提供访问数据的统一接口，数据以类似文件系统的树形结构组织。</p>
<p><code>Get-PSProvider</code>列出所有支持的数据接口<strong>类型</strong>，包括文件系统、证书目录、注册表等。特别地，==PowerShell的函数、环境变量==等也支持该接口。</p>
<pre><code class="language-powershell">Get-PSProvider
# Name           Capabilities                          Drives
# ----           ------------                          ------
# Registry       ShouldProcess, Transactions           {HKLM, HKCU}
# Alias          ShouldProcess                         {Alias}
# Environment    ShouldProcess                         {Env}
# FileSystem     Filter, ShouldProcess, Credentials    {C, D, E, F}
# Function       ShouldProcess                         {Function}
# Variable       ShouldProcess                         {Variable}
# Certificate    ShouldProcess                         {Cert}
# WSMan          Credentials                           {WSMan}
</code></pre>
<p><code>Get-PSDrive</code>获取所有<strong>支持类型</strong>的数据源<strong>实例</strong>信息。</p>
<pre><code class="language-powershell">Get-PSDrive
# Name      Used (GB)  Free (GB) Provider      Root               
# ----      ---------  --------- --------      ----               
# Alias                          Alias                            
# Cert                           Certificate   \                  
# C            256.94     674.00 FileSystem    C:\                
# D            310.46    1552.56 FileSystem    D:\                
# E            920.11    6531.80 FileSystem    E:\                
# F                              FileSystem    F:\                
# Env                            Environment                      
# Function                       Function                         
# HKCU                           Registry      HKEY_CURRENT_USER  
# HKLM                           Registry      HKEY_LOCAL_MACHINE 
# Variable                       Variable                         
# WSMan                          WSMan                            
</code></pre>
<blockquote>
<p>省略了<code>CurrentLocation</code>属性，调整了显示顺序。</p>
</blockquote>
<p>使用<code>Get-ChildItem</code>读取数据源路径下的数据。</p>
<pre><code class="language-powershell">Get-ChildItem -Path Cert:\LocalMachine\CA
Get-ChildItem -Path Function:
</code></pre>
<blockquote>
<p>路径的根为<code>Name:</code>，其中<code>Name</code>为数据源实例名称，如<code>C:</code>、<code>Cert:</code>等。</p>
</blockquote>
<h4 id="services"><a class="header" href="#services">Services</a></h4>
<pre><code class="language-powershell">Get-Service &lt;Name&gt;
</code></pre>
<p>调用服务的方法：</p>
<pre><code class="language-powershell">$service=$(Get-Service -Name w32time)
$service.Stop()
</code></pre>
<blockquote>
<p>成员方法可用于修改获取的对象，而通常没有相关<code>cmdlet</code>直接修改对象。</p>
</blockquote>
<h4 id="自定义对象类型"><a class="header" href="#自定义对象类型">自定义对象类型</a></h4>
<pre><code class="language-shell">$obj = [pscustomobject]@{
   FirstName='Kevin';
   LastName='Marquette'
}
</code></pre>
<h5 id="添加和删除属性"><a class="header" href="#添加和删除属性">添加和删除属性</a></h5>
<pre><code class="language-powershell">$myObject | Add-Member -MemberType NoteProperty -Name 'ID' -Value 'KevinMarquette'
$myObject.psobject.properties.remove('ID')
</code></pre>
<p>添加方法</p>
<pre><code class="language-powershell">$scriptBlock = {...}  # 使用this引用目标对象
Add-Member -MemberType ScriptMethod -InputObject $myObject -Name 'ToHashtable' -Value $scriptBlock
</code></pre>
<h2 id="语法-5"><a class="header" href="#语法-5">语法</a></h2>
<h3 id="语句-2"><a class="header" href="#语句-2">语句</a></h3>
<p>使用<code>;</code>在一行书写多条语句；</p>
<h5 id="换行"><a class="header" href="#换行">换行</a></h5>
<p><code>,</code>，<code>{}</code>，<code>[]</code>，<code>()</code>，<code>;</code>，<code>=</code>，<code>'</code>，<code>&quot;</code>可以支持命令跨行书写。</p>
<pre><code class="language-powershell">ps_cmd (expr)           # &quot;(...)&quot; 优先计算子表达式并返回值
</code></pre>
<p>如果命令中包含需要首先展开的参数，则使用<code>&amp;</code>对参数进行展开，然后执行展开后的命令语句。</p>
<pre><code class="language-powershell">&amp; $str_cmd $str_opts    # 执行字符串参数所表示的命令
</code></pre>
<p>==在行末使用<code>`</code>强制命令换行以增强可读性==，换行命令间可包含多行注释内容<code>&lt;#...#&gt;</code>。</p>
<h5 id="引号"><a class="header" href="#引号">引号</a></h5>
<blockquote>
<p><em>In PowerShell, you should always use single quotes instead of double quotes unless the contents of the quoted string contains a variable that needs to be expanded to its actual value. By using single quotes, PowerShell doesn't have to parse the contents contained within the quotes so your code runs a little faster.</em></p>
</blockquote>
<h5 id="注释-2"><a class="header" href="#注释-2">注释</a></h5>
<p>单行注释：<code>#</code>后续内容为注释；</p>
<p>多行注释：<code>&lt;# comment #&gt;</code>。</p>
<h4 id="管道-2"><a class="header" href="#管道-2">管道</a></h4>
<p>通过管道传递对象（变量、数组）将多个命令连接起来。</p>
<pre><code class="language-powershell">dir | Sort-Object -Descending | Select-Object -First 1
</code></pre>
<blockquote>
<p>使用管道操作符连接的命令可在操作符后换行，以方便阅读。</p>
</blockquote>
<p>命令必须产生输出才能传递给管道，使用<code>-PassThru</code>参数强制命令输出内容。通过帮助文档可查看命令的输入和输出要求（<code>INPUT</code>，<code>OUTPUT</code>），查看参数帮助文档以确定参数值是否接受管道输入以及接受输入的类型（<code>Accept pipeline input? True (ByValue, ByPropertyName)</code>）。</p>
<pre><code class="language-powershell">Get-Command -ParameterType ServiceController
</code></pre>
<blockquote>
<p>帮助文档中可能会给出命令的输入输出说明（是否接受管道输入）。</p>
</blockquote>
<p>非PowerShell命令输出的文本行会被自动转换为字符串对象，因此后续命令可基于字符串对象进行计算（如<a href="Windows/Windows%20Shell.html#%E6%95%B0%E7%BB%84%E8%BF%87%E6%BB%A4">过滤</a>）。</p>
<h5 id="左侧过滤优先"><a class="header" href="#左侧过滤优先">左侧过滤优先</a></h5>
<p>优先使用命令参数过滤返回结果（除非过滤条件没有对应参数支持）；对返回结果进行过滤（<a href="Windows/Windows%20Shell.html#%E6%95%B0%E7%BB%84%E5%AF%B9%E8%B1%A1%E8%BF%90%E7%AE%97"><code>Where-Object</code></a>）可能产生较大开销。</p>
<h5 id="右侧格式化优先"><a class="header" href="#右侧格式化优先">右侧格式化优先</a></h5>
<p>尽可能最后对数据执行<a href="Windows/Windows%20Shell.html#%E6%A0%BC%E5%BC%8F%E8%BE%93%E5%87%BA">格式化输出</a>（如<code>Format-Table</code>）。</p>
<h3 id="流程控制-9"><a class="header" href="#流程控制-9">流程控制</a></h3>
<h4 id="分支"><a class="header" href="#分支">分支</a></h4>
<pre><code class="language-powershell">if (&lt;result1-to-be-matched&gt; -eq (&lt;test-expression&gt;)) {&lt;action&gt;}
</code></pre>
<p><a href="https://docs.microsoft.com/en-us/powershell/scripting/learn/deep-dives/everything-about-if?view=powershell-7.2">Everything you wanted to know about the if statement - PowerShell | Microsoft Docs</a></p>
<pre><code class="language-powershell">switch [-regex| -wildcard| -exact] [-casesensitive](&lt;test-expression&gt;)
{
    &lt;result1-to-be-matched&gt; {&lt;action&gt;}
    &lt;result2-to-be-matched&gt; {&lt;action&gt;}
    default { &lt;action-scriptblock&gt; }
}
</code></pre>
<blockquote>
<p>默认为精确比较（<code>-exact</code>）。如果输入对象为数组，则<a href="Windows/Windows%20Shell.html#%E8%BF%AD%E4%BB%A3%E6%95%B0%E7%BB%84">对每个元素进行计算</a>。</p>
</blockquote>
<p><a href="https://docs.microsoft.com/en-us/powershell/scripting/learn/deep-dives/everything-about-switch?view=powershell-7.2">Everything you ever wanted to know about the switch statement - PowerShell | Microsoft Docs</a></p>
<h4 id="循环-9"><a class="header" href="#循环-9">循环</a></h4>
<pre><code class="language-powershell">for ($i = 1; $i -lt 5; $i++) {
	Write-Output &quot;Sleeping for $i seconds&quot;
	Start-Sleep -Seconds $i
}
</code></pre>
<blockquote>
<p><a href="Windows/Windows%20Shell.html#%E8%BF%AD%E4%BB%A3%E6%95%B0%E7%BB%84">数组迭代方法</a>。</p>
</blockquote>
<pre><code class="language-powershell">do{ statements } until (cond_expr)
do{ statements } while (cond_expr)
while (cond_expr) { statements }
</code></pre>
<h4 id="跳转-2"><a class="header" href="#跳转-2">跳转</a></h4>
<p>使用<code>break</code>，<code>continue</code>，<a href="https://mikefrobbins.com/2015/07/23/the-powershell-return-keyword/"><code>return</code></a>控制循环执行（loop, switch）。</p>
<h5 id="labeled-continue"><a class="header" href="#labeled-continue">labeled continue</a></h5>
<p>用于连续中断多层循环。</p>
<pre><code class="language-powershell">:labelA for ($i = 1; $i -le 10; $i++) {
    :labelB for ($j = 1; $j -le 10; $j++) {
        :labelC for ($k = 1; $k -le 10; $k++) {
            if ($conditionA) {
                continue labelA   # 连续中断
            else if ($conditionB) {
                continue labelB   # 等效于brek
            } else {
                $condition = Update-Condition
            }
        }
    }
}
</code></pre>
<h4 id="异常处理-7"><a class="header" href="#异常处理-7">异常处理</a></h4>
<pre><code class="language-powershell">try { CmdName -ErrorAction Stop } catch {...}
</code></pre>
<blockquote>
<p><em>Only terminating errors are caught.</em></p>
</blockquote>
<p><a href="https://docs.microsoft.com/en-us/powershell/scripting/learn/deep-dives/everything-about-exceptions?view=powershell-7.2">Everything you wanted to know about exceptions - PowerShell | Microsoft Docs</a></p>
<h3 id="函数-9"><a class="header" href="#函数-9">函数</a></h3>
<p>函数命名遵循<code>Verb-Noun</code>原则（通过<code>Get-Verb</code>查看常用动词）。</p>
<pre><code class="language-powershell">function Get-Version {
    [CmdletBinding()] # &lt;&lt; turns into an advanced function
    param (
      [Parameter(Mandatory)]                # 必须提供的参数
      [String[]]$ComputerName,              # 声明类型以在运行时自动执行参数类型校验
      
      [ValidateNotNullOrEmpty()]             # 可选参数
      [string[]]$ComputerName = $some_value, # 可选参数的默认值
      
      [Parameter(Mandatory,ValueFromPipeline)] # 接受管道传递参数(by value
      [String[]]$ComputerName, # ValueFromPipelineByPropertyName(by name)
	)
	dynamicparam {&lt;statement list&gt;}
	begin { begin_statements }
	process { process_statements }
	end { end_statements }
}
function Get-Version([type1]$param1[,[type2]$param2]) {}
</code></pre>
<p>通过<code>param</code>声明输入参数，参数命名尽量与内置标准命令方式一致，多个参数以<code>,</code>分隔；对于较为简单的参数声明，也可以直接在函数名后声明。</p>
<h4 id="输入参数"><a class="header" href="#输入参数">输入参数</a></h4>
<h5 id="参数类型"><a class="header" href="#参数类型">参数类型</a></h5>
<ul>
<li>命名参数：通过<code>param()</code>语句声明的参数，可以指定默认值，为指定默认值的参数在运行时必须提供参数值，否则函数报错。</li>
<li>位置参数：非命名参数，通过<code>$args[i]</code>数组访问。可通过<code>@args</code>将所有参数传递给其他函数或命令。</li>
<li>开关参数：通过<code>param()</code>声明类型为<code>[switch]</code>的参数。不需要为该参数提供值，当该参数选项出现在命令时，参数的的值为<code>True</code>。</li>
<li>动态参数：</li>
</ul>
<h5 id="从管道读取参数"><a class="header" href="#从管道读取参数">从管道读取参数</a></h5>
<p><code>begin</code>、<code>process</code>和<code>end</code>语句块用于处理管道输入。<code>begin</code>和<code>end</code>会在函数开始和结束时分别被执行一次，而<code>process</code>语句块则对每一个管道输入对象<code>$_</code>执行一次。</p>
<p>如果声明了以上语句块，则函数的所有语句都必须位于语句块中。未声明语句块的情况，所有语句相当于位于<code>end</code>语句块中。</p>
<h5 id="过滤器"><a class="header" href="#过滤器">过滤器</a></h5>
<p>过滤器(Filters)可被看作只有<code>process</code>代码块的函数。</p>
<h4 id="返回值-4"><a class="header" href="#返回值-4">返回值</a></h4>
<p>函数的返回值可以在终端显示、赋值给变量或转递给其他函数/命令。函数中可通过调用的命令返回数据，或通过调用<code>return</code>返回数据对象。<code>return</code>语句会立即令函数返回。</p>
<h4 id="高级函数"><a class="header" href="#高级函数">高级函数</a></h4>
<p>高级函数具有自动添加的公共参数，例如<code>Debug</code>和<code>Verbose</code>。</p>
<p><a href="https://docs.microsoft.com/en-us/powershell/scripting/learn/deep-dives/everything-about-shouldprocess?view=powershell-7.2">Everything you wanted to know about ShouldProcess - PowerShell | Microsoft Docs</a></p>
<h3 id="cmdlets"><a class="header" href="#cmdlets">cmdlets</a></h3>
<h4 id="注释文档"><a class="header" href="#注释文档">注释文档</a></h4>
<p>函数注释文档可位于：函数体开头（位于<code>{</code>之后的行）；函数体结束前（位于<code>}</code>之前），或==函数定义关键字前<code>function</code>的行（不可有空行隔开）==。</p>
<p>脚本注释文档位于脚本开始或结束。</p>
<p>脚本模块注释文档<code>.psm1</code>与函数注释文档语法一致。</p>
<pre><code class="language-powershell">&lt;#
.SYNOPSIS
    函数用途简要说明。

.DESCRIPTION
    函数功能的详细描述。

.PARAMETER ComputerName
    参数说明

.EXAMPLE
     使用示例。

.INPUTS
    输入类型

.OUTPUTS
    输出类型

.NOTES
    Author:  Mike F Robbins
    Website: http://mikefrobbins.com
    Twitter: @mikefrobbins
#&gt;
</code></pre>
<p><code>PARAMETER</code>和<code>EXAMPLE</code>可声明多次。</p>
<div class="footnote-definition" id="comment-keywords"><sup class="footnote-definition-label">3</sup>
<p> <a href="https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_comment_based_help?view=powershell-7.2#comment-based-help-keywords">Comment-based help keywords</a>。</p>
</div>
<h3 id="命名空间-4"><a class="header" href="#命名空间-4">命名空间</a></h3>
<p>在脚本开始位置引入命名空间，方便引用其中的类型和方法。</p>
<pre><code class="language-powershell">using namespace System.Collections.Generic
$myList = [List[int]]@(1,2,3)
</code></pre>
<h3 id="作用域"><a class="header" href="#作用域">作用域</a></h3>
<p><a href="https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_scopes?view=powershell-7.2">about Scopes - PowerShell | Microsoft Learn</a></p>
<h2 id="输入输出-10"><a class="header" href="#输入输出-10">输入输出</a></h2>
<pre><code class="language-powershell">Get-Content [-Path] filepath      # -&gt; cat, type
Write-Output 'message' &gt; filename # -&gt; echo
'message' &gt; filename
'message' | Out-File -FilePath filename
</code></pre>
<p>不同级别的输出函数：</p>
<pre><code class="language-powershell">Write-Verbose -Message &quot;message&quot;  # 仅在开启Verbose选项时输出
Write-Debug
Write-Information
Write-Warning
Write-Error
</code></pre>
<h3 id="重定向-2"><a class="header" href="#重定向-2">重定向</a></h3>
<h5 id="输出重定向"><a class="header" href="#输出重定向">输出重定向</a></h5>
<p><code>n&gt;, n&gt;&gt;</code>：输出流<code>n=</code>：<code>*</code> All output；<code>1</code> Success output；<code>2</code> Errors；<code>3</code> Warning messages；<code>4</code> Verbose output；<code>5</code> Debug messages。</p>
<h5 id="吸收输出"><a class="header" href="#吸收输出">吸收输出</a></h5>
<ul>
<li><code>expr | Out-Null</code>，<code>expr &gt; $null</code>；</li>
<li><code>[void] expr</code>；</li>
<li><code>$null=expr</code>；</li>
</ul>
<h3 id="格式输出"><a class="header" href="#格式输出">格式输出</a></h3>
<p>当输出为多个对象组成的列表格式（即<code>key:value</code>形式），可通过<code>Format-Table</code>将其转换为表格形式：</p>
<pre><code class="language-powershell">$obj | Select-Object -Property Name,Type,Status | Format-Table
</code></pre>
<p>反之，可以将表格输出转换为列表输出。</p>
<pre><code class="language-powershell">Format-List
</code></pre>
<p><code>Format-*</code>命令会将输出对象封装为<code>Foramt</code>对象，因此可能<a href="Windows/Windows%20Shell.html#%E5%8F%B3%E4%BE%A7%E6%A0%BC%E5%BC%8F%E5%8C%96%E4%BC%98%E5%85%88">不再能传递给其他命令</a>。</p>
<h5 id="文本模式输出"><a class="header" href="#文本模式输出">文本模式输出</a></h5>
<p>将对象转换为文本输出（可用于传统基于文本的命令进行后续处理）：</p>
<pre><code class="language-powershell">Find-Module *cim* | Out-String -Stream | grep CimSession
</code></pre>
<p><code>-Stream</code>将输出按行分解便于后续处理。</p>
<p><code>-Width</code>设置输出宽度，避免换行或截断。</p>
<h3 id="网络应用"><a class="header" href="#网络应用">网络应用</a></h3>
<blockquote>
<p>The <code>Invoke-WebRequest</code> cmdlet sends HTTP and HTTPS requests to a web page or web service. It parses the response and returns collections of links, images, and other significant HTML elements.</p>
</blockquote>
<pre><code class="language-powershell">Invoke-WebRequest # alias =&gt; curl,wget
	-Uri &lt;uri&gt;
	-Headers &lt;dict&gt;  # http header
	-Body &lt;obj&gt;      # http body
	-InFile &lt;file&gt;   # read request from file
	-OutFile &lt;filename&gt;  # 未指定则输出到管道
	-Method &lt;m&gt;      # http method: get/put/post...
</code></pre>
<h2 id="脚本-1"><a class="header" href="#脚本-1">脚本</a></h2>
<p>脚本文件类型<code>.ps1</code>。</p>
<p>在当前Shell环境执行脚本。</p>
<pre><code class="language-powershell">. 'c:\scripts\sample.ps1'
</code></pre>
<h5 id="脚本文件编码"><a class="header" href="#脚本文件编码">脚本文件编码</a></h5>
<p>PowerShell 5.x默认使用的是本地化编码方案（如GBK/936），因此如果包含非ASCII码文字的脚本应该使用对应区域的本地化编码方案保存。（例外：VS Code中的集成终端代码页为936，但能正确读取UTF-8编码）</p>
<p>PowerShell 7.x默认使用UTF-8/65001编码。</p>
<p>PowerShell解释器会首先读入整个脚本文件内容，并检查语法错误。如果出现编码问题导致语法错误，则会直接抛出语法错误而不执行文件。</p>
<p>通过启动配置<code>$Profile</code>修改终端的默认编码（<a href="https://stackoverflow.com/a/49481797/6571140">由于.NET缓存机制的原因，在启动后的PowerShell终端中调用<code>chcp</code>命令无效</a>，<code>chcp</code>在<code>cmd</code>中是有效的）：</p>
<pre><code class="language-powershell">$OutputEncoding = [console]::InputEncoding `
                = [console]::OutputEncoding `
                = New-Object System.Text.UTF8Encoding
</code></pre>
<h3 id="作用域-1"><a class="header" href="#作用域-1">作用域</a></h3>
<h4 id="全局作用域"><a class="header" href="#全局作用域">全局作用域</a></h4>
<p>位于脚本中的函数的作用域为脚本（<em>Script</em> scope），当脚本被加载或执行完后，脚本作用域中的函数不再可见。使用<code>.</code>命令加载脚本中的函数到全局作用域（<em>Global</em> scope）。</p>
<pre><code class="language-powershell">. .\My-Script.ps1
</code></pre>
<h4 id="脚本模块"><a class="header" href="#脚本模块">脚本模块</a></h4>
<p>以<code>.psm1</code>保存的脚本。如果脚本模块保存在PoweShell模块搜索路径下，<a href="Windows/Windows%20Shell.html#%E5%AF%BC%E5%85%A5%E6%A8%A1%E5%9D%97">则会被自动加载；反之，需要手动导入</a>。</p>
<pre><code class="language-powershell">Export-ModuleMember -Function Get-PublicFunction  # 在模块中导出定义公开函数
</code></pre>
<p>为模块创建元数据（元数据存储路径通常和模块位于同一路径下）：</p>
<pre><code class="language-powershell">New-ModuleManifest -Path $ModulePath\MyScriptModule\MyScriptModule.psd1 
                   -RootModule MyScriptModule      # 必须指定
                   -Author 'Mike F Robbins' 
                   -Description 'MyScriptModule' 
                   -CompanyName 'mikefrobbins.com'
Update-ModuleManifest # 更新元数据，重复调用New-ModuleManifest会导致GUID变化                   
</code></pre>
<p>导出的公开函数也可在元数据文件中指定：</p>
<pre><code class="language-powershell">FunctionsToExport = 'Get-PublicFunction'
</code></pre>
<h3 id="运行环境-4"><a class="header" href="#运行环境-4">运行环境</a></h3>
<h4 id="环境变量-3"><a class="header" href="#环境变量-3">环境变量</a></h4>
<h5 id="读取环境变量"><a class="header" href="#读取环境变量">读取环境变量</a></h5>
<pre><code class="language-powershell">Get-ChildItem env:  # 注意结尾的“:”
Get-ChildItem Env:JAVA_HOME # =&gt; Get-ChildItem Env:\JAVA_HOME
echo $Env:JAVA_HOME         # echo ${Env:JAVA_HOME} =&gt; echo ${Env:\JAVA_HOME}
Get-ChildItem Env: | Format-Table -Wrap -AutoSize
</code></pre>
<h5 id="设置环境变量"><a class="header" href="#设置环境变量">设置环境变量</a></h5>
<pre><code class="language-powershell">$Env:JAVA_HOME='C:\tools\jdk'  # 仅当前会话有效
$Env:Path='C:\tools\jdk;'+$Env:Path
</code></pre>
<blockquote>
<p>路径搜索优先级：从左至右搜索，将新路径置于左侧将覆盖已有配置。</p>
</blockquote>
<h4 id="脚本输入参数"><a class="header" href="#脚本输入参数">脚本输入参数</a></h4>
<p>脚本的输入参数格式与函数输入参数语法格式一致。</p>
<pre><code class="language-powershell">param (
    [string]$Target = '.\src',
    [string]$Source = '.\target'
)
</code></pre>
<p>定义的参数可在命令行中获得自动补全功能。</p>
<h4 id="语句的退出状态码"><a class="header" href="#语句的退出状态码">语句的退出状态码</a></h4>
<pre><code class="language-powershell">$?             # return 'True'/'False' for success/error
$LastExistCode # Return 0 for success
</code></pre>
<h4 id="执行策略"><a class="header" href="#执行策略">执行策略</a></h4>
<p>PowerShell 执行策略是一项安全功能，用于控制 PowerShell 加载配置文件和运行脚本的条件。 此功能有助于防止恶意脚本的执行。可以为本地计算机、当前用户或特定会话设置执行策略。 你还可以使用组策略设置为计算机和用户设置执行策略。本地计算机和当前用户的执行策略存储在注册表中。 不需要在 PowerShell 配置文件中设置执行策略。 特定会话的执行策略仅存储在内存中，并在会话关闭时丢失。</p>
<blockquote>
<p>执行策略不是限制用户操作的安全系统。 例如，当用户无法运行脚本时，可以通过在命令行中键入脚本内容来轻松地绕过策略。 相反，执行策略可帮助用户设置基本规则并防止无意中违反它们。</p>
</blockquote>
<div class="table-wrapper"><table><thead><tr><th>策略</th><th>详情</th></tr></thead><tbody>
<tr><td>AllSigned</td><td>脚本必须由信任发布方签名；在未确认的脚本运行前提示用户；==可能面临运行已签名的恶意脚本的风险==。</td></tr>
<tr><td>Bypass</td><td>不会阻止且不会产生警告或信息；</td></tr>
<tr><td>Default</td><td>默认策略：<strong>Restricted</strong> for Windows clients.<strong>RemoteSigned</strong> for Windows servers.</td></tr>
<tr><td>RemoteSigned</td><td>来自互联网的脚本需要来自信任发布方的数字签名；本地脚本允许执行。</td></tr>
<tr><td>Restricted</td><td>==允许单独执行命令，但不允许运行脚本==；</td></tr>
<tr><td>Undefined</td><td>If the policy in all scopes is <strong>Undefined</strong>, use <strong>Default</strong>.</td></tr>
<tr><td>Unrestricted</td><td>非Windows主机的默认策略；未签名脚本可以运行，非本地脚本运行前警告用户。</td></tr>
</tbody></table>
</div>
<h5 id="设置策略"><a class="header" href="#设置策略">设置策略</a></h5>
<pre><code class="language-powershell">Set-ExecutionPolicy &lt;policy&gt;
</code></pre>
<h2 id="标准库-3"><a class="header" href="#标准库-3">标准库</a></h2>
<h3 id="wmi和cim"><a class="header" href="#wmi和cim">WMI和CIM</a></h3>
<p>Windows Management Instrumentation (WMI)模块：弃用。</p>
<p>Common Information Model (CIM)模块：跨平台，通过CIM可访问WMI。</p>
<pre><code class="language-powershell">Get-Command -Module CimCmdlets
Get-CimInstance -Query 'Select * from Win32_BIOS'  # WMI Query Language (WQL)
Get-CimInstance -ClassName Win32_BIOS
</code></pre>
<p>远程管理（指定<code>ComputerName</code>参数）：以域管理员启动PowerShell并执行</p>
<pre><code class="language-powershell">Get-CimInstance -ComputerName dc01 -ClassName Win32_BIOS
</code></pre>
<p>或者首先提供凭据（密码）并创建CIM会话：</p>
<pre><code class="language-powershell">$CimSession = New-CimSession -ComputerName dc01 -Credential (Get-Credential)
Get-CimInstance -CimSession $CimSession -ClassName Win32_BIOS
</code></pre>
<h2 id="远程登录"><a class="header" href="#远程登录">远程登录</a></h2>
<p>从Windows可选功能中安装OpenSSH Server。</p>
<p><a href="https://docs.microsoft.com/en-us/windows-server/administration/openssh/openssh_install_firstuse">Installation of OpenSSH For Windows Server 2019 and Windows 10</a></p>
<p>远程登录后默认的Shell是<code>cmd.exe</code>，如果要启用<code>PowerShell</code>，可在命令窗口中运行<code>powershell</code>，或者直接在远程登录命令中运行该命令。</p>
<pre><code class="language-powershell">ssh user@host &quot;chcp65001 &amp;&amp; powershell&quot;
</code></pre>
<blockquote>
<p>直接进入Powershell会导致中文乱码，需要先切换编码到<code>UTF-8</code>。</p>
</blockquote>
<p><a href="https://docs.microsoft.com/en-us/powershell/scripting/learn/remoting/ssh-remoting-in-powershell-core?view=powershell-7.2">PowerShell Remoting Over SSH - PowerShell | Microsoft Docs</a></p>
<h2 id="附录-2"><a class="header" href="#附录-2">附录</a></h2>
<h3 id="cmd"><a class="header" href="#cmd">cmd</a></h3>
<p>注释语句：</p>
<pre><code class="language-bash">REM comment something
</code></pre>
<p>使用<code>^</code>对单条命令进行换行，<code>^</code>后不可包含任何符号。</p>
<h4 id="变量-9"><a class="header" href="#变量-9">变量</a></h4>
<p>变量名不区分大小写。查看变量：</p>
<pre><code class="language-powershell">set [ | more]
set var           # print: key=value
echo %variable%   # 使用`%%`读取变量的值，未定义的变量将打印变量名
</code></pre>
<h5 id="定义console环境变量"><a class="header" href="#定义console环境变量">定义console环境变量</a></h5>
<pre><code class="language-powershell">set variable=value   # 必须设用set，不支持VAR=VALUE
</code></pre>
<blockquote>
<p><code>PATH</code>既是环境变量，也是一个命令（单独使用<code>PATH</code>可显示<code>PATH</code>变量的值，也可使用<code>PATH=value</code>为<code>PATH</code>变量赋值，普通变量必须使用<code>set</code>命令）。</p>
</blockquote>
<p>参数变量：</p>
<pre><code class="language-sh">%1 %2 %3 %4 %5 %6 %7 %8 %9
</code></pre>
<pre><code class="language-sh">%~dp0
</code></pre>
<blockquote>
<p>获取当前执行文件所在目录。</p>
<p><a href="https://www.cnblogs.com/smwikipedia/archive/2009/03/30/1424749.html">扩充变量语法</a>。</p>
</blockquote>
<h5 id="字符串-7"><a class="header" href="#字符串-7">字符串</a></h5>
<p>字符串不需要使用引号表示，单双引号均为普通字符。将两个字符串连接即视为字符串拼接。</p>
<h5 id="环境变量-4"><a class="header" href="#环境变量-4">环境变量</a></h5>
<pre><code class="language-bash">echo %USERPROFILE%   # 用户目录
echo %PROGRAMDATA%   # 应用程序配置文件路径
chcp 65001  # 支持PowerShell
</code></pre>
<blockquote>
<p><strong>Windows Code page 936</strong>, is Microsoft's character encoding for <a href="https://en.wikipedia.org/wiki/Simplified_Chinese">simplified Chinese</a>, one of the four <a href="https://en.wikipedia.org/wiki/DBCS">DBCSs</a> for <a href="https://en.wikipedia.org/wiki/East_Asian_languages">East Asian languages</a>. Originally, Windows-936 covered <a href="https://en.wikipedia.org/wiki/GB_2312">GB 2312</a> (in its <a href="https://en.wikipedia.org/wiki/EUC-CN">EUC-CN</a> form), but it was expanded to cover most of <a href="https://en.wikipedia.org/wiki/GBK_(character_encoding)">GBK</a> with the release of <a href="https://en.wikipedia.org/wiki/Windows_95">Windows 95</a>.</p>
<p>https://en.wikipedia.org/wiki/UTF-8#Official_name_and_variants.</p>
</blockquote>
<p><a href="https://en.wikipedia.org/wiki/Windows_code_page">Windows Code Page</a>: <a href="Windows/936/1386">936/1386</a> (GBK), 950/1370 (Big5), 1200 (UTF-16LE), 1201 (UTF-16BE), 54936 (GB18030), 65001 (UTF-8).</p>
<h5 id="环境变量作用域"><a class="header" href="#环境变量作用域">环境变量作用域</a></h5>
<pre><code class="language-powershell">setlocal  # 执行之后所做的环境改动只限于批处理文件直到endlocal。
endlocal  # 脚本结束前隐式执行
</code></pre>
<h4 id="语句-3"><a class="header" href="#语句-3">语句</a></h4>
<pre><code class="language-powershell">dir &amp; echo foo
dir &amp;&amp; echo foo   # execute only if the first exited successfully
</code></pre>
<p><a href="https://stackoverflow.com/questions/8055371/how-do-i-run-two-commands-in-one-line-in-windows-cmd">batch file - How do I run two commands in one line in Windows CMD? - Stack Overflow</a></p>
<h4 id="常用命令"><a class="header" href="#常用命令">常用命令</a></h4>
<pre><code class="language-powershell">help [cmd]  # cmd /?
</code></pre>
<pre><code class="language-powershell">call jobname.bat
</code></pre>
<blockquote>
<p>调用脚本。</p>
</blockquote>
<pre><code class="language-powershell">pause
</code></pre>
<blockquote>
<p>暂停。</p>
</blockquote>
<pre><code class="language-powershell">exit
</code></pre>
<blockquote>
<p>退出。</p>
</blockquote>
<pre><code class="language-powershell">cd [/D] path 
</code></pre>
<blockquote>
<p>切换当前目录。</p>
</blockquote>
<pre><code class="language-powershell">type file
</code></pre>
<blockquote>
<p>输出文件内容。</p>
</blockquote>
<h3 id="流程控制-10"><a class="header" href="#流程控制-10">流程控制</a></h3>
<pre><code class="language-powershell">if [not] ERRORLEVEL &lt;number&gt; &lt;command&gt; [else &lt;expression&gt;]
if [not] &lt;string1&gt; == &lt;string2&gt; &lt;command&gt; [else &lt;expression&gt;]
if [not] exist &lt;filename&gt; &lt;command&gt; [else &lt;expression&gt;]
</code></pre>
<p><code>errorlevel</code>：上一条命令的执行状态。</p>
<p><a href="https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/if">if | Microsoft Docs</a></p>
<pre><code class="language-powershell">for {%% | %}&lt;variable&gt; in (&lt;set&gt;) do &lt;command&gt; [&lt;commandlineoptions&gt;]
# for %f in (*.doc *.txt) do type %f
</code></pre>
<p><a href="https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/for">for | Microsoft Docs</a></p>
<h3 id="控制台输入输出"><a class="header" href="#控制台输入输出">控制台输入输出</a></h3>
<pre><code class="language-powershell">echo on|off      # 控制是否回显命令行提示符
echo some string 
</code></pre>
<blockquote>
<p>字符串不需要使用引号表示，单双引号均为普通字符。</p>
</blockquote>
<h2 id="参考资料-6"><a class="header" href="#参考资料-6">参考资料</a></h2>
<div class="footnote-definition" id="pw101"><sup class="footnote-definition-label">4</sup>
<p><a href="https://docs.microsoft.com/en-us/powershell/scripting/learn/ps101/00-introduction">PowerShell 101</a>.
<sup class="footnote-reference"><a href="#nuget">1</a></sup>: <a href="https://docs.microsoft.com/en-us/powershell/scripting/gallery/how-to/working-with-packages/manual-download?view=powershell-7">Manual Package Download - PowerShell | Microsoft Docs</a></p>
</div>
<div class="footnote-definition" id="pwstd"><sup class="footnote-definition-label">5</sup>
<p><a href="https://docs.microsoft.com/en-us/powershell/scripting/lang-spec/chapter-01?view=powershell-7.2">Windows PowerShell Language Specification 3.0</a>
<sup class="footnote-reference"><a href="#pwcore">6</a></sup>: <a href="https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/?view=powershell-7.2">Reference - Microsoft.PowerShell.Core</a>
<sup class="footnote-reference"><a href="#preced">2</a></sup>: <a href="https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_operator_precedence?view=powershell-7.2">about Operator Precedence - PowerShell | Microsoft Docs</a></p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="windows应用软件"><a class="header" href="#windows应用软件">Windows应用软件</a></h1>
<h2 id="视频编辑"><a class="header" href="#视频编辑">视频编辑</a></h2>
<h3 id="字幕"><a class="header" href="#字幕">字幕</a></h3>
<h4 id="字幕格式"><a class="header" href="#字幕格式">字幕格式</a></h4>
<h5 id="srt"><a class="header" href="#srt">srt</a></h5>
<pre><code>1
00:00:01,000 --&gt; 00:00:04,000
&lt;font color=red&gt;{\fn黑体\fs27}这是一条字幕&lt;/font&gt;

2
00:00:04,100 --&gt; 00:00:06,000
&lt;i&gt;在经历了一场人生巨变之后&lt;/i&gt;
&lt;b&gt;When I was lying there in the VA hospital ...&lt;/b&gt;

</code></pre>
<blockquote>
<p>字幕包含序号，以空行分隔。可以添加HTML格式标记。</p>
</blockquote>
<p><a href="https://www.cnblogs.com/tocy/p/subtitle-format-srt.html">SRT字幕格式 - Tocy - 博客园 (cnblogs.com)</a></p>
<h4 id="字幕编辑软件"><a class="header" href="#字幕编辑软件">字幕编辑软件</a></h4>
<p><a href="https://www.nikse.dk/subtitleedit/">Subtitle Edit (nikse.dk)</a></p>
<p><a href="https://aegi.vmoe.info/">Aegisub 高级字幕编辑器 (vmoe.info)</a></p>
<h3 id="视频编码"><a class="header" href="#视频编码">视频编码</a></h3>
<h5 id="格式工厂"><a class="header" href="#格式工厂">格式工厂</a></h5>
<ul>
<li>问题1：添加字幕和倍速播放不能同时进行；</li>
</ul>
<h2 id="浏览器"><a class="header" href="#浏览器">浏览器</a></h2>
<p>防止浏览器自动使用到HTTPS协议：访问<code>chrome://net-internals/#hsts</code>。在<strong>Delete domain</strong>中输入要访问的域名，并点击删除（但无法删除系统内置规则的域名）。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="程序开发软件"><a class="header" href="#程序开发软件">程序开发软件</a></h1>
<h2 id="编辑器-1"><a class="header" href="#编辑器-1">编辑器</a></h2>
<h3 id="vim"><a class="header" href="#vim">Vim</a></h3>
<img src="应用软件/程序开发软件.assets/vim-vi-workmodel.png" alt="img" style="zoom:60%;" />
<p>https://www.runoob.com/linux/linux-vim.html</p>
<p><a href="http://xstarcd.github.io/wiki/vim/vim_replace_encodeing.html">vi使用技巧</a>。</p>
<h4 id="配置-2"><a class="header" href="#配置-2">配置</a></h4>
<p>在命令模式下输入<code>set</code>命令修改当前配置，或在配置文件<code>/etc/vim/vimrc</code>中配置相应命令以永久修改。</p>
<h5 id="缩进"><a class="header" href="#缩进">缩进</a></h5>
<pre><code class="language-sh"># edit 
set tabstop=4      
set softtabstop=0   # 不要将空格和tab混合输入
set shiftwidth=4    # 默认用4个空格
set autoindent      # 自动缩进
set expandtab       # tab转换为空格
# 对于下列文件类型，4个空格太宽了，可以换成2个空格。
autocmd FileType html,css,xml,yaml,json,sh set sw=2 ts=2 
</code></pre>
<p>https://www.kawabangga.com/posts/2817</p>
<h5 id="显示行号"><a class="header" href="#显示行号">显示行号</a></h5>
<pre><code class="language-shell">set [no]number          # =&gt; set [no]nu
set [no]relativenumber  # =&gt; set [no]rnu *
set numberwidth=2
</code></pre>
<blockquote>
<p><code>*</code>：相对行号和绝对行号可同时存在。</p>
</blockquote>
<h4 id="常用命令-1"><a class="header" href="#常用命令-1">常用命令</a></h4>
<h5 id="查找-10"><a class="header" href="#查找-10">查找</a></h5>
<pre><code class="language-sh">/&lt;search-pattern&gt;   # forward
?&lt;search-pattern&gt;   # backward
</code></pre>
<p>回到命令模式后，输入<code>n</code>查找下一个，输入<code>N</code>查找上一个。</p>
<h5 id="替换-3"><a class="header" href="#替换-3">替换</a></h5>
<p>使用<code>sed</code>替换语法：</p>
<pre><code class="language-sh">:n,[m]$s/&lt;origin&gt;/&lt;replace&gt;/g #替换第n行（到m行，默认到最后）中origin为replace
</code></pre>
<p>转义字符&quot;<code>/</code>&quot; $\rightarrow$ &quot;<code>\/</code>&quot;。</p>
<h5 id="复制粘贴"><a class="header" href="#复制粘贴">复制粘贴</a></h5>
<pre><code class="language-sh">yy  # 复制一行，
V   #选择连续多行，
v   # 移动方向键任意选择，Ctrl+v 选择光标开始的矩形区域
y   # 复制所选内容
d   # 剪切
p   # 粘贴所选内容，如果选择整行，则粘贴到所在行的后一行；否则粘贴到光标所在位置
</code></pre>
<h5 id="删除-6"><a class="header" href="#删除-6">删除</a></h5>
<pre><code class="language-sh"># 普通命令模式
gg	# 返回文件开始
dG	# 删除至文件末尾的所有行
# 底线命令模式
:1,$d   # 删除第1行至最后一行$的所有内容
:%d     # %代表所有行
</code></pre>
<h5 id="撤销重做"><a class="header" href="#撤销重做">撤销|重做</a></h5>
<pre><code class="language-sh">u,:u,:undo  # 撤销单步
4u          # 撤销多步
Ctrl+r      # 重做
</code></pre>
<h5 id="保存"><a class="header" href="#保存">保存</a></h5>
<pre><code class="language-shell">:w !sudo tee %   # 以管理员权限保存只读文件
</code></pre>
<blockquote>
<p>If <code>Ctrl+S</code> freezes your terminal, type <code>Ctrl+Q</code> to get it going again.</p>
</blockquote>
<h3 id="visual-studio-code-1"><a class="header" href="#visual-studio-code-1">Visual Studio Code</a></h3>
<h4 id="开发环境-6"><a class="header" href="#开发环境-6">开发环境</a></h4>
<h5 id="vscodemsys2"><a class="header" href="#vscodemsys2">VSCode+MSYS2</a></h5>
<p><a href="%E5%BA%94%E7%94%A8%E8%BD%AF%E4%BB%B6/../Windows/Windows%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86.html#MSYS2">安装MSYS2</a>后，在MSYS2终端中安装开发工具链，以C++/mingw64开发为例，</p>
<pre><code class="language-shell">pacman -S --needed base-devel mingw-w64-x86_64-toolchain
</code></pre>
<p>将<code>$MSYS2_ROOT/mingw64/bin</code>加入Windows路径，可在Windows下使用MSYS2的开发工具链。</p>
<p><a href="https://code.visualstudio.com/docs/cpp/config-mingw">Get Started with C++ and Mingw-w64 in Visual Studio Code</a></p>
<h4 id="资源管理器"><a class="header" href="#资源管理器">资源管理器</a></h4>
<h5 id="排除要显示的文件"><a class="header" href="#排除要显示的文件">排除要显示的文件</a></h5>
<p>设置的文件模式将不会在资源管理器中显示，如果直接在用户主目录下工作，通常需要将系统或程序产生的隐藏目录排除。</p>
<pre><code class="language-json">&quot;files.exclude&quot;: {
  &quot;.*hst&quot;: true,
  &quot;.*rc&quot;: true,
  &quot;.bash*&quot;: true,
  &quot;.pki&quot;: true,
  &quot;.vscode-server&quot;: true
}
</code></pre>
<h4 id="离线安装vscode远程服务"><a class="header" href="#离线安装vscode远程服务">离线安装VSCode远程服务</a></h4>
<p>在联网状态下，VSCode远程服务会在建立远程连接后自动安装。在离线状态下，自动安装会失败，但可以从日志中得到要安装的远程服务软件包的地址。</p>
<pre><code class="language-shell">https://update.code.visualstudio.com/commit:dfd34e8260c270da74b5c2d86d61aee4b6d56977/server-linux-x64/stable
</code></pre>
<p>利用此地址，可以从联网计算机上下载安装包，并解压到目标机器的<code>~/.vscode-server/bin/</code>目录下，并将解压内容根目录以上述URL中的commit ID命名。</p>
<h3 id="code-server"><a class="header" href="#code-server">Code-Server</a></h3>
<h4 id="安装-12"><a class="header" href="#安装-12">安装</a></h4>
<p><a href="https://coder.com/docs/code-server/latest/install">Install - code-server docs (coder.com)</a></p>
<p><a href="https://coder.com/docs/code-server/latest/guide">Usage - code-server docs (coder.com)</a></p>
<h4 id="安装插件"><a class="header" href="#安装插件">安装插件</a></h4>
<p>Code-Server从<a href="https://open-vsx.org/">Open VSX Registry</a>下载安装插件。如果存在网络问题，可离线安装：</p>
<pre><code class="language-shell">code-server --install-extension  ext_name.vsix  # --list-extensions
</code></pre>
<h4 id="反向代理"><a class="header" href="#反向代理">反向代理</a></h4>
<p>目前不支持为Web服务设置根路径，因此需要使用独立的服务站点（独立端口）来代理。</p>
<pre><code class="language-nginx">server {
    listen 80;
    listen [::]:80;
    server_name mydomain.com;
    location / {
      proxy_pass http://localhost:8080/;
      proxy_set_header Host $host;
      proxy_set_header Upgrade $http_upgrade;
      proxy_set_header Connection upgrade;
      proxy_set_header Accept-Encoding gzip;
    }
}
</code></pre>
<h4 id="多用户使用"><a class="header" href="#多用户使用">多用户使用</a></h4>
<p><img src="%E5%BA%94%E7%94%A8%E8%BD%AF%E4%BB%B6/%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E8%BD%AF%E4%BB%B6.assets/how-code-works.64be3f50.svg" alt="img" /></p>
<p>可以为每个系统用户启用一个服务：</p>
<pre><code class="language-shell">systemctl enable --now code-server@USER
# ExecStart=/usr/local/code-server 
</code></pre>
<p>服务将从用户目录下读取配置文件<code>~/.config/code-server/config.yaml</code>（配置项对应命令行参数名），其中包含服务的监听地址端口和身份认证配置。</p>
<pre><code class="language-yaml">bind-addr: 0.0.0.0:8081
auth: password
password: xxxxyyyy
#cert: /PATH/CERTFILE
#cert-key: /PATH/CERT_KEY
disable-telemetry: true
disable-update-check: true
user-data-dir: /PATH
extensions-dir: /PATH
</code></pre>
<p>建议使用普通用户建立Code-Server服务，防止用户越权修改服务器后台文件。 </p>
<h3 id="coder"><a class="header" href="#coder">Coder</a></h3>
<h4 id="安装-13"><a class="header" href="#安装-13">安装</a></h4>
<h5 id="预装环境"><a class="header" href="#预装环境">预装环境</a></h5>
<p>如果需要在本地使用docker部署工作空间，则需要首先<a href="%E5%BA%94%E7%94%A8%E8%BD%AF%E4%BB%B6/../%E6%9C%8D%E5%8A%A1%E5%99%A8/%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92.html#%E5%AE%89%E8%A3%85Docker%20Engine">安装docker</a>。</p>
<blockquote>
<p>如果未预先安装docker，会出现以下错误：<em><code>...Got permission denied while trying to connect to the Docker daemon socket</code></em>。此时，需要将用户<code>coder</code>加入<code>docker</code>组中。</p>
<pre><code class="language-shell">sudo usermod -aG docker coder
systemctl restart coder.service
</code></pre>
</blockquote>
<h5 id="在线安装"><a class="header" href="#在线安装"><a href="https://coder.com/docs/coder-oss/latest/install#installsh">在线安装</a></a></h5>
<pre><code class="language-shell">curl -fsSL https://coder.com/install.sh | sh
</code></pre>
<h5 id="离线安装-3"><a class="header" href="#离线安装-3"><a href="https://github.com/coder/coder/releases">离线安装</a></a></h5>
<p>使用发行版软件包<code>.deb</code>、<code>.rpm</code>、<code>.apk</code>安装。</p>
<h5 id="docker-compose安装"><a class="header" href="#docker-compose安装">Docker-compose安装</a></h5>
<h5 id="kuberneteshelm"><a class="header" href="#kuberneteshelm">Kubernetes+<a href="https://helm.sh/zh/docs/">Helm</a></a></h5>
<blockquote>
<p><em>Helm 是 Kubernetes 的包管理器。</em></p>
</blockquote>
<h4 id="配置和启动服务"><a class="header" href="#配置和启动服务">配置和启动服务</a></h4>
<p>服务的访问地址<code>CODER_ACCESS_URL</code>，可通过<code>/etc/coder.d/coder.env</code>配置。</p>
<pre><code class="language-shell">coder server 
      -a,--address $CODER_ADDRESS             # 127.0.0.1:3000 
      --access-url $CODER_ACCESS_URL          # http://localhost:3000
      --postgres-url $CODER_PG_CONNECTION_URL # 数据库地址*
      --global-config $CODER_CONFIG_DIR       # 配置数据目录**
sudo systemctl enable --now coder  # 作为服务启动
</code></pre>
<blockquote>
<p><code>*</code>：如果未指定，则Coder将自动下载PostgreSQL数据库，并将数据存储在配置目录下。使用<code>coder server postgres-builtin-url</code>可查看内置数据库的访问地址。</p>
<p><code>**</code>：默认配置数据目录位于<code>/root/.config/coderv2</code>。</p>
</blockquote>
<p><strong>网络代理</strong>：为了保证Coder服务访问<code>registry.terraform.io</code>以及<code>github.com</code>等网站下载资源，可能需要<a href="%E5%BA%94%E7%94%A8%E8%BD%AF%E4%BB%B6/../Linux/Linux%E9%85%8D%E7%BD%AE%E5%92%8C%E7%AE%A1%E7%90%86.html#%E6%9C%AC%E5%9C%B0%E7%BD%91%E7%BB%9C%E4%BB%A3%E7%90%86">配置代理</a>（通过<code>/etc/coder.d/coder.env</code>配置）。</p>
<h5 id="身份认证"><a class="header" href="#身份认证">身份认证</a></h5>
<p>通过终端登录并配置第一个管理员用户。Coder默认使用用户名和密码认证。</p>
<pre><code class="language-shell">coder login http://localhost:3000 # 配置用户名、邮箱和密码
coder login -u USER http://localhost:3000 # 在终端登录
</code></pre>
<p>管理用户身份：</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Functions</th><th style="text-align: left">User Admin</th><th style="text-align: left">Template Admin</th><th>Owner</th></tr></thead><tbody>
<tr><td style="text-align: left">Add and remove Users</td><td style="text-align: left">✅</td><td style="text-align: left"></td><td>✅</td></tr>
<tr><td style="text-align: left">Change User roles</td><td style="text-align: left"></td><td style="text-align: left"></td><td>✅</td></tr>
<tr><td style="text-align: left">Manage Templates</td><td style="text-align: left"></td><td style="text-align: left">✅</td><td>✅</td></tr>
<tr><td style="text-align: left">View, update and delete <strong>ALL</strong> Workspaces</td><td style="text-align: left"></td><td style="text-align: left">✅</td><td>✅</td></tr>
<tr><td style="text-align: left">Execute and use <strong>ALL</strong> Workspaces</td><td style="text-align: left"></td><td style="text-align: left"></td><td>✅</td></tr>
</tbody></table>
</div>
<p>所有用户隐含<code>Member</code>身份，可创建工作空间。</p>
<h4 id="工作空间配置"><a class="header" href="#工作空间配置">工作空间配置</a></h4>
<h5 id="工作空间模板配置"><a class="header" href="#工作空间模板配置">工作空间模板配置</a></h5>
<p>在终端中登录用户并执行：</p>
<pre><code class="language-shell">coder templates init [directory] -v  # 选择模板类型并初始化。
cd directory &amp;&amp; vim main.tf          # 修改模板描述文件
coder templates create/push --parameter-file params.yaml # 创建/更新模板
</code></pre>
<blockquote>
<p><code>directory</code>是模板名称和模板文件所在目录名。</p>
</blockquote>
<h5 id="创建工作空间"><a class="header" href="#创建工作空间">创建工作空间</a></h5>
<p>命令行基于模板创建工作空间，也可登录Web界面选择模板创建。</p>
<pre><code class="language-shell">coder create --template=&quot;yourTemplate&quot; &lt;workspace-name&gt;
coder show &lt;workspace-name&gt;
</code></pre>
<p><strong>问题</strong>：==访问<code>https://registry.terraform.io/.well-known/terraform.json</code>失败，网络连接问题。==</p>
<h4 id="编写模板"><a class="header" href="#编写模板">编写模板</a></h4>
<p><a href="https://coder.com/docs/coder-oss/latest/templates">Templates - Coder OSS main docs</a></p>
<h5 id="安装ide"><a class="header" href="#安装ide">安装IDE</a></h5>
<pre><code class="language-hcl">resource &quot;coder_agent&quot; &quot;main&quot; {
    arch          = &quot;amd64&quot;
    os            = &quot;linux&quot;
    startup_script = &lt;&lt;EOF
    #!/bin/sh
    # install and start code-server
    curl -fsSL https://code-server.dev/install.sh | sh
    code-server --auth none --port 13337
    EOF
}
</code></pre>
<p><a href="https://coder.com/docs/coder-oss/latest/ides/configuring-web-ides">Configuring Web IDEs - Coder OSS main docs</a></p>
<h5 id="安装jetbrains-projector"><a class="header" href="#安装jetbrains-projector">安装JetBrains Projector</a></h5>
<h5 id="安装jupyterlab"><a class="header" href="#安装jupyterlab">安装JupyterLab</a></h5>
<h5 id="安装airflow"><a class="header" href="#安装airflow">安装airflow</a></h5>
<h2 id="终端-1"><a class="header" href="#终端-1">终端</a></h2>
<h3 id="windows-terminal"><a class="header" href="#windows-terminal">Windows Terminal</a></h3>
<h4 id="离线安装-4"><a class="header" href="#离线安装-4">离线安装</a></h4>
<p>从Github下载最新的<a href="https://github.com/microsoft/terminal/releases">发布版本</a>，如果离线安装需要使用带依赖库的<code>Win10</code>版本包。</p>
<pre><code class="language-powershell">Add-AppxPackage FILENAME.msixbundle
</code></pre>
<blockquote>
<p><em>安装时如果出现VC运行时版本错误，则首先安装附带的依赖库（<a href="https://docs.microsoft.com/en-us/troubleshoot/developer/visualstudio/cpp/libraries/c-runtime-packages-desktop-bridge?msclkid=3e1dd82aac8b11ec8f9dbd86d5979ca8#how-to-install-and-update-desktop-framework-packages"><code>Microsoft.VCLibs.x64.*.appx</code></a>）；如果手动安装，可能需要安装<a href="https://docs.microsoft.com/en-us/cpp/windows/latest-supported-vc-redist"><code>VC_redist.x64.exe</code></a>。</em></p>
</blockquote>
<h4 id="配置-3"><a class="header" href="#配置-3">配置</a></h4>
<p><a href="https://devblogs.microsoft.com/commandline/windows-terminal-tips-and-tricks/">Windows Terminal Tips and Tricks | Windows Command Line</a></p>
<p>配置文件为<code>settings.json</code>，其中终端配置项位于<code>$.profiles.list[*]</code>，基本配置项如下：</p>
<pre><code class="language-json">{
	&quot;name&quot;: &quot;Windows PowerShell&quot;,
	&quot;commandline&quot;: &quot;powershell.exe&quot;,
	&quot;startingDirectory&quot;: &quot;%HOMEPATH%&quot;,
	&quot;startingDirectory&quot;: &quot;//wsl$/Ubuntu/home/gary&quot;,  // 代替默认的&quot;~&quot;,避免找不到目录
}
</code></pre>
<h5 id="字体-3"><a class="header" href="#字体-3">字体</a></h5>
<p><a href="https://github.com/microsoft/cascadia-code">microsoft/cascadia-code</a><img src="应用软件/程序开发软件.assets/cascadia-code-16502448769902.png" alt="Cascadia Code" style="zoom: 20%; float: right;" /></p>
<pre><code class="language-json">{
	&quot;fontFace&quot;: &quot;Cascadia Code PL&quot;,
	&quot;fontSize&quot;: 12    
}
</code></pre>
<h5 id="颜色和背景"><a class="header" href="#颜色和背景">颜色和背景</a></h5>
<p>终端的颜色配置项包括：</p>
<pre><code class="language-json">{
	&quot;colorScheme&quot;: &quot;One Half Dark&quot;,    
    &quot;useAcrylic&quot;: true,
    &quot;opacity&quot;: 70
}
</code></pre>
<blockquote>
<p>内置颜色方案位于配置文件的<code>$.schemes[*]</code>，可自定义颜色方案。</p>
<p><a href="https://terminalsplash.com/">&gt;_TerminalSplash - Windows Terminal Themes</a><img src="应用软件/程序开发软件.assets/TerminalSplash.png" alt="img" style="zoom: 30%; float: right;" /></p>
</blockquote>
<img src="应用软件/程序开发软件.assets/Windows Terminal Miku.png" style="zoom: 67%;" />
<p>背景</p>
<pre><code class="language-json">{
	&quot;backgroundImage&quot;: &quot;C:\Users\admin\background.png&quot;,
	&quot;backgroundImageAlignment&quot; : &quot;bottomRight&quot;,
	&quot;backgroundImageStretchMode&quot; : &quot;uniform&quot;,
	&quot;backgroundImageOpacity&quot; : 0.3,
}
</code></pre>
<p>除上述基础配置外，可使用<a href="%E5%BA%94%E7%94%A8%E8%BD%AF%E4%BB%B6/%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E8%BD%AF%E4%BB%B6.html#%E7%BB%88%E7%AB%AF%E4%B8%BB%E9%A2%98%E5%8C%96%E5%B7%A5%E5%85%B7">Oh-My-Posh等工具</a>对终端进行个性化定制。</p>
<h4 id="集成终端工具"><a class="header" href="#集成终端工具">集成终端工具</a></h4>
<h5 id="msys2-2"><a class="header" href="#msys2-2">MSYS2</a></h5>
<pre><code class="language-shell">C:\msys64\msys2_shell.cmd -mingw64 -defterm -no-start
</code></pre>
<p>启动的终端环境包括<code>mingw64</code>、<code>clang64</code>、<code>msys</code>、<code>ucrt64</code>等。</p>
<h5 id="anaconda"><a class="header" href="#anaconda">Anaconda</a></h5>
<pre><code class="language-powershell">%windir%\System32\WindowsPowerShell\v1.0\powershell.exe -ExecutionPolicy ByPass -NoExit -Command &quot;&amp; 'C:\Users\gary\miniconda3\shell\condabin\conda-hook.ps1' ; conda activate 'C:\Users\gary\miniconda3' &quot;
</code></pre>
<h3 id="nushell"><a class="header" href="#nushell">Nushell</a></h3>
<blockquote>
<p><em>Nushell is both a programming language and a shell.</em></p>
</blockquote>
<h4 id="安装-14"><a class="header" href="#安装-14">安装</a></h4>
<pre><code class="language-powershell">winget install nushell # [Windows]--&gt; choco/scoop
brew   install nushell # [Linux/Mac]
</code></pre>
<h5 id="设置登录终端"><a class="header" href="#设置登录终端">设置登录终端</a></h5>
<p>Linux：将<code>nu</code>加入<code>/etc/shells</code>白名单中，然后使用<code>chsh</code>命令切换Shell程序。</p>
<p>Windows：安装完成后将自动为Windows Terminal生成Nushell配置，初次启动会进行初始化。</p>
<h4 id="配置-4"><a class="header" href="#配置-4">配置</a></h4>
<pre><code class="language-shell">config nu
</code></pre>
<h4 id="常用命令-2"><a class="header" href="#常用命令-2">常用命令</a></h4>
<p>Nushell命令输出内容为对象（类似于Powershell，包括表格、字典和字符串等）并以表格形式显示，方便后续命令操作数据。</p>
<p>命令支持Tab补全，并同时提供命令候选与帮助信息。</p>
<p><code>ps</code>：显示进程信息。</p>
<p><code>date</code>：显示日期信息。</p>
<pre><code class="language-shell">date now | date to-table
</code></pre>
<p><code>sys</code>：显示系统硬件信息。返回对象不是简单表格，而是键值组成的字典（以表格列的形式分别显示键和值），每个值是嵌套的字典或表格。</p>
<pre><code class="language-shell">sys | get host # 返回嵌套字典
sys | get cpu  # 返回嵌套表格
sys | get host.sessions.name
</code></pre>
<h5 id="文件操作-1"><a class="header" href="#文件操作-1">文件操作</a></h5>
<p><code>ls</code>：显示目录内容。</p>
<pre><code class="language-shell">ls | sort-by size | reverse  # 排序
ls | where size &gt; 1kb        # 筛选
ls *.md                      # 匹配 (**/*.md:匹配所有子目录)
</code></pre>
<p><code>cd</code>，<code>mv</code>，<code>cp</code>，<code>rm</code>，<code>mkdir</code>（跨平台）。</p>
<h5 id="读取数据-1"><a class="header" href="#读取数据-1">读取数据</a></h5>
<pre><code class="language-shell">open package.json # 将数据加载为记录对象。
open pokemon.csv  # 将数据加载为表格对象。
open Cargo.lock | from toml  # 将未识别格式数据按指定格式处理
open Cargo.toml --raw        # 按原始文本输出
</code></pre>
<p>Nushell当前支持加载以下格式的数据：<code>csv</code>，<code>ini</code>，<code>json</code>，<code>nuon</code>，<code>SQLite</code>，<code>toml</code>，<code>url</code>，<code>xlsx/xls</code>，<code>xml</code>，<code>yaml/yml</code>……对于不支持的文件格式，Nushell将尝试直接输出文件内容。</p>
<blockquote>
<p>Nushell Object Notation (NUON) 是JSON的一个超集，支持注释（<code>#</code>开头）。</p>
</blockquote>
<h5 id="读取sqlite"><a class="header" href="#读取sqlite">读取SQLite</a></h5>
<pre><code class="language-shell">open foo.db | query db &quot;select * from some_table&quot;
</code></pre>
<h5 id="读取url指定的文件"><a class="header" href="#读取url指定的文件">读取URL指定的文件</a></h5>
<pre><code class="language-shell">fetch https://blog.rust-lang.org/feed.xml
</code></pre>
<h5 id="帮助信息"><a class="header" href="#帮助信息">帮助信息</a></h5>
<p>除通过<code>Tab</code>补全时提供的提示信息外，通过<code>help</code>命令可查看Nushell命令的使用方法。</p>
<h4 id="输出设置"><a class="header" href="#输出设置">输出设置</a></h4>
<p>使用<code>ansi</code>命令，设置输出文字颜色（<code>ansi reset</code>回复之前的设置）。</p>
<pre><code class="language-shell">$'(ansi purple_bold)This text is a bold purple!(ansi reset)'
</code></pre>
<h4 id="语法-6"><a class="header" href="#语法-6">语法</a></h4>
<ul>
<li><a href="https://www.nushell.sh/book/thinking_in_nu.html#variables-are-immutable">变量是不可变的</a>；</li>
<li><a href="https://www.nushell.sh/book/thinking_in_nu.html#nushell-s-environment-is-scoped">运行环境具有作用域</a>。</li>
</ul>
<h3 id="web终端"><a class="header" href="#web终端">Web终端</a></h3>
<p><a href="https://github.com/tsl0922/ttyd">tsl0922/ttyd: Share your terminal over the web (github.com)</a></p>
<h4 id="webssh"><a class="header" href="#webssh">WebSSH</a></h4>
<p>通过浏览器访问远程的SSH连接终端，其工作模式</p>
<pre><code class="language-shell">+---------+     http     +--------+    ssh    +-----------+
| browser | &lt;==========&gt; | webssh | &lt;=======&gt; | ssh server|
+---------+   websocket  +--------+    ssh    +-----------+
</code></pre>
<p><code>webssh</code>是一个Python模块，可通过<a href="%E5%BA%94%E7%94%A8%E8%BD%AF%E4%BB%B6/">pip</a>或<a href="%E5%BA%94%E7%94%A8%E8%BD%AF%E4%BB%B6/">Conda</a>安装。启动服务：</p>
<pre><code class="language-bash">wssh --address=0.0.0.0 --port=8080 \       # 服务器地址端口
	   --ssladdress=0.0.0.0 --sslport=8088 \ # HTTPS地址端口
	   --certfile=&quot;path_to_certfile.crt&quot; \
	   --keyfile=&quot;path_to_keyfile.key&quot; \     # 证书密钥文件
	   --fbidhttp=True \                     # 禁用外部HTTP请求（只允许localhost访问）
     --maxconn=20 	\                      # 最大连接数
     --debug --origin='*'                  # 
     &gt; /tmp/wssh/wssh.log 2&gt; /tmp/wssh/wss.error.log &amp; # 日志输出，脱离终端
</code></pre>
<blockquote>
<p>避免证书/密钥文件询问密码。</p>
<p><em>Cross origin operation is not allowed</em>：设置<code>--debug --orgin='*'</code>。</p>
</blockquote>
<h4 id="butterfly"><a class="header" href="#butterfly">butterfly</a></h4>
<blockquote>
<p><em><a href="https://github.com/paradoxxxzero/butterfly">Butterfly</a> is an xterm-compatible web terminal based on websocket and tornado.</em></p>
</blockquote>
<pre><code class="language-shell">butterfly.server.py --host=soc3.113.cn --port=57575 --unsecure
</code></pre>
<p>使用SSL加密通信</p>
<pre><code class="language-shell">butterfly.server.py --generate-certs --host=soc3.113.cn
butterfly.server.py --generate-user-pkcs=root
butterfly.server.py --host=soc3.113.cn --port=57575
</code></pre>
<blockquote>
<p><em><code>SSL Error on 8 ('172.28.76.6', 65440): [SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed: EE certificate key too weak (_ssl.c:997)</code></em>.</p>
</blockquote>
<h3 id="终端复用"><a class="header" href="#终端复用">终端复用</a></h3>
<h4 id="tmux"><a class="header" href="#tmux">Tmux</a></h4>
<p>Tmux可以将终端窗口与会话解绑：</p>
<ul>
<li>从而使任务可以进入后台运行，</li>
<li>同时也能在同一终端访问多个已存在的会话；</li>
<li>且支持将终端窗口进行拆分，从而同时访问多个会话。</li>
</ul>
<p>在终端中执行<code>tmux</code>进入Tmux环境，输入<code>exit</code>退出。</p>
<h5 id="快捷键"><a class="header" href="#快捷键">快捷键</a></h5>
<p>使用<code>Ctrl+b</code>进入快捷键模式，输入命令对应的快捷键。</p>
<div class="table-wrapper"><table><thead><tr><th>快捷键</th><th>命令</th><th>说明</th></tr></thead><tbody>
<tr><td><code>?</code></td><td></td><td>显示帮助信息</td></tr>
<tr><td><code>d</code></td><td><code>attach</code></td><td>分离当前会话</td></tr>
<tr><td><code>$</code></td><td><code>rename</code></td><td>重命名会话</td></tr>
<tr><td><code>%</code></td><td><code>split-window -h</code></td><td>左右拆分窗格</td></tr>
<tr><td><code>&quot;</code></td><td><code>split-window</code></td><td>上下差分窗格</td></tr>
<tr><td>$\uparrow\downarrow$<code>-&gt;&lt;-</code></td><td>`select-pane -U</td><td>D</td></tr>
<tr><td><code>x</code></td><td><code>exit</code></td><td>退出当前窗格</td></tr>
<tr><td><code>Ctrl+</code>$\uparrow\downarrow$<code>-&gt;&lt;-</code></td><td></td><td>按箭头方向调整窗格大小</td></tr>
<tr><td><code>q</code></td><td></td><td>显示窗格编号</td></tr>
<tr><td><code>c</code></td><td><code>new-window</code></td><td>新建窗口（状态栏显示窗口信息）</td></tr>
<tr><td>`p</td><td>n</td><td><N>`</td></tr>
<tr><td><code>w</code></td><td><code>select-window</code></td><td>从列表中选择窗口</td></tr>
<tr><td><code>,</code></td><td><code>rename-window</code></td><td>窗口重命名</td></tr>
</tbody></table>
</div>
<h5 id="会话管理"><a class="header" href="#会话管理">会话管理</a></h5>
<p>新建窗格（子窗口）时创建会话，并自动编号（<code>0,1,...</code>）；或者手动创建会话并命名，方便后续访问该会话。</p>
<pre><code class="language-shell">tmux new -s &lt;session-name&gt;
tmux detach  # 将当前会话与终端脱离
tmux ls      # 列出所有Tmux会话
tmux attach|switch -t &lt;session-id&gt;|&lt;session-name&gt;  # 重新接入或切换会话
tmux kill-session -t ......
tmux rename-session -t 0 &lt;new-name&gt;
</code></pre>
<h5 id="划分窗格"><a class="header" href="#划分窗格">划分窗格</a></h5>
<pre><code class="language-shell">tmux split-window [-h]   # -h =&gt; 拆分为左右两个窗口 
tmux swap-pane -U|D      # 移动当前窗口位置（上移|下移）
</code></pre>
<h5 id="窗口管理"><a class="header" href="#窗口管理">窗口管理</a></h5>
<p>除了将一个窗口划分成多个窗格，Tmux 也允许新建多个窗口并在多个窗口间切换（命令类型与窗格管理）。</p>
<pre><code class="language-shell">tmux new-window -n &lt;window-name&gt;  # 默认自动编号
tmux select-window -t &lt;window-number&gt;|&lt;window-name&gt;  # 切换窗口
</code></pre>
<ol>
<li><a href="https://www.ruanyifeng.com/blog/2019/10/tmux.html">Tmux 使用教程 - 阮一峰的网络日志 (ruanyifeng.com)</a></li>
</ol>
<h3 id="终端主题化工具"><a class="header" href="#终端主题化工具">终端主题化工具</a></h3>
<h4 id="oh-my-posh"><a class="header" href="#oh-my-posh">oh-my-posh</a></h4>
<p>使用“<a href="https://ohmyposh.dev/">Oh my Posh 3</a>”来为PowerShell/Bash等终端提供主题功能。</p>
<h5 id="安装-15"><a class="header" href="#安装-15">安装</a></h5>
<pre><code class="language-powershell">winget install|upgrade oh-my-posh # JanDeDobbeleer.OhMyPosh
</code></pre>
<p>安装内容：</p>
<ul>
<li><code>oh-my-posh.exe</code> - Windows executable, added to your $PATH；</li>
<li><code>oh-my-posh-wsl</code> - Linux executable, added to your $PATH for use in the ==WSL==；</li>
<li><code>themes</code> - The latest Oh My Posh themes (<code>~\AppData\Local\Programs\oh-my-posh\themes\</code>)。</li>
</ul>
<h6 id="安装linux版本"><a class="header" href="#安装linux版本">安装Linux版本</a></h6>
<p>使用<code>linuxbrew</code>安装/升级。</p>
<pre><code class="language-shell">brew install oh-my-posh  # jandedobbeleer/oh-my-posh/oh-my-posh
brew update &amp;&amp; brew upgrade oh-my-posh # 新版本的路径可能发生变化，需要重新开启Shell
</code></pre>
<p>安装内容位于<code>$(brew --prefix oh-my-posh)</code>，包括可执行文件和主题。</p>
<h5 id="应用样式"><a class="header" href="#应用样式">应用样式</a></h5>
<p>在Powshell中执行<code>Get-PoshThemes</code>预览样式。</p>
<p>在PowerShell初始化配置文件（<code>$PROFILE</code>）中设置命令：</p>
<pre><code class="language-powershell"># code $PROFILE
oh-my-posh init pwsh --config $env:POSH_THEMES_PATH/paradox.omp.json | Invoke-Expression
</code></pre>
<blockquote>
<p>Windows内置的PowerShell 5和独立安装的PowerShell 7使用的shell配置都为<code>pwsh</code>；</p>
</blockquote>
<h6 id="linux版本命令"><a class="header" href="#linux版本命令">Linux版本命令</a></h6>
<p>预览主题：</p>
<pre><code class="language-shell">THEME_PATH=&quot;$(brew --prefix oh-my-posh)/themes&quot;
for file in $THEME_PATH/*.omp.json; do 
    eval &quot;$(oh-my-posh init bash --config $file)&quot; #**无法预览主题**
    echo &quot;$file&quot;
done
</code></pre>
<p>设置主题（<code>~/.bashrc</code>）：</p>
<pre><code class="language-shell">eval &quot;$(oh-my-posh init bash --config $THEME_PATH/agnoster.omp.json)&quot;
</code></pre>
<h5 id="离线安装-5"><a class="header" href="#离线安装-5">离线安装</a></h5>
<p>从<a href="https://github.com/JanDeDobbeleer/oh-my-posh/releases">Github Release</a>直接下载发布的可执行文件以及主题文件，将可执行文件路径添加到系统路径中，配置方法与自动安装一致。</p>
<h5 id="图标"><a class="header" href="#图标">图标<img src="应用软件/程序开发软件.assets/nerd-fonts-logo.svg" alt="@SankeyMATIC Diagram" style="zoom:40%;float:right" /></a></h5>
<p>下载带图标的字体（<code>nerdfont</code>）。优先使用<code>Windows Compatible</code>的Code字体（<code>Mono</code>字体不支持连字）。</p>
<p><img src="%E5%BA%94%E7%94%A8%E8%BD%AF%E4%BB%B6/%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E8%BD%AF%E4%BB%B6.assets/sankey-glyphs-combined-diagram.svg" alt="@SankeyMATIC Diagram" /></p>
<p><a href="https://github.com/ryanoasis/nerd-fonts">ryanoasis/nerd-fonts</a></p>
<p><a href="https://github.com/ryanoasis/nerd-fonts/tree/master/patched-fonts/CascadiaCode">ryanoasis/nerd-fonts</a></p>
<p>在PowerShell中安装并设置图标模块：</p>
<pre><code class="language-powershell">Install-Module -Name Terminal-Icons -Repository PSGallery -Scope CurrentUser
Import-Module -Name Terminal-Icons   # code $PROFILE
</code></pre>
<h5 id="git插件"><a class="header" href="#git插件">git插件</a></h5>
<pre><code class="language-powershell">Install-Module posh-git -Scope CurrentUser
</code></pre>
<blockquote>
<p>Posh-Git将Git状态信息添加到提示，并为Git命令、参数、远程和分支名称添加<code>Tab</code>自动补全。</p>
</blockquote>
<pre><code class="language-powershell">Import-Module posh-git
</code></pre>
<h4 id="powerline-go"><a class="header" href="#powerline-go">powerline-go</a></h4>
<blockquote>
<p><em>A beautiful and useful low-latency prompt for your shell, written in go.</em></p>
</blockquote>
<pre><code class="language-bash">sudo apt install golang-go
export GOPROXY=https://goproxy.io
export GO111MODULE=on
go get -u github.com/justjanne/powerline-go
</code></pre>
<p>编辑shell配置文件（<code>.bashrc</code>）</p>
<pre><code class="language-bash">GOPATH=$HOME/go
function _update_ps1() {
    PS1=&quot;$($GOPATH/bin/powerline-go -error $?)&quot;
}
if [ &quot;$TERM&quot; != &quot;linux&quot; ] &amp;&amp; [ -f &quot;$GOPATH/bin/powerline-go&quot; ]; then
    PROMPT_COMMAND=&quot;_update_ps1; $PROMPT_COMMAND&quot;
fi
</code></pre>
<p><a href="https://github.com/justjanne/powerline-go">justjanne/powerline-go: A beautiful and useful low-latency prompt for your shell, written in go (github.com)</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="服务器管理软件"><a class="header" href="#服务器管理软件">服务器管理软件</a></h1>
<h2 id="网络管理工具-2"><a class="header" href="#网络管理工具-2">网络管理工具</a></h2>
<h3 id="ip工具包"><a class="header" href="#ip工具包">IP工具包</a></h3>
<pre><code class="language-Bash">ip -Version        # =&gt; ip utility, iproute2-ss200127
ip -batch filename
</code></pre>
<p>选项：<code>-b,-batch</code>：从文件中读取命令执行。</p>
<pre><code class="language-Bash">ip [OPTIONS] OBJECT COMMAND
</code></pre>
<p>默认命令为<code>show</code>(即列出指定对象的信息)或<code>help</code>(对应<code>object</code>的帮助信息)。</p>
<h5 id="信息选项"><a class="header" href="#信息选项">信息选项</a></h5>
<ul>
<li><code>-h,-human,-human-readable</code>：以更易阅读的方式输出统计信息。</li>
<li><code>-s,-stats,—statistics</code>：输出更多信息，如果该选项出现多次，则输出更多信息。</li>
<li><code>-d,-details</code>：输出更多详细信息。</li>
<li><code>-o,-online</code>：每行输出一条记录，使用<code>\</code>替换原纪录中的换行。</li>
<li><code>-r,-resolve</code>：使用DNS解析。</li>
<li><code>-c,-color=always|auto|never</code>：设定彩色输出模式。</li>
<li><code>-t,-timestamp</code>：输出当前时间；<code>-ts, -tshort</code>：使用短时间格式。</li>
<li><code>-br, -brief</code>：以列表形式显示简要信息，目前仅适用于<code>ip addr show</code> 和<code>ip link show</code>。</li>
<li><code>-j, -json</code>：以JSON格式输出信息； <code>-p, -pretty</code>增强JSON输出的可读性。</li>
</ul>
<h5 id="协议族选项"><a class="header" href="#协议族选项">协议族选项</a></h5>
<ul>
<li>
<pre><code>-f, -family &lt;FAMILY&gt;
</code></pre>
<p>：选择协议族，包括：</p>
<pre><code>inet, inet6, link
</code></pre>
<ul>
<li><code>-4</code>：等效于<code>-family inet</code>；</li>
<li><code>-6</code>：等效于<code>-family inet6</code>；</li>
<li><code>-B</code>：等效于<code>-family bridge</code>；</li>
<li><code>-M</code>：等效于<code>-family mpls</code>；</li>
<li><code>-0</code>：等效于<code>-family link</code>；</li>
</ul>
</li>
</ul>
<h5 id="网络命名空间选项"><a class="header" href="#网络命名空间选项">网络命名空间选项</a></h5>
<ul>
<li><code> -n, -netns &lt;NETNS&gt;</code>：切换网络命名空间到<code>NETS</code>以执行命令；该选项等效于<code>ip netns exec NETNS...</code></li>
</ul>
<h4 id="命令对象object"><a class="header" href="#命令对象object">命令对象（object）</a></h4>
<h5 id="ip地址-1"><a class="header" href="#ip地址-1">IP地址</a></h5>
<pre><code class="language-Bash">ip address show [up]         # address &lt;-&gt; addr
ip address show [up] dev eth0
ip address add|delete 2001:0db8:85a3::0370:7334/64 dev eth1 # add/delete address
ip address flush dev eth4 scope global   # remove global address
</code></pre>
<h5 id="网络设备"><a class="header" href="#网络设备">网络设备</a></h5>
<p><code>ip link set x up|down</code></p>
<h5 id="虚拟设备"><a class="header" href="#虚拟设备">虚拟设备</a></h5>
<p><code>tuntap</code>：manage TUN/TAP devices.</p>
<h5 id="路由表项"><a class="header" href="#路由表项">路由表项</a></h5>
<ul>
<li><code>route</code>：；</li>
</ul>
<h5 id="其他-4"><a class="header" href="#其他-4">其他</a></h5>
<ul>
<li>
<p><code>neighbour,neigh</code>：管理ARP或NDISC缓存项；</p>
</li>
<li>
<p><code>addrlabel</code>：地址标签；</p>
</li>
<li>
<p><code>maddress</code>：多播地址；</p>
</li>
<li>
<p><code>rule</code>：路由策略数据库中的规则；</p>
</li>
<li>
<p><code>mroute</code>：多播路由缓存项；</p>
</li>
<li>
<p><code>mrule</code>：多播路由策略数据库中的规则；</p>
</li>
<li>
<p><code>ntable</code>：管理邻居缓存空间；</p>
</li>
<li>
<p><code>l2tp</code>：</p>
</li>
<li>
<p><code>tunnel</code>：IP承载的隧道；</p>
</li>
<li>
<p><code>xfrm</code>：   - 管理IPSec策略。</p>
</li>
<li>
<p><code>monitor</code>：</p>
</li>
<li>
<p><code>netns</code>：管理网络命名空间；</p>
</li>
<li>
<p><code>tcp_metrics/tcpmetrics</code>：管理TCP 度量；</p>
</li>
<li>
<p><code>token</code>：manage tokenized interface identifiers.</p>
</li>
</ul>
<h2 id="系统监控软件"><a class="header" href="#系统监控软件">系统监控软件</a></h2>
<h3 id="cockpit"><a class="header" href="#cockpit">cockpit</a></h3>
<pre><code class="language-shell">yum install cockpit
systemctl enable --now cockpit.socket
firewall-cmd --permanent --zone=public --add-service=cockpit
firewall-cmd --reload
</code></pre>
<h3 id="glances"><a class="header" href="#glances">glances</a></h3>
<h5 id="安装-16"><a class="header" href="#安装-16">安装</a></h5>
<p>可通过Python虚拟环境安装：</p>
<pre><code class="language-shell">conda create -n glances -c conda-forge glances \
    bottle         # for web server mode
    zeroconf       # for autodiscover mode
    docker-py      # docker monitor
    netifaces      # IP
    py3nvml        # GPU
    py-cpuinfo    # quicklook cpuinfo
    elasticsearch  # es export
    kafka-python   # kafka export
conda activate glances &amp; pip install \
    hddtemp        # Linux HDD temerature monitoring
    pymdstat       # Linux RAID
    pySMART.smartx # Linux HDD SMART
# pip install glances[browser,cpuinfo,docker,export,gpu,ip,raid,web]'
</code></pre>
<p>或通过Linux发行版软件仓库安装（如果提供）：</p>
<pre><code class="language-shell">sudo apt install glances
</code></pre>
<blockquote>
<p>Debian/Ubuntu发行版中可能不包含Web预编译文件，导致Web服务模式无法正常工作。</p>
<p>CentOS 7软件仓库不包含<code>glances</code>。</p>
</blockquote>
<h5 id="运行-3"><a class="header" href="#运行-3">运行</a></h5>
<p>标准模式：直接运行<code>glances</code>，根据终端窗口尺寸自动布局监控指标。</p>
<p>输出模式：</p>
<pre><code class="language-shell">glances --stdout cpu.user,mem.used,load # 显示指定度量
glances --stdout-csv cpu.user,mem.used,load # 以CSV格式显示
</code></pre>
<p>Web服务模式：<code>glances -w</code>，在浏览器中显示监控数据（终端风格）。</p>
<p>客户服务器模式：客户端可访问并显示服务端的监控数据。</p>
<pre><code class="language-shell">glances -s -B ip_addr -p PORT # server side (默认0.0.0.0:61209)
glances -c &lt;addr&gt; -p PORT     # client side
</code></pre>
<p><em>显示网络上所有的Glances服务</em>（自动发现或根据配置文件定义）。</p>
<pre><code class="language-shell">glances --browser               
        --disable-autodiscover  # 禁用自动发现
</code></pre>
<p>扫描配置文件：</p>
<pre><code class="language-ini">[serverlist]
server_1_name=xps
server_1_alias=xps
server_1_port=61209
</code></pre>
<h3 id="tiptop"><a class="header" href="#tiptop">tiptop</a></h3>
<p><code>tiptop</code>的终端显示更加整齐美观，但与<code>glances</code>相比没有服务模式和Web访问模式。</p>
<pre><code class="language-shell">conda create -n tiptop -c conda-forge tiptop
# pip install tiptop
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="网络访问软件"><a class="header" href="#网络访问软件">网络访问软件</a></h1>
<h2 id="ssh"><a class="header" href="#ssh">SSH</a></h2>
<p>SSH可以通过终端或<a href="%E5%BA%94%E7%94%A8%E8%BD%AF%E4%BB%B6/../%E5%BA%94%E7%94%A8%E8%BD%AF%E4%BB%B6/%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E8%BD%AF%E4%BB%B6.html#WebSSH">Web终端</a>远程访问Linux服务器，也可以使用X Window访问服务器的图形界面应用。使用SSH访问服务器需要在服务器上安装<code>openssh-server</code>。</p>
<pre><code class="language-shell">ssh -p SSH_PORT [user@]host
    -4/6   # ipv4/ipv6 only
    -b ip_addr
</code></pre>
<p>通过中间节点登录远程主机：</p>
<pre><code class="language-shell">ssh -J [user@]host[:port] user@host  # connect via a jump host
</code></pre>
<blockquote>
<p>中间节点需要与目的节点建立连接，因此如果目的节点使用主机名，则需要在中间节点上配置目的节点的“主机名<code>&lt;-&gt;</code>IP地址”映射。</p>
</blockquote>
<h3 id="ssh客户端配置文件"><a class="header" href="#ssh客户端配置文件">SSH客户端配置文件</a></h3>
<p>配置文件用于保存固定的SSH连接配置，以简化命令行输入参数。</p>
<pre><code class="language-shell">HOST dev     # 远程地址匹配模式*
   HostName dev.example.com
   User gary
</code></pre>
<p>当SSH的目标非<code>user@host</code>形式，则客户端逐次匹配<code>HOST</code>指定的模式，并将匹配模式下的SSH连接配置应用于当前连接请求。如果有多个模式匹配成功，==重复出现的配置项被忽略==（先出现的配置项优先级高）。</p>
<blockquote>
<p><code>*</code>：可使用通配符<code>*</code>和<code>?</code>，可对模式添加前缀<code>!</code>表示反向匹配；</p>
</blockquote>
<h4 id="服务器身份记录"><a class="header" href="#服务器身份记录">服务器身份记录</a></h4>
<p>当客户端尝试SSH连接远程服务器时，服务器会提供一个身份识别信息（ECDSA key指纹）让客户端确认。当客户端确认后，该服务器地址和对应的身份信息被保存到<code>.ssh/known_hosts</code>中。如果服务器发生变更导致其提供的身份识别信息发生变化，则会产生*<code>Host key verification failed</code>*错误。要解决此问题，只需从<code>.ssh/known_hosts</code>中删除对应服务器的记录（错误信息提示该记录所在的行号）。</p>
<h4 id="ssh配置问题"><a class="header" href="#ssh配置问题">SSH配置问题</a></h4>
<ul>
<li>
<p><code>root</code>账户无法通过SSH登录，其他账户可以。原因：SSH配置不允许<code>root</code>登录，修改配置（<code>/etc/ssh/sshd_config</code>）：</p>
<pre><code class="language-shell">#PermitRootLogin prohibit-password
#PubkeyAuthentication yes
PermitRootLogin yes  #*
</code></pre>
<blockquote>
<p><code>*</code>：允许<code>root</code>远程登录存在较大安全隐患，使用密码登录风险更大（已知密码可在任意可访问服务器的机器上登录）。将该选项设置为<code>prohibit-password</code>并设置使用公钥验证，则只有预先在远程机器上配置了客户端的公钥，才能在相应客户端上登录<code>root</code>账户。</p>
</blockquote>
</li>
<li>
<p>由于SELinux的安全策略，Fedora/CentOS<strong>非root账户</strong>仍无法自动登录，需要修改目标主机下的目录<code>.ssh</code>及文件<code>.ssh/authorized_keys</code>的权限。</p>
<pre><code class="language-sh">chmod 0700 ~/.ssh                  # rwx------
chmod 0600 ~/.ssh/authorized_keys  # rw-------
</code></pre>
</li>
<li>
<p>无法使用密码进行远程登录（出现<code>publickey</code>错误）。原因：<code>sshd</code>的配置未开启密码验证（各发行版的默认配置可能不同，此问题出现在<a href="%E5%BA%94%E7%94%A8%E8%BD%AF%E4%BB%B6/../%E6%9C%8D%E5%8A%A1%E5%99%A8/%E8%99%9A%E6%8B%9F%E5%8C%96.html#Window_Sub-system_of_Linux" title="WSL">WSL</a>上）。</p>
<pre><code class="language-shell">PasswordAuthentication yes
ChallengeResponseAuthentication no
UsePAM yes
# 利用PAM管理使用者认证有很多好处，可以记录与管理。
# 所以这里我们建议你使用 UsePAM 且 ChallengeResponseAuthentication 设定为 no 
</code></pre>
</li>
<li>
<p><em><a href="https://github.com/microsoft/terminal/issues/7467">blocked by Windows Terminal</a></em>；</p>
</li>
<li>
<p><em><a href="https://superuser.com/a/1437891/771784">无法从Linux主机免密登录Windows主机</a></em>：Windows 10 v1809之后的OpenSSH服务器定义了以下配置，用于管理员用户登录。</p>
<pre><code class="language-shell"># sshd_config
Match Group administrators
       AuthorizedKeysFile __PROGRAMDATA__/ssh/administrators_authorized_keys
</code></pre>
<p>解决方法：</p>
<ol>
<li>使用非管理员用户登录；</li>
<li>注释上述配置项，恢复默认在用户目录下读取用户的公钥（<a href="https://superuser.com/a/1447229">推荐</a>）；</li>
<li>将管理员用户的公钥添加到<code>%PROGRAMDATA%\ssh\administrators_authorized_keys</code>文件中。</li>
</ol>
</li>
<li>
<p><code>client_loop: send disconnect: Connection reset</code>，Windows终端长时间未操作自动断开与服务器的连接，<a href="https://superuser.com/questions/1591674/idle-ssh-connection-gets-reset-in-ubuntu-20-04-wsl-windows10">修改终端配置</a>。</p>
<pre><code class="language-shell">ClientAliveInterval 60
ClientAliveCountMax 5
</code></pre>
<p>如果错误信息为<code>Connection reset by peer</code>，则可尝试修改服务端的对应配置：</p>
<pre><code class="language-shell">ServerAliveInterval 60
ServerAliveCountMax 5
</code></pre>
</li>
</ul>
<h3 id="免密码登录"><a class="header" href="#免密码登录">免密码登录</a></h3>
<p>在远程主机保存登录用户的公钥。</p>
<pre><code class="language-sh">ssh-keygen  # 在本地生成SSH的登录密钥
for node in '[user@]node1' 'node2' ...; do
 ssh-copy-id -i ~/.ssh/id_rsa.pub $node
done
</code></pre>
<blockquote>
<h4 id="ssh-keygen选项"><a class="header" href="#ssh-keygen选项">ssh-keygen选项</a></h4>
<p><code>-t rsa | dsa | ecdsa | ed25519</code>：指定创建的密钥类型；</p>
<p><code>-b bits</code>：密钥的长度。RSA密钥最小长度为1024，默认为2048；DSA密钥长度为1024；ECDSA密钥长度为256、384或521（椭圆曲线）；Ed25519密钥长度为定值，该选项无效。</p>
<p><code>-C comment</code>：添加注释。</p>
<p><code>-f filename</code>：指定密钥文件（默认位于<code>~/.ssh</code>目录下）</p>
<p><code>-h</code>：创建主机凭证而非用户凭证；</p>
<p><code>-e</code>：读取一个OpenSSH公钥文件并以指定格式输出（<code>-m RFC4756|PKCS8|PEM</code>，默认格式为RFC4716）。</p>
<p><code>-F hostname</code>：在<code>known_hosts</code>文件中搜索指定主机并列举。</p>
<p><code>-l</code>：输出公钥文件的指纹，使用<code>-E md5|sha256</code>指定文件hash算法。</p>
<p><code> -R hostname</code>：移除<code>known_hosts</code>中所有属于<code>hostname</code>的密钥。</p>
</blockquote>
<p>从Windows主机免密登录Linux主机：</p>
<pre><code class="language-powershell"># Powershell at user home of Windows host
cat ~/.ssh/id_rsa.pub | ssh user@HOST 'mkdir -p ~/.ssh &amp;&amp; cat &gt;&gt; ~/.ssh/authorized_keys'
</code></pre>
<h3 id="ssh远程执行命令"><a class="header" href="#ssh远程执行命令">SSH远程执行命令</a></h3>
<pre><code class="language-sh">ssh user@remote_server &quot;command1; command2; ./script&quot;
ssh user@remote_server &quot;command1;&quot; &quot;command2;&quot; &quot;./script&quot;
</code></pre>
<blockquote>
<p>可以提供多条命令，分隔的命令会在远端重组。</p>
</blockquote>
<h4 id="提升远端管理员权限"><a class="header" href="#提升远端管理员权限">提升远端管理员权限</a></h4>
<p>适用于Ubuntu等未开启<code>root</code>账号的系统，从远程执行管理命名需要提升管理员权限。此时需要使用<code>-t</code>选项使终端支持输入远程主机的密码。</p>
<pre><code class="language-shell">ssh -t adminuser@host &quot;sudo command&quot;
</code></pre>
<p>远程执行命令时远程主机默认只提供基本环境变量（<code>non-interactive</code>，不会自动加载<code>~/.bashrc</code>文件）。为了自动加载<code>~/.bashrc</code>中的环境变量（<a href="%E5%BA%94%E7%94%A8%E8%BD%AF%E4%BB%B6/../Linux/Linux-Shell.html#%E7%94%A8%E6%88%B7%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6">不是<code>.bash_profile</code>或<code>.profile</code>文件</a>），在SSH配置文件<code>/etc/ssh/sshd_config</code>中启用：</p>
<pre><code class="language-sh">sed -Ei 's/#(PermitUserEnvironment\s+)(no)/\1yes/' /etc/ssh/sshd_config
</code></pre>
<p>再次启动SSH会话后，新添加环境变量生效。</p>
<blockquote>
<p>在Ubuntu（20.04）的<code>.bashrc</code>的开头有判断，如果是非交互式shell的语句（例如通过<code>ssh</code>远程执行的命令），则直接跳过后续初始化，因此需要把需要暴露给远端用户的变量置于该判断条件之前。</p>
<pre><code class="language-shell">if [[ ! $PATH = *java* ]]; then
    export PATH=$PATH:$JAVA_HOME/bin
fi
</code></pre>
</blockquote>
<h4 id="允许root远程登录"><a class="header" href="#允许root远程登录">允许root远程登录</a></h4>
<pre><code class="language-shell"># vi /etc/ssh/sshd_config
PermitRootLogin yes
# service sshd restart
</code></pre>
<h3 id="通过ssh进行安全端口转发"><a class="header" href="#通过ssh进行安全端口转发">通过SSH进行安全端口转发</a></h3>
<p>本地通过SSH客户端与远程服务端口建立安全连接，利用SSH端口转发功能，用户只需访问本地SSH开放的端口即可访问远程服务。（使用前提是服务器开启SSH服务，且网络策略允许通过SSH访问服务器）</p>
<h4 id="使用ssh建立隧道代理远端服务"><a class="header" href="#使用ssh建立隧道代理远端服务">使用SSH建立隧道代理远端服务</a></h4>
<p><code>ssh</code>会在本地建立一个监听套接字<code>local_addr:local_port</code>以转发其接收的请求到远端的服务端口<code>r_addr:r_port</code>。</p>
<pre><code class="language-shell">ssh -N -L [local_addr]:local_port:r_addr:r_port USER@HOST  
# -N disables executing a remote shell
</code></pre>
<h4 id="将远端访问请求转发至本地服务端口"><a class="header" href="#将远端访问请求转发至本地服务端口">将远端访问请求转发至本地服务端口</a></h4>
<pre><code class="language-shell">ssh -N -R [r_addr:]r_port:local_addr:local_port USER@HOST
</code></pre>
<p><code>r_addr</code>：远端地址，默认为环回地址，如果为空或<code>*</code>则表示所有地址。</p>
<blockquote>
<p><code>ssh</code>会在远端建立一个监听套接字以转发其接收的请求到本地。</p>
</blockquote>
<h4 id="常见问题-6"><a class="header" href="#常见问题-6">常见问题</a></h4>
<ol>
<li>
<p>SSH登录等待时间太长。</p>
<p>原因：可能是SSH服务所在主机配置了DNS服务器地址，但对应的服务器不可用，导致DNS解析等待。</p>
<p>解决方法：查看<code>/etc/resolve.conf</code>查看是否存在不可用的DNS服务器地址。如果有，修改网络接口的DNS配置并重启网络服务。</p>
</li>
</ol>
<h2 id="wget"><a class="header" href="#wget">wget</a></h2>
<p>HTTP, HTTPS, FTP和FTPS下载。</p>
<pre><code class="language-shell">wget [option]... [URL]...
</code></pre>
<p>选项：</p>
<pre><code class="language-shell">-c, --continue # Continue getting a partially-downloaded file. 
--limit-rate=amount  # Limit download speed
--user=user, --password=password # user/password if necessary
--ask-password
-P prefix, --directory-prefix=prefix  # base directory
-O --output-document=FILE # save download as FILE
</code></pre>
<p>如果所在网络的Web流量是经本地网络的代理转发的，需要<a href="https://www.techrepublic.com/article/how-to-use-wget-behind-a-proxy/">为<code>wget</code>配置本地代理</a>（系统<code>/etc/wgetrc</code>或用户<code>~/.wgetrc</code>）。</p>
<pre><code class="language-ini">https_proxy = http://USERNAME:PASSWORD@proxy.server.net:port/
http_proxy = http://proxy.server.net:port/
ftp_proxy = http://proxy.server.net:port/
</code></pre>
<p>或者通过<a href="%E5%BA%94%E7%94%A8%E8%BD%AF%E4%BB%B6/../Linux/Linux%E9%85%8D%E7%BD%AE%E5%92%8C%E7%AE%A1%E7%90%86.html">环境变量配置代理</a>。</p>
<h2 id="curl"><a class="header" href="#curl">curl</a></h2>
<pre><code class="language-shell">curl [optiosn] url
</code></pre>
<div class="table-wrapper"><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody>
<tr><td><code>-H HEADER</code></td><td>为请求添加头部信息</td></tr>
<tr><td><code>-d, --data &lt;data&gt; </code></td><td>上传数据体<br/>JSON数据需要指定：<code>Content-Type: application/json</code></td></tr>
<tr><td><code>-k,--insecure </code></td><td>允许非安全SSL</td></tr>
<tr><td><code>-I,--head</code></td><td>仅返回响应头部</td></tr>
<tr><td><code>-L,--location</code></td><td>跟踪重定向</td></tr>
<tr><td><code>-o,--output file</code></td><td>输出内容到文件</td></tr>
<tr><td><code>-x,--proxy addr</code></td><td>使用代理<code>[protocol://]host[:port]</code></td></tr>
<tr><td><code>-0,--http1.0</code></td><td>HTTP 1.0，`http1.1</td></tr>
<tr><td><code>-1,--tlsv1</code></td><td>使用TLS，`tlsv1.0</td></tr>
<tr><td>`--ssl,-2</td><td>3`</td></tr>
<tr><td><code>-u,--user user:password</code></td><td>提供服务器用户名和密码</td></tr>
<tr><td><code>-E,--cert CERT</code></td><td><code>CERT=certificate[:password]</code></td></tr>
<tr><td><code>-#,--progress-bar</code></td><td>传输进度显示为进度条</td></tr>
<tr><td><code>-Z,--parallel</code></td><td>并发传输</td></tr>
<tr><td>`-4</td><td>6,--ipv4</td></tr>
</tbody></table>
</div>
<h3 id="信息展示"><a class="header" href="#信息展示">信息展示</a></h3>
<p><code>-v,--verbose</code>：显示<code>curl</code>的处理过程；</p>
<p><code>-s,--silent</code>：  ==不输出传输过程的状态信息（仅输出响应数据）==；</p>
<p><code>-S,--show-error</code>：在安静模式下仍能输出错误信息；</p>
<p><code>--trace dumpfile</code>：将传输过程中输出的信息和接收的数据（十六进制编码）输出到文件中，使用<code>-</code>代替文件名以输出到标准输出。</p>
<p><code>--trace-ascii dumpfile</code>：将数据以ASCII码方式存储；</p>
<p><code>--trace-time</code>：在输出信息/数据前显示时间<code>hours:minutes:seconds.microseconds</code>。</p>
<p><code>-w,--write-out MSG</code>：在传输完成后输出信息，信息可以是简单字符串，文件内容<code>@filename</code>（标准输入<code>@-</code>），或是从接受数据中提取的<a href="https://everything.curl.dev/usingcurl/verbose/writeout#available-write-out-variables">字段</a><code>%{variable_name}</code>。</p>
<h3 id="下载-3"><a class="header" href="#下载-3">下载</a></h3>
<p><a href="https://everything.curl.dev/usingcurl/downloads">Downloads - Everything curl</a></p>
<h3 id="上传"><a class="header" href="#上传">上传</a></h3>
<p><a href="https://everything.curl.dev/usingcurl/uploads">Uploads - Everything curl</a></p>
<h3 id="http-1"><a class="header" href="#http-1">HTTP</a></h3>
<p><a href="https://everything.curl.dev/http">HTTP with curl - Everything curl</a></p>
<h5 id="http方法"><a class="header" href="#http方法">HTTP方法</a></h5>
<p>默认为<code>GET</code>，添加<code>-d,-F</code>选项则默认为<code>POST</code>，<code>-T</code>则默认为<code>HEAD</code>，<code>-T</code>默认为<code>PUT</code>。</p>
<p><code>-X,--request COMMAND</code>：<code>COMMAND=GET|POST|...</code>。</p>
<h2 id="netcat"><a class="header" href="#netcat">netcat</a></h2>
<p>选项：</p>
<pre><code class="language-shell">-s 10.1.2.3 # 指定源端IP
-p 31337    # 指定源端本地端口
-w 5        # 连接超时（秒）
-u          # 建立UDP连接
</code></pre>
<h3 id="basic-client-server-model"><a class="header" href="#basic-client-server-model">basic client-server model</a></h3>
<pre><code class="language-shell">nc -l [server_addr] port  # server
nc server_addr port       # client
</code></pre>
<blockquote>
<p>建立连接后可双向通信（通过标准输入输出进行通信）。</p>
</blockquote>
<h4 id="远程shell访问服务"><a class="header" href="#远程shell访问服务">远程Shell访问服务</a></h4>
<pre><code class="language-shell">rm -f /tmp/f; mkfifo /tmp/f  # remove the FIFO file when finished
cat /tmp/f | /bin/sh -i 2&gt;&amp;1 | nc -l 127.0.0.1 1234 &gt; /tmp/f
</code></pre>
<blockquote>
<p><code>nc</code>从远程接收的数据被定向到管道；管道中的数据被<code>cat</code>读取作为<code>sh</code>的输入命令；执行命令的输出作为<code>nc</code>的输入由其转发给远端。（==该操作可让远端执行任何命令==）</p>
</blockquote>
<h4 id="数据传输"><a class="header" href="#数据传输">数据传输</a></h4>
<pre><code class="language-shell"> nc -l 1234 &gt; filename.out
 nc -N host.example.com 1234 &lt; filename.in
</code></pre>
<h4 id="访问基于文本协议的服务"><a class="header" href="#访问基于文本协议的服务">访问基于文本协议的服务</a></h4>
<pre><code class="language-shell">printf &quot;GET / HTTP/1.1\r\n\r\n&quot; | nc www.baidu.com 80
</code></pre>
<h4 id="端口扫描"><a class="header" href="#端口扫描">端口扫描</a></h4>
<pre><code class="language-shell">nc -zv host.example.com 20-30 http
</code></pre>
<h4 id="通过代理连接"><a class="header" href="#通过代理连接">通过代理连接</a></h4>
<pre><code class="language-shell">nc -x10.2.3.4:8080 -Xconnect [-P&lt;username&gt;] host.example.com 42
</code></pre>
<h2 id="代理"><a class="header" href="#代理">代理</a></h2>
<h3 id="v2ray"><a class="header" href="#v2ray">v2ray</a></h3>
<p><a href="https://github.com/2dust/v2rayN">v2rayN</a></p>
<h5 id="qv2ray"><a class="header" href="#qv2ray"><a href="https://github.com/Qv2ray/Qv2ray">Qv2ray</a></a></h5>
<p>在==分组==中编辑订阅信息：</p>
<img src="应用软件/网络访问软件.assets/image-20220302162543149-16587251899603.png" alt="image-20220302162543149" style="zoom: 67%;" />
<p>在分组的订阅设置中输入<strong>订阅地址</strong>并选择<strong>订阅类型</strong>。</p>
<img src="应用软件/网络访问软件.assets/image-20220302162622744-16587252296335.png" alt="image-20220302162622744" style="zoom:60%;" />
<h3 id="clash"><a class="header" href="#clash">clash</a></h3>
<h5 id="初始化配置"><a class="header" href="#初始化配置">初始化配置</a></h5>
<pre><code class="language-shell">wget -O ~/.config/clash/config.yaml $SUBSCRIBE_URL
COUNTRY_DB_URL=https://www.sub-speeder.com/client-download/Country.mmdb
wget -O ~/.config/clash/Country.mmdb $COUNTRY_DB_URL
</code></pre>
<h5 id="配置前端web界面"><a class="header" href="#配置前端web界面">配置前端web界面</a></h5>
<pre><code class="language-shell">git clone https://github.com/Dreamacro/clash-dashboard.git
cd clash-dashboard
git checkout -b gh-pages origin/gh-pages
</code></pre>
<p>编辑<code>clash</code>配置文件，设置界面的登录密码和网页资源地址。</p>
<pre><code class="language-yaml">secret: gang2019
external-ui: /home/gary/downloads/clash-dashboard
</code></pre>
<p>Clash的Web访问地址为：<code>http://127.0.0.1:9090/ui/</code>。</p>
<h5 id="启动服务"><a class="header" href="#启动服务">启动服务</a></h5>
<pre><code class="language-shell">clash -d /home/gary/.config/clash/
</code></pre>
<p>设置为系统服务：</p>
<pre><code class="language-ini">[Unit]
Description=Clash - a rule-based tunnel in Go.
Documentation=https://github.com/Dreamacro/clash
After=network.target network-online.target
[Service]
Type=simple
User=clash
Group=clash
WorkingDirectory=/home/clash
ExecStart=/usr/local/clash/clash -d /usr/local/clash/config
StandardOutput=syslog
StandardError=syslog
SyslogIdentifier=clash
ProtectSystem=true
[Install]
WantedBy=multi-user.target
</code></pre>
<p>设置Crontab规则以周期更新配置文件中的订阅信息。</p>
<pre><code class="language-shell">sudo crontab -e  # 进入编辑模式
</code></pre>
<pre><code class="language-shell">m  h  dom   mon dow  command
30 4  1,15  *   *    bash /home/gary/bin/clash.sh init $URL
</code></pre>
<h2 id="软路由"><a class="header" href="#软路由">软路由</a></h2>
<p>主机具有多个网络接口，其中一个连接WAN（假设为<code>eth0</code>），其他作为LAN接口（<code>eth1</code>, <code>eth2</code>, ...，使用<code>ifconfig</code>查看网络接口信息）<sup class="footnote-reference"><a href="#soft-router">1</a></sup>。</p>
<blockquote>
<p><strong>场景1</strong>：与可联网主机<code>host1</code>在同一网络的另一台设备<code>host2</code>无法认证上网。</p>
</blockquote>
<ol>
<li>
<p>编辑<a href="%E5%BA%94%E7%94%A8%E8%BD%AF%E4%BB%B6/%E7%BD%91%E7%BB%9C%E8%AE%BF%E9%97%AE%E8%BD%AF%E4%BB%B6.html#%E7%BD%91%E7%BB%9C%E6%8E%A5%E5%8F%A3%E9%85%8D%E7%BD%AE">网络接口配置</a></p>
<p>根据网络状况分别设置WAN口的IP地址获取方式（手动配置或DHCP），LAN口设置固定IP地址。</p>
</li>
<li>
<p>如果需要为LAN中的机器分配IP地址，则为LAN口配置DHCP服务器</p>
<pre><code class="language-bash">sudo apt install isc-dhcp-server
sudo nano /etc/default/isc-dhcp-server 
# configure interfaces for DHCP server
# INTERFACESv4=&quot;eth1&quot;	 # support multi-interfaces, &quot;eth0 eth1&quot;.
sudo nano /etc/dhcp/dhcpd.conf  # configure DHCP server...
# after editing, start DHCP server
sudo systemctl restart isc-dhcp-server
sudo systemctl enable isc-dhcp-server
# check the status of DHCP server
sudo systemctl status isc-dhcp-server
</code></pre>
<p>编辑DHCP服务器的配置文件（<code>dhcpd.conf</code>） </p>
<pre><code class="language-shell">option domain-name &quot;whatever.you.want&quot;;
option domain-name-servers 223.5.5.5, 223.6.6.6;
default-lease-time 600;
max-lease-time 7200;
ddns-update-style none;
authoritative;
log-facility local7;
subnet 192.168.1.0 netmask 255.255.255.0 {
     range 192.168.1.101 192.168.1.200;
     option subnet-mask 255.255.255.0;
     option routers 192.168.1.1;
     option broadcast-address 192.168.1.255;
}
</code></pre>
<p>如果配置正确，则最后查看DHCP服务器状态，可以看到一行显示<code>active</code>。</p>
</li>
<li>
<p>==启用防火墙==并配置转发规则。</p>
<pre><code class="language-shell">sudo ufw enable		
sudo vi /etc/rc.local
sudo chmod 755 /etc/rc.local  # make it executable, executed at boot time
</code></pre>
<p>在<code>rc.local</code>中配置防火墙的转发规则。</p>
<pre><code class="language-shell">#!/bin/bash
LAN=eth1
WAN=eth0
# Default policy to drop all incoming packets.
iptables -P INPUT DROP
iptables -P FORWARD DROP
# Accept incoming packets from localhost and the LAN interface.
iptables -A INPUT -i lo -j ACCEPT
iptables -A INPUT -i $LAN -j ACCEPT
# Accept incoming packets from the WAN if the router initiated the connection.
iptables -A INPUT -i $WAN -m conntrack \
  --ctstate ESTABLISHED,RELATED -j ACCEPT
# Forward LAN packets to the WAN.
iptables -A FORWARD -i $LAN -o $WAN -j ACCEPT
# Forward WAN packets to the LAN if the LAN initiated the connection.
iptables -A FORWARD -i $WAN -o $LAN -m conntrack \
  --ctstate ESTABLISHED,RELATED -j ACCEPT
# NAT traffic going out the WAN interface.
iptables -t nat -A POSTROUTING -o $WAN -j MASQUERADE
exit 0  # rc.local needs to exit with 0
</code></pre>
</li>
</ol>
<h3 id="虚拟机解决方案"><a class="header" href="#虚拟机解决方案">虚拟机解决方案</a></h3>
<p>如果物理主机仅有单个网络接口，可使用虚拟机进行软件路由，可为虚拟机配置两个接口，一个用于连接宿主机NAT网络访问WAN，另一个用于桥接物理网络（转发其他机器的流量）。</p>
<blockquote>
<ul>
<li>为虚拟机<code>vm-router</code>设置两张网卡：<code>eth0</code>使用NAT连接至主机<code>host1</code>；<code>eth1</code>使用网桥连接至主机<code>host1</code>（与物理网络其他主机连通）；</li>
<li>按上述方法配置软件路由；</li>
<li>将<code>host2</code>的默认网关设置为<code>eth1</code>的IP地址；</li>
<li>将<code>eth1</code>的默认网关设置为自己的IP地址（如果设置为物理网络的网关会导致<code>eth1</code>向<code>host2</code>发送网关重定向）。</li>
</ul>
</blockquote>
<p>虚拟机的<a href="%E5%BA%94%E7%94%A8%E8%BD%AF%E4%BB%B6/../Linux/Linux%E9%85%8D%E7%BD%AE%E5%92%8C%E7%AE%A1%E7%90%86.html#%E8%B7%AF%E7%94%B1%E8%A1%A8">路由表</a>内容如下：</p>
<pre><code class="language-shell"># vm router的路由表
Destination    Gateway        Genmask       ... Metric Iface
0.0.0.0        192.168.178.2  0.0.0.0             0    eth0  # 默认路由网关
172.28.76.0    0.0.0.0        255.255.255.0       0    eth1  # PHY net
192.168.178.0  0.0.0.0        255.255.255.0       0    eth0  # NAT net
</code></pre>
<h3 id="路由失效解决方案"><a class="header" href="#路由失效解决方案">路由失效解决方案</a></h3>
<ol>
<li>主机无法访问通过软路由访问其他虚拟主机：可能是主机网络问题，重启虚拟机和主机。</li>
</ol>
<h2 id="参考资料-7"><a class="header" href="#参考资料-7">参考资料</a></h2>
<div class="footnote-definition" id="soft-router"><sup class="footnote-definition-label">1</sup>
<p><a href="https://www.ascinc.com/blog/linux/how-to-build-a-simple-router-with-ubuntu-server-18-04-1-lts-bionic-beaver/">How To: Build a Simple Router with Ubuntu Server 18.04.1 LTS (Bionic Beaver) - Ascinc.com</a>
<sup class="footnote-reference"><a href="#curl">2</a></sup>: <a href="https://everything.curl.dev/usingcurl">Using curl - Everything curl</a></p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="网络服务软件"><a class="header" href="#网络服务软件">网络服务软件</a></h1>
<h2 id="apache2"><a class="header" href="#apache2">Apache2</a></h2>
<h3 id="安装-17"><a class="header" href="#安装-17">安装</a></h3>
<pre><code class="language-sh">sudo apt install apache2
</code></pre>
<p>安装完成后，服务器在后台运行，即可通过IP地址访问服务器。</p>
<p>服务器以管理员身份运行。</p>
<h5 id="服务器运行管理"><a class="header" href="#服务器运行管理">服务器运行管理</a></h5>
<pre><code class="language-shell">sudo service apache2 start
sudo /etc/init.d/apache2
apache2ctl start|stop|restart|....	
</code></pre>
<h3 id="创建网站"><a class="header" href="#创建网站">创建网站</a></h3>
<h4 id="默认站点"><a class="header" href="#默认站点">默认站点</a></h4>
<p>内容位于<code>/var/www/html</code>（可通过配置文件<code>/etc/apache2/sites-enabled/000-default.conf</code>修改站点的根目录等信息）。</p>
<h4 id="创建站点"><a class="header" href="#创建站点">创建站点</a></h4>
<p>Apache通过编辑虚拟主机（Virtual Host）文件来管理多个站点。可以通过复制默认站点文件来创建新的站点的配置文件。</p>
<pre><code class="language-sh">cd /etc/apache2/sites-available
sudo cp 000-default.conf server.conf
</code></pre>
<blockquote>
<p><code>000-default.conf</code>对应的是HTTP服务的默认站点，<code>default-ssl.conf</code>对应的是HTTPS服务的默认站点。</p>
</blockquote>
<h5 id="虚拟站点"><a class="header" href="#虚拟站点">虚拟站点</a></h5>
<p>然后编辑站点的<a href="https://httpd.apache.org/docs/2.4/vhosts/examples.html">配置文件</a>*，其中</p>
<pre><code class="language-xml">[Listen [ip_addr:][port]]

&lt;VirtualHost [ip_addr][:port]&gt;
    ServerAdmin yourname@example.com  # 管理员邮箱
    DocumentRoot /var/www/server/     # 站点根目录
    ServerName www.server.net         # 站点域名（默认文件中没有此项）
&lt;/VirtualHost&gt;
</code></pre>
<blockquote>
<p>IP地址可以为通配符（<code>*</code>）；</p>
<p>一个配置文件可包含多个<code>VirtualHost</code>，默认站点不需要添加域名，其他站点需要设置唯一的<code>ServerName</code>。也可以将不同的<code>VirtualHost</code>放到单独的配置文件中。</p>
</blockquote>
<p>在<code>/var/www/</code>（或其他目录）下创建站点对应的文件夹。</p>
<pre><code class="language-sh">sudo mkdir /var/www/server
</code></pre>
<p>完成上述配置后，需要运行以下命令以启用站点。</p>
<pre><code class="language-sh">sudo a2ensite server.conf  # enable an apache2 site(virtual host) 
</code></pre>
<blockquote>
<p>使用<code>a2dissite</code>停用站点。</p>
</blockquote>
<p>完成后重启Apache，</p>
<pre><code class="language-sh">service apache2 reload # or
systemctl reload apache2
</code></pre>
<h4 id="启用安全服务https"><a class="header" href="#启用安全服务https">启用安全服务(HTTPS)</a></h4>
<p>启用<code>ssl</code>模块和安全站点的<a href="%E5%BA%94%E7%94%A8%E8%BD%AF%E4%BB%B6/%E7%BD%91%E7%BB%9C%E6%9C%8D%E5%8A%A1%E8%BD%AF%E4%BB%B6.html#%E5%88%9B%E5%BB%BA%E7%AB%99%E7%82%B9">配置文件</a>。</p>
<pre><code class="language-sh">sudo a2enmod ssl
systemctl restart apache2  # 重启Apache服务器
</code></pre>
<h3 id="服务器管理"><a class="header" href="#服务器管理">服务器管理</a></h3>
<h5 id="配置文件"><a class="header" href="#配置文件">配置文件</a></h5>
<p>配置文件位于：<code>/etc/apache2/</code>。</p>
<pre><code>/etc/apache2/
|-- apache2.conf
|----  ports.conf
|-- mods-enabled
|---- *.load
|---- *.conf
|-- conf-enabled
|---- *.conf
|-- sites-enabled
|---- *.conf
</code></pre>
<p><code>apache2.conf</code>是主要配置文件。</p>
<p><code>ports.conf</code></p>
<h2 id="httpd"><a class="header" href="#httpd">httpd</a></h2>
<p>默认欢迎页面配置：<code>/etc/httpd/conf.d/welcome.conf</code>，移除该文件以禁用默认配置。</p>
<p>支持在服务目录下访问符号链接的权限：</p>
<ol>
<li>
<p>服务目录配置支持跟踪符号链接；</p>
<pre><code class="language-xml">&lt;Directory &quot;/var/www/html&quot;&gt;
    Options Indexes FollowSymLinks
    AllowOverride None
    Require all granted
&lt;/Directory&gt;
</code></pre>
</li>
<li>
<p>http服务的运行用户（<code>apache</code>）具有<a href="https://unix.stackexchange.com/questions/20993/symbolic-link-not-allowed-or-link-target-not-accessible-apache-on-centos-6">访问（<code>execute</code>）目标目录（及其父目录）的权限</a>；</p>
<blockquote>
<p><em><code>httpd</code> Symbolic link not allowed or link target not accessible</em></p>
</blockquote>
</li>
<li>
<p>可能需要<a href="https://stackoverflow.com/questions/17442370/you-dont-have-permission-to-access-on-this-server">关闭SELinux</a>，以允许http服务访问服务目录外的位置。</p>
<blockquote>
<p><em>You don't have permission to access <code>/directory</code> on this server</em></p>
</blockquote>
</li>
</ol>
<h2 id="nginx"><a class="header" href="#nginx">Nginx</a></h2>
<p><img src="%E5%BA%94%E7%94%A8%E8%BD%AF%E4%BB%B6/%E7%BD%91%E7%BB%9C%E6%9C%8D%E5%8A%A1%E8%BD%AF%E4%BB%B6.assets/nginx.jpg" alt="img" /></p>
<p>CentOS安装：Nginx位于<a href="%E5%BA%94%E7%94%A8%E8%BD%AF%E4%BB%B6/../Linux/Linux%E5%8F%91%E8%A1%8C%E7%89%88.html#epel">EPEL软件源</a>中；Ubuntu软件源中已包含Nginx。</p>
<p>Nginx服务通常通过<code>systemd</code>管理（<code>start|stop|restart|reload</code>）。</p>
<h3 id="服务器配置"><a class="header" href="#服务器配置">服务器配置</a></h3>
<h5 id="配置文件-1"><a class="header" href="#配置文件-1">配置文件</a></h5>
<pre><code class="language-sh">/etc/nginx/
-- /etc/nginx/nginx.conf           # top-level configuration file
-- /etc/nginx/conf.d/              # HTTP server sites
-- /etc/nginx/conf.d/default.conf  # configuration template
-- /etc/nginx/sites-available      # apache-style config dir
-- /etc/nginx/sites-enable
</code></pre>
<p><code>nginx.conf</code>是Nginx的主要配置文件，其中可以使用<code>include</code>指令将其他服务配置文件加入。如果某个配置项有错误，该配置项以及之后的配置项都不会被加载。在运行Nginx之前可先测试配置是否存在问题：</p>
<pre><code class="language-shell">nginx -t -c /PATH/nginx.conf  # 使用绝对路径，否则nginx会从默认配置目录读取
</code></pre>
<h5 id="配置语法"><a class="header" href="#配置语法">配置语法</a></h5>
<p>设置变量：<code>set $variable value;</code>，值如果包含空格等特殊字符，需要使用<code>&quot;&quot;</code>。</p>
<h4 id="基本配置"><a class="header" href="#基本配置">基本配置</a></h4>
<pre><code class="language-shell">access_log  /var/nginx/logs/access.log;
error_log   /var/nginx/logs/error.log;      # 错误日志
error_log   /var/nginx/logs/info.log  info; # 将指定级别日志输出到指定文件
pid         /var/nginx/logs/nginx.pid;      # Nginx主进程ID
</code></pre>
<h5 id="日志格式-1"><a class="header" href="#日志格式-1">日志格式</a></h5>
<pre><code class="language-nginx">log_format main '$remote_addr - $remote_user [$time_local] $server_name ...'
</code></pre>
<p>日志中NGINX提供的内置变量，以记录请求服务信息。</p>
<ul>
<li><code>$server_name/server_addr/server_port</code>：接受该请求的服务器名称（域名/IP地址）、地址、端口；</li>
<li><code>$request_uri/$uri|$document_uri</code>：原始请求URI（包含参数）、规范化URI；</li>
<li><code>$query_string|$args</code>：请求URI的查询参数；</li>
<li><code>$scheme/$server_protocol/$request_method</code>：请求使用<code>http</code>/<code>https</code>、HTTP协议版本、HTTP方法；</li>
<li><code>$https</code>：是否开启HTTPS、</li>
<li><code>$request_length/$request</code>：请求数据长度（包括请求行、头部以及请求体）、请求行；</li>
<li><code>$remote_addr/$remote_port/$remote_user/</code>：客户端地址、端口和用户名（基本认证机制）；</li>
<li><code>$content_type/$cookie_name</code>：请求头部信息；</li>
<li><code>$time_local</code>：服务器当前时间；</li>
<li><code>status</code>：响应状态；</li>
</ul>
<h4 id="http静态站点"><a class="header" href="#http静态站点">HTTP静态站点</a></h4>
<p>通过<code>server</code>块定义虚拟HTTP服务站点。其中<code>listen</code>和<code>server</code>用于定义虚拟服务的映射条件<sup class="footnote-reference"><a href="#nginx_server">1</a></sup>：</p>
<ul>
<li><code>listen</code>：映射目标IP和端口，多个虚拟服务可共用相同的地址和端口，通过域名进行区分；如果省略IP地址，则监听服务器的所有地址；如果省略端口，则默认监听端口为80或8000。</li>
<li><code>server_name</code>：客户端请求域名，多个域名以空格分隔，支持通配符以及正则表达式匹配<sup class="footnote-reference"><a href="#nginx-server-name">2</a></sup>。如果未匹配到任何域名，则将请求转发至<code>listen</code>字段包括<code>default_server</code>的服务站点。</li>
</ul>
<pre><code class="language-shell">http {
   server {
      listen 80 default_server;       # 监听[ip_addr:]port
      server_name www.example.com example.com; 
      root /var/www;                  # 默认根目录(仅能访问根目录下的内容)
      location / {                    # 根目录配置
         index index.html index.htm;  # 默认主页，设置在根目录的配置下
         root /usr/share/nginx/html;  # 根目录对应的物理目录[路径重定向]
      }
   }
   server {   # 使用相同地址服务不同域名的HTTP服务
      listen      80;
      server_name test.example.com;  
      root /var/test;
   }
}
</code></pre>
<blockquote>
<p><code>default_server</code>：未匹配到域名时的默认服务。</p>
</blockquote>
<p>Nginx默认的服务进程用户为<code>nobody/nginx</code>，因此服务目录下文件应该对所有用户有读权限，所有目录对所有用户有访问权限，否则会产生<code>403 Forbidden</code>错误。</p>
<h5 id="文件服务器"><a class="header" href="#文件服务器">文件服务器</a></h5>
<pre><code class="language-nginx">http {
  server {
    autoindex on;            # 显示目录
    autoindex_exact_size on; # 显示文件大小
    autoindex_localtime on;  # 显示文件时间
    # ...
    root /share/fs;
  }
}
</code></pre>
<h4 id="反向代理转发"><a class="header" href="#反向代理转发">反向代理转发</a></h4>
<pre><code class="language-nginx">location ^~ /test/ {
    proxy_pass      http://host_addr:8080;
}
location ^~ /test/1 {
    proxy_pass      http://127.0.0.1:8080;
}
location = /test/prefix/ {
    proxy_pass      http://127.0.0.1:8080;
}
location ~ ^/debug(.*)/log(.*)/ {
    proxy_pass      http://host_addr:8080/debug_log/$1/$2/;  #*
}
location / {
    proxy_pass      http://127.0.0.1:8080;
}
</code></pre>
<blockquote>
<p><code>*</code>：如果匹配规则为正则表达式，转发地址中可包含正则表达式的捕获参数。</p>
</blockquote>
<p>URL位置匹配规则（匹配优先级从高到低）<sup class="footnote-reference"><a href="#nginx-loc">3</a></sup>：</p>
<ul>
<li>
<p><strong>前缀匹配</strong>：以<code>=</code>、<code>^~</code>修饰或无修饰符的匹配规则，按书写顺序检查。</p>
<ul>
<li><code>location = URI</code>：<strong>精确</strong>匹配，匹配后立即响应请求。通常写在规则列表前面，用于匹配最常访问的URL如<code>location = /</code>。</li>
<li><code>location ^~ URI</code>：<strong>优先</strong>最长匹配，如果请求路径包含指定前缀，在匹配所有前缀匹配规则后，返回带<code>^~</code>的最长匹配；通常用于匹配服务器上的资源目录。</li>
<li><code>location URI</code>：<strong>最长</strong>匹配，记录下最长匹配记录，==但不做处理==（==优先级最低==，但搜索先于正则匹配；<em>可能是为了一同调用前缀匹配模块</em>）。</li>
</ul>
<p>以<code>/test/1</code>合上述规则为例，匹配顺序为：</p>
<pre><code class="language-shell">priority prefix match for location: /test/
priority prefix match for location: /test/1  # Final Match
prefix match for location: /
</code></pre>
<blockquote>
<p><a href="https://nginx.viraptor.info/">Nginx location match tester</a>.</p>
</blockquote>
</li>
<li>
<p><strong>正则表达式匹配</strong>：<code>location ~ URI</code>（<code>~*</code>大小写敏感）按顺序查找，匹配到后立即响应请求；通常用于根据规则匹配URL，并在后续对URL进行修改。</p>
</li>
<li>
<p><strong>最长前缀匹配</strong>：使用<strong>前缀匹配</strong>过程中记录到的最长匹配响应请求；通常会设置<code>location /</code>作为默认规则，因此，请求最后总能被一条规则所处。</p>
<blockquote>
<p>Nginx location block section：https://stackoverflow.com/a/59846239/6571140</p>
</blockquote>
</li>
</ul>
<p>编写匹配规则时，应该将较为精确的匹配项放在靠前的位置，否则更加模糊匹配项会覆盖精确匹配项，导致与期望的转发行为不一致。当出现转发失败或未按期望转发时，可对比Nginx的日志文件<code>access.log</code>和<code>error.log</code>（其中包含了用户的请求URL与Nginx的响应URL），排查错误原因。</p>
<h5 id="资源路径重定向"><a class="header" href="#资源路径重定向">资源路径重定向</a></h5>
<p><code>rewrite</code>将指定路径并替换为新的路径，<code>root</code>重新指定资源的根目录。</p>
<pre><code class="language-shell">location [modifier] [URI] {
  rewrite /path/($REGEX)/subpath/ replace_path break;
  root base_path;   # 实际访问 base_path/replace_path
}
</code></pre>
<blockquote>
<p><code>$REGEX</code>表达式可使用正则表达式，<code>replace_path</code>和<code>base_path</code>可使用<code>rewrite</code>表达式的捕获组（<code>$1,$2,...</code>）。</p>
</blockquote>
<h4 id="https配置"><a class="header" href="#https配置">HTTPS配置</a></h4>
<p><a href="https://docs.rocket.chat/installing-and-updating/docker-containers#5-installing-nginx-and-ssl-certificate">Docker Containers - Rocket.Chat Docs</a></p>
<pre><code class="language-shell">server {
   ssl_certificate /etc/nginx/certificate.crt;
   ssl_certificate_key /etc/nginx/certificate.key;
   ssl_dhparam /etc/nginx/dhparams.pem;
}
</code></pre>
<blockquote>
<ul>
<li>
<p><code>&quot;ngx_master_****&quot; was not signaled for 5s</code>：<a href="https://stackoverflow.com/questions/69896680/nginx-getting-the-event-ngx-master-was-not-signaled-for-5s">在Windows下，由于SSL密钥需要输入密码导致Nginx服务启动超时</a>。可将证书密码保存在文本文件中（放在安全位置），并在Nginx配置文件中添加</p>
<pre><code class="language-nginx">ssl_password_file       pass.txt
</code></pre>
<p>或者将密钥的密码验证移除：</p>
<pre><code class="language-shell">openssl rsa -in server.key -out serverunsecure.key
</code></pre>
</li>
</ul>
</blockquote>
<h3 id="负载均衡"><a class="header" href="#负载均衡">负载均衡</a></h3>
<pre><code class="language-nginx">http {
  upstream load_balance_server {
    least_conn;  # 负载均衡策略(默认为轮询)
    server 192.168.1.11:80   weight=5;  #*
    server 192.168.1.12:80   weight=1;
    server 192.168.1.13:80   weight=6;
  }
  server {
    location / {
      proxy_pass http://load_balance_server;
    }
  }
}
</code></pre>
<p>负载均衡策略：</p>
<ul>
<li>（加权）轮询：<code>weigth</code>参数表示权值，权值越高被分配到的几率越大。；</li>
<li>（加权）最少连接：<code>least_conn</code>；</li>
<li>IP映射：<code>ip_hash</code>；</li>
<li>URL映射：<code>hash $request_uri</code>；</li>
</ul>
<h3 id="nginx常见错误"><a class="header" href="#nginx常见错误">Nginx常见错误</a></h3>
<ul>
<li>
<p><em><code>unknown directive &quot;ssl&quot; nginx</code></em>：Nginx未安装SSL模块。</p>
</li>
<li>
<p><code>403 Forbidden (nginx: Permission denied)</code>：1）文件及其上级目录权限配置不正确，Nginx工作进程所属用户无访问权限；SELinux开启阻止Nginx访问文件（特殊情况下，仅某个特殊文件无法被访问）。</p>
<blockquote>
<p><a href="https://www.nginx.com/blog/using-nginx-plus-with-selinux/">Modifying SELinux Settings for Full NGINX and NGINX Plus Functionality</a></p>
</blockquote>
</li>
<li>
<p><code>502 Bad Gateway (nginx: (13: Permission denied) while connecting to upstream)</code>：<a href="https://stackoverflow.com/questions/23948527/13-permission-denied-while-connecting-to-upstreamnginx">系统开启SELinux，默认不允许HTTP服务软件连接系统的其他服务（进行代理转发）</a>。可选择：1）关闭SELinux；2）<a href="%E5%BA%94%E7%94%A8%E8%BD%AF%E4%BB%B6/../Linux/Linux%E9%85%8D%E7%BD%AE%E5%92%8C%E7%AE%A1%E7%90%86.html#SELinux%E7%AD%96%E7%95%A5">修改SELinux策略</a>；</p>
<pre><code class="language-shell">setsebool -P httpd_can_network_connect on  # [on/1] -P for persistent
</code></pre>
</li>
<li>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS">CORS</a>(<em><strong>cross-origin resource sharing</strong></em>，跨源资源共享)错误：客户端请求缺少CORS标准相关的HTTP头部字段，浏览器不允许上述跨域访问行为。在不修改客户端（HTML或JS代码等）的情况下，可通过NGINX代理修改HTTP请求头部实现跨域资源共享。</p>
<pre><code class="language-nginx">add_header 'Access-Control-Allow-Origin' '*';                   #*
add_header 'Access-Control-Allow-Methods' 'GET, POST, OPTIONS'; #**
add_header 'Access-Control-Allow-Headers' '*';                  #***
add_header 'Access-Control-Allow-Credentials' 'true';           #****
if ($request_method = 'OPTIONS') {
    return 204;
}
</code></pre>
<blockquote>
<p><code>*</code>：该头部选项允许通配符以允许匹配的请求源站点。</p>
<p><code>**</code>：允许跨域访问的HTTP方法，支持通配符。</p>
<p><code>***</code>：如果出现<code>Request header field xxx is not allowed by Access-Control-Allow-Headers in preflight response.</code>，添加该头部，支持通配符。</p>
<p><code>****</code>：如果响应内容未携带该头部，浏览器将不会把响应内容返回给请求发送者。在响应附带身份凭证的请求时，不能将上述头部的值设置为通配符。</p>
</blockquote>
</li>
<li>
<p>修改配置重新加载不生效（例如日志配置无效不输出日志）：</p>
<p>可能原因：Nginx后台进程未正常关闭（Windows），导致新启动的Nginx实例无法正常初始化。</p>
<p>解决方法：手动结束所有Nginx进程后，重新启动Nginx。</p>
</li>
</ul>
<h2 id="caddy"><a class="header" href="#caddy">Caddy</a></h2>
<blockquote>
<p><em>Fast and extensible multi-platform HTTP/3 web server with automatic HTTPS.</em></p>
<ul>
<li><a href="https://caddyserver.com/docs/quick-starts">Quick-starts — Caddy Documentation (caddyserver.com)</a></li>
</ul>
</blockquote>
<h3 id="安装-18"><a class="header" href="#安装-18">安装</a></h3>
<pre><code class="language-powershell">choco install caddy
</code></pre>
<h4 id="运行caddy服务"><a class="header" href="#运行caddy服务">运行Caddy服务</a></h4>
<pre><code class="language-powershell">$env:XDG_DATA_HOME='path/'
caddy run --config caddy.json/Caddyfile --watch #*
caddy start|stop|reload  # 后台服务管理
</code></pre>
<p><code>caddy.json</code>或<code>Caddyfile</code>是<a href="%E5%BA%94%E7%94%A8%E8%BD%AF%E4%BB%B6/%E7%BD%91%E7%BB%9C%E6%9C%8D%E5%8A%A1%E8%BD%AF%E4%BB%B6.html#">配置文件</a>，如果未提供配置文件，则服务器只有管理接口可访问。</p>
<blockquote>
<p><code>*</code>：<code>--watch</code>将监视配置文件更改并自动重新加载。</p>
</blockquote>
<h4 id="管理接口"><a class="header" href="#管理接口">管理接口</a></h4>
<p><code>http://localhost:2019/config/</code></p>
<h4 id="caddy模块"><a class="header" href="#caddy模块">Caddy模块</a></h4>
<p>Caddy预装了标准模块，如匹配器、处理器、反向代理、TLS和日志等。</p>
<pre><code class="language-shell">.\caddy.exe list-modules
</code></pre>
<h3 id="配置caddy"><a class="header" href="#配置caddy">配置Caddy</a></h3>
<p>可使用JSON或Caddyfile对Caddy服务进行配置。JSON格式信息完整，对计算机解析更加友好；Caddyfile相对更加简洁，适合人工配置。</p>
<h4 id="json配置"><a class="header" href="#json配置">JSON配置</a></h4>
<pre><code class="language-json">{
    &quot;apps&quot;: {
        &quot;http&quot;: {
            &quot;servers&quot;: {
                &quot;&lt;server-name&gt;&quot;: {
                    &quot;listen&quot;: [
                        &quot;[host]:port&quot;
                    ],
                    &quot;routes&quot;: [
                        {
                            &quot;match&quot;: [
                                {&quot;host&quot;: [&quot;domain.name&quot;]}
                            ],
                            &quot;handle&quot;: [
                                {
                                    &quot;handler&quot;: &quot;file_server&quot;,
                                    &quot;root&quot;: &quot;/path/to/html&quot;
                                }
                            ]
                        }
                    ]
                }
            }
        }
    },
    &quot;admin&quot;: {/*...*/},
    &quot;logging&quot;: {/*...*/},
    &quot;storage&quot;: {/*...*/}
}
</code></pre>
<p><a href="https://caddyserver.com/docs/json/">JSON Config Structure - Caddy Documentation (caddyserver.com)</a></p>
<h5 id="routes-1"><a class="header" href="#routes-1">routes</a></h5>
<p>定义了请求的匹配规则及其处理路径。<code>match</code>用于定义匹配规则，<code>handle</code>定义请求的处理方法。</p>
<h5 id="handler"><a class="header" href="#handler">handler</a></h5>
<ul>
<li><code>static_response</code>：直接通过配置文件设置响应内容（<code>body</code>）；</li>
<li><code>file_server</code>：响应服务器上的静态文件资源（<code>root</code>）。</li>
<li><code>reverse_proxy</code>：反向代理。</li>
</ul>
<h4 id="caddyfile配置"><a class="header" href="#caddyfile配置">Caddyfile配置</a></h4>
<p>Caddyfile包含全局选项（可选）、配置片段（可选）、一个或多个站点配置块以及注释（<code>#</code>开头后续内容）。如果配置文件只包含一个站点，其配置块的<code>{}</code>可省略。</p>
<p><img src="%E5%BA%94%E7%94%A8%E8%BD%AF%E4%BB%B6/%E7%BD%91%E7%BB%9C%E6%9C%8D%E5%8A%A1%E8%BD%AF%E4%BB%B6.assets/caddyfile-visual.png" alt="Caddyfile structure" /></p>
<p>匹配器必须在站点内部定义，不存在跨站点的全局匹配器。</p>
<p>站点地址格式：</p>
<ul>
<li><code>localhost</code>、<code>localhost:8080</code>、<code>127.0.0.1</code>：监听指定IP地址/主机名和端口的请求；</li>
<li><code>example.com</code>、<code>http://example.com</code>：监听指定端口上的域名请求；</li>
<li><code>:443</code>、<code>[::1]:2015</code>、<code>http://</code>：监听所有地址的指定端口；</li>
<li><code>*.example.com</code>：监听所有匹配域名的请求。</li>
</ul>
<p>在Caddyfile中可引用Shell环境变量，<code>{$SITE_ADDRESS}</code>。</p>
<h3 id="静态资源服务"><a class="header" href="#静态资源服务">静态资源服务</a></h3>
<h4 id="文件服务"><a class="header" href="#文件服务">文件服务</a></h4>
<pre><code class="language-nginx">example.com {  # 站点域名(IP地址端口)
    root * /home/me/mysite
    try_files {path} /index.html # 如果指定URL不存在, 则回落到index.html
    templates                    # 支持模板
    encode zstd gzip             # 开启内容压缩
    file_server browse           #*
}
</code></pre>
<blockquote>
<p><code>*</code>：<code>browse</code>选项为没有<code>index.html</code>的目录提供自动文件索引，否则访问对应目录的URL将返回<code>404</code>。</p>
</blockquote>
<p>提供文件服务的快捷方式：</p>
<pre><code class="language-shell">caddy file-server --listen :2015 --browse --root ~/mysite --domain my.domain
</code></pre>
<h4 id="静态响应"><a class="header" href="#静态响应">静态响应</a></h4>
<pre><code class="language-nginx">localhost {
    respond &quot;hello world!&quot;
}
</code></pre>
<h3 id="反向代理-1"><a class="header" href="#反向代理-1">反向代理</a></h3>
<pre><code class="language-nginx">example.com {
    reverse_proxy &quot;/api/*&quot; localhost:5000
    # handle /api/* {
    #     reverse_proxy backend:8000
    # }
}
</code></pre>
<p>反向代理可与静态站点结合使用：反向代理仅转发API请求，通过<code>/api/*</code>过滤后的静态文件则直接通过文件服务器响应。==具有匹配规则的处理方法将被优先检查==。</p>
<p>反向代理服务快捷方式：</p>
<pre><code class="language-shell">caddy reverse-proxy --from :2080 --to :9000
</code></pre>
<blockquote>
<p>省略<code>--form</code>，则默认监听<code>localhost:443</code>的请求（或在<code>.localhost</code>中定义的域名）。<code>--to</code>默认转发至协议为<code>http</code>，如果后端使用<code>https</code>，则在转发地址中显式指定<code>https://</code>。</p>
</blockquote>
<h3 id="https-1"><a class="header" href="#https-1">HTTPS</a></h3>
<blockquote>
<p><em><strong>By default, Caddy serves all sites over HTTPS.</strong></em></p>
</blockquote>
<p><code>local_certs</code>：（全局选项）所有证书采用通过本地签发，不通过公开的证书签发机构（用于开发环境）。</p>
<h4 id="本地https"><a class="header" href="#本地https">本地HTTPS</a></h4>
<blockquote>
<p><em>To serve non-public sites over HTTPS, Caddy generates its own <strong>certificate authority</strong> (CA) and uses it to sign certificates. The trust chain consists of a <strong>root</strong> and <strong>intermediate certificate</strong>. <strong>Leaf certificates</strong> are signed by the intermediate. They are stored in <a href="https://caddyserver.com/docs/conventions#data-directory">Caddy's data directory</a> at <code>pki/authorities/local</code>.</em></p>
</blockquote>
<h2 id="pelican"><a class="header" href="#pelican">Pelican</a></h2>
<p>Pelican is a static site generator</p>
<ul>
<li>Write your content directly with your editor of choice in <a href="http://docutils.sourceforge.net/rst.html">reStructuredText</a> or <a href="http://daringfireball.net/projects/markdown/">Markdown</a> formats</li>
<li>Includes a simple CLI tool to (re)generate your site</li>
</ul>
<p>http://docs.getpelican.com/en/3.6.3/index.html</p>
<p>http://docs.getpelican.com/en/3.6.3/publish.html#deployment</p>
<h2 id="gunicorn"><a class="header" href="#gunicorn">Gunicorn</a></h2>
<blockquote>
<p><em>Gunicorn, 'Green Unicorn' is a Python WSGI HTTP Server for UNIX.</em></p>
</blockquote>
<blockquote>
<p><em>It is best to use Gunicorn behind an HTTP proxy server. We strongly advise you to use nginx.</em></p>
</blockquote>
<h2 id="squid代理服务"><a class="header" href="#squid代理服务">Squid代理服务</a></h2>
<p><em><strong>web proxy cache server</strong></em>：提供HTTP、FTP等协议的代理和缓存服务，支持全面、细粒度的访问控制机制。</p>
<p>安装：</p>
<pre><code class="language-shell">sudo apt install squid
sudo systemctl start/stop/reload squid #* 非root用户需要使用sudo, 否则可能导致缓存目录创建失败
</code></pre>
<h3 id="配置-5"><a class="header" href="#配置-5">配置</a></h3>
<p><code>/etc/squid/squid.conf</code></p>
<h5 id="服务端口"><a class="header" href="#服务端口">服务端口</a></h5>
<pre><code class="language-shell">http_port 3128 
</code></pre>
<p>服务地址：<code>http://proxy-server:http_port</code>。</p>
<h5 id="磁盘缓存"><a class="header" href="#磁盘缓存">磁盘缓存</a></h5>
<p>默认缓存在内存中（重启服务丢失），可指定多行以使用不同的磁盘分区。</p>
<pre><code class="language-shell">cache_dir ufs/aufs/diskd Directory-Name Mbytes L1 L2 [options]
cache_dir rock Directory-Name Mbytes [options]
</code></pre>
<ul>
<li>
<p>缓存数据格式，包括<code>ufs</code>（默认包含）、<code>aufs</code>、<code>diskd</code>、<code>rock</code>。不同系统中的分发版可能不包含所有格式，通过修改配置文件并尝试启动服务确定相应格式是否可用。</p>
</li>
<li>
<p><code>Mbytes</code>：缓存容量限制（默认<code>100MB</code>）；</p>
</li>
<li>
<p><code>L1</code>：缓存目录下一级子目录数量，默认为<code>16</code>，Squid将请求URL通过Hash计算确定缓存内容的目录；</p>
<blockquote>
<p>这些子目录不是动态生成的，因此在服务运行时删除缓存目录下生成的子目录，会导致后续缓存内容无法保存（从而无法响应客户端）。</p>
</blockquote>
</li>
<li>
<p><code>L2</code>：缓存一级子目录下二级子目录数量限制，默认为<code>256</code>；</p>
</li>
</ul>
<h5 id="访问控制-2"><a class="header" href="#访问控制-2">访问控制</a></h5>
<p>限定访问代理服务的用户IP、访问时间。</p>
<pre><code class="language-shell">acl src_rule  src ip_addr/mask
acl time_rule time M T W T F 9:00-17:00  # 工作日工作时段
http_access allow src_rule time_rule   # 满足所有规则才可使用代理
</code></pre>
<h2 id="nexus代理服务"><a class="header" href="#nexus代理服务">Nexus代理服务</a></h2>
<h3 id="安装-19"><a class="header" href="#安装-19">安装</a></h3>
<h4 id="主机安装"><a class="header" href="#主机安装">主机安装</a></h4>
<p><a href="https://help.sonatype.com/repomanager3/download/download-archives---repository-manager-3">下载Linux版本</a>的二进制档案文件，并解压到安装路径（例如<code>/opt/sonatype</code>），将<code>nexus-ver</code>重命名为<code>nexus</code>。档案的基本结构如右图所示。</p>
<p>创建运行nexus服务的用户，并将nexus的安装目录所有权限更改为该用户。</p>
<pre><code class="language-shell">useradd --system --no-create-home nexus
chown -R nexus:nexus /opt/sonatype
# edit: nexus/bin/nexus.rc
run_as_user=&quot;nexus&quot;
</code></pre>
<p>设置数据和日志目录（<code>nexus/bin/nexus.vmoptions</code>）。如果默认位置的存储空间不够或读写速率较低，则可以修改以下配置项。</p>
<pre><code class="language-shell">-XX:LogFile=../sonatype-work/nexus3/log/jvm.log
-Dkaraf.data=../sonatype-work/nexus3
-Dkaraf.log=../sonatype-work/nexus3/log      # 日志文件目录
-Djava.io.tmpdir=../sonatype-work/nexus3/tmp
</code></pre>
<p>Nexus主要配置位于安装目录<code>etc/</code>目录下，其中<code>nexus-default.properties</code>为HTTP连接和网络应用默认配置。用户可在数据目录下的<code>$data_dir/etc/nexus.properties</code>修改相应属性（首次运行前该目录和文件不存在）<sup class="footnote-reference"><a href="#nexus-conf">4</a></sup>。</p>
<blockquote>
<pre><code class="language-properties">application-port=9081      # 网络连接
nexus-context-path=/nexus/ # Base URL
</code></pre>
<p><code>base URL</code>也可以在运行后，通过<code>System/Capabilities/Base URL</code>来设置。</p>
</blockquote>
<p>更新Java运行环境（）：</p>
<pre><code class="language-shell">export JAVA_HOME=/usr/local/openjdk8  # 或 JDK_HOME,INSTALL4j_JAVA_HOME
INSTALL4J_JAVA_HOME_OVERRIDE=/usr/local/openjdk8  # edit: nexus/bin/nexus
</code></pre>
<p>修改打开文件限制（如果使用<code>systemd</code>启动则在服务配置文件中设置相应选项）：</p>
<pre><code class="language-shell"># edit: /etc/security/limits.conf
#&lt;domain&gt;      &lt;type&gt;  &lt;item&gt;         &lt;value&gt;
  nexus         -       nofile         65536
</code></pre>
<p>配置为系统服务、<a href="%E5%BA%94%E7%94%A8%E8%BD%AF%E4%BB%B6/../Linux/Linux%E9%85%8D%E7%BD%AE%E5%92%8C%E7%AE%A1%E7%90%86.html#systemd">加载服务配置并启用该服务</a>。</p>
<pre><code class="language-shell">[Unit]
Description=Nexus Service
After=syslog.target network.target
[Service]
Type=forking
LimitNOFILE=65536
Environment=JAVA_HOME=/usr/local/openjdk8
ExecStart=/opt/sonatype/nexus/bin/nexus start
ExecStop=/opt/sonatype/nexus/bin/nexus stop
User=nexus
Group=nexus
Restart=on-failure
[Install]
WantedBy=multi-user.target
</code></pre>
<blockquote>
<p>注意启动命令不要使用符号链接，因为<code>nexus</code>启动时会根据可执行文件所在目录的相对路径来寻找数据目录<code>sonatype-work</code>，而符号链接会导致相对路径位置不正确。</p>
</blockquote>
<p>首次登录管理员：初始密码随机生成，存储在<code>/nexus-data/admin.password</code>。</p>
<blockquote>
<p>Windows下的服务管理，</p>
<pre><code class="language-powershell">./nexus.exe /install/uninstall    # 安装卸载服务
./nexus.exe /start/status/stop    # 启停服务，查看状态
./nexus.exe /run                  # 直接运行服务
</code></pre>
</blockquote>
<p><a href="https://www.fosslinux.com/27838/installing-sonatype-nexus-repository-oss-on-centos-7.htm">Installing Sonatype Nexus Repository OSS on CentOS 7 | FOSS Linux</a></p>
<h5 id="存储配置"><a class="header" href="#存储配置">存储配置</a></h5>
<p>仓库清理策略：通过<code>Repository/Cleanup Policies</code>添加清理策略，可按包的发布时间或最后下载时间设置清理策略。</p>
<h5 id="http网络代理配置"><a class="header" href="#http网络代理配置">HTTP网络代理配置</a></h5>
<p><code>System/HTTP/{HTTP proxy|HTTPS proxy}</code>（<em>例外项可使用<code>http.nonProxyHosts</code>通配符</em>）。</p>
<h4 id="docker"><a class="header" href="#docker">docker</a></h4>
<pre><code class="language-shell">docker run -d -p 8081:8081 --name nexus-porxy \
           -v nexus-data:/nexus-data sonatype/nexus3
</code></pre>
<h3 id="配置软件源代理"><a class="header" href="#配置软件源代理">配置软件源代理</a></h3>
<p>主要配置访问地址（仓库名称）、仓库的远程仓库地址和本地存储设置。</p>
<img src="应用软件/网络服务软件.assets/image-20210916004311944-16587252890037.png" alt="image-20210916004311944" style="zoom: 50%;" />
<img src="应用软件/网络服务软件.assets/image-20210916004416287-16587253199949.png" alt="image-20210916004416287" style="zoom: 60%;" />
<blockquote>
<p><code>Blocked</code>：阻止从远程仓库获取内容，适用于服务无法访问网络的情况以避免产生无效的网络请求。</p>
</blockquote>
<img src="应用软件/网络服务软件.assets/image-20210916004455195-165872535016411.png" alt="image-20210916004455195" style="zoom:60%;" />
<h5 id="pypi代理"><a class="header" href="#pypi代理">pypi代理</a></h5>
<pre><code class="language-shell">Name=&quot;pypi-proxy&quot;
Remote=&quot;https://pypi.doubanio.com&quot;  # 远端镜像去掉/simple后缀
URL=&quot;http://localhost:8081/repository/pypi-proxy/simple&quot;
</code></pre>
<blockquote>
<p><code>/simple</code>是仓库下的索引目录，Nexus会为远端地址自动添加该后缀。</p>
</blockquote>
<h5 id="conda代理"><a class="header" href="#conda代理">conda代理</a></h5>
<pre><code class="language-shell">Name=&quot;conda-pkgs&quot;
Remote=&quot;https://mirror.sjtu.edu.cn/anaconda/pkgs&quot;
URL=&quot;http://localhost:8081/repository/conda-pkgs[/main]&quot; # 使用时去掉main后缀
Name=&quot;conda-cloud&quot;
Remote=&quot;https://mirror.sjtu.edu.cn/anaconda/cloud&quot;
URL=&quot;http://localhost:8081/repository/conda-cloud[/main]&quot; # 使用时去掉main后缀
</code></pre>
<p>如果远程仓库中包含多个通道（如<code>conda-forge</code>和<code>pytorch</code>），则可将多个通道配置为一个代理仓库。配置<code>condarc</code>文件时，<code>custom_channels</code>对应的URL均为上述代理访问URL。</p>
<h5 id="maven代理"><a class="header" href="#maven代理">maven代理</a></h5>
<pre><code class="language-shell">Name=&quot;maven-central&quot;
Remote=&quot;https://maven.aliyun.com/repository/central&quot;
URL=&quot;http://localhost:8081/repository/maven-central/&quot;
</code></pre>
<h5 id="apt代理"><a class="header" href="#apt代理">apt代理</a></h5>
<p>需要为不同版本设置不同的代理仓库（在配置中要填写版本名称，如<code>focal</code>，<code>jammy</code>），不支持多个仓库合并为组。</p>
<pre><code class="language-shell">Name=&quot;ubuntu-focal&quot;
Remote=&quot;https://mirrors.tuna.tsinghua.edu.cn/ubuntu/&quot;
URL=&quot;http://localhost:8081/repository/ubuntu-focal/&quot;
Name=&quot;ubuntu-jammy&quot;
Remote=&quot;https://mirrors.tuna.tsinghua.edu.cn/ubuntu/&quot;
URL=&quot;http://localhost:8081/repository/ubuntu-jammy/&quot;
</code></pre>
<h5 id="yum代理"><a class="header" href="#yum代理">yum代理</a></h5>
<pre><code class="language-shell">Name=&quot;yum-centos&quot;
Remote=&quot;http://mirrors.aliyun.com/centos/&quot;
# https://mirrors.tuna.tsinghua.edu.cn/{fedora|centos}
URL=&quot;http://localhost:8081/repository/yum-centos/&quot;
</code></pre>
<h3 id="配置合并镜像源group"><a class="header" href="#配置合并镜像源group">配置合并镜像源（group）</a></h3>
<p>可从同一个地址获取多个仓库的内容（按顺序依次请求）。</p>
<img src="应用软件/网络服务软件.assets/image-20211017215604788-165872538423013.png" alt="image-20211017215604788" style="zoom:55%;" />
<h3 id="web服务目录与反向代理"><a class="header" href="#web服务目录与反向代理">Web服务目录与反向代理</a></h3>
<p>设置Web服务目录：1) ==修改配置文件==。2）通过Web管理界面“System/Capabilities/Create capabilities”添加“Base URL”（<code>http://addr_or_name:8081/prefix</code>）。</p>
<pre><code class="language-nginx">client_max_body_size 1G;     # allow large uploads of files
proxy_max_temp_file_size 2G; # optimize downloading files larger than 1G
location /nexus {
  # Use IPv4 address to avoid IPv6 DNS lookup
  proxy_pass http://127.0.0.1:8081/nexus;
  proxy_set_header Host $host;
  proxy_set_header X-Real-IP $remote_addr;
  proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
  proxy_set_header X-Forwarded-Proto &quot;https&quot;;  # If https terminated at nginx proxy
}
</code></pre>
<h2 id="参考资料-8"><a class="header" href="#参考资料-8">参考资料</a></h2>
<div class="footnote-definition" id="nexus-conf"><sup class="footnote-definition-label">4</sup>
<p><a href="https://help.sonatype.com/repomanager3/installation-and-upgrades/configuring-the-runtime-environment?_ga=2.15475440.714739.1650532475-1707272426.1649329767">Configuring the Runtime Environment (sonatype.com)</a>
<sup class="footnote-reference"><a href="#nginx_server">1</a></sup>: <a href="http://nginx.org/en/docs/http/request_processing.html">How nginx processes a request</a>
<sup class="footnote-reference"><a href="#nginx-server-name">2</a></sup>: <a href="http://nginx.org/en/docs/http/server_names.html">Server names (nginx.org)</a></p>
</div>
<div class="footnote-definition" id="nginx-loc"><sup class="footnote-definition-label">3</sup>
<p><a href="https://www.digitalocean.com/community/tutorials/nginx-location-directive">Tutorial: Nginx location directive examples, DigitalOcean</a>.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="文档生成工具"><a class="header" href="#文档生成工具">文档生成工具</a></h1>
<h2 id="sphinx"><a class="header" href="#sphinx">Sphinx</a></h2>
<p>Sphinx最初用于生成Python代码文档，支持多种语言软件项目的文档生成。支持：输出HTML、LaTeX、ePub、manual页面等、自动交叉引用以及代码高亮等。Sphinx使用<a href="https://docutils.sourceforge.io/docs/user/rst/quickref.html">reStructuredText</a>作为标记语言（类似于Markdown，标记语法更多）<sup class="footnote-reference"><a href="#rst">1</a></sup>。</p>
<blockquote>
<p>Sphinx uses <a href="https://docutils.sourceforge.io/rst.html">reStructuredText</a> as its markup language, and many of its strengths come from the power and straightforwardness of reStructuredText and its parsing and translating suite, the <a href="https://docutils.sourceforge.io/">Docutils</a><sup class="footnote-reference"><a href="#sphinx">2</a></sup>.</p>
</blockquote>
<h3 id="安装-20"><a class="header" href="#安装-20">安装</a></h3>
<h5 id="独立安装"><a class="header" href="#独立安装">独立安装</a></h5>
<pre><code class="language-shell">apt install python3-sphinx  # yum install python-sphinx, choco install sphinx
</code></pre>
<blockquote>
<p>如果系统不存在Python环境，将自动安装Python环境；</p>
</blockquote>
<h5 id="虚拟环境安装"><a class="header" href="#虚拟环境安装">虚拟环境安装</a></h5>
<p>使用<a href="%E5%BA%94%E7%94%A8%E8%BD%AF%E4%BB%B6/../Python/Python%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83.html#%E8%99%9A%E6%8B%9FPython%E7%8E%AF%E5%A2%83">virtualenv或conda虚拟环境</a>。如果用于生成代码文档，应该安装在代码开发所在虚拟环境中，因为在导入代码模块时会导入其中的依赖项。因此，独立的虚拟环境无法满足依赖。</p>
<pre><code class="language-shell">conda activate env_dev &amp;&amp; conda install sphinx -c conda-forge
</code></pre>
<p><a href="https://docs.readthedocs.io/en/stable/intro/getting-started-with-sphinx.html">Getting Started with Sphinx — Read the Docs 5.21.0 documentation</a></p>
<p><a href="https://www.sphinx-doc.org/en/master/tutorial/index.html">Sphinx tutorial — Sphinx documentation (sphinx-doc.org)</a></p>
<h3 id="配置和编译"><a class="header" href="#配置和编译">配置和编译</a></h3>
<pre><code class="language-shell">sphinx-quickstart  # 自动生成配置文件和编译脚本(make.bat)
sphinx-build -b html sourcedir builddir # =&gt; make html
</code></pre>
<p><code>sourcedir</code>：Sphinx项目使用的所有源文件所在目录（子目录）</p>
<p>语言：默认为英语<code>en</code>，可选择设置中文<code>zh_CN</code>。</p>
<p><a href="https://www.sphinx-doc.org/en/master/usage/configuration.html#confval-language">Configuration — Sphinx documentation (sphinx-doc.org)</a></p>
<h5 id="首页配置文件"><a class="header" href="#首页配置文件">首页配置文件</a></h5>
<p>定制文档首页以及目录。</p>
<pre><code class="language-rst">.. toctree::
   :maxdepth: 2

   usage/installation   添加要转换的文件：省略扩展名，使用`/`作为路径分隔符
   usage/quickstart
   ...
</code></pre>
<blockquote>
<p>被添加文件所引用的文件也会被解析。</p>
<p><em>文件路径</em></p>
</blockquote>
<h5 id="编译配置文件"><a class="header" href="#编译配置文件">编译配置文件</a></h5>
<p>主题：</p>
<pre><code class="language-shell">conda install -c conda-forge sphinx_rtd_theme
html_theme = 'sphinx_rtd_theme'   # in conf.py
extensions = [ 'sphinx_rtd_theme' ]
</code></pre>
<p><a href="https://sphinx-themes.org/#themes">Sphinx Themes Gallery (sphinx-themes.org)</a></p>
<h3 id="解析和转换python代码"><a class="header" href="#解析和转换python代码">解析和转换Python代码</a></h3>
<pre><code class="language-python">extensions = [
  'sphinx.ext.autodoc',
  'sphinx.ext.napoleon'  # 使用Numpy/Google风格代码注释
]
</code></pre>
<blockquote>
<p>NumPy风格代码注释：可在VS Code中使用<code>autoDocstring</code>自动生成模板并修改内容。</p>
<p><a href="https://www.sphinx-doc.org/en/master/usage/extensions/napoleon.html">sphinx.ext.napoleon – Support for NumPy and Google style docstrings — Sphinx documentation (sphinx-doc.org)</a></p>
<p>注释章节标题：</p>
<ul>
<li><code>Parameters|Arguments|Args</code>/<code>Keyword Args|Keyword Arguments</code>：参数说明；</li>
<li><code>Return|Returns</code>：返回值说明；</li>
<li><code>Raise|Raises</code>：抛出异常说明；</li>
<li><code>Example|Examples</code>：示例；</li>
<li><code>References</code>/<code>See Also</code>：参考文献或跳转链接；</li>
<li><code>Tip</code>/<code>Note</code>/<code>Warns|Warn</code>/<code>Todo</code>：额外的提示信息。</li>
</ul>
</blockquote>
<p>自动导入模块内容：</p>
<pre><code class="language-rst">.. automodule:: my.module
   :members:                    自动导入所有内容并生成文档
.. autoclass:: my.module.class
   :members: open, close        导入指定内容并生成文档
</code></pre>
<blockquote>
<p><a href="https://www.sphinx-doc.org/en/master/usage/extensions/autodoc.html#module-sphinx.ext.autodoc">sphinx.ext.autodoc – Include documentation from docstrings — Sphinx documentation (sphinx-doc.org)</a></p>
</blockquote>
<p>使用<code>sphinx-apidoc</code>可自动扫描指定模块中的内容，并生成对应的<code>.rst文件</code>。</p>
<pre><code class="language-shell">sphinx-apidoc [OPTIONS] -o &lt;OUTPUT_PATH&gt; &lt;MODULE_PATH&gt; [EXCLUDE_PATTERN, ...]
#-f,--force
#-e, --separate        put documentation for each module on its own page
#-M, --module-first    put module documentation before submodule documentation
</code></pre>
<blockquote>
<p>包含<code>__init__.py</code>的目录才会被识别为子模块。</p>
</blockquote>
<h3 id="解析和转换markdown文件3"><a class="header" href="#解析和转换markdown文件3">解析和转换Markdown文件<sup class="footnote-reference"><a href="#sphinx-md">3</a></sup></a></h3>
<p>安装插件：</p>
<pre><code class="language-python">conda install myst-parser -c conda-forge
</code></pre>
<p>更新Sphinx配置文件：配置处理的文件格式扩展名，以及支持的<a href="https://myst-parser.readthedocs.io/en/latest/syntax/optional.html">Markdown扩展</a>。</p>
<pre><code class="language-python">extensions = ['myst_parser']
source_suffix = {
    '.rst': 'restructuredtext',
    '.txt': 'restructuredtext',
    '.md': 'markdown',
}
myst_enable_extensions = [...]  # optional depends: linkify-it-py
</code></pre>
<blockquote>
<p><code>myst-parser</code>不能转换代码中Markdown格式的注释文档。</p>
</blockquote>
<h2 id="d2lbook"><a class="header" href="#d2lbook">d2lbook</a></h2>
<h3 id="安装-21"><a class="header" href="#安装-21">安装</a></h3>
<pre><code class="language-shell">conda create -n d2lbook -c conda-forge python=3.8 sphinx pandoc librsvg
conda activate d2lbook
git clone https://github.com/d2l-ai/d2l-book.git
pip install ./d2l-book
</code></pre>
<p>如果需要编译为PDF需要安装一个LaTeX发行版（如TexLive或MikTeX），<code>librsvg</code>用于将SVG转换为PDF文件。</p>
<h3 id="编写编译配置文件"><a class="header" href="#编写编译配置文件">编写编译配置文件</a></h3>
<pre><code class="language-ini">[build]
index = index                        # 默认首页index.md
notebooks = *.md source/*.md         # 需要将markdown文件放在notebooks类别才会输出内容
exclusions = source/get_started.md   # 排除文件
non-notebooks = 
eval_notebook = False                # 是否执行代码块中的代码
tabs = mxnet, pytorch, tensorflow    # 多标签内容
</code></pre>
<h3 id="编写文档"><a class="header" href="#编写文档">编写文档</a></h3>
<p>和Sphinx的首页文件类似，在首页文件（<code>index.md</code>）中添加目录：</p>
<pre><code class="language-markdown">````toc
source/get_started
source/reference
````
</code></pre>
<p>编写正文：</p>
<p>使用<code>:begin_tab:</code>和<code>:end_tab:</code>来标记标签页，以生成多标签页面。</p>
<pre><code class="language-markdown">:begin_tab:`mxnet`
接下来，我们实例化`mxnet`类并访问其模型参数。
:end_tab:
</code></pre>
<p>在代码块中，使用<code>#@tab tabname</code>来标记相应标签（默认为配置文件中声明的第一个标签）。</p>
<pre><code class="language-markdown">```python
#@tab pytorch
import torch
from torch import nn
import torch.nn.functional as F
```
</code></pre>
<h3 id="编译-6"><a class="header" href="#编译-6">编译</a></h3>
<p>生成HTML文件：</p>
<pre><code class="language-shell">d2lbook build --tab all html  # 需要执行两次，否则可能出现错误（找不到index.rst）
</code></pre>
<blockquote>
<p>编译前可能需要执行<code>d2lbook clear</code>（<code>rm -rf _build</code>），否则更改内容可能不会被重新编译。</p>
</blockquote>
<h3 id="修改主题资源"><a class="header" href="#修改主题资源">修改主题资源</a></h3>
<p>在线资源处理：主题中的部分字体图片资源需要在线下载，如果网络不佳或离线使用会使页面等待加载。因此，可以将这些资源预先下载到本地，并修改资源文件使用本地资源路径（文件或本地http URL）替换相应资源URL。</p>
<ul>
<li>
<p>字体：将<code>_build/html/_static/font.css</code>（来自安装的<code>mxtheme</code>主题）中以<code>//fonts.gstatic.com</code>开头的字体URL添加协议<code>https:</code>，使之能被正常访问；其次，将其中的字体URL提取出来并批量下载到本地，然后将<code>font.css</code>中的URL替换为本地路径。</p>
</li>
<li>
<p>图片：修改<code>d2l-book</code>的<code>sphinx_template</code>模块引用的在线资源文件为本地文件加快访问速度。</p>
<pre><code>https://raw.githubusercontent.com/choldgraf/sphinx-copybutton/master/sphinx_copybutton/_static/copy-button.svg -&gt; PREFIX/_static/copy-button.svg
</code></pre>
</li>
<li>
<p>服务：注释<code>d2l-book.sphinx</code>中生成的访问<code>google-analytics</code>的JavaScript代码；</p>
</li>
</ul>
<p><a href="https://book.d2l.ai/user/index.html">2. User Guide — D2L-Book: A Toolkit for Hands-on Books 0.1.17 documentation</a></p>
<h2 id="doxygen-2"><a class="header" href="#doxygen-2">doxygen</a></h2>
<h5 id="doxyfile"><a class="header" href="#doxyfile">Doxyfile</a></h5>
<pre><code class="language-makefile">DOXYFILE_ENCODING      = UTF-8
PROJECT_NAME           = &quot;Triangle Library&quot;
PROJECT_NUMBER         = 1.1
PROJECT_BRIEF          = &quot;Triangle Library for C++ Documentation Tutorial&quot;
OUTPUT_DIRECTORY       = &quot;build&quot; 
FULL_PATH_NAMES        = NO
INPUT                  = &quot;source/path&quot;
RECURSIVE              = YES
GENERATE_XML           = NO
GENERATE_LATEX         = NO
GENERATE_RTF           = NO 
GENERATE_MAN           = NO
</code></pre>
<h2 id="mdbook"><a class="header" href="#mdbook">mdBook</a></h2>
<h3 id="安装-22"><a class="header" href="#安装-22">安装</a></h3>
<p>下载<a href="https://github.com/rust-lang/mdBook/releases">mdbook</a>。</p>
<p>创建工作目录并初始化项目（作者、项目标题，信息位于工作目录下的<code>book.toml</code>文件中）。</p>
<pre><code class="language-shell">mdbook init book_path
       --theme       # 将主题文件复制到工作目录下以便修改默认配置(./theme/)
       --title TITLE # 未指定改选项则提示用户输入标题
       --ignore      # 生成默认的.gitignore文件(其中包含book目录)
</code></pre>
<p>项目的Markdown文档内容位于<code>src/</code>目录下（Markdown文件内不能超链接该目录外的文件，可通过符号链接将外部文档置于<code>src/</code>下），<code>src/SUMMARY.md</code>是所有文档的入口。</p>
<blockquote>
<p>修改<code>./theme/css/general.css</code>以自定以标题和正文以及代码块的字体字号。</p>
</blockquote>
<h4 id="安装插件-1"><a class="header" href="#安装插件-1">安装插件</a></h4>
<p>从<a href="https://github.com/rust-lang/mdBook/wiki/Third-party-plugins">插件仓库</a>下载发行版本，并释放到<code>mdbook</code>同一目录下（将该目录加入路径变量）。</p>
<ul>
<li>
<p>✨<a href="https://github.com/zjp-CN/mdbook-theme">mdbook-theme: A preprocessor and a backend to config themes for mdbook, especially creating a pagetoc on the right and setting full color themes from the offical ace editor. (github.com)</a></p>
</li>
<li>
<p><a href="https://github.com/slowsage/mdbook-pagetoc">slowsage/mdbook-pagetoc: Adds sidebar table of contents. (github.com)</a></p>
<p>下载安装侧边栏目录插件：</p>
<pre><code class="language-ini">[preprocessor.pagetoc]
[output.html]
additional-css = [&quot;theme/pagetoc.css&quot;]
additional-js  = [&quot;theme/pagetoc.js&quot;, &quot;theme/MathJax.js&quot;]
no-section-label = true
</code></pre>
</li>
<li>
<p><a href="https://github.com/lzanini/mdbook-katex">lzanini/mdbook-katex: A preprocessor for mdBook, rendering LaTeX equations to HTML at build time. (github.com)</a></p>
</li>
</ul>
<h3 id="项目配置-2"><a class="header" href="#项目配置-2">项目配置</a></h3>
<h5 id="预处理器"><a class="header" href="#预处理器">预处理器</a></h5>
<h5 id="渲染器"><a class="header" href="#渲染器">渲染器</a></h5>
<p>mdBook内置HTML渲染器和Markdown渲染器（调试用途），第三方渲染器包括<code>pdf</code>、<code>epub</code>和<code>man</code>等。</p>
<pre><code class="language-toml">[output.html]
theme = &quot;mytheme&quot;
mathjax-support = true  # 暂不支持$$标记的数学公式
# [output.pdf]
# mdbook-pdf 利用chrome提供的PDF生成功能生成PDF文件，无法控制文档格式。
</code></pre>
<h3 id="文档结构"><a class="header" href="#文档结构">文档结构</a></h3>
<pre><code class="language-markdown"># Summary
[prefix_chapter](./prefix.md)
# Part Title
- [chapter name](./chapter_name.md)
  - [sub_chapter_name](./some_path/sub_chapter_name.md)
--- &lt;!-- separater line --&gt;
[suffix_chapter](./suffix.md)
</code></pre>
<blockquote>
<p>以<code>-</code>开头的声明为编号章节，通过缩进区分大纲级别，可在编号章节前后添加无编号的序言/附录等内容（不可出现在编号章节之间，不可缩进嵌套）。</p>
<p>如果章节声明的超链接为空，则在目录中该章节无法点击。</p>
<p>使用<code>---</code>以在目录中添加分割线。</p>
</blockquote>
<h3 id="渲染文档"><a class="header" href="#渲染文档">渲染文档</a></h3>
<h5 id="使用mdbook内置服务"><a class="header" href="#使用mdbook内置服务">使用mdBook内置服务</a></h5>
<pre><code class="language-shell">mdbook serve --open   # 在工作目录下执行
</code></pre>
<p>项目目录下的源文件修改后，mdBook将会重新编译内容并刷新浏览页面。</p>
<h5 id="编译发布"><a class="header" href="#编译发布">编译发布</a></h5>
<pre><code class="language-shell">mdbook build 
       --dest-dir [book_path] # 生成HTML文件，输出到指定目录(默认为./book/)
       --open                 # 打开编译结果
</code></pre>
<blockquote>
<p>编译过程会将源文件目录下的除<code>.md</code>外的所有文件复制到输出目录下。</p>
</blockquote>
<p>编译输出内容可通过HTTP服务进行发布。</p>
<h2 id="mkdocs"><a class="header" href="#mkdocs">MkDocs</a></h2>
<h3 id="安装mkdocs"><a class="header" href="#安装mkdocs">安装MkDocs</a></h3>
<pre><code class="language-shell">conda create -n mkdocs mkdocs
</code></pre>
<h4 id="安装插件-2"><a class="header" href="#安装插件-2">安装插件</a></h4>
<pre><code class="language-shell">pip install mkdocs-section-index mkdocs-exclud
</code></pre>
<h3 id="创建项目-2"><a class="header" href="#创建项目-2">创建项目</a></h3>
<pre><code class="language-shell">mkdocs new [dir-name] # Create a new project.
</code></pre>
<h4 id="编译配置"><a class="header" href="#编译配置">编译配置</a></h4>
<pre><code class="language-yaml">theme:
  docs_dir: docs
  site_dir: site
  include_sidebar: true
  use_directory_urls: false  #*
</code></pre>
<blockquote>
<p><code>*</code>：问题：附件相对路径多了一层当前文档名，如<code>./docs/docs.assets/xyz.png</code>，正确形式应该为<code>./docs.assets/xyz.png</code>。</p>
</blockquote>
<h3 id="构建项目"><a class="header" href="#构建项目">构建项目</a></h3>
<pre><code class="language-shell">mkdocs serve          # Start the live-reloading docs server.
mkdocs build          # Build the documentation site.
</code></pre>
<h2 id="gitbook"><a class="header" href="#gitbook">gitbook</a></h2>
<p>https://app.gitbook.com/</p>
<h3 id="插入文档作为子页面"><a class="header" href="#插入文档作为子页面">插入文档作为子页面</a></h3>
<h3 id="与git仓库github或gitlab同步"><a class="header" href="#与git仓库github或gitlab同步">与git仓库(GitHub或GitLab)同步</a></h3>
<h2 id="参考资料-9"><a class="header" href="#参考资料-9">参考资料</a></h2>
<div class="footnote-definition" id="rst"><sup class="footnote-definition-label">1</sup>
<p><a href="https://docutils.sourceforge.io/docs/user/rst/quickstart.html">A ReStructuredText Primer (sourceforge.io)</a>
<sup class="footnote-reference"><a href="#sphinx">2</a></sup>:<a href="https://www.sphinx-doc.org/en/master/">Overview — Sphinx documentation (sphinx-doc.org)</a>
<sup class="footnote-reference"><a href="#sphinx-md">3</a></sup>:<a href="https://docs.readthedocs.io/en/stable/intro/getting-started-with-sphinx.html#using-markdown-with-sphinx">Getting Started with Sphinx — using-markdown-with-sphinx</a></p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="文件处理工具"><a class="header" href="#文件处理工具">文件处理工具</a></h1>
<h2 id="切割和拼接"><a class="header" href="#切割和拼接">切割和拼接</a></h2>
<p>将一个文件分割为多块：</p>
<pre><code class="language-shell">split [OPTION]... FILE PREFIX
</code></pre>
<p><code>PREFIX</code>：输出文件名前缀，输出文件名自动添加后缀编号，形如：<code>PREFIXaa</code>、<code>PREFIXab</code>、...。
<code>FILE</code>：输入文件名，如果未提供或为<code>-</code>则从标准输入读取（管道）。</p>
<p>选项：</p>
<p><code>-a</code>：后缀长度；
<code>-d</code>：使用数字编号，<code>--numeric-suffixes[=FROM]</code>允许指定起始编号；
<code>-x</code>：使用十六进制编号，<code>--hex-suffix[=FROM]</code>；</p>
<p><code>-b,--bytes=SIZE</code>：每个输出文件的长度（字节），<code>K,M,G,T,P,E,Z,Y</code> (1024)或<code>KB,MB,...</code> (1000)；
<code>-l,--lines=NUMBER</code>：每个输出文件的行数；
<code> -n,--number=CHUNKS</code>：指定输出文件的个数，<code>l/N</code>不在行内分割；<code>K/N</code>仅输出第<code>K</code>个分块到标准输出（<code>l/K/N</code>）；==<code>r/N</code>将文本文件内容按行轮流输出到<code>N</code>个分块中==。</p>
<h5 id="合并文件"><a class="header" href="#合并文件">合并文件</a></h5>
<pre><code class="language-shell">cat [OPTION] ... FILE ...
</code></pre>
<p>将文件拼接并输出到标准输出，或使用输出重定向将内容输出到新文件。如果<code>FILE</code>未提供或为<code>-</code>则从标准输入读取（管道）。</p>
<h2 id="diff-and-patch"><a class="header" href="#diff-and-patch">diff and patch</a></h2>
<h3 id="用法-2"><a class="header" href="#用法-2">用法</a></h3>
<pre><code class="language-shell">diff [options] origin_filename changed_file
diff [options] origin_dir/ updated_dir/      # 对比文件夹下的对应文件变更
</code></pre>
<p><code>diff</code>文件模式：默认模式仅记录改动的位置信息和改动内容；</p>
<ul>
<li>
<p><code>-c</code>：copied context（补丁内容附带修改部分的前后内容，从而不仅依赖行号定位改动位置）；</p>
<p><code>-C N</code>：指定上下文行数；</p>
</li>
<li>
<p><code>-u</code>：unified context（修改内容直接对比，更加紧凑，<em>GNU diff and patch</em>）。</p>
</li>
<li>
<p><code>-y</code>：side-by-side（输出两列对比）。<code>colordiff</code>不支持此模式的高亮。</p>
</li>
</ul>
<p>空白对比处理：</p>
<ul>
<li><code>-b,--ignore-space-change</code></li>
<li><code>-w, --ignore-all-space</code> </li>
<li><code>-B, --ignore-blank-lines</code></li>
</ul>
<h3 id="升级补丁patch"><a class="header" href="#升级补丁patch">升级补丁(patch)</a></h3>
<p><code>diff</code>输出内容可保存为补丁文件，利用<code>patch</code>程序可基于旧版本和补丁文件重建新文件。</p>
<pre><code class="language-shell">patch originalfile -i patchfile.patch -o updatedfile #*
patch -p 0 -i patchfile.patch  # -p N 仅处理&lt;=第N层子文件夹
</code></pre>
<blockquote>
<p><code>*</code>：<code>yum install patch</code>；</p>
</blockquote>
<p>对于已分发文文件<code>v1.file</code>，如果要进行更新可选择生成补丁（<code>diff v1.file v2.file &gt; v12.patch</code>），从而减小传输带宽；在远程机器上将补丁应用于修改后的文件（<code>patch v1.file -i v12.patch -o v2.file</code>）。对于被修改过的远程文件<code>v1r.file</code>，则这种更新方式会失败，因为补丁信息与基础文件不能匹配，因此需要人工将<code>v1.file-&gt;v1r.file</code>中的修改内容合并到<code>v2.file</code>中。</p>
<ol>
<li><a href="https://acloudguru.com/blog/engineering/introduction-using-diff-and-patch">Introduction to Using Diff and Patch | A Cloud Guru</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2012/08/how_to_read_diff.html">读懂diff - 阮一峰的网络日志 (ruanyifeng.com)</a></li>
</ol>
<p><a href="https://www.gnu.org/software/diffutils/manual/html_mono/diff.html">Comparing and Merging Files (gnu.org)</a></p>
<h3 id="高亮比较结果"><a class="header" href="#高亮比较结果">高亮比较结果</a></h3>
<pre><code class="language-shell">diff origin changed | colordiff # =&gt; colordiff origin changed *
diff origin changed | vim -R -  # 在Vim中显示diff结果
vim -d origin changed           # =&gt; vimdiff 在Vim中显示对比结果，显著高亮行内不同部分。
git diff --no-index --word-diff=color origin changed  # **
</code></pre>
<blockquote>
<p><code>*</code>：<code>yum install colordiff</code>：高亮比较结果。</p>
<p><code>**</code>：<code>--no-index</code>比较的文件不在git仓库中时使用。</p>
</blockquote>
<h2 id="归档-1"><a class="header" href="#归档-1">归档</a></h2>
<pre><code class="language-shell">tar -[cruxt][z][v] -f path/archive.tar.gz \
   -C /file/path \ # 更改操作目录
   file1 file2 ...
</code></pre>
<h5 id="操作模式"><a class="header" href="#操作模式">操作模式</a></h5>
<p><code>-c,--create</code>：从选定的文件创建新的档案（覆盖已有同名档案）；</p>
<blockquote>
<p>当不声明压缩格式选项<code>-z</code>时（且文件扩展名为<code>.tar</code>或添加<code>--no-auto-compress</code>选项），只进行归档而不执行压缩。</p>
</blockquote>
<p><code>-r,--append</code>：将选定文件追加文件至档案末尾（不会覆盖同名文件）；</p>
<p><code>-u,--update</code>：追加文件至档案，覆盖档案中较旧的文件；</p>
<p><code>-t,--list</code>：列出档案内容；</p>
<p><code>-x,--extract</code>：提取档案中的文件（到当前目录），使用<code>-C</code>指定提取文件的存储目录；</p>
<p><code>-A</code> ：追加<code>tar</code>文件合并至档案末尾（<code>--catenate, --concatenate</code>）；</p>
<p><code>--delete</code>：从档案中删除文件；</p>
<pre><code class="language-sh">tar -f archive.tar --delete test2.txt
</code></pre>
<h5 id="文件"><a class="header" href="#文件">文件</a></h5>
<p><code>-f,--file=ARCHIVE</code>：选择操作的目标档案文件；<code>-T,--files-from=FILE</code>：从文件读取进行操作的文件列表。</p>
<p><code>-C,--directory=DIR</code>：更改操作目录。对于归档操作，该选项影响后续源文件的根目录；对于提取操作，该选项影响提取内容的存储目录。</p>
<p><code>-h,--dereference</code>：压缩时读取<strong>符号链接</strong>指向的目标文件内容==替换符号链接==；如果压缩时未指定<code>-h</code>，则保留符号链接信息，解压缩时还原为符号链接。（<em>相应地，<code>--hard-dereference</code>对于<code>hardlink</code>文件似乎没用</em>）。</p>
<p><code>--strip-components=1</code>：移除档案中的目录层级（==为了修改根目录名而自行创建根目录==）；</p>
<p><code>--add-file=FILENAME</code>：添加包含特殊字符的文件。</p>
<p><code>--exclude=PATTERN</code>：排除文件的模式；<code>-X,--exclude-from=FILE</code>：从文件中读取排除文件的多个模式；</p>
<pre><code class="language-shell">--exclude=&quot;*.pyc&quot; --exclude=&quot;*tmp/*&quot; --exclude=&quot;*model/*&quot; --exclude=&quot;*output/*&quot;
</code></pre>
<p><code>-N, --newer=DATE-OR-FILE, --after-date=DATE-OR-FILE</code>：仅存储比所给日期或文件更新的文件（包括所给定日期的文件）。</p>
<p><code>-p,--preserve-permissions</code>：保留文件访问权限。</p>
<h5 id="压缩"><a class="header" href="#压缩">压缩</a></h5>
<p><code>-z</code>：等效于对归档后的文件/文件夹，使用<code>gzip</code>压缩或解压文件，输出文件扩展名为<code>.tar.gz</code>。</p>
<pre><code class="language-sh">tar -cvf archive.tar FILES ...
gzip --keep archive.tar # &gt;&gt; archive.tar.gz
</code></pre>
<h5 id="信息"><a class="header" href="#信息">信息</a></h5>
<p><code>-v</code>：列出所处理的文件。</p>
<h5 id="文件覆盖"><a class="header" href="#文件覆盖">文件覆盖</a></h5>
<p><code>-k, --keep-old-files</code>：不覆盖文件，提示错误（<strong>默认为覆盖</strong>），<code>--skip-old-files</code>直接跳过，不产生错误。
<code>--keep-newer-files</code> ：不覆盖本地更新的文件（本地存在相同时间或更新时间的同名文件时输出提示）。
<code>--overwrite</code>：提取时覆盖已有文件。
<code>--remove-files</code>：归档后删除原文件。</p>
<p>https://www.rootusers.com/23-tar-command-examples-for-linux/</p>
<h2 id="压缩解压"><a class="header" href="#压缩解压">压缩/解压</a></h2>
<h3 id="gzip-1"><a class="header" href="#gzip-1">gzip</a></h3>
<pre><code class="language-sh">gzip filename       # 压缩*
     -c,--stdout    # 输出到标准输出, 保留源文件
     -k,--keep      # 保留输入文件
     -f,--force     # 强制覆盖输出文件  
     -r,--recursive # 递归遍历文件，并分别执行压缩**
     -1,--fast
     -9,--best
gzip -l,--list filename # 列出压缩内容的信息
</code></pre>
<blockquote>
<p>如果未指定文件名，或文件名为<code>-</code>，从标准输入读取数据。</p>
<p><code>*</code>：<code>gzip</code>默认进行压缩操作，指定<code>-d,--decompress</code>执行解压任务（等效于调用<code>gunzip</code>）。</p>
<p><code>**</code>：<code>gzip</code> 只支持压缩文件，不支持文件夹；使用<code>-r</code>选项会对文件下的文件分别进行压缩；使用<code>tar</code>对文件夹归档后再进行压缩。</p>
</blockquote>
<h3 id="zip-1"><a class="header" href="#zip-1">zip</a></h3>
<pre><code class="language-sh"># sudo apt install zip unzip
zip [options] archive[.zip] INPATH1 INPATH2 ... 
  # -可替代使用标准输入/输出分别代替输入(文件名)/输出(压缩内容), 
  # 使用-代替输入会将输出定位到标准输出; -@则仍将压缩内容输出至文件; 
  -r,--recurse-paths  # 默认至包括给定的目录/文件，不包含子目录内容
  -x,--exclude file_pattern # 排除文件  -x@exclude.lst
  -i,--incldue        # 指定输入
  -y,--symlinks       # 存储符号链接而非其指向的文件
  --out,--output-file # 不更新已有zip文件而是输出到新文件
  -FS,--filesync      # 源和zip文件同步模式
  -P,--password password
  -du,--display-usize # Display the uncompressed size of each entry.
  -z，--archive-comment # 从标准输入/文件(&lt;conmment_file)读取注释
  -Z,--compression-method=store|deflate|bzip2 # 压缩方法
  -N  # N=0-9 0表示不压缩(-Z store)
zip add|update|freshen|delete|copy ...
  # &quot;update&quot; (-u,--update)
  # &quot;freshen&quot; (-f,--freshen) only update existed files, not add new files. 
  # &quot;delete&quot; (-d,--delete)
  # &quot;copy&quot; (-U,--copy-entries) 从zip文件中选取文件并输出到新的zip文件(--out)
unzip -O GB2312 file.zip -d dir  
      -l FILE # 仅列出包含的文件的信息
      -z FILE # 仅列出压缩包的注释信息
      -P password
</code></pre>
<blockquote>
<p>如果出现文件名乱码：<code>-O</code>指定Windows压缩文件使用的编码方案；<code>-I</code>指定UNIX或其他系统下的编码方案。</p>
<p><code>zip</code>在操作时会先创建一个临时文件，仅当</p>
</blockquote>
<p><code>zip</code>可对压缩文件进行分片，从而方便大文件的传输。<code>unzip</code>无法直接对分片的压缩文件进行解压，可首先将其拼接（<code>cat</code>）为一个文件再执行解压。</p>
<pre><code class="language-shell">  A split archive is a standard zip archive split over multiple files.  (Note that split archives are not just archives split in to pieces, as the offsets of entries are now based on the start of each split. Concatenating the pieces together will invalidate these offsets, but unzip can usually deal with it. zip will usually refuse to process such a spliced archive unless the -FF fix option is used to fix the offsets.
   When changing an existing zip archive, zip will write a temporary file with the new contents, and only replace the old one when the process of creating the  new  version  has  been completed without error.
</code></pre>
<pre><code class="language-shell">zip -s 700m ARCHIVE.zip --out ARCHIVE-SPLIT.zip   # 将字zip文件分片(-s,--split-size)
# ARCHIVE-SPLIT.z01, ARCHIVE-SPLIT.z02, ..., ARCHIVE-SPLIT.zip.
# k (kB), m (MB), g (GB), or t (TB) (the default is m)
zip -s 0 input-split.zip --out input-unsplit.zip  # 将分片文件合并
</code></pre>
<blockquote>
<p>还支持将一种分片容量的输入改变为另一种分片容量进行输出（中间过程可能需要恢复为完整文件）。</p>
</blockquote>
<h2 id="主机之间复制文件"><a class="header" href="#主机之间复制文件">主机之间复制文件</a></h2>
<h3 id="scp"><a class="header" href="#scp">scp</a></h3>
<p><code>scp</code>命令(secure copy)用于Linux之间复制文件和目录，是linux系统下基于<code>ssh</code>登录进行安全的远程文件拷贝命令。<code>scp</code>是加密的，<code>scp</code>是 <a href="https://www.runoob.com/linux/linux-comm-rcp.html"><code>rcp</code></a> (不加密的)加强版。</p>
<pre><code class="language-sh">scp [options] file user@dest_host:file # local to remote
scp [options] user@src_host:file file  # remote to local
</code></pre>
<blockquote>
<p><code>-P</code>：指定远程服务器端口号。</p>
<p><strong>注意</strong>：使用<code>scp</code>命令要确保使用的用户具有可读取远程服务器相应文件的权限，否则<code>scp</code>命令是无法起作用的。</p>
</blockquote>
<p><code>scp</code>可以在源与目的主机以外的第三台主机执行，只需保证源与目的主机间有相应地读写权限。</p>
<h3 id="rsync"><a class="header" href="#rsync">rsync</a></h3>
<p><code>rsync</code>常用于文件备份和镜像，支持本地和远程目标之间的文件传输。对于目标路径已有的文件，仅传输源和目标文件的差异部分；并且支持只更新较新的文件。<code>rsync</code>默认检测文件的修改时间和大小，如果未发生变化，则仅修改目标文件的相关属性信息。<code>rsync</code>会对传输文件按文件名排序。</p>
<p>==目标目录如果不存在==，<code>rsync</code>会自动创建。</p>
<blockquote>
<p><code>rsync</code>支持两种模式：远程shell（如<code>ssh</code>,目标形如<code>user@host:path</code>）；<code>rsync daemon</code>（目标形如<code>user@host::path</code>或<code>rsync://</code>）。<code>rsync</code>==必须安装在收发两台机器==。</p>
<p>启动<code>rsync daemon</code>：<code>man rsyncd.conf</code>。</p>
</blockquote>
<pre><code class="language-shell">rsync -rua srcfiles ... user@host:path  # files支持通配符
rsync -ua --delete source/ target       # source-&gt;target同步
</code></pre>
<h5 id="文件路径格式"><a class="header" href="#文件路径格式">文件路径格式</a></h5>
<ul>
<li>==如果源路径为目录且以<code>/</code>结尾则只拷贝目录下的内容到目标目录；反之，将该目录拷贝到目目录下（目标目录后是否有<code>/</code>无影响）==；</li>
<li>如果源路径为文件，目标路径为目录，则将该文件保存到目标目录下；如果目标路径为文件，则保存为目标文件。</li>
</ul>
<h4 id="文件传输控制"><a class="header" href="#文件传输控制">文件传输控制</a></h4>
<blockquote>
<p><code>-a,--archive</code>：归档模式，保证文件属性保留，等效于<code> -rlptgoD</code>。</p>
<ul>
<li><code>-r</code>：递归复制子目录内容，若未指定该选项，将跳过提供的文件夹；<code>-d,--dirs</code>只拷贝==当前目录==，不包含目录内容（除非目录名为<code>.</code>或以<code>/</code>结尾）；如果同时出现，<code>-r</code>优先级高于<code>-d</code>。</li>
<li><code>-l,--links</code>符号链接不转换为实际文件；<code>-L,--copy-links</code>将符号链接转换为实际文件。</li>
<li><code>-t,--times</code>：保留文件的时间信息。</li>
<li><code>-g,--group;-o,--owner</code>：保留文件的用户信息。</li>
<li><code>-D,--devices --specials</code>：传输字符或块设备文件和特殊文件（如明明套接字和FIFIO）。</li>
</ul>
<p><code>-v,--verbose</code>：打印传输过程信息，可叠加最多两个<code>-v</code>以增加输出信息量。</p>
<p><code>--progress</code>：显示传输进度信息。</p>
<p><code>-R,--relative</code>：保留源文件参数给出的路径并拼接到目标路径下。</p>
<p><code>-c,--checksum</code>：使用文件大小和校验和（MD5）而非修改时间检查文件是否更改。由于收发两端都需要读取文件计算校验和，因此处理速度较慢。</p>
<p><code>-z,--compress</code>：压缩传输内容；<code> --compress-level=NUM</code>。</p>
<p><code>-b,--backup</code>：目标位置已存在的文件和目录将被重命名； <code>--backup-dir=DIR</code>, <code>--suffix=SUFFIX</code></p>
<p><code>-n,--dry-run</code>：与<code>-v</code>或<code>-i</code>结合使用。</p>
<p>如果未指定目标路径，则列出源文件（类似于<code>ls -l</code>，源也可以是远程）。如果源和目的都为本地路径，则在本地路径间进行复制。</p>
</blockquote>
<h5 id="目标文件权限控制"><a class="header" href="#目标文件权限控制">目标文件权限控制</a></h5>
<ul>
<li><code>-p,--perms</code>：目标文件的权限信息与源文件保持一致。如果未指定该选项：已有文件再更新时权限信息不变；新文件的普通权限标志位与源文件一致，其他的继承自接收目录的默认权限。</li>
<li><code>-E,--executability</code>：在未启用<code>--perms</code>时，为普通文件添加可执行权限（启用时忽略该选项）。</li>
<li><code>--chmod=u=rw,go=r,D+x</code>：该选项修改<strong>来自源文件的权限信息</strong>（而非已保存在本地的文件权限），因此未启用<code>--perms</code>，则对已有文件无影响。除<code>chmod</code>的权限声明方式外（也支持数字模式<code>--chomd=F644,D755</code>），可添加额外的前缀：<code>D</code>表示仅应用于目录，<code>F</code>表示仅应用于普通文件。</li>
</ul>
<h4 id="同步条件选项"><a class="header" href="#同步条件选项">同步条件选项</a></h4>
<p><code>-u,--update</code>：跳过目标路径下修改时间比源文件新的文件。
<code>--delete</code>：删除目标路径下，不存在于发送方的内容，与发送方保持一致（镜像）。
<code>--existing, --ignore-non-existing</code>：只同步目标已存在的内容；
<code>--ignore-existing</code>：只同步目标不存在的内容。
<code>--exclude=PATTERN</code>：排除无需同步的文件（收发双方同时忽略），可多次使用该选项；<code>--exclude-from=FILE</code>从文件指定多个模式；文件中的空行、以<code>’;’</code>或<code>’#’</code>开头的行被忽略。</p>
<pre><code class="language-shell">foo   # 包含foo的路径
/foo  # 匹配传输目录下以foo开头的文件路径
foo/  # 仅匹配目录
*     # 匹配任何内容直到&quot;/&quot;
**    # 匹配任何内容
?     # 匹配除了&quot;/&quot;以外的字符
[]    # 定义匹配字符集合
</code></pre>
<p><code>--include=PATTERN</code>和<code>--include-from=FILE</code>：指定要包括的文件，优先级高于<code>--exclude</code>。
<code>--files-from=FILE</code>：确切指定要传输的文件。</p>
<h4 id="增量备份"><a class="header" href="#增量备份">增量备份</a></h4>
<p>第一次同步是全量备份，所有文件在基准目录里面同步一份。其后每次使用最近的备份目录作为基准目录，只同步源目录与基准目录之间有变动的部分并将其保存到新的目标目录；没有变动的文件都是指向基准目录文件的==硬链接==（不能生成软链接，否则后期对比时与源文件不同）。</p>
<pre><code class="language-shell">rsync -a --delete --link-dest=COMPARE_DIR /source/path /target/path
</code></pre>
<blockquote>
<p><code>--copy-dest=DIR</code>：直接从基准目录<code>DIR</code>复制未发生变化的文件（而非创建链接），减少网络传输量。通过复制而非创建硬链接保证对基准目录的修改不会影响目标目录内容。
<code>--compare-dest=DIR</code>：仅复制与基准目录<code>DIR</code>相比发生变化的文件，并删除目标目录下已存在于<code>DIR</code>中未发生变化的文件。==利用该选项可以找出两个版本之间的差异文件（相当于文件级别的<code>diff</code>）==。</p>
<pre><code class="language-shell">rsync -a --delete --compare-dest=LastVersion LastestVersion AddedFiles
rsync -a --delete --compare-dest=LastestVersion LastVersion RemovedFiles
</code></pre>
</blockquote>
<p><a href="http://www.ruanyifeng.com/blog/2020/08/rsync.html">rsync 用法教程 - 阮一峰的网络日志 (ruanyifeng.com)</a></p>
<h4 id="cwrsync"><a class="header" href="#cwrsync">cwrsync</a></h4>
<p>cwrsync是基于cgywin开发的rsync软件。<code>cwrsync 5.5</code> 包含<code>rsync 3.1.2</code>（与CentOS7.x rsync版本兼容），<code>cwrsync 6.2.4</code>包含<code>rsync 3.2.3</code>。</p>
<h5 id="配置cwrsync执行脚本"><a class="header" href="#配置cwrsync执行脚本">配置cwrsync执行脚本</a></h5>
<pre><code class="language-powershell">SET CWRSYNCHOME=C:\apps\cwRsync_5.5.0_x86_Free
SET PATH=%CWRSYNCHOME%\bin;%PATH%
</code></pre>
<blockquote>
<p>如果系统中未安装其他SSH客户端，可将<code>%CWRSYNCHOME%\bin</code>配置到用户路径中。</p>
</blockquote>
<h5 id="配置免密码远程访问"><a class="header" href="#配置免密码远程访问">配置免密码远程访问</a></h5>
<p>如果系统已经使用Open-SSH客户端，并生成密钥且已配置远程SSH免密码访问。则将<code>~/.ssh/</code>目录下的<code>id_rsa</code>复制到<code>%CWRSYNCHOME%/home/%USERNAME%/.ssh</code>目录下，并将其访问权限设置为仅限当前用户。</p>
<p>如果系统未使用Open-SSH客户端，则使用<code>cwrsync</code>自带SSH客户端程序<code>ssh-keygen</code>生成密钥并分发给远程机器。</p>
<h5 id="文件访问权限配置"><a class="header" href="#文件访问权限配置">文件访问权限配置</a></h5>
<p>由于Windows与Linux的文件访问权限设置方式不一致，容易导致向Linux系统同步时目标系统文件权限不正确。因此执行<code>rsync</code>命令时配置以下选项（关闭保持权限的选项，并显式设置目标系统的访问权限）：</p>
<pre><code class="language-shell">rsync -urltDv --delete --chown USER:GROUP --chmod a+rX,u+w,go-w SOURCE TARGET
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="协作办公软件"><a class="header" href="#协作办公软件">协作办公软件</a></h1>
<h2 id="rocketchat"><a class="header" href="#rocketchat">Rocket.Chat</a></h2>
<h3 id="安装-23"><a class="header" href="#安装-23">安装</a></h3>
<p>可手动、使用容器或<a href="https://docs.rocket.chat/installing-and-updating/snaps">使用snap安装</a>。推荐使用snap安装，可避免多数配置。</p>
<pre><code class="language-shell">sudo snap install rocketchat-server  # 安装后自动启动运行
</code></pre>
<p>可使用浏览器或下载客户端访问<code>http://&lt;host_addr&gt;:3000</code>并进行初始设置（默认仅支持<code>localhost</code>或IP地址访问，主机名或域名访问需要<a href="%E5%BA%94%E7%94%A8%E8%BD%AF%E4%BB%B6/%E5%8D%8F%E4%BD%9C%E5%8A%9E%E5%85%AC%E8%BD%AF%E4%BB%B6.html#%E9%85%8D%E7%BD%AE%E8%AE%BF%E9%97%AE%E4%BB%A3%E7%90%86">配置Caddy或其他代理服务</a>）。使用<a href="%E5%BA%94%E7%94%A8%E8%BD%AF%E4%BB%B6/../Linux/Linux%E9%85%8D%E7%BD%AE%E5%92%8C%E7%AE%A1%E7%90%86.html#%E4%BD%BF%E7%94%A8snap%E6%9F%A5%E7%9C%8B%E8%BD%AF%E4%BB%B6%E4%BF%A1%E6%81%AF">snap可查看服务状态</a>。</p>
<h5 id="离线安装snap版本"><a class="header" href="#离线安装snap版本">离线安装snap版本</a></h5>
<p>在未安装过<code>snap</code>软件的机器上需要<a href="%E5%BA%94%E7%94%A8%E8%BD%AF%E4%BB%B6/../Linux/Linux%E9%85%8D%E7%BD%AE%E5%92%8C%E7%AE%A1%E7%90%86.html#%E5%AE%89%E8%A3%85%E5%92%8C%E5%8D%87%E7%BA%A7snap%E8%BD%AF%E4%BB%B6">下载和安装</a><code>core18</code>和<code>snapd</code>依赖。</p>
<h3 id="配置-6"><a class="header" href="#配置-6">配置</a></h3>
<p>获取<code>rocketchat-server</code>当前的配置：</p>
<pre><code class="language-shell">snap get rocketchat-server
# Key                Value
# backup-on-refresh  disable
# ignore-errors      false
# mongo-oplog-url    mongodb://localhost:27017/local
# mongo-url          mongodb://localhost:27017/parties
# port               3000
# siteurl            http://localhost:3000
</code></pre>
<blockquote>
<p>如果<code>siteurl</code>与实际访问URL不匹配，客户端会提示URL跳转。</p>
</blockquote>
<h5 id="启动服务-1"><a class="header" href="#启动服务-1">启动服务</a></h5>
<pre><code class="language-shell">snap start rocketchat-server  # 将启动server以及数据库(和可选的caddy服务)
snap start rocketchat-server.rocketchat-server # 单独启动server服务
</code></pre>
<blockquote>
<p>问题：</p>
<ol>
<li>服务无限重启，日志（<code>snap logs -f rocketchat-server.rocketchat-server</code>查看服务日志）出现<code>Segmentation fault</code>未知错误：尝试重启服务器然后启动<code>rocketchat-server</code>服务。</li>
<li>重启<code>rocketchat-server</code>服务后，无法正常访问：需要重启机器（可能是因为之前的服务占用某些资源未释放）。</li>
</ol>
</blockquote>
<h5 id="设置端口"><a class="header" href="#设置端口">设置端口</a></h5>
<pre><code class="language-shell">sudo snap set rocketchat-server port=8080  # 默认端口3000
sudo snap restart rocketchat-server.rocketchat-server # 重启服务生效
</code></pre>
<blockquote>
<p>将配置项置空将恢复默认配置。</p>
<p>注意：如果设置的服务端口或以下代理端口无法连接，检查是否开启防火墙及相关策略。如果客户端配置了代理将无法正常访问，需要将域名或地址排除到代理范围外。</p>
</blockquote>
<h5 id="设置数据库服务配置"><a class="header" href="#设置数据库服务配置">设置数据库服务配置</a></h5>
<p>Mongdb数据库服务的配置文件位于<code>/var/snap/rocketchat-server/current/mongod.conf</code>。</p>
<blockquote>
<p>问题：</p>
<ol>
<li>
<p><code>Failed to set up listener: SocketException: No such file or directory</code>：无法（在默认位置<code>/tmp</code>）创建UNIX域套接字，修改配置文件，显式设置UNIX域套接字所在目录：</p>
<pre><code class="language-yaml">net:
  unixDomainSocket:
    enabled: true
    pathPrefix: /var/snap/rocketchat-server/common  # 使用数据目录
</code></pre>
</li>
</ol>
</blockquote>
<h5 id="配置访问代理"><a class="header" href="#配置访问代理">配置访问代理</a></h5>
<p>RocketChat服务本身可作为独立的HTTP服务。如果需要配置外部使用HTTPS请求，可使用内置<code>caddy</code>作为反向代理（如果要使用其他代理（例如<a href="%E5%BA%94%E7%94%A8%E8%BD%AF%E4%BB%B6/%E5%8D%8F%E4%BD%9C%E5%8A%9E%E5%85%AC%E8%BD%AF%E4%BB%B6.html#Nginx">NGINX</a>），则无需以下配置）。</p>
<pre><code class="language-shell">sudo snap set rocketchat-server https=enable
sudo snap set rocketchat-server caddy=enable
sudo snap set rocketchat-server caddy-url=https://&lt;domain-name&gt;[:&lt;port&gt;]
sudo snap run rocketchat-server.initcaddy  # 生成Caddyfile*
</code></pre>
<blockquote>
<p><code>*</code>：如果提示找不到<code>initcaddy</code>命令，可直接编辑配置目录下的<code>Caddyfile</code>文件。</p>
</blockquote>
<pre><code class="language-shell">https://example-domain.com { # *
    tls self_signed          # **
    proxy / localhost:3000 {
        websocket
        transparent
    }
}
</code></pre>
<blockquote>
<p><code>*</code>：同一服务器上代理与rocketchat服务不要使用同一端口。</p>
<p><code>**</code>：测试或内部使用可使用Caddy自签名证书，仅需在Caddyfile中声明<code>tls self_signed|internal</code>。如果具有公开可访问的域名，Caddy可自动使用<a href="https://letsencrypt.org/">Let's Encrypt</a>生成SSL证书。</p>
</blockquote>
<p>配置完成后，启动<code>caddy</code>服务并重启<code>server</code>服务。</p>
<pre><code class="language-shell">sudo snap start rocketchat-server.rocketchat-caddy
</code></pre>
<h3 id="升级迁移"><a class="header" href="#升级迁移">升级迁移</a></h3>
<p>进行升级迁移前首先对数据进行备份，以防过程中出现错误。snap支持对应用数据生成快照，但快照通常仅能用于同一版本的数据恢复（通常用于使用过程中的备份）。升级迁移情况下，需要使用RocketChat内部的数据备份恢复机制。</p>
<h4 id="数据备份和恢复"><a class="header" href="#数据备份和恢复">数据备份和恢复</a></h4>
<p>备份或恢复操作时应先停止server服务，保留数据库服务。</p>
<pre><code class="language-shell">sudo rocketchat-server.backupdb  # 然后，将备份文件保存到其他地方
sudo cp /var/snap/rocketchat-server/common/rocketchat_backup.tar.gz ~/backup
</code></pre>
<p>恢复（必须将备份文件存放到<code>/var/snap/rocketchat-server/common/</code>）</p>
<pre><code class="language-shell">sudo rocketchat-server.restoredb rocketchat_backup.tgz
</code></pre>
<h2 id="文件服务-1"><a class="header" href="#文件服务-1">文件服务</a></h2>
<h3 id="filebrowser"><a class="header" href="#filebrowser">filebrowser</a></h3>
<h4 id="安装-24"><a class="header" href="#安装-24">安装</a></h4>
<p><code>filebrowser</code>仅包含单独的可执行文件，将档案文件释放到创建的指定目录即可。</p>
<pre><code class="language-shell">tar -xzf linux-amd64-filebrowser.tar.gz -C /opt/filebrowser
/opt/filebrowser/filebrowser -r /content/root/  # 指定文件服务的根目录
</code></pre>
<blockquote>
<p>默认用户名和密码为<code>admin:admin</code>，可在启动服务后通过Web界面或命令行修改。</p>
<p><code>filebrowser</code>的运行数据保存在工作目录下的数据库文件<code>database.db</code>（Bolt DB）中，不依赖于外部数据库服务。</p>
</blockquote>
<h4 id="配置-7"><a class="header" href="#配置-7">配置</a></h4>
<p>配置项可通过配置文件、环境变量、命令行选项提供，配置项的优先级高于数据库中存储的配置项。优先级从高到低：</p>
<ul>
<li>选项：
<ul>
<li><code>-a,--address</code>：监听地址；</li>
<li><code>-p,--port</code>：监听端口；</li>
<li><code>-b,--baseurl</code>：Web服务URL的根路径；</li>
<li><code>-c,--config</code>：配置文件路径；</li>
<li><code>-d,--databse</code>：数据库文件路径；</li>
</ul>
</li>
<li>环境变量命名规则：<code>FB_OPTION_NAME</code>。</li>
<li>配置文件<code>.filebrowser.{json|toml|yaml|yml}</code>，搜索路径包括：<code>./</code>、<code>$HOME/</code>、<code>/etc/filebrowser/</code>。</li>
<li>数据库配置：通过Web界面或命令行<code>filebrowser config</code>等修改的信息将更新到数据库中。</li>
<li>默认值。</li>
</ul>
<h5 id="服务配置"><a class="header" href="#服务配置">服务配置</a></h5>
<pre><code class="language-ini">[Unit]
Description=filebrowser - Web File Explorer
Documentation=https://filebrowser.org/
Wants=network-online.target
After=network-online.target
[Service]
Type=simple
WorkingDirectory=/opt/filebrowser/
ExecStart=/opt/filebrowser/filebrowser -c config.json -r /content/root/
ExecStop=/bin/kill -s TERM $MAINPID
KillSignal=SIGTERM
StandardOutput=syslog
StandardError=syslog
SyslogIdentifier=filebrowser
[Install]
WantedBy=multi-user.target
</code></pre>
<h3 id="syncthing"><a class="header" href="#syncthing">Syncthing</a></h3>
<h4 id="配置-8"><a class="header" href="#配置-8">配置</a></h4>
<h5 id="配置文件-2"><a class="header" href="#配置文件-2">配置文件</a></h5>
<p>配置文件路径：</p>
<pre><code class="language-shell">$HOME/.config/syncthing   # Linux
%LOCALAPPDATA%\Syncthing  # Windows
</code></pre>
<blockquote>
<p><code>--config CONFIG_PATH</code>覆盖默认路径。</p>
</blockquote>
<p>配置文件路径下可能包含的内容：</p>
<pre><code class="language-shell">config.xml  
cert.pem       # ECDSA public/private key
key.pem
https-cert.pem # for HTTPS GUI
https-key.pem
csrftokens.txt # A list of recently issued CSRF tokens
</code></pre>
<p>数据库路径（优先级从高到低）：</p>
<pre><code class="language-shell">/path/to/exist_db         # 指定的路径???
$XDG_DATA_HOME/syncthing
~/.local/share/syncthing  # Windows:$HOME\AppData\Local\Syncthing
$HOME/.config/syncthing
</code></pre>
<blockquote>
<p><code>--data DB_PATH</code>覆盖默认配置。</p>
</blockquote>
<h5 id="配置文件格式"><a class="header" href="#配置文件格式">配置文件格式</a></h5>
<pre><code class="language-xml">&lt;configuration version=&quot;35&quot;&gt;
    &lt;folder&gt;&lt;/folder&gt;
    &lt;device&gt;&lt;/device&gt;
    &lt;gui&gt;&lt;/gui&gt;
    &lt;ldap&gt;&lt;/ldap&gt;
    &lt;options&gt;&lt;/options&gt;
    &lt;remoteIgnoredDevice&gt;&lt;/remoteIgnoredDevice&gt;
    &lt;defaults&gt;&lt;/defaults&gt;
&lt;/configuration&gt;
</code></pre>
<h5 id="通信方式与监听地址配置"><a class="header" href="#通信方式与监听地址配置">通信方式与监听地址配置</a></h5>
<ul>
<li>
<p>TCP：<code>tcp[4]://0.0.0.0:22000,tcp[4|6]://:22000</code>，<code>tcp6://[::]:22000</code>；<code>tcp</code>协议监听IPv4/v6地址。</p>
</li>
<li>
<p>QUIC：<code>quic://[0.0.0.0]:22000</code>，类似于TCP，可指定<code>quic4</code>和<code>quic6</code> 。</p>
<blockquote>
<p>如果上述端口被占用，则<code>syncthing</code>会自动切换为选择随机端口（如<code>57350</code>）。</p>
</blockquote>
</li>
<li>
<p><a href="%E5%BA%94%E7%94%A8%E8%BD%AF%E4%BB%B6/%E5%8D%8F%E4%BD%9C%E5%8A%9E%E5%85%AC%E8%BD%AF%E4%BB%B6.html#Syncthing-Discovery-Server">发现服务</a>：<code>https://discover_server:8443?</code>；</p>
</li>
<li>
<p>中继</p>
<ul>
<li>动态中继：<code>dynamic+https://relays.syncthing.net/endpoint</code>；</li>
<li>动态中继池：<code>dynamic+https://192.0.2.42/relays</code>；</li>
<li>静态中继：<code>relay://192.0.2.42:22067?id=abcd123...</code>；</li>
</ul>
</li>
<li>
<p>默认(<code>default</code>)：<code>tcp://0.0.0.0:22000</code>, <code>quic://0.0.0.0:22000</code> 和<code>dynamic+https://relays.syncthing.net/endpoint</code>.</p>
</li>
</ul>
<p><a href="https://docs.syncthing.net/v1.20.2/users/config#config-file-format">Syncthing Configuration — Syncthing v1.20.2 documentation</a></p>
<h4 id="命令行"><a class="header" href="#命令行">命令行</a></h4>
<p>服务启动选项：</p>
<pre><code class="language-shell">--home=&lt;dir&gt;                # 配置文件和数据库路径
                            # --config=&lt;dir&gt;, --data=&lt;dir&gt;
--gui-address=0.0.0.0:8384  # or '/var/run/st.sock'
--logfile=&lt;filename&gt;        # '-' for stdout
--log-max-old-files=&lt;num&gt;
--log-max-size=&lt;num&gt;
--no-browser                # 不启动浏览器(适用于服务器)
--no-console                # 隐藏终端窗口(Windows)
</code></pre>
<pre><code class="language-shell">syncthing --device-id      # Print device ID
syncthing --paths          # 打印配置相关路径
          --version
syncthing --generate=&lt;dir&gt; # 生成配置文件和密钥文件
syncthing generate \       # 指定新的用户名和密码
          --gui-user=&lt;username&gt;       
          --gui-password=&lt;password&gt;   # or '-' 从命令行读取,覆盖配置文件(Hash)
</code></pre>
<h5 id="命令行扩展工具"><a class="header" href="#命令行扩展工具">命令行扩展工具</a></h5>
<p><a href="https://github.com/tenox7/stc">tenox7/stc: Syncthing CLI Tool (github.com)</a></p>
<h5 id="自启动配置"><a class="header" href="#自启动配置">自启动配置</a></h5>
<p><a href="https://docs.syncthing.net/users/autostart.html">Starting Syncthing Automatically — Syncthing documentation</a></p>
<h4 id="常见问题-7"><a class="header" href="#常见问题-7">常见问题</a></h4>
<h5 id="inotify-limit"><a class="header" href="#inotify-limit">inotify limit</a></h5>
<pre><code class="language-shell">echo &quot;fs.inotify.max_user_watches=204800&quot; | sudo tee -a /etc/sysctl.conf
</code></pre>
<h5 id="linux只读目录的同步"><a class="header" href="#linux只读目录的同步">Linux只读目录的同步</a></h5>
<p>syncthing不推荐使用<code>root</code>账户运行，但syncthing会在目录下创建<code>.stfolder</code>目录以存放同步信息，只读目录下无法自动创建。可用<code>root</code>账户手动创建该目录并将其所有者修改为<code>syncthing</code>服务的执行用户。</p>
<h4 id="web用户界面简介"><a class="header" href="#web用户界面简介">Web用户界面简介</a></h4>
<p><img src="%E5%BA%94%E7%94%A8%E8%BD%AF%E4%BB%B6/%E5%8D%8F%E4%BD%9C%E5%8A%9E%E5%85%AC%E8%BD%AF%E4%BB%B6.assets/gui1-16587263079781.png" alt="" /></p>
<h5 id="文件夹视图"><a class="header" href="#文件夹视图">文件夹视图</a></h5>
<p>屏幕左侧显示所有已配置文件夹的 ID 和当前状态。单击文件夹名称可使该部分展开以显示更详细的文件夹信息，以及用于暂停文件夹、强制重新扫描或编辑配置的按钮。</p>
<p>文件夹可以处于以下任一状态：</p>
<ul>
<li>未知：在加载 GUI 时，</li>
<li>未共享：当您尚未共享此文件夹时，</li>
<li>暂停：当文件夹的活动被搁置时，</li>
<li>停止：当文件夹遇到错误时，</li>
<li>最新的：当文件夹与其他设备同步时，</li>
<li>等待扫描：在扫描文件夹之前等待其他文件夹空闲时，</li>
<li>扫描：当Syncthing在文件夹中查找本地更改时，</li>
<li>等待同步：在同步文件夹之前等待其他文件夹空闲时，</li>
<li>准备同步：当 Syncthing 收集要同步的文件更改时，</li>
<li>同步：当此设备从网络下载更改时，</li>
<li>等待清洁：在清理版本之前等待文件夹空闲时，</li>
<li>清洁版本：同时从<code>.stversions</code>文件夹中删除过时的文件。</li>
</ul>
<p>在文件夹详细信息中，您可以看到当前的“全局状态”和“本地状态”摘要，以及如果文件夹状态不是最新的，则“不同步”的数据量。</p>
<ul>
<li>全局状态：指示完全最新的文件夹包含的数据量，这基本上是所有连接设备中所有文件的最新版本的总和。这是计算机上与远程设备完全同步时文件夹的大小。</li>
<li>本地状态：显示文件夹现在实际包含的数据量。如果文件夹当前正在与其他设备同步，则此值可能大于或小于全局状态。</li>
<li>不同步：显示需要从其他设备同步的数据量。请注意，这是所有不同步<em>文件</em>的总和 - 如果您已经拥有此类文件的一部分或该文件的旧版本，则需要通过网络传输的数据少于此值。</li>
<li>错误：介绍了文件夹处于“已停止”状态时出现的问题。一种可能的消息是“缺少文件夹标记”。这意味着此文件夹的根目录不包含名为 （marker） 的文件或目录。当此标记丢失时，同步将停止，以防止数据丢失，例如，当文件夹路径被卸载时。如果标记被意外删除，只需重新创建它，然后按 UI 中的重新扫描按钮即可。</li>
</ul>
<h5 id="创建新的同步文件夹"><a class="header" href="#创建新的同步文件夹">创建新的同步文件夹</a></h5>
<p>使用同步 Web 界面。单击“添加文件夹”按钮，该按钮将显示具有以下选项的对话框：</p>
<ul>
<li>文件夹标签：应设置为描述性内容。此标签最初将与远程设备共享，但可以根据需要在每个设备上进行更改。</li>
<li>文件夹标识：所有设备都必须相同，因为它是文件夹的唯一标识符。最佳做法是保留自动生成的 ID，以避免与其他设备上的同名文件夹发生冲突。</li>
<li>文件夹路径：指定文件夹的物理路径，即硬盘驱动器上的物理路径。</li>
</ul>
<p>接下来，选择要与哪些设备共享文件夹，然后按添加，这将添加文件夹并开始同步。</p>
<h5 id="设备视图"><a class="header" href="#设备视图">设备视图</a></h5>
<p>屏幕右侧显示所有已配置设备的整体状态。本地设备始终位于顶部，远程设备按字母顺序排列。对于每个设备，您都会看到其当前状态，并在展开时看到更详细的信息。所有传输速率（“下载速率”和“上传速率”）都是从本地设备的角度出发的，即使是针对远程设备显示的传输速率。本地设备的速率是远程设备的速率之和。对于每个速率，您可以看到当前的传输速度，然后是到目前为止传输的数据总量。您可以单击当前传输速度以在字节和位之间切换单位。</p>
<h5 id="桌面软件-1"><a class="header" href="#桌面软件-1">桌面软件</a></h5>
<p><a href="https://github.com/Martchus/syncthingtray">Martchus/syncthingtray: Tray application and Dolphin/Plasma integration for Syncthing (github.com)</a></p>
<h4 id="syncthing-discovery-server"><a class="header" href="#syncthing-discovery-server">Syncthing Discovery Server</a></h4>
<p>如果需要同步的设备不在同一网络中，则需要配置发现服务。<code>syncthing</code>默认使用联网的发现服务器（<code>default</code>）。如果在离线环境部署<code>syncthing</code>，则需要自行部署发现服务。</p>
<pre><code class="language-shell">stdiscosrv 
    -cert=./cert.pem -key=./key.pem
    -db-dir=./discovery.db
    -debug 
    -http   # Listen on HTTP (使用HTTPS反向代理)
    -listen=':8443'
    -metrics-listen=&lt;address&gt;  # default disabled
    -replicate=&lt;peers&gt;
    -replication-listen=':19200'
</code></pre>
<p><code>syncthing</code>配置选项：</p>
<ul>
<li><code>https://discover_server:8443</code>：使用CA签发证书。</li>
<li><code>https://discover_server:8443?id=&lt;server_id&gt;</code>：使用自签名证书，使用发现服务ID验证证书。</li>
<li><code>http://discover_server:8443?insecure</code>：取消证书验证。</li>
</ul>
<img src="应用软件/协作办公软件.assets/global_discovery_server_config.png" style="zoom: 50%;" />
<blockquote>
<p>如果需要要从互联网访问发现服务，可能需要动态DNS服务。</p>
</blockquote>
<h5 id="负载均衡-1"><a class="header" href="#负载均衡-1">负载均衡</a></h5>
<p><a href="https://docs.syncthing.net/users/stdiscosrv.html#replication">Syncthing Discovery Server — Replication</a></p>
<h5 id="反向代理-2"><a class="header" href="#反向代理-2">反向代理</a></h5>
<p><a href="https://docs.syncthing.net/users/stdiscosrv.html#reverse-proxy-setup">Syncthing Discovery Server — Reverse Proxy Setup</a></p>
<h4 id="自定义升级服务器"><a class="header" href="#自定义升级服务器">自定义升级服务器</a></h4>
<p><a href="https://docs.syncthing.net/users/custom-upgrades.html">Custom Upgrade Server — Syncthing documentation</a></p>
<h3 id="hedgedoc"><a class="header" href="#hedgedoc">HedgeDoc</a></h3>
<h4 id="安装-25"><a class="header" href="#安装-25">安装</a></h4>
<p>安装依赖组件：</p>
<ul>
<li>
<p><a href="%E5%BA%94%E7%94%A8%E8%BD%AF%E4%BB%B6/../JavaScript/JS%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83.html#Node.js">Node.js 16</a>（包含NPM）；</p>
</li>
<li>
<p>数据库（<a href="%E5%BA%94%E7%94%A8%E8%BD%AF%E4%BB%B6/../%E6%95%B0%E6%8D%AE%E5%BA%93/PostgreSQL.html#%E5%AE%89%E8%A3%85"><strong>PostgreSQL</strong></a>, <a href="%E5%BA%94%E7%94%A8%E8%BD%AF%E4%BB%B6/../%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL.html#%E5%AE%89%E8%A3%85%E8%BF%90%E8%A1%8C">MySQL</a>, MariaDB, SQLite），数据库应使用UTF-8编码（PostgreSQL和SQLite默认）。为数据库创建库实例和用户，并分配访问权限。</p>
<pre><code class="language-shell">createdb hedgedoc
createuser -h localhost hedgedoc -P
</code></pre>
<pre><code class="language-sql">GRANT ALL ON DATABASE hedgedoc TO hedgedoc;
</code></pre>
</li>
<li>
<p><a href="%E5%BA%94%E7%94%A8%E8%BD%AF%E4%BB%B6/../JavaScript/JS%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83.html#yarn">Yarn 1.22+</a>。</p>
</li>
</ul>
<p>安装配置HedgeDoc：</p>
<ul>
<li>
<p>在软件根目录下执行：<code>bin/setup</code><strong>在线下载</strong>依赖项和生成配置文件；</p>
</li>
<li>
<p>如果需要对前端进行定制修改（例如markdown的展示样式），可在修改后重新编译前端内容。</p>
<pre><code class="language-shell">yarn install --frozen-lockfile &amp;&amp; yarn build
</code></pre>
</li>
<li>
<p>修改配置文件（<code>./config.json</code>）：</p>
<pre><code class="language-json">{
    &quot;production&quot;: {
        &quot;domain&quot;: &quot;10.131.5.6&quot;,
        &quot;port&quot;: 4000,
        &quot;urlAddPort&quot;: true,
        &quot;db&quot;: {
            &quot;dialect&quot;: &quot;postgres&quot;,
            &quot;username&quot;: &quot;USERNAME&quot;,
            &quot;password&quot;: &quot;PASSWORD&quot;,
            &quot;database&quot;: &quot;hedgedoc&quot;,
            &quot;host&quot;: &quot;10.131.5.11&quot;,
            &quot;port&quot;: &quot;5432&quot;
        }
    }
}
</code></pre>
</li>
<li>
<p>手动启动服务，检查是否产生错误：</p>
<pre><code class="language-shell">NODE_ENV=production yarn start
</code></pre>
</li>
<li>
<p>创建用户。</p>
<pre><code class="language-shell">useradd -m hedgedoc
mkdir -p /home/hedgedoc/public/uploads /home/hedgedoc/db
</code></pre>
</li>
<li>
<p>配置系统服务<code>hedgedoc.service</code>。基于<a href="https://docs.hedgedoc.org/setup/manual-setup/#systemd-unit-example">文档提供模板</a>根据实际安装情况进行修改。</p>
<pre><code class="language-shell">Environment=PATH=/node/path:/system/path
Environment=NODE_ENV=production
ExecStart=/path/to/yarn start --production
WorkingDirectory=/path/to/hedgedoc
ReadWritePaths=/home/hedgedoc/public/uploads /home/degedoc/db
</code></pre>
</li>
<li>
<p>将服务文件安装到系统服务目录，启用并运行服务，查看服务运行状态。</p>
<pre><code class="language-shell">cp hedgedoc.service /lib/systemd/system/
systemctl daemon-reload &amp;&amp; systemctl enable --now hedgedoc
journalctl -xe -f -u hedgedoc 
</code></pre>
</li>
</ul>
<h4 id="反向代理配置"><a class="header" href="#反向代理配置">反向代理配置</a></h4>
<p>如果需要通过反向代理访问HedegDoc服务，则服务的某些配置与直接访问的方式不同。具体包括：</p>
<ul>
<li><code>domain</code>：配置为反向代理的域名或IP，这将使响应内容中URL的主机地址为代理服务器，而非HedgeDoc服务所在主机。同时，也避免浏览器的跨站访问检测策略阻止访问HedgeDoc服务（CSP和<a href="%E5%BA%94%E7%94%A8%E8%BD%AF%E4%BB%B6/./%E7%BD%91%E7%BB%9C%E6%9C%8D%E5%8A%A1%E8%BD%AF%E4%BB%B6.html#Nginx%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF">CORS</a>策略）。</li>
<li><code>protocolUseSSL</code>：如果浏览器是通过<code>HTTPS</code>访问服务，则应该设置为<code>true</code>；这将保证响应内容中的URL统一使用<code>https</code>，从而能正确被反向代理响应。该选项只影响URL的协议，而不影响实际使用HTTP或HTTPS。</li>
<li><code>urlAddPort</code>：由于反向代理具有统一的访问端口，通常为<code>80</code>或<code>443</code>，因此响应内容中的URL应该不添加HedgeDoc服务所使用的端口。</li>
<li><code>urlPath</code>：如果反向代理处需要通过URL路径区分服务，则需要为HedgeDoc设置根路径而不是使用默认的<code>/</code>。</li>
</ul>
<p>Nginx配置中添加HedgeDoc服务（HTTP）的转发规则。</p>
<pre><code class="language-nginx">map $http_upgrade $connection_upgrade {
    default upgrade;
    ''      close;
}
server {
    server_name hedgedoc.example.com;
    location / {
        proxy_pass http://hedgedoc-server:3000;
        proxy_set_header Host $host; 
        proxy_set_header X-Real-IP $remote_addr; 
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; 
        proxy_set_header X-Forwarded-Proto $scheme;
    }
    location /socket.io/ {  # WebSocket
        proxy_pass http://hedgedoc-server:3000;
        proxy_set_header Host $host; 
        proxy_set_header X-Real-IP $remote_addr; 
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; 
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection $connection_upgrade;
    }
}
</code></pre>
<p>如果设置了<code>urlPath='hedgedoc'</code>，则上述转发规则做相应修改：</p>
<pre><code class="language-nginx">location /hedgedoc {
    proxy_pass http://hedgedoc-server:3000/;
}
location /hedgedoc/socket.io/ {  # WebSocket
    proxy_pass http://hedgedoc-server:3000/socket.io/;
}
</code></pre>
<h2 id="远程桌面"><a class="header" href="#远程桌面">远程桌面</a></h2>
<h3 id="vnc"><a class="header" href="#vnc">VNC</a></h3>
<h5 id="安装tigervnc服务"><a class="header" href="#安装tigervnc服务">安装TigerVNC服务</a></h5>
<blockquote>
<p>Gnome（Fedora）自带远程桌面服务无法连接，在配置以下服务前首先关闭系统自带的远程桌面服务。</p>
</blockquote>
<pre><code class="language-shell">sudo dnf -y install tigervnc-server
sudo firewall-cmd --add-service=vnc-server --permanent
sudo firewall-cmd --reload
vncpasswd
</code></pre>
<p>编辑<code>~/.vnc/config</code>修改显示分辨率<code>geometry=1920x1080</code>。</p>
<p>编辑<code>/etc/tigervnc/vncserver.users</code>添加用户映射：<code>:2=gary</code>。</p>
<p>启动服务：<code>systemctl enable --now vncserver@:2.service</code></p>
<blockquote>
<p>注意：<a href="https://forums.fedoraforum.org/showthread.php?321053-tiger-VNC-server-shows"><code>:1</code>显示可能无法正常工作</a>，因此从<code>:2</code>开始配置。如果服务无法启动，尝试禁用并重启服务。</p>
</blockquote>
<h5 id="连接安全性"><a class="header" href="#连接安全性">连接安全性</a></h5>
<p>VNC传输未加密。为保证通信安全，应该在受信任的网络中使用，或首先从建立一条安全的隧道：</p>
<pre><code class="language-shell">ssh -v -C -L 590N:localhost:590M vncserver.host # local_590N -&gt; remote_590M
</code></pre>
<h5 id="vnc客户端"><a class="header" href="#vnc客户端">VNC客户端</a></h5>
<p>常用包括：UtralVNC、TigerVNC Viewer、TightVNC等。</p>
<blockquote>
<p>MobaXTerm连接质量较低（切换屏幕会导致VNC服务终止）；</p>
</blockquote>
<p>VNC客户端连接黑屏：<a href="https://forums.fedoraforum.org/showthread.php?321053-tiger-VNC-server-shows">登录界面显示服务不兼容</a>，修改<code>/etc/gdm/custom.conf</code>。</p>
<pre><code class="language-shell"># Uncomment the line below to force the login screen to use Xorg
WaylandEnable=false
</code></pre>
<ol>
<li><a href="https://www.server-world.info/en/note?os=Fedora_34&amp;p=desktop&amp;f=6">Fedora 34 : Configure VNC Server : Server World (server-world.info)</a></li>
</ol>
<h3 id="rdp-2"><a class="header" href="#rdp-2">RDP</a></h3>
<p><a href="https://linuxize.com/post/how-to-install-xrdp-on-ubuntu-20-04/">How to Install Xrdp Server (Remote Desktop) on Ubuntu 20.04 | Linuxize</a>。</p>
<blockquote>
<p>*<code>XRDP</code>*在Elementary OS上无法正常使用。</p>
</blockquote>
<h2 id="文档处理"><a class="header" href="#文档处理">文档处理</a></h2>
<h3 id="visio"><a class="header" href="#visio">Visio</a></h3>
<h5 id="为形状添加连接点"><a class="header" href="#为形状添加连接点">为形状添加连接点</a></h5>
<p><img src="%E5%BA%94%E7%94%A8%E8%BD%AF%E4%BB%B6/%E5%8D%8F%E4%BD%9C%E5%8A%9E%E5%85%AC%E8%BD%AF%E4%BB%B6.assets/20181127143610980.png" alt="添加连接点" /></p>
<p><img src="%E5%BA%94%E7%94%A8%E8%BD%AF%E4%BB%B6/%E5%8D%8F%E4%BD%9C%E5%8A%9E%E5%85%AC%E8%BD%AF%E4%BB%B6.assets/20181127143936590.png" alt="连接点视图" /></p>
<h5 id="更改连接线跨越风格"><a class="header" href="#更改连接线跨越风格">更改连接线跨越风格</a></h5>
<p>“设计/版式/连接线”：取消“显示跨线”，则交叉点处不会拐弯。</p>
<h2 id="参考资料-10"><a class="header" href="#参考资料-10">参考资料</a></h2>
<div class="footnote-definition" id="syncthing"><sup class="footnote-definition-label">1</sup>
<p><a href="https://github.com/syncthing/syncthing">syncthing - Open Source Continuous File Synchronization</a>.
<sup class="footnote-reference"><a href="#st-conf">2</a></sup>: <a href="https://docs.syncthing.net/v1.20.2/users/config.html">Syncthing Configuration — Syncthing v1.20.2 documentation</a>.
<sup class="footnote-reference"><a href="#sync-mechanism">3</a></sup>: <a href="https://docs.syncthing.net/users/syncing.html">Understanding Synchronization — Syncthing documentation</a></p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="知识管理软件"><a class="header" href="#知识管理软件">知识管理软件</a></h1>
<h2 id="obsidian"><a class="header" href="#obsidian">Obsidian</a></h2>
<h5 id="callout"><a class="header" href="#callout">callout</a></h5>
<pre><code>&gt; [!INFO]
&gt; Here's a callout block.
&gt; It supports **markdown**, [[Internal link|wikilinks]], and [[Embed files|embeds]]!
&gt; ![[og-image.png]]
</code></pre>
<p><a href="https://help.obsidian.md/How+to/Use+callouts">Use callouts - Obsidian Help</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="多媒体编辑软件"><a class="header" href="#多媒体编辑软件">多媒体编辑软件</a></h1>
<h2 id="图形编辑软件"><a class="header" href="#图形编辑软件">图形编辑软件</a></h2>
<h3 id="gimp"><a class="header" href="#gimp">GIMP</a></h3>
<p><em><strong>GNU Image Manipulation Program</strong></em><sup class="footnote-reference"><a href="#about-gimp">1</a></sup>。</p>
<pre><code class="language-powershell">winget install GIMP.GIMP
</code></pre>
<h3 id="inkscape"><a class="header" href="#inkscape">Inkscape</a></h3>
<pre><code class="language-powershell">winget install Inkscape.Inkscape
</code></pre>
<h3 id="imagemagick"><a class="header" href="#imagemagick">ImageMagick</a></h3>
<blockquote>
<p><em>create, edit, compose, or convert digital images<sup class="footnote-reference"><a href="#image-magick">2</a></sup>:</em></p>
<ul>
<li>*resize, flip, mirror, rotate, distort, shear and transform images, *</li>
<li>*adjust image colors, *</li>
<li>*apply various special effects, *</li>
<li><em>draw text, lines, polygons, ellipses and Bézier curves.</em></li>
</ul>
</blockquote>
<p>ImageMagick适用于后台处理图像。</p>
<ul>
<li>https://imagemagick.org/archive/binaries/ImageMagick-7.1.0-51-Q16-HDRI-x64-dll.exe</li>
<li><a href="https://www.imagemagick.org/script/download.php#windows">ImageMagick – Download</a></li>
</ul>
<p>安装：</p>
<pre><code class="language-shell">apt install imagemagick                # ImageMagick 6.9.11-60 Q16 x86_64
winget install ImageMagick.ImageMagick # ImageMagick 7.1.0-51 Q16-HDRI x64
</code></pre>
<blockquote>
<p><em>A <code>Q16</code> version permits you to read or write <strong>16-bit</strong> images without losing precision but requires twice as much resources as the <code>Q8</code> version.</em></p>
</blockquote>
<pre><code class="language-shell">magick -version
magick -help
</code></pre>
<h4 id="用法-3"><a class="header" href="#用法-3">用法</a></h4>
<p>在Linux下ImageMagick提供的命令行工具是独立的，如<code>convert</code>、<code>identify</code>、<code>display</code>……；在Windows下，相应地工具则统一通过<code>magick</code>子命令调用（Linux下也支持此方式）。</p>
<pre><code class="language-powershell">command { [settings] [operation] }...  &quot;implict_write&quot;
</code></pre>
<p>命令执行模式，每个命令由一个或多个<code>operation</code>和一个输出操作组成。每个<code>operation</code>定义包含读取/创建图像以及对图像的处理选项，处理后的图像缓存在图像序列中，由最后定义的输出操作统一处理。</p>
<h5 id="工具集简介"><a class="header" href="#工具集简介">工具集简介</a></h5>
<ul>
<li><code>magick</code>：作为所有命令行的调用入口；未提供子命令时，默认调用<code>convert</code>命令。</li>
<li><code>identify:</code> 输出一个或多个图像文件的格式和特征信息，如分辨率、大小、尺寸、色彩空间等。</li>
<li><code>convert</code>：创建、编辑图像，转换图像格式，以及调整图像大小、模糊、裁切、除去杂点、抖动 ( dither )、绘图、翻转、合并、重新采样等。</li>
<li><code>mogrify:</code> 与 <code>convert</code> 功能一样，直接修改原始图像文件。</li>
<li><code>composite:</code> 将一个图片或多个图片组合成新图片。</li>
<li><code>montage:</code> 组合多个独立的图像来创建合成图像。每个图像都可以用边框，透明度等特性进行装饰。</li>
<li><code>compare:</code> 从数学和视觉角度比较源图像与重建图像之间的差异。</li>
<li><code>stream:</code> 将图像或部分图像的一个或多个像素组件流式传输到存储设备。在处理大图像或原始像素组件时很有用。</li>
<li><code>conjure:</code> 解释并执行 MSL ( Magick Scripting Language ) 写的脚本。</li>
</ul>
<p>✨<a href="https://imagemagick.org/Usage/basics/">Basic Usage -- ImageMagick Examples</a></p>
<p>[ImageMagick – Command-line Tools](file:///C:/Program Files/ImageMagick-7.1.0-Q16-HDRI/www/command-line-tools.html)</p>
<p><a href="https://jelly.jd.com/article/5c34081bd7aa2c0055d09a71">JELLY | 图像处理 - ImageMagick 简单介绍与案例 (jd.com)</a></p>
<h4 id="convert"><a class="header" href="#convert">convert</a></h4>
<pre><code class="language-shell">magick input.jpg \
       -resize 50% \
       output.png 
</code></pre>
<h2 id="参考资料-11"><a class="header" href="#参考资料-11">参考资料</a></h2>
<div class="footnote-definition" id="about-gimp"><sup class="footnote-definition-label">1</sup>
<p><a href="https://www.gimp.org/about/introduction.html">GIMP - About GIMP</a>.
<sup class="footnote-reference"><a href="#image-magick">2</a></sup>:<a href="https://imagemagick.org/">ImageMagick – Convert, Edit, or Compose Digital Images</a></p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="机器学习实践"><a class="header" href="#机器学习实践">机器学习实践</a></h1>
<h2 id="搭建开发环境"><a class="header" href="#搭建开发环境">搭建开发环境</a></h2>
<h3 id="python环境-1"><a class="header" href="#python环境-1">Python环境</a></h3>
<p>数据处理和算法库：</p>
<ul>
<li><code>numpy</code>、<code>pandas</code>；</li>
<li><code>scipy</code>、sklearn (<code>scikit-learn</code>)</li>
<li><code>tensorflow</code>、<code>keras</code>（<code>tensorflow</code>已将<code>keras</code>作为内置模块，但使用需要单独安装）；</li>
<li><code>pytorch</code>；</li>
</ul>
<h4 id="安装tensorflow"><a class="header" href="#安装tensorflow">安装Tensorflow</a></h4>
<p><code>tensorflow 1.x</code>分为CPU和GPU版本，且<code>1.x</code>和<code>2.x</code>版本不兼容，因此需要在单独的虚拟环境中分别安装：</p>
<pre><code class="language-shell">conda create -n tf2 [tensorflow-gpu] tensorflow=&lt;ver&gt; cudnn cudatoolkit=11.2 keras
conda create -n tfgpu tensorflow-gpu=&lt;ver&gt; ... # 1.x GPU版本
</code></pre>
<blockquote>
<p>2.x版本的包名不区分GPU/CPU版本，根据是否安装GPU工具包（<code>cudnn</code>和<code>cudatoolkit</code>）决定是否能使用GPU计算。<code>tensorflow-gpu</code>声明了对GPU库的依赖保证安装支持GPU的版本。</p>
<p>使用<code>pip</code>安装：</p>
<pre><code class="language-shell">pip install tensorflow    # CPU 版本
</code></pre>
</blockquote>
<h5 id="gpu支持"><a class="header" href="#gpu支持">GPU支持</a></h5>
<p>在系统中安装<a href="https://www.nvidia.com/drivers">NVIDIA® GPU 驱动程序</a>（CUDA 11.2需要450.80.02或更高版本）。==使用Conda安装<code>tensorflow-gpu</code>将自动为虚拟环境安装兼容版本的CUDA Toolkit和cuDNN==。官方提供CUDA Toolkit包含了进行CUDA相关程序开发的编译、调试等过程相关的所有组件。而Conda虚拟环境提供的CUDA Toolkit仅包含运行时库。以下为可选安装内容：</p>
<ul>
<li>
<p><a href="https://developer.nvidia.com/cuda-toolkit-archive">CUDA® 工具包</a>（CUDA Toolkit）：TensorFlow 支持 CUDA 11.2（TensorFlow 2.5.0及更高版本）。 </p>
</li>
<li>
<p><a href="https://developer.nvidia.com/cudnn">cuDNN SDK</a>（8.1.0）</p>
</li>
<li>
<p>CUDA 工具包附带的 <a href="http://docs.nvidia.com/cuda/cupti/">CUPTI</a>。</p>
<pre><code class="language-shell">export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/usr/local/cuda/extras/CUPTI/lib64
</code></pre>
</li>
<li>
<p><a href="https://docs.nvidia.com/deeplearning/sdk/tensorrt-install-guide/index.html">TensorRT 6.0</a>，可缩短用某些模型进行推断的延迟时间并提高吞吐量。</p>
</li>
</ul>
<h5 id="tensorflow容器"><a class="header" href="#tensorflow容器"><a href="https://hub.docker.com/r/tensorflow/tensorflow/">TensorFlow容器</a></a></h5>
<pre><code class="language-shell">docker run -it -p 8888:8888 tensorflow/tensorflow:latest-jupyter
</code></pre>
<p><a href="https://www.tensorflow.org/install/docker">Docker  | TensorFlow</a></p>
<h5 id="验证安装"><a class="header" href="#验证安装">验证安装</a></h5>
<pre><code class="language-python">import tensorflow as tf
print(tf.version.VERSION)
tf.config.list_physical_devices()
</code></pre>
<h5 id="tensorflow-with-directml-on-wsl"><a class="header" href="#tensorflow-with-directml-on-wsl"><a href="https://docs.microsoft.com/en-us/windows/ai/directml/gpu-tensorflow-wsl">Tensorflow with DirectML on WSL</a></a></h5>
<h4 id="安装pytorch"><a class="header" href="#安装pytorch">安装PyTorch</a></h4>
<p>使用Conda安装<code>pytorch</code>：相关包可使用<code>pytorch</code>通道下载（注意<a href="https://pytorch.org/get-started/locally/">选择操作系统和计算平台</a>，以下仅为示例）。</p>
<pre><code class="language-shell">conda create -n pytorch[-gpu] python=3.8   # python&gt;=3.6
conda install pytorch torchvision torchaudio cpuonly -c pytorch
conda install pytorch=&quot;1.10.*&quot;=&quot;*cuda*&quot; torchvision torchaudio cudatoolkit=11.3 -c pytorch
</code></pre>
<blockquote>
<p>2022/01/21：<code>conda-forge: cudatoolkit&lt;=11.2</code>；<code>pytorch: cudatoolkit&lt;=11.3</code>。当Pytorch和TensorFlow共同安装时，可能导致依赖解析问题无法安装Pytorch的GPU版本，此时可指定安装<code>pytorch-gpu</code>（Linux下才有此包）。</p>
<p>使用pip安装<code>pytorch</code>： </p>
<pre><code class="language-shell">pip install torch torchvision torchaudio           # CPU version
pip3 install torch==1.10.1+cu113 \
  torchvision==0.11.2+cu113 torchaudio==0.10.1+cu113 \
  -f https://download.pytorch.org/whl/cu113/torch_stable.html # GPU version
</code></pre>
<p>验证安装：</p>
<pre><code class="language-python">import torch
x = torch.rand(5, 3); print(x)
torch.cuda.is_available()
</code></pre>
</blockquote>
<h5 id="enable-pytorch-with-directml-on-wsl-2"><a class="header" href="#enable-pytorch-with-directml-on-wsl-2"><a href="https://docs.microsoft.com/en-us/windows/ai/directml/gpu-pytorch-wsl">Enable PyTorch with DirectML on WSL 2</a></a></h5>
<h4 id="图神经网络库"><a class="header" href="#图神经网络库">图神经网络库</a></h4>
<h5 id="dgl"><a class="header" href="#dgl">DGL</a></h5>
<pre><code class="language-shell">conda create -n dgl -c pytorch pytorch=1.12 cudatoolkit=11.6 cudnn
conda activate dgl
conda install -c dglteam dgl-cuda11.6
</code></pre>
<p><code>dglteam</code>仓库仅在Anaconda官方源中可用，如果使用Nexus代理，增加以下仓库代理。</p>
<pre><code class="language-ini">Name=anaconda-cloud
Remote=https://conda.anaconda.org/
URL=http://192.168.178.52:8081/repository/anaconda-cloud
</code></pre>
<p>也可使用DGL提供的pip仓库安装<code>dgl</code>库。</p>
<pre><code class="language-shell">pip install dgl-cu116 dglgo -f https://data.dgl.ai/wheels/repo.html
</code></pre>
<p>通过配置文件<code>~/.dgl/config.json </code>或环境变量指定使用的深度学习框架后端。</p>
<pre><code class="language-json">{
    &quot;backend&quot;:  &quot;pytorch&quot;
}
</code></pre>
<pre><code class="language-shell">export DGLBACKEND=pytorch  # pytorch, mxnet, tensorflow
</code></pre>
<h5 id="pytorch-geometric"><a class="header" href="#pytorch-geometric">PyTorch Geometric</a></h5>
<blockquote>
<p><em><strong>PyG</strong> (PyTorch Geometric) is a library built upon PyTorch to easily write and train Graph Neural Networks (GNNs) for a wide range of applications related to structured data.</em></p>
</blockquote>
<pre><code class="language-shell">conda create -n pyg -c pytorch pytorch=1.12 cudatoolkit=11.6 cudnn
conda activate pyg
conda install pyg -c pyg
</code></pre>
<p>使用<code>pip</code>安装：</p>
<pre><code class="language-shell">CUDA={cpu|cu102|cu113|cu116}
pip install torch-scatter -f https://data.pyg.org/whl/torch-1.12.0+${CUDA}.html
pip install torch-sparse -f https://data.pyg.org/whl/torch-1.12.0+${CUDA}.html
pip install torch-geometric
</code></pre>
<div class="table-wrapper"><table><thead><tr><th></th><th><code>cpu</code></th><th><code>cu102</code></th><th><code>cu113</code></th><th><code>cu116</code></th></tr></thead><tbody>
<tr><td><strong>Linux</strong></td><td>✅</td><td>✅</td><td>✅</td><td>✅</td></tr>
<tr><td><strong>Windows</strong></td><td>✅</td><td></td><td>✅</td><td>✅</td></tr>
<tr><td><strong>macOS</strong></td><td>✅</td><td></td><td></td><td></td></tr>
</tbody></table>
</div>
<p><a href="https://github.com/pyg-team/pytorch_geometric">pyg-team/pytorch_geometric: Graph Neural Network Library for PyTorch (github.com)</a></p>
<h3 id="gpu计算库"><a class="header" href="#gpu计算库">GPU计算库</a></h3>
<h4 id="nvidia-cuda"><a class="header" href="#nvidia-cuda">NVIDIA CUDA</a></h4>
<p>安装：<code>./cuda-xxx.run --no-opengl-libs</code>；</p>
<p>如果机器已经安装驱动程序，则安装过程中可跳过驱动程序安装；</p>
<p>修改环境变量使CUDA全局可用；<img src="机器学习/机器学习实践.assets/wsl-launch-upt-0625-rz.png" alt="CUDA on WSL Overview." style="zoom:35%;float:right" /></p>
<h5 id="cuda-on-wsl-2"><a class="header" href="#cuda-on-wsl-2">CUDA on WSL 2</a></h5>
<blockquote>
<p>系统版本需要为<a href="https://docs.microsoft.com/en-us/windows/ai/directml/gpu-cuda-in-wsl">Windows 10 21H2或更高</a>，WSL发行版使用Ubuntu或Debian（Linux 5.10.43.3+）。</p>
</blockquote>
<ol>
<li>
<p>在Windows中安装<a href="https://developer.nvidia.com/cuda/wsl">支持WSL的NVIDIA CUDA驱动程序</a>。</p>
</li>
<li>
<p>[可选] 在WSL中安装<a href="https://developer.nvidia.com/cuda-downloads?target_os=Linux&amp;target_arch=x86_64&amp;Distribution=WSL-Ubuntu&amp;target_version=2.0">专用CUDA工具包</a>（注意使用<code>run</code>文件不要安装显卡驱动）；如果需要<a href="https://docs.nvidia.com/cuda/wsl-user-guide/index.html#ch03a-setting-up-cuda">编译CUDA程序</a>，则需要安装CUDA Toolkit。</p>
</li>
<li>
<p>使用CUDA自带样例验证安装是否正确；</p>
</li>
<li>
<p>安装完成后，即可和普通Linux一样使用PyTorch、TensorFlow或<a href="https://github.com/NVIDIA/nvidia-docker">NVIDIA Docker</a>。</p>
<pre><code class="language-shell"># 验证
nvidia-smi -q
chmod -R a+w /usr/local/cuda-11.4/samples
cd /usr/local/cuda-11.4/samples/4_Finance/BlackScholes
make BlackScholes &amp;&amp; ./BlackScholes
</code></pre>
</li>
</ol>
<h4 id="nvidia-docker"><a class="header" href="#nvidia-docker">NVIDIA Docker</a></h4>
<blockquote>
<p>Note that NVIDIA Container Toolkit has not yet been validated with <a href="https://docs.docker.com/docker-for-windows/wsl/">Docker Desktop WSL 2</a> backend（实测可以运行）.</p>
<p><a href="%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/">NVIDIA/nvidia-docker: Build and run Docker containers leveraging NVIDIA GPUs (github.com)</a></p>
</blockquote>
<p>安装NVIDIA Docker工具包：</p>
<pre><code class="language-shell">distribution=$(. /etc/os-release;echo $ID$VERSION_ID)
curl -fsSL https://nvidia.github.io/libnvidia-container/gpgkey | sudo gpg --dearmor -o /usr/share/keyrings/nvidia-container-toolkit-keyring.gpg
curl -s -L https://nvidia.github.io/libnvidia-container/$distribution/libnvidia-container.list | \
sed 's#deb https://#deb [signed-by=/usr/share/keyrings/nvidia-container-toolkit-keyring.gpg] https://#g' | \
sudo tee /etc/apt/sources.list.d/nvidia-container-toolkit.list

sudo apt update &amp;&amp; sudo apt install -y nvidia-docker2
</code></pre>
<p>需要重启docker服务以完成安装。</p>
<p>容器示例：</p>
<pre><code class="language-shell">docker run --gpus all nvcr.io/nvidia/k8s/cuda-sample:nbody nbody -gpu -benchmark
docker run -it --gpus all -p 8888:8888 tensorflow/tensorflow:latest-gpu-py3-jupyter
docker run --gpus all -it --shm-size=1g --ulimit memlock=-1 --ulimit stack=67108864 nvcr.io/nvidia/tensorflow:20.03-tf2-py3 # Unknown runtime specified nvidia.
</code></pre>
<h3 id="java环境"><a class="header" href="#java环境">Java环境</a></h3>
<p><a href="https://spark.apache.org/mllib/">Spark MLlib</a></p>
<h2 id="数据准备"><a class="header" href="#数据准备">数据准备</a></h2>
<p>尽管单个向量的默认方向是列向量，但在表示表格数据集的矩阵中， 将每个数据样本作为矩阵中的行向量更为常见。</p>
<ul>
<li>向量：$\mathbf{y}, \boldsymbol{y}$</li>
<li>矩阵：$\mathbf{A}, \boldsymbol{A}$</li>
<li>张量：$\mathsf{X}$</li>
</ul>
<h3 id="数据类型-5"><a class="header" href="#数据类型-5">数据类型</a></h3>
<ul>
<li>
<p><a href="%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/../Python/Python%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.html#%E7%9F%A9%E9%98%B5">Numpy数组</a></p>
</li>
<li>
<p><a href="%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/Pytorch.html#Pytorch%E5%BC%A0%E9%87%8F">Pytorch张量</a></p>
</li>
</ul>
<h3 id="数据集划分"><a class="header" href="#数据集划分">数据集划分</a></h3>
<p>将数据集按比例随机抽样划分为训练集、开发集（交叉验证集）和测试集。</p>
<ul>
<li><a href="%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/ScikitLearn.html#%E6%95%B0%E6%8D%AE%E9%9B%86%E5%88%92%E5%88%86">Scikit Learn</a></li>
</ul>
<blockquote>
<p>能在开发集上运行性能良好，却在测试集上效果不佳的系统。如果此时开发集和测试集的分布相同，那么你就能清楚地明白问题所在：算法在开发集上过拟合了（overfit）。解决方案显然就是去获取更多的开发集数据。</p>
<p>但是如果开发集和测试集服从不同的分布，解决方案就不那么明确了。此时可能存在以下一种或者多种情况：</p>
<ol>
<li>算法在开发集上过拟合了。</li>
<li>测试集比开发集更难进行预测，尽管算法做得足够好了，却很难有进一步的提升空间。</li>
<li>测试集不一定更难预测，但它与开发集性质并不相同（分布不同）。因此在开发集上表现良好的算法不一定在测试集上也能够取得出色表现。如果是这种情况，大量针对开发集性能的改进工作将会是徒劳的。</li>
</ol>
<p><a href="https://deeplearning-ai.github.io/machine-learning-yearning-cn/docs/ch06/">开发集和测试集应该服从同一分布 (deeplearning-ai.github.io)</a></p>
</blockquote>
<h3 id="真实数据集"><a class="header" href="#真实数据集">真实数据集</a></h3>
<ul>
<li>
<p><code>keras.datasets</code></p>
<p>提供在线获取（缓存在本地<code>~/.keras/datasets/</code>）和加载示例数据集的接口。数据集包括：<code>mnist</code>、<code>boston_house</code>、<code>cifar</code>、<code>imdb</code>、<code>reuters</code>等。</p>
</li>
<li></li>
</ul>
<h2 id="数据预处理"><a class="header" href="#数据预处理">数据预处理</a></h2>
<ul>
<li>清理：错误、丢失信息；</li>
<li>使用统计方法理解数据；</li>
<li>可视化数据，发现有用特征；</li>
<li>构造新特征；</li>
<li>反复迭代；</li>
</ul>
<h3 id="数值化numeralization"><a class="header" href="#数值化numeralization">数值化（Numeralization）</a></h3>
<h4 id="类别数据categorical-variables"><a class="header" href="#类别数据categorical-variables">类别数据（<em>Categorical Variables</em>）</a></h4>
<ul>
<li><strong>无序数据</strong>（<em><strong>nominal</strong></em>），例如：<code>{male, female}</code>；不应该被编码为数值，类别之间无大小关系；</li>
<li><strong>有序数据</strong>（<em><strong>ordinal</strong></em>），例如<code>{low, medium, high}</code>；可以编码成任意具有大小关系的数值，不能准确表示原始数据的意图。</li>
</ul>
<h5 id="one-hot-encoding-scheme"><a class="header" href="#one-hot-encoding-scheme">One-hot Encoding Scheme</a></h5>
<pre><code class="language-python">pd_dummy= pd.get_dummies(drop_first=True)
</code></pre>
<p>默认仅对<code>object</code>类型的列进行编码。</p>
<h6 id="dummy-variable-trap"><a class="header" href="#dummy-variable-trap">Dummy Variable Trap</a></h6>
<p>Multicollinearity: Variance Inflation Factor.</p>
<p>https://towardsdatascience.com/one-hot-encoding-multicollinearity-and-the-dummy-variable-trap-b5840be3c41a</p>
<h6 id="dummy-coding-scheme"><a class="header" href="#dummy-coding-scheme">Dummy Coding Scheme</a></h6>
<h6 id="effect-coding-scheme"><a class="header" href="#effect-coding-scheme">Effect Coding Scheme</a></h6>
<h5 id="bin-counting-scheme"><a class="header" href="#bin-counting-scheme">Bin-counting Scheme</a></h5>
<h5 id="feature-hashing-scheme"><a class="header" href="#feature-hashing-scheme">Feature Hashing Scheme</a></h5>
<ol>
<li>UNDERSTANDING FEATURE ENGINEERING (PART 2), Categorical Data, Strategies for working with discrete, categorical data, https://towardsdatascience.com/understanding-feature-engineering-part-2-categorical-data-f54324193e63.</li>
<li>scikit-learn 0.22.1, Preprocessing data, Discretization, https://scikit-learn.org/stable/modules/preprocessing.html#discretization.</li>
</ol>
<h4 id="word2vec"><a class="header" href="#word2vec">Word2vec</a></h4>
<p>利用One-hot Encoding表示单词，使用降维方法减小向量空间。</p>
<p><a href="https://www.jianshu.com/p/471d9bfbd72f">通俗理解word2vec - 简书 (jianshu.com)</a></p>
<p><a href="https://www.cnblogs.com/peghoty/p/3857839.html">word2vec 中的数学原理详解 - peghoty - 博客园 (cnblogs.com)</a></p>
<h4 id="标签编码"><a class="header" href="#标签编码">标签编码</a></h4>
<p>标签编码，将文本数据转换为整数。</p>
<blockquote>
<ul>
<li><a href="%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/ScikitLearn.html#LabelEncoder"><code>sklearn.preprocessing.LabelEncoder</code></a></li>
</ul>
</blockquote>
<p>标签二值化，将样本的负/正标签值转换为<code>(0,1)</code>二值。如果标签值类别超过两类，则分别对每类值（视为正样本，映射为<code>1</code>）执行二值化（非正样本映射为<code>0</code>）。</p>
<blockquote>
<ul>
<li><a href="%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/ScikitLearn.html#LabelBinarizer"><code>sklearn.preprocessing.LabelBinarizer</code></a></li>
</ul>
</blockquote>
<p>多标签二元化，样本的每个标签对应的编码位置为1。</p>
<blockquote>
<ul>
<li><a href="%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/ScikitLearn.html#MultiLabelBinarizer"><code>sklearn.preprocessing.MultiLabelBinarizer</code></a></li>
</ul>
</blockquote>
<h3 id="标准化normalization"><a class="header" href="#标准化normalization">标准化（Normalization）</a></h3>
<blockquote>
<p><em>Change the values of numeric columns in the dataset to a common scale, without distorting differences in the ranges of values.</em></p>
</blockquote>
<p>每个特征具有的物理意义不同，其具体数值在特征之间通常不具有可比性（更换数据的单位其数值就相应地缩放，但是物理意义没有变化）；将数据特征的区间缩放到一个常见的范围，提升算法稳定性。</p>
<p><strong>对于基于距离的算法，则需要考虑：1）原始数据的取值范围（单位）是否影响算法；2）标准化是否破坏了原始的距离信息；</strong></p>
<blockquote>
<p>如果一列数据为常量，缩放方法无效；同时，该列数据在学习任务中通常没有作用。</p>
</blockquote>
<h4 id="线性缩放"><a class="header" href="#线性缩放">线性缩放</a></h4>
<p>线性缩放处理特征之间数据范围不一致的情形。</p>
<h5 id="标准缩放standardscaler"><a class="header" href="#标准缩放standardscaler">标准缩放（StandardScaler）</a></h5>
<p>移除样本的统计均值并将统计方差缩放为1：
$$
z = (x-\mu)/\sigma \notag
$$</p>
<h5 id="min-max缩放"><a class="header" href="#min-max缩放">Min-Max缩放</a></h5>
<p>将特征区间缩放到$[0,1]$区间。
$$
\hat{x}=\frac{x-\min{x}}{\max{x}-\min{x}}\notag
$$</p>
<h4 id="非线性缩放"><a class="header" href="#非线性缩放">非线性缩放</a></h4>
<h5 id="对数缩放logscaler"><a class="header" href="#对数缩放logscaler">对数缩放（LogScaler）*</a></h5>
<p>样本特征分布<a href="https://towardsdatascience.com/visualizing-data-with-pair-plots-in-python-f228cf529166">范围很大（长尾分布）</a>，根据特征的属性，如果在特征取值较大，而其变化对目标任务影响较小时（例如收入、数据下载量、音量等），可以采用对数缩放，从而保留更多特征信息。</p>
<blockquote>
<p>对数缩放可能使得异常点不显著。</p>
</blockquote>
<p>$$
\hat{x}=\log_{10}{(1+x)}\notag
$$</p>
<p>可以与线性缩放结合使用。</p>
<h3 id="归一化unit-vector-normalization"><a class="header" href="#归一化unit-vector-normalization">归一化（Unit Vector Normalization）</a></h3>
<p>针对每个样本而不是每个特征进行处理。</p>
<p>将向量（<strong>样本特征向量</strong>）长度缩放为1，即将所有样本缩放到一个单位超球面上。需要注意，==如果原始数据本身具有不同的向量长度，且算法对数据的向量长度敏感==（基于距离的算法），则此类标准化方法不适用。此方法常用于<strong>文本分类或聚类</strong>。
$$
\hat{\boldsymbol{x}}=\frac{\boldsymbol{x}}{|\boldsymbol{x}|}\notag
$$</p>
<p><a href="https://scikit-learn.org/stable/auto_examples/preprocessing/plot_all_scaling.html#sphx-glr-auto-examples-preprocessing-plot-all-scaling-py">Compare the effect of different scalers on data with outliers</a>。</p>
<h3 id="特征生成"><a class="header" href="#特征生成">特征生成</a></h3>
<h4 id="多项式特征生成"><a class="header" href="#多项式特征生成">多项式特征生成</a></h4>
<p>基于已有特征生成高阶非线性特征，如：$x^2, x^3, xy, \cdots$。</p>
<h2 id="处理流程"><a class="header" href="#处理流程">处理流程</a></h2>
<h3 id="pipeline"><a class="header" href="#pipeline">Pipeline</a></h3>
<img src="机器学习/Python.assets/pipeline.png" alt="img" style="zoom: 67%;" />
<p>将数据预处理、学习算法等流程串联起来（<strong>最后一个流程必须执行预测</strong>）。</p>
<ul>
<li><a href="%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/ScikitLearn.html#Pipeline%E5%B7%A5%E4%BD%9C%E6%B5%81">Scikit-Learn Pipeline</a></li>
</ul>
<h2 id="性能评估"><a class="header" href="#性能评估">性能评估</a></h2>
<h3 id="评估方法"><a class="header" href="#评估方法">评估方法：</a></h3>
<ul>
<li>
<p>学习方法（estimator）的<code>score</code>方法</p>
</li>
<li>
<p><code>sklearn.metrics</code>提供的评估预测误差的方法，包括分类误差计算方法：<code>accuracy_score</code>、<code>f1_score</code>、<code>precision_score</code>、<code>recall_score</code>，回归误差计算方法<code>r2_score</code>。</p>
</li>
<li>
<p>交叉验证的评分策略，通过<code>scoring</code>参数选择评分方法。评分器（<code>scorer</code>）约定越高评分代表越好的性能。预定义的<code>scoring</code>参数对应了<code>metrics</code>中的评估方法。</p>
<p><code>make_scorer</code></p>
<p>自定义打分方法：</p>
<pre><code class="language-python">def scoring_func(estimator, X, y):
  # do scoring
  return score # higher is better.
</code></pre>
</li>
</ul>
<p>多分类或多标签分类的评分方法。</p>
<blockquote>
<p>当你需要在多个分类器之间进行选择时，使用单值评估指标将帮助你更快速地作出决定。它能给出一个清晰明了的分类器性能排名，从而帮助团队明确后续的改进方向。</p>
<p><a href="https://deeplearning-ai.github.io/machine-learning-yearning-cn/docs/ch08/">使用单值评估指标进行优化 (deeplearning-ai.github.io)</a></p>
<p><a href="https://deeplearning-ai.github.io/machine-learning-yearning-cn/docs/ch09/">优化指标和满意度指标 (deeplearning-ai.github.io)</a></p>
</blockquote>
<h3 id="交叉验证"><a class="header" href="#交叉验证">交叉验证</a></h3>
<blockquote>
<p><em>Cross Validation (CV) provides the ability to estimate model performance on unseen data not used while training.</em></p>
</blockquote>
<ul>
<li>test on unseen data</li>
<li>avoid overfitting</li>
</ul>
<h5 id="k折交叉验证"><a class="header" href="#k折交叉验证">K折交叉验证</a></h5>
<p>步骤：splitting the data into subsets (called folds, <strong>K-fold</strong>) and rotating the training and validation among them. </p>
<p><img src="%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5.assets/1rRqMSQZ38QKPWqf79GYQRQ.png" alt="K-fold" /></p>
<ul>
<li><a href="%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/ScikitLearn.html#%E4%BA%A4%E5%8F%89%E9%AA%8C%E8%AF%81">Scikit Learn</a></li>
</ul>
<p>https://towardsdatascience.com/what-is-cross-validation-60c01f9d9e75</p>
<p><a href="https://scikit-learn.org/stable/modules/model_evaluation.html#scoring-parameter">Metrics and scoring: quantifying the quality of predictions</a></p>
<h3 id="参数搜索"><a class="header" href="#参数搜索">参数搜索</a></h3>
<p>获取非训练过程调整的你参数。</p>
<h5 id="网格搜索交叉验证"><a class="header" href="#网格搜索交叉验证">网格搜索交叉验证</a></h5>
<p>在各个超参数的取值范围内穷举参数组合，分别应用于模型进行训练和预测，根据预测性能获得最佳的超参数组合。为了计算应用超参数组合的模型的性能，需要结合(K折)交叉验证，即将数据集划分为==训练集和验证集==。</p>
<ul>
<li><a href="%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/ScikitLearn.html#%E7%BD%91%E6%A0%BC%E6%90%9C%E7%B4%A2%E4%BA%A4%E5%8F%89%E9%AA%8C%E8%AF%81"><code>GridSearchCV</code></a></li>
</ul>
<h5 id="random-search-cross-validation"><a class="header" href="#random-search-cross-validation">Random Search Cross Validation</a></h5>
<p>从参数空间中随机采样。</p>
<ol>
<li><a href="https://scikit-learn.org/stable/modules/grid_search.html#">Tuning the hyper-parameters of an estimator</a></li>
<li><a href="https://scikit-learn.org/stable/modules/generated/sklearn.model_selection.GridSearchCV.html">sklearn.model_selection.GridSearchCV</a></li>
</ol>
<h2 id="深度学习算法"><a class="header" href="#深度学习算法">深度学习算法</a></h2>
<h3 id="autoencoder"><a class="header" href="#autoencoder">AutoEncoder</a></h3>
<p><a href="https://blog.keras.io/building-autoencoders-in-keras.html">Building Autoencoders in Keras, 2016</a></p>
<h2 id="end-to-end-ml-lifecycle-management"><a class="header" href="#end-to-end-ml-lifecycle-management">End-to-End ML Lifecycle Management</a></h2>
<h3 id="mlflow"><a class="header" href="#mlflow">MLflow</a></h3>
<ul>
<li><strong>MLflow Tracking</strong>: 记录实验结果，比较参数和结果；</li>
<li><strong>MLflow Projects</strong>：将ML代码打包未可重用可复现的形式（用于共享或生产部署）；</li>
<li><strong>MLflow Models</strong>：支持多种机器学习库模型在多种平台上的管理和部署；</li>
<li><strong>MLflow Registry</strong>：提供模型管理协作中心。</li>
</ul>
<p><a href="https://www.mlflow.org/docs/latest/concepts.html">Concepts — MLflow 1.24.0 documentation</a></p>
<p><a href="https://www.mlflow.org/docs/latest/tutorials-and-examples/index.html">Tutorials and Examples — MLflow 1.24.0 documentation</a></p>
<p><a href="https://github.com/mlflow/mlflow/tree/master/examples/multistep_workflow">Orchestrating Multistep Workflows</a></p>
<pre><code class="language-shell">conda create -n mlflow -c conda-forge mlflow
pip install mlflow
pip install mlflow[pipelines] # + experimental MLflow Pipelines
pip install mlflow[extras]    # + extra ML libraries and 3rd-party tools
pip install mlflow-skinny     # + lightweight version of MLflow
</code></pre>
<blockquote>
<p><em>MLflow requires <code>conda</code> to be on the <code>PATH</code> for the projects feature.</em></p>
</blockquote>
<h4 id="mlflow-tracking"><a class="header" href="#mlflow-tracking">MLflow Tracking</a></h4>
<p><a href="https://www.mlflow.org/docs/latest/tracking.html#tracking-server">MLflow Tracking — MLflow 1.24.0 documentation</a></p>
<h5 id="tracking-api"><a class="header" href="#tracking-api">Tracking API</a></h5>
<pre><code class="language-python">from mlflow import log_metric, log_param
mlflow.set_tracking_uri(&quot;http://YOUR-SERVER:4040&quot;)  # 默认为本地文件存储
mlflow.set_experiment(&quot;my-experiment&quot;) # 实验名，默认为Default
log_param(&quot;param1&quot;, randint(0, 100))   # 记录输入的参数
log_metric(&quot;foo&quot;, random() + 2)        # 记录输出的指标
</code></pre>
<p>为不同的实验设置不相同的实验名称，从而方便对比实验参数和输出指标。</p>
<p>默认将运行记录写入本地<code>./mlruns</code>目录，可在当前目录下运行<code>mlfllow ui</code>查看其中的运行记录。每个运行记录由唯一的<strong>Run ID</strong>。</p>
<p><strong>Artifacts</strong>包含模型代码、运行环境声明等信息。</p>
<h4 id="mlflow-projects"><a class="header" href="#mlflow-projects">MLflow Projects</a></h4>
<pre><code class="language-shell">mlflow run --no-conda project_path -P param1=value1
</code></pre>
<p>如果指定<code>--no-conda</code>，则MLflow不会自动创建虚拟环境并安装依赖（MLflow内部会维护虚拟环境列表而不会重复创建），而是使用系统已有环境。</p>
<p>项目声明文件：</p>
<pre><code class="language-yaml">name: tutorial           # 项目名称
conda_env: conda.yaml    # 项目使用的虚拟环境配置
entry_points:            # 代码入口信息
  main:                  # 可定义多个入口，按顺序指定（构成处理流程）
    parameters:          # 代码接收的参数
      alpha: {type: float, default: 0.5}
      l1_ratio: {type: float, default: 0.1}
    command: &quot;python train.py {alpha} {l1_ratio}&quot;  # 执行代码的命令
</code></pre>
<p>虚拟环境配置文件：</p>
<pre><code class="language-yaml">name: tutorial           # 虚拟环境名称（MLflow内部使用，映射conda虚拟环境名称）
channels:                # 使用的软件源通道
  - conda-forge
dependencies:            # 依赖库声明
  - python=3.7
  - pip
  - pip:                 # 需要使用pip安装的依赖库
      - scikit-learn==0.23.2
      - mlflow&gt;=1.0
      - pandas
</code></pre>
<h5 id="sklearn"><a class="header" href="#sklearn">sklearn</a></h5>
<p><em>pandas, numpy, and sklearn</em></p>
<h4 id="mlflow-models"><a class="header" href="#mlflow-models">MLflow Models</a></h4>
<h5 id="保存模型"><a class="header" href="#保存模型">保存模型</a></h5>
<pre><code class="language-shell">mlflow.log_artifacts(&quot;output_path&quot;)    # 将本地目录中的内容作为模型内容保存
mlflow.sklearn.log_model(lr, &quot;model&quot;)  # 将模型对象保存到本地
</code></pre>
<h5 id="运行模型"><a class="header" href="#运行模型">运行模型</a></h5>
<pre><code class="language-shell">mlflow models serve -m runs:/&lt;RUN_ID&gt;/model --port 5001
</code></pre>
<p>根据模型自带的环境声明自动创建Conda虚拟环境并运行模型。模型启动后可以通过REST接口向其发送数据。模型将执行预测并输出结果。</p>
<p>运行模型使用的Python版本必须与创建模型时使用的版本一致（否则<code>pickle</code>无法正常工作）。</p>
<h5 id="运行时检测依赖库"><a class="header" href="#运行时检测依赖库">运行时检测依赖库</a></h5>
<p><a href="https://www.mlflow.org/docs/latest/tutorials-and-examples/tutorial.html#specifying-pip-requirements-using-pip-requirements-and-extra-pip-requirements">specifying pip requirements using <code>pip_requirements</code> and <code>extra_pip_requirements</code></a></p>
<h3 id="ray"><a class="header" href="#ray">Ray</a></h3>
<p>📚<a href="https://docs.ray.io/en/latest/ray-air/user-guides.html">User Guides — Ray 2.0.0</a></p>
<h4 id="安装-26"><a class="header" href="#安装-26">安装</a></h4>
<h5 id="机器学习运行环境架构"><a class="header" href="#机器学习运行环境架构">机器学习运行环境架构</a></h5>
<p><img src="%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5.assets/ray-air.svg" alt="" /></p>
<ul>
<li>
<p><a href="https://docs.ray.io/en/latest/data/dataset.html#data-compatibility">Ray Datasets: Distributed Data Preprocessing — Ray 2.0.0</a></p>
</li>
<li>
<p>Ray Train: Scalable Model Training</p>
</li>
<li>
<p>Tune: Scalable Hyperparameter Tuning</p>
</li>
<li>
<p>Serve: Scalable and Programmable Serving</p>
</li>
<li>
<p>RLlib: Industry-Grade Reinforcement Learning</p>
</li>
</ul>
<blockquote>
<p><em>Ray Datasets is designed to load and preprocess data for distributed ML training pipelines.</em></p>
</blockquote>
<p><img src="%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5.assets/air-ecosystem.svg" alt="AIR ecosystem map" /></p>
<blockquote>
<p><a href="https://docs.ray.io/en/latest/ray-air/air-ecosystem.html#air-ecosystem-map">AIR ecosystem map</a>.</p>
</blockquote>
<h5 id="安装机器学习运行环境"><a class="header" href="#安装机器学习运行环境">安装机器学习运行环境</a></h5>
<pre><code class="language-python">conda create -n ray-ml python=3.10
pip install 'ray[air]'                # 包含机器学习运行环境的所有模块
pip install tqdm                      # tqdm用于显示数据处理进度
pip install fastapi                   # 用于模型部署提供API
pip install xgboost xgboost_ray torch tensorflow  
</code></pre>
<p>Ray集成的机器学习框架以及其他工具需要独立安装。</p>
<h4 id="数据预处理-1"><a class="header" href="#数据预处理-1">数据预处理</a></h4>
<p>加载并拆分数据集，构造训练、验证和测试集。</p>
<pre><code class="language-python">dataset = ray.data.read_csv(&quot;s3://anonymous@air-example-data/breast_cancer.csv&quot;)
train_dataset, valid_dataset = dataset.train_test_split(test_size=0.3)
test_dataset = valid_dataset.drop_columns(cols=[&quot;target&quot;])
</code></pre>
<blockquote>
<p>Ray会自动在本地创建一个集群，可通过仪表板查看（<code>http://127.0.0.1:8265</code>）。</p>
</blockquote>
<p>构造预处理器，如标准化等；</p>
<pre><code class="language-python">from ray.data.preprocessors import StandardScaler
preprocessor = StandardScaler(columns=[&quot;mean radius&quot;, &quot;mean texture&quot;])
</code></pre>
<h5 id="预处理器-1"><a class="header" href="#预处理器-1">预处理器</a></h5>
<p>预处理处理标准的数据集对象<code>DataSet</code>。预处理器在训练阶段进行拟合（<code>fit_transform</code>）并应用于训练和服务阶段（<code>transform</code>）。</p>
<p>自定义预处理器：</p>
<pre><code class="language-python">import ray
from pandas import DataFrame
from ray.data.preprocessor import Preprocessor
from ray.data import Dataset
from ray.data.aggregate import Max

class CustomPreprocessor(Preprocessor):
    def _fit(self, dataset: Dataset) -&gt; Preprocessor:
        self.stats_ = dataset.aggregate(Max(&quot;value&quot;))
    def _transform_pandas(self, df: DataFrame) -&gt; DataFrame:
        return df * self.stats_[&quot;max(value)&quot;]
</code></pre>
<p>使用<code>BatchMapper</code>构造无需拟合的预处理</p>
<pre><code class="language-python">preprocessor = BatchMapper(lambda df: df * 2)
</code></pre>
<h4 id="训练模型"><a class="header" href="#训练模型">训练模型</a></h4>
<p>选择常用机器学习框架训练模型。此阶段通常需要输入训练和验证数据集以优化模型，防止过拟合。</p>
<pre><code class="language-python">from ray.air.config import ScalingConfig
from ray.train.xgboost import XGBoostTrainer
trainer = XGBoostTrainer(...)
result = trainer.fit()
print(result.metrics)
</code></pre>
<h4 id="超参数调优"><a class="header" href="#超参数调优">超参数调优</a></h4>
<pre><code class="language-python">from ray import tune
param_space = {&quot;params&quot;: {&quot;max_depth&quot;: tune.randint(1, 9)}}
metric = &quot;train-logloss&quot;

from ray.tune.tuner import Tuner, TuneConfig
from ray.air.config import RunConfig
tuner = Tuner(trainer,param_space=param_space,tune_config=TuneConfig(**kwargs))
result_grid = tuner.fit()
# Fetch the best result.
best_result = result_grid.get_best_result()
print(&quot;Best Result:&quot;, best_result)
</code></pre>
<h4 id="使用模型进行预测"><a class="header" href="#使用模型进行预测">使用模型进行预测</a></h4>
<h5 id="checkpoints"><a class="header" href="#checkpoints">Checkpoints</a></h5>
<p><code>Checkpoint</code>对象由训练器、调优器以及预训练模型生成，用于构建模型对象。</p>
<h5 id="批量预测"><a class="header" href="#批量预测">批量预测</a></h5>
<pre><code class="language-python">from ray.train.batch_predictor import BatchPredictor
from ray.train.xgboost import XGBoostPredictor
# You can also create a checkpoint from a trained model using
# `XGBoostCheckpoint.from_model`.
checkpoint = best_result.checkpoint
batch_predictor = BatchPredictor.from_checkpoint(checkpoint, XGBoostPredictor)
predicted_probabilities = batch_predictor.predict(test_dataset)
predicted_probabilities.show()
</code></pre>
<h4 id="模型部署"><a class="header" href="#模型部署">模型部署</a></h4>
<pre><code class="language-shell">from ray import serve
from fastapi import Request
from ray.serve import PredictorDeployment
from ray.serve.http_adapters import json_request


async def adapter(request: Request):
    content = await request.json()
    print(content)
    return pd.DataFrame.from_dict(content)

serve.start(detached=True)
deployment = PredictorDeployment.options(name=&quot;XGBoostService&quot;)
deployment.deploy(
    XGBoostPredictor, result.checkpoint, batching_params=False, http_adapter=adapter
)
print(deployment.url)
</code></pre>
<pre><code class="language-shell">import requests
sample_input = test_dataset.take(1)
sample_input = dict(sample_input[0])
output = requests.post(deployment.url, json=[sample_input]).json()
print(output)
</code></pre>
<h2 id="参考文献-10"><a class="header" href="#参考文献-10">参考文献</a></h2>
<ol>
<li><a href="https://github.com/Nyandwi/machine_learning_complete">Nyandwi/machine_learning_complete: A comprehensive machine learning repository containing 30+ notebooks on different concepts, algorithms and techniques. (github.com)</a></li>
<li><a href="https://deeplearning-ai.github.io/machine-learning-yearning-cn/docs/ch04/">规模驱动机器学习发展 (deeplearning-ai.github.io)</a></li>
<li><a href="https://github.com/deeplearning-ai/machine-learning-yearning-cn/">deeplearning-ai/machine-learning-yearning-cn: Machine Learning Yearning 中文版 - 《机器学习训练秘籍》 - Andrew Ng 著 (github.com)</a></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="scikit-learn"><a class="header" href="#scikit-learn">Scikit Learn</a></h1>
<h2 id="数据准备-1"><a class="header" href="#数据准备-1">数据准备</a></h2>
<h3 id="数据集划分-1"><a class="header" href="#数据集划分-1"><a href="%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5.html#%E6%95%B0%E6%8D%AE%E9%9B%86%E5%88%92%E5%88%86">数据集划分</a></a></h3>
<pre><code class="language-python">from sklearn.model_selection import train_test_split
X_train, X_test, y_train, y_test = train_test_split(
    df_data,             # 支持DataFrame输出DataFrame, 可省略.to_numpy()
    df_target,           # support 1d array/series
    test_size=0.25, random_state=1
)
</code></pre>
<h2 id="数据预处理-2"><a class="header" href="#数据预处理-2">数据预处理</a></h2>
<h3 id="数值化"><a class="header" href="#数值化">数值化</a></h3>
<h4 id="特征编码"><a class="header" href="#特征编码">特征编码</a></h4>
<h5 id="one-hot-encoder"><a class="header" href="#one-hot-encoder">One-Hot Encoder</a></h5>
<p><code>OneHotEncoder</code>可以利用数据训练得到数据的取值集合，随后用于新数据的编码（<code>fit</code>、<code>transform</code>）；而<code>pd.get_dummies</code>仅能对当前数据进行编码（<code>fit_transform</code>）。</p>
<pre><code class="language-python">from sklearn.preprocessing import OneHotEncoder
enc = OneHotEncoder(categories='auto', drop=None, sparse=True, 
                    dtype=np.float64, handle_unknown='error')
</code></pre>
<p><code>categories</code>：指定离散数据的类型。默认为<code>'auto'</code>，编码器从数据中推导每个特征包含的类别（<code>fit()</code>）；反之，可以为每一列指定离散值（<code>list_of_list</code>，每个特征对应的类别数量可能不同，不适合使用矩阵表示），==每一列的值不应该混合字符串和数值；如果为数值类型，则应该有序==。</p>
<p><code>drop</code>：默认保留编码后的所有列，<code>first</code>：丢弃第一列，去除冗余；<code>if_binary</code>：仅对有两类的列丢弃第一列。</p>
<p><code>sparse</code>：如果设置为<code>True</code>，则在执行<code>transform</code>时，要求数据也是稀疏类型的。</p>
<p><code>enc.categories_</code>：拟合后得到的类别数据取值集合（<code>enc.categories</code>为初始化的集合）。</p>
<p><code>enc.get_feature_names(col_names)</code>：根据原数据列名（<code>col_names</code>为序列类型），生成编码后数据列名；==需要首先执行<code>fit()</code>操作==，<code>fit()</code>返回的是编码后的数值矩阵，可结合生成的列名构建编码后的表格（<code>pd.DataFrame</code>）。</p>
<h4 id="标签编码-1"><a class="header" href="#标签编码-1"><a href="%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5.html#%E6%A0%87%E7%AD%BE%E7%BC%96%E7%A0%81">标签编码</a></a></h4>
<h5 id="labelencoder"><a class="header" href="#labelencoder"><code>LabelEncoder</code></a></h5>
<ul>
<li>
<p><code>fit</code>：统计标签类别；</p>
</li>
<li>
<p><code>transform</code>：将标签根据已知类别进行数字编码。<code>fit_transform</code>：在相同数据上进行类别学习和编码。</p>
</li>
</ul>
<h5 id="labelbinarizer"><a class="header" href="#labelbinarizer"><code>LabelBinarizer</code></a></h5>
<p><code>fit(y)</code>/<code>transform(y)</code>/<code>fit_transform(y)</code>：从<code>y</code>（序列类型）中统计标签的类别，标签按数值/字符串大小排序。</p>
<blockquote>
<p><code>fit</code>决定拟合的类别数量<code>n_classes</code>；<code>transform</code>根据输入决定标签类型：<code>y_type=multiclass/binary/...'</code></p>
</blockquote>
<ul>
<li>
<p>普通情况：拟合数据包含两类（==从小到大==分别为<code>neg_label</code>, <code>pos_label</code>），变换数据包含相同的一类/两类；则对变换数据根据<code>y</code>中二值对应进行编码；由于负标签和正标签总是按拟合数据的大小顺序确定的，因此如果与认为规定的正负标签不一致，可对变换后的编码求反：<code>y=1-y</code>。</p>
</li>
<li>
<p><strong>标签正交二值化</strong>（<code>'multiclass'</code>）：如果<code>fit</code>或<code>transform</code>的数据<code>y</code>至少包含两类，且总类别数超过两类；则将拟合数据<code>y</code>中的每类数值单独进行二值编码，不同类别的标签变换后的编码相互正交。</p>
<pre><code class="language-python">lb.fit(['a', 'b', 'c'])
lb.transform(['c','b','a','d'])
# input l_a l_b l_c    # fit -&gt; a b c
#   c    0   0   1     # 对应类型标签列的值为1，其余为0
#   b    0   1   0
#   a    1   0   0
#   d    0   0   0     # 不属于任何一类 
</code></pre>
</li>
<li>
<p>如果拟合数据只有一类（通常不应该出现），如果变换数据包含除拟合类别外的数值，则将拟合类别视为正类别；<em>如果变换数据也只包含拟合类别，视拟合类别为负类别</em>（即该列为常量，应该剔除）。</p>
</li>
</ul>
<pre><code class="language-python">lb.fit(['b', 'a'])  # 记录拟合的标签 ['a','b']
lb.classes_         # 按大小顺序，与出现顺序无关
y = lb.transform(['a', 'b', 'b','a']) # -&gt;[0, 1, 1, 0]
y = lb.transform(['a', 'b', 'c','a']) # -&gt;[[1,0], [0,1], [0,0], [1,0]]
</code></pre>
<blockquote>
<p>标签二值编码的计算实现：</p>
<pre><code class="language-python">y = column_or_1d(y)  
# pick out the known labels from y
y_in_classes = np.in1d(y, classes) # Test whether each element of a 1-D array is also 
                                   # present in a second array.
y_seen = y[y_in_classes]
indices = np.searchsorted(sorted_class, y_seen) # Find indices where elements should be 
                                                # inserted to maintain order.
                                                # 此处等效查找y的分类序号
indptr = np.hstack((0, np.cumsum(y_in_classes))) # if y_in_classes, then it has 1
                                                 # corresp. index.
data = np.empty_like(indices)
data.fill(pos_label)                            
Y = sp.csr_matrix((data, indices, indptr),      # 每一行只有一个非零元素（只属于一类）
                  shape=(n_samples, n_classes)) # 因此适用于csr_matrix
</code></pre>
</blockquote>
<h5 id="multilabelbinarizer"><a class="header" href="#multilabelbinarizer"><code>MultiLabelBinarizer</code></a></h5>
<p>与<code>LabelBinarizer</code>存在超过两类的情况不同在于，==每个样本可以拥有多个标签，样本标签可以有交集，因此样本二值编码后并不一定相互正交==。如果每个样本仅包含一个标签，则等价于<code>LabelBinarizer</code>。</p>
<pre><code class="language-python">mlb.fit_transform([{'sci-fi', 'thriller'}, {'comedy'}])
# array([[0, 1, 1],
#       [1, 0, 0]])
mlb.classes_
# array(['comedy', 'sci-fi', 'thriller'], dtype=object)
</code></pre>
<p>每个样本的多个标签应该用列表，元组或集合表示。</p>
<blockquote>
<p>上述示例中，总共包括三类标签，记录的类别按标签字典序排序。所以第一个标签样本编码后为<code>011</code>，第二个标签样本编码为<code>100</code>。</p>
</blockquote>
<h3 id="特征生成-1"><a class="header" href="#特征生成-1">特征生成</a></h3>
<h5 id="多项式特征生成-1"><a class="header" href="#多项式特征生成-1">多项式特征生成</a></h5>
<pre><code class="language-python">from sklearn.preprocessing import PolynomialFeatures
pf = PolynomialFeatures(degree=2)
X_train = pf.fit_transform(X_train)  # 生成所有特征的所有二阶及以下多项式组合特征
</code></pre>
<h3 id="特征尺度变换"><a class="header" href="#特征尺度变换">特征尺度变换</a></h3>
<p><code>StandardScaler</code></p>
<p><code>MinMaxScaler</code></p>
<p><code>Normalizer(norm='l2', copy=True)</code></p>
<h2 id="机器学习流程"><a class="header" href="#机器学习流程">机器学习流程</a></h2>
<pre><code class="language-python">steps = [
  ('proc_name', estimator), 
  ...
]
workflow = Pipeline(steps)
pred = workflow.fit(x)		# fit transform/predict
pipe.score(x,y)
pipe['proc_name'].func_name()
</code></pre>
<p>流程的参数可以通过<code>Pipeline.set_params</code>进行修改，也可以<strong>对每个流程的对象单独修改</strong>。</p>
<p>为了与<code>Pipeline</code>保持兼容，相应处理流程需要提供三个参数（<code>self,x,y=None</code>），对于预处理流程第三个参数不起作用。</p>
<h3 id="机器学习算法模型"><a class="header" href="#机器学习算法模型">机器学习算法模型</a></h3>
<h4 id="模型参数"><a class="header" href="#模型参数">模型参数</a></h4>
<pre><code class="language-python">estimator.get_params()
</code></pre>
<h3 id="pipeline工作流"><a class="header" href="#pipeline工作流">Pipeline工作流</a></h3>
<h4 id="featureunion"><a class="header" href="#featureunion">FeatureUnion</a></h4>
<p>多个转换流程并行处理所有数据，并将转换结果合并。</p>
<h4 id="columntransformer"><a class="header" href="#columntransformer">ColumnTransformer</a></h4>
<p>对数据特征执行并行处理，并将结果合并。</p>
<pre><code class="language-python">colunm_trans = ColumnTransformer[
  [('proc_name', proc, idx), ...]
]
</code></pre>
<p><code>proc</code>：可以是具体的对象，或是<code>'passthrough'</code>、<code>'drop'</code>。</p>
<p>Ignored. This parameter exists only for compatibility with <a href="https://scikit-learn.org/stable/modules/generated/sklearn.pipeline.Pipeline.html#sklearn.pipeline.Pipeline"><code>sklearn.pipeline.Pipeline</code></a>.</p>
<h2 id="性能评估-1"><a class="header" href="#性能评估-1">性能评估</a></h2>
<h3 id="交叉验证-1"><a class="header" href="#交叉验证-1"><a href="%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5.html#%E4%BA%A4%E5%8F%89%E9%AA%8C%E8%AF%81">交叉验证</a></a></h3>
<pre><code class="language-python">from sklearn.model_selection import KFold
kf = KFold(n_split=5)
X_train = [None]*5 # X_test = X_train.copy() ...
# 通过迭代依次交换训练/测试集
for train_index, test_index in kf.split(X):
  X_train[i], X_test[i] = X[train_index], X[test_index]
  y_train[i], y_test[i] = y[train_index], y[test_index]
</code></pre>
<h3 id="参数搜索-1"><a class="header" href="#参数搜索-1">参数搜索</a></h3>
<h4 id="网格搜索交叉验证-1"><a class="header" href="#网格搜索交叉验证-1">网格搜索交叉验证</a></h4>
<pre><code class="language-python">from sklearn.model_selection import GridSearchCV
cv = GridSearchCV(estimator, param_grid, scoring=None,jobs=None,cv=None)
cv.fit(data, label)
</code></pre>
<p>参数网格定义：可定义一个或多个参数组合。</p>
<pre><code class="language-python"># 使用字典代表参数网格
param_grid = {'kernel': ('linear', 'rbf'), 'C': [1, 10]}
# 使用字典的列表代表多个参数网格
param_grid = [{'kernel': ['rbf'], 'gamma': [1e-3, 1e-4], 'C': [1, 10, 100]},
              {'kernel': ['linear'], 'C': [1, 10, 100, 1000]}]
</code></pre>
<p>交叉验证参数<code>cv</code>：</p>
<ul>
<li><code>None</code>：默认使用5折交叉验证；</li>
<li><code>N</code>：N折交叉验证；</li>
<li><code>CV splitter</code>：</li>
<li>一个返回<code>(train,test)</code>数据的迭代器。</li>
</ul>
<p>计算结果包括：</p>
<ul>
<li>
<p><code>cv_results_</code>：各个参数组合及其评估性能结果；</p>
</li>
<li>
<p><code>best_estimator_</code>：通过搜索得到的性能最好的模型实例；</p>
</li>
<li>
<p><code>best_score_</code></p>
</li>
<li>
<p><code>best_params_</code></p>
</li>
<li>
<p><code>best_index_</code>：最佳结果在<code>cv_results_</code>中的索引；</p>
</li>
<li></li>
</ul>
<h4 id="随机搜索交叉验证"><a class="header" href="#随机搜索交叉验证">随机搜索交叉验证</a></h4>
<p><code>RandomizedSearchCV</code></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tensorflow"><a class="header" href="#tensorflow">TensorFlow</a></h1>
<p><a href="%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5.html#%E5%AE%89%E8%A3%85TensorFlow">安装TensorFlow</a>。</p>
<h2 id="数据结构-1"><a class="header" href="#数据结构-1">数据结构</a></h2>
<h3 id="tensor"><a class="header" href="#tensor">Tensor</a></h3>
<p>操作间传递的数据的数据结构都是<code>Tensor</code>，内部可以看作储存了一个N维的数组（类似于<code>Numpy.ndarray</code>）。 <a href="http://www.tensorfly.cn/tfdoc/resources/dims_types.html">Rank, Shape, 和 Type.</a></p>
<pre><code class="language-python">x.name         # 'input:0'
x.valaue_index # 0
x.op.name      # 'input'
</code></pre>
<h5 id="创建变量"><a class="header" href="#创建变量">创建变量</a></h5>
<p>当训练模型时，用变量来<strong>存储和更新参数</strong>。变量的初始值可以为Numpy数组或tensorflow提供的初始化方法（<code>tf.zeros</code>、<code>tf.random_normal</code>等）生成。</p>
<pre><code class="language-python">state = tf.Variable(0, name=&quot;counter&quot;)
biases = tf.Variable(tf.zeros([200]), name=&quot;biases&quot;, dtype=tf.int32)
weights = tf.Variable(tf.random_normal([784, 200], stddev=0.35),name=&quot;weights&quot;)
</code></pre>
<p><code>tf.Variable</code>操作储存初始值以及相关信息（例如<code>name</code>）。变量类型至关重要，不同类型的变量无法进行运算。</p>
<h4 id="常量-4"><a class="header" href="#常量-4">常量</a></h4>
<pre><code class="language-python">one = tf.constant(1)
</code></pre>
<h3 id="计算图"><a class="header" href="#计算图">计算图</a></h3>
<p>TensorFlow将耗时计算任务完全运行在Python外部，通过计算图来描述各计算任务（Operation）间的交互。因此Python代码的目的是用来构建这个可以在外部运行的计算图，以及安排计算图的哪一部分应该被运行。</p>
<p>变量的初始化必须在模型的其它操作运行之前先明确地完成。</p>
<pre><code class="language-python"># 在计算图启动之后，变量必须先经过`初始化` 操作初始化
# 事先定义初始化操作：
init_op = tf.initialize_all_variables()
with tf.Session() as sess:
    sess.run(init_op)  # Run the init operation.
    # Use the model
</code></pre>
<p><code>tf.initialize_all_variables()</code>函数便捷地添加一个操作来初始化模型的所有变量。你也可以给它传入一组变量进行初始化。(事实上是一个<code>tf.assign</code>操作)</p>
<p>有时候会需要用另一个变量的初始化值给当前变量初始化，而<code>tf.initialize_all_variables()</code>是并行地初始化所有变量，所以在有这种需求的情况下需要小心。用其它变量的值初始化一个新的变量时，使用其它变量的<code>initialized_value()</code>属性。</p>
<h4 id="激活函数"><a class="header" href="#激活函数">激活函数</a></h4>
<p>内置激活函数定义在<code>tensorflow.keras.activations</code>模块中，可使用激活函数的函数名或函数对象作为<code>activation</code>参数的值。函数名会由<code>tensorflow.keras.activations.deserialize()</code>方法（或<code>get()</code>）转换为函数对象。</p>
<h2 id="session"><a class="header" href="#session">Session</a></h2>
<p>Tensorflow依赖于一个高效的C++后端来进行计算。与后端的这个连接叫做session。一般而言，使用TensorFlow程序的流程是先创建一个图，然后在session中启动它。</p>
<pre><code class="language-python">import tensorflow as tf
sess = tf.Session()
result = sess.run(graph)
sess.close()

with tf.Session() as sess:
    [with tf.device(&quot;/gpu:1&quot;):]
        result = sess.run(result)
</code></pre>
<h3 id="管理多个图"><a class="header" href="#管理多个图">管理多个图</a></h3>
<h3 id="取回结果"><a class="header" href="#取回结果">取回结果</a></h3>
<p>可以在使用<code>Session</code>对象的<code>run()</code>调用 执行图时, 传入一些 tensor, 这些 tensor 会帮助你取回结果。</p>
<h3 id="feed"><a class="header" href="#feed">Feed</a></h3>
<pre><code class="language-python">input1 = tf.placeholder(tf.types.float32)
input2 = tf.placeholder(tf.types.float32)
output = tf.mul(input1, input2)
with tf.Session() as sess:
  print sess.run([output], feed_dict={input1:[7.], input2:[2.]})
</code></pre>
<h3 id="interactivesession"><a class="header" href="#interactivesession">InteractiveSession</a></h3>
<p><code>InteractiveSession</code>让你在运行图的时候，插入一些计算图，这些计算图是由某些操作(operations)构成的。</p>
<p>如果你没有使用<code>InteractiveSession</code>，那么你需要在启动session之前构建整个计算图，然后启动该计算图。</p>
<pre><code class="language-python">import tensorflow as tf
sess = tf.InteractiveSession()
x = tf.Variable([1.0, 2.0])
a = tf.constant([3.0, 3.0])
x.initializer.run()
sub = tf.sub(x, a)
</code></pre>
<h3 id="使用gpu计算"><a class="header" href="#使用gpu计算">使用GPU计算</a></h3>
<p><a href="https://www.tensorflow.org/guide/gpu?hl=zh-cn">使用 GPU  | TensorFlow Core</a></p>
<pre><code class="language-python">devs = tf.config.list_physical_devices()  # 列出计算设备，包括CPU、GPU
with tf.device(devs[0].name.replace('physical_device:','')):
   # 构建计算图
</code></pre>
<p>设备名称形如<code>'/physical_device:CPU:0'</code>，而<code>tf.device</code>只需要<code>'/CPU:0' </code>。 </p>
<h2 id="构建模型"><a class="header" href="#构建模型">构建模型</a></h2>
<h3 id="权重初始化"><a class="header" href="#权重初始化">权重初始化</a></h3>
<blockquote>
<p><em>Weight initialization is a procedure to set the weights of a neural network to small random values that define the starting point for the optimization (learning or training) of the neural network model.</em></p>
<p><em>We cannot initialize all weights to the value 0.0 as the optimization algorithm results in some asymmetry in the error gradient to begin searching effectively.</em></p>
<p><a href="https://machinelearningmastery.com/weight-initialization-for-deep-learning-neural-networks/">Weight Initialization for Deep Learning Neural Networks (machinelearningmastery.com)</a></p>
</blockquote>
<h3 id="训练"><a class="header" href="#训练">训练</a></h3>
<blockquote>
<p><em>We run a machine learning “algorithm” on a dataset to get a machine learning “model.”</em></p>
<ul>
<li><strong>Algorithm</strong>: Procedure run on data that results in a model (e.g. training or learning).</li>
<li><strong>Model</strong>: Data structure and coefficients used to make predictions on data.</li>
</ul>
<p><em>Stochastic machine learning algorithms use randomness during learning, ensuring a different model is trained each run.</em></p>
<ul>
<li>Initialization, such as weights.</li>
<li>Regularization, such as dropout.</li>
<li>Layers, such as word embedding.</li>
<li>Optimization, such as stochastic optimization.</li>
</ul>
<p><a href="https://machinelearningmastery.com/different-results-each-time-in-machine-learning/">Why Do I Get Different Results Each Time in Machine Learning? (machinelearningmastery.com)</a></p>
<p><em>The random initialization allows the network to learn a good approximation for the function being learned. Nevertheless, there are times when you need the exact same result every time the same network is trained on the same data. Such as for a tutorial, or perhaps operationally.</em></p>
<h5 id="seed-the-random-number-generator"><a class="header" href="#seed-the-random-number-generator">Seed the Random Number Generator</a></h5>
<p><em>Random number generators require a seed to kick off the process, and it is common to use the current time in milliseconds as the default in most implementations.</em></p>
</blockquote>
<pre><code class="language-python">from numpy.random import seed
seed(1)
from tensorflow import set_random_seed
set_random_seed(2)
</code></pre>
<blockquote>
<p><em>This is a best practice because it is possible that some randomness is used when various Keras or Theano (or other) libraries are imported as part of their initialization, even before they are directly used.</em></p>
</blockquote>
<h2 id="keras"><a class="header" href="#keras">Keras</a></h2>
<p>Keras库结构：</p>
<ul>
<li>
<p>models：包括神经网络模型的定义，例如<code>Sequential</code>。</p>
<pre><code class="language-python">from keras.models import Sequential
</code></pre>
</li>
<li>
<p>layers：神经网络各层的模型定义，例如<code>Dense</code>。</p>
<pre><code class="language-python">from keras.layers import Dense
model.layers # 获取模型中各层对象。
</code></pre>
</li>
</ul>
<h3 id="模型类"><a class="header" href="#模型类">模型类</a></h3>
<h4 id="sequential"><a class="header" href="#sequential">Sequential</a></h4>
<h3 id="层类"><a class="header" href="#层类">层类</a></h3>
<h4 id="输入-2"><a class="header" href="#输入-2">输入</a></h4>
<p><code>Input</code>类：限定模型的输入维度。</p>
<pre><code class="language-python">input=Input(shape=, batch_shape=, name=, dtype=, sparse=, tensor=)
</code></pre>
<p>当模型仅包含输入层时，模型不包含任何可训练参数（权重矩阵和偏置）；训练参数位于两层之间。使用<code>model.summary()</code>可查看层定义、输出维数以及参数数量，使用<code>model.inputs</code>, <code>model.outputs</code>查看整个模型的输入输出维数。</p>
<h4 id="预处理"><a class="header" href="#预处理">预处理</a></h4>
<p><a href="https://www.tensorflow.org/guide/keras/preprocessing_layers">Working with preprocessing layers  | TensorFlow Core</a></p>
<h5 id="normalization"><a class="header" href="#normalization">Normalization</a></h5>
<h4 id="dense"><a class="header" href="#dense">Dense</a></h4>
<pre><code class="language-python">layer = Dense(
    units,                     # 计算单元数量（输出数量）
    activation=None,           # 激活函数,不指定则直接输出
    use_bias=True,             # 是否添加偏置
    bias_initializer=&quot;zeros&quot;,  # 偏置向量初始化函数
    kernel_initializer=&quot;glorot_uniform&quot;, # 权重矩阵初始化方法
    **kwargs
)
</code></pre>
<p>其他参数<code>kernel_regularizer, bias_regularizer, activity_regularizer, kernel_constraint, bias_constraint</code>。</p>
<p>模型参数数量：<code>(num_input+1)*units</code>，每个计算单元对应一组权重和一个偏置：$\mathbf{y}=\mathbf{Wx}+\mathbf{b}$；</p>
<h4 id="conv2d"><a class="header" href="#conv2d"><a href="https://keras.io/api/layers/convolution_layers/convolution2d/">Conv2D</a></a></h4>
<p><a href="%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%8E%9F%E7%90%86%E4%B8%8E%E7%AE%97%E6%B3%95.html#%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9CCNN">2D卷积层</a>：创建卷积核与输入数据进行运算（$\mathbf{y}=\mathbf{wx}+b$）。</p>
<pre><code class="language-python">layer = Conv2D(
   filters,         # 每个输入通道的卷积核数量（对应输出图像的数量）
   kernel_size,     # 卷积核大小
   strides=(1, 1),  # 卷积滑动的步长
   padding='valid', # 边缘填充，&quot;valid&quot;不填充，&quot;same&quot;填充0
   data_format=&quot;channels_last&quot;, 
   input_shape=(28,28,3),               # 28*28 RGB image
   activation=None, use_bias=True, bias_initializer='zeros',            
   kernel_initializer='glorot_uniform', # 卷积核(权重矩阵)初始化函数
   **kwargs) -&gt; None
</code></pre>
<p><code>data_format</code>：输入数据格式，数据中RGB通道的表示方式：<code>channels_last-&gt;(batch_size, height, width, channels)</code>；<code>channels_first-&gt;(batch_size, channels, height, width)</code>；</p>
<p><code>input_shape</code>：当作为输入层时，使用此参数指定输入数据样本的维数（对应<code>data_format</code>去掉<code>batch_size</code>）。</p>
<blockquote>
<p>其他参数：<code>dilation_rate, groups,</code></p>
</blockquote>
<p>输出维数：</p>
<ul>
<li><code>channels_last-&gt;(batch_size, new_rows, new_cols, filters)</code>；</li>
<li><code>channels_first-&gt;(batch_size, filters, new_rows, new_cols)</code>；</li>
</ul>
<h4 id="maxpooling2d"><a class="header" href="#maxpooling2d">MaxPooling2D</a></h4>
<h4 id="upsampling2d"><a class="header" href="#upsampling2d">UpSampling2D</a></h4>
<h3 id="构建编译模型"><a class="header" href="#构建编译模型">构建编译模型</a></h3>
<h5 id="构建模型-1"><a class="header" href="#构建模型-1">构建模型</a></h5>
<p><strong>顺序式</strong>构建：创建<code>Sequential</code>对象，并使用<code>model.add(layer)</code>方法逐次添加层。</p>
<pre><code class="language-python">from tf.keras import Input,Model
from tf.keras.layers import Dense
model = tf.keras.Sequential()
model.add(Dense(8, input_shape=(16,))) 
model.add(Dense(4))                    # automatic shape inference
</code></pre>
<blockquote>
<p><code>input_shape</code>参数用于限定模型的输入数据维数，等效于首先添加<code>Input(shape=(16,))</code>；如果未指定输入维数，则会在训练时根据输入维数确定输入层到第一层的权重矩阵维数。</p>
</blockquote>
<p><strong>函数式API</strong>：将每层对象视为函数，将前一层的输出作为该层的输入；最后使用输入和最后的输出构建模型，通过输入输出关系构建整个网络。</p>
<pre><code class="language-python">inputs = Input(shape=(3,))
x = Dense(4, activation=tf.nn.relu)(inputs)     
outputs = Dense(5, activation=tf.nn.softmax)(x)
model = Model(inputs=inputs, outputs=outputs)  
</code></pre>
<h5 id="配置keras模型"><a class="header" href="#配置keras模型"><a href="https://keras.io/api/models/model_training_apis/">配置Keras模型</a></a></h5>
<pre><code class="language-python">model.compile(
    optimizer=&quot;rmsprop&quot;,   # 优化算法
    loss=None,             # 损失函数
    metrics=None,          # 性能度量函数，如accuracy,mse
    loss_weights=None,
    weighted_metrics=None,
    **kwargs
)
</code></pre>
<blockquote>
<p><a href="https://www.tensorflow.org/api_docs/python/tf/keras/optimizers">优化算法：<code>&quot;sgd&quot;, &quot;adam&quot;, ...</code></a>；</p>
<p><a href="https://www.tensorflow.org/api_docs/python/tf/keras/losses">损失函数</a>；</p>
<p><a href="https://www.tensorflow.org/api_docs/python/tf/keras/metrics">性能度量函数</a>；</p>
</blockquote>
<h5 id="训练模型-1"><a class="header" href="#训练模型-1">训练模型</a></h5>
<pre><code class="language-python">fit()
</code></pre>
<blockquote>
<p><a href="https://keras.io/api/callbacks/model_checkpoint/"><code>ModelCheckpoint</code></a> callback is used in conjunction with training using <code>model.fit()</code> to save a model or weights (in a checkpoint file) at some interval, so the model or weights can be loaded later to continue the training from the state saved.</p>
</blockquote>
<h3 id="自定义模型组件"><a class="header" href="#自定义模型组件">自定义模型组件</a></h3>
<h4 id="自定义模型"><a class="header" href="#自定义模型">自定义模型</a></h4>
<pre><code class="language-python">class CustomModel(keras.Model):
  def get_config(self):
    return {&quot;hidden_units&quot;: self.hidden_units}
  @classmethod
  def from_config(cls, config):
    return cls(**config)
</code></pre>
<p><strong>自定义模型的导入导出</strong>：需要定义<code>get_config()</code>方法用于导出自定义类型的参数，<code>from_config</code>用于正确初始化模型和层对象。</p>
<h4 id="自定义层"><a class="header" href="#自定义层">自定义层</a></h4>
<pre><code class="language-python">class CustomLayer(keras.Layer):
  pass
</code></pre>
<p><a href="https://www.tensorflow.org/guide/keras/custom_layers_and_models">Making new Layers and Models via subclassing  | TensorFlow Core</a></p>
<h3 id="常见问题-8"><a class="header" href="#常见问题-8">常见问题</a></h3>
<ol>
<li><a href="https://stackoverflow.com/questions/40785224/tensorflow-cannot-interpret-feed-dict-key-as-tensor">neural network - Tensorflow: Cannot interpret feed_dict key as Tensor - Stack Overflow</a></li>
</ol>
<h2 id="序列化数据和模型"><a class="header" href="#序列化数据和模型">序列化数据和模型</a></h2>
<h3 id="保存tensorflow模型"><a class="header" href="#保存tensorflow模型">保存TensorFlow模型</a></h3>
<h5 id="protocol-buffers"><a class="header" href="#protocol-buffers">Protocol Buffers</a></h5>
<p><a href="https://developers.google.com/protocol-buffers/docs/pythontutorial">Why Use Protocol Buffers?</a></p>
<h4 id="保存和加载计算图"><a class="header" href="#保存和加载计算图">保存和加载计算图</a></h4>
<p>The <code>GraphDef</code> class is an object created by the <em>ProtoBuf</em> library. After you've created a TensorFlow <code>Graph</code> object, you can save it out by calling <code>as_graph_def()</code>, which returns a <code>GraphDef</code> object.</p>
<p>保存<code>GraphDef</code>。</p>
<pre><code class="language-python">tf.io.write_graph(
    graph_or_graph_def, # A Graph or a GraphDef protocol buffer.
    logdir, # Directory where to write the graph
    name,	# file name
    as_text=True # By default, writes as an ASCII proto
)
</code></pre>
<h5 id="text-and-binary-formats"><a class="header" href="#text-and-binary-formats">Text and Binary Formats</a></h5>
<p>Text Format is a human-readable form, which makes it nice for debugging and editing, but can get large when there's numerical data like weights stored in it.</p>
<p>Binary format files are a lot smaller than their text equivalents, even though they're not as readable.</p>
<pre><code class="language-python">f.write(graph_def.SerializeToString())  # save as binary
graph_def.ParseFromString(f.read())     # read from binary
</code></pre>
<h4 id="保存和加载变量"><a class="header" href="#保存和加载变量">保存和加载变量</a></h4>
<h5 id="保存变量"><a class="header" href="#保存变量">保存变量</a></h5>
<pre><code class="language-python">saver = tf.train.Saver()
with tf.Session() as sess:
  sess.run(init_op)
  # Do some work with the model.
  # Save the variables to disk.
  save_path = saver.save(sess, &quot;/tmp/model.ckpt&quot;)
  print(&quot;Model saved in path: %s&quot; % save_path)
</code></pre>
<p>默认保存全部变量。在创建Saver对象时指定要保存的变量，可以创建多个Saver对象以保存不同分组的变量。</p>
<pre><code class="language-python"># Add ops to save and restore only `v2` using the name &quot;v2&quot;
saver = tf.train.Saver({&quot;v2&quot;: v2})
</code></pre>
<h5 id="恢复变量"><a class="header" href="#恢复变量">恢复变量</a></h5>
<p>恢复变量时无需执行初始化操作。如果只是恢复部分变量，那么需要在会话开始前初始化其他变量。</p>
<pre><code class="language-python">saver = tf.train.Saver()
# Later, launch the model
with tf.Session() as sess:
	# Restore variables from disk.
	saver.restore(sess, &quot;/tmp/model.ckpt&quot;)
    # do some work with the model
</code></pre>
<h4 id="保存和加载模型"><a class="header" href="#保存和加载模型">保存和加载模型</a></h4>
<p><code>simple_save</code>：模型（<code>*.pb</code>）和变量（<code>/variables</code>）分别输出（等效于使用<code>Saver.save</code>+<code>tf.io.write</code>）。</p>
<pre><code class="language-python">tf.saved_model.simple_save(
    session,
    export_dir,
    inputs,		// providing names for model's inputs
    outputs,	// providing names for model's outputs
    legacy_init_op=None
)
</code></pre>
<p>检查保存后的模型：</p>
<pre><code class="language-shell">saved_model_cli show --dir {export_path} --all
</code></pre>
<h5 id="serve-your-model-with-tensorflow-serving"><a class="header" href="#serve-your-model-with-tensorflow-serving">Serve your model with TensorFlow Serving</a></h5>
<p>https://www.tensorflow.org/tfx/tutorials/serving/rest_simple#serve_your_model_with_tensorflow_serving</p>
<h5 id="savedmodel"><a class="header" href="#savedmodel">SavedModel</a></h5>
<p><code>builder = tf.saved_model.builder.SavedModelBuilder(export_dir)</code></p>
<p><code>builder.add_meta_graph_and_variables</code>
<code>builder.add_meta_graph</code></p>
<p>A <strong>MetaGraph</strong> is a dataflow graph, plus its associated variables, assets, and signatures. 
A <code>MetaGraphDef </code>is the protocol buffer representation of a MetaGraph. 
A <strong>signature</strong> is the set of inputs to and outputs from a graph.</p>
<p><code>tf.saved_model.loader.load</code></p>
<p><code>Estimators</code>自动保存和恢复变量。</p>
<img src="机器学习/TensorFlow.assets/1564058159981.png" alt="1564058159981" style="zoom: 67%;" />
<h4 id="export"><a class="header" href="#export">Export</a></h4>
<h5 id="freezing"><a class="header" href="#freezing">Freezing</a></h5>
<p>The <em>weights</em> usually aren't stored inside the file format during training. Instead, they're held in separate <em>checkpoint</em> files, and there are <code>Variable</code> ops in the graph that load the latest values when they're initialized.</p>
<p>==there's the <code>freeze_graph.py</code> script that takes a graph definition and a set of checkpoints and freezes them together into a single file.==</p>
<pre><code class="language-python">tensorflow.python.tools.freeze_graph.freeze_graph(...)
</code></pre>
<p><code>freeze_graph</code>调用以下方法将图中的变量（权重）转换为常量：</p>
<pre><code class="language-python">tf.graph_util.convert_variables_to_constants( 
    sess,             # Active TensorFlow session
    input_graph_def,  # GraphDef object holding the network
    output_node_names, # List of node names for the result graph.
    variable_names_whitelist=None,
    variable_names_blacklist=None
)# Warning: deprecated
</code></pre>
<blockquote>
<p>将图中的变量全部替换为常量，使得图能够以单一<code>GraphDef</code>对象被导出保存，同时也移除了关于加载和保存变量的操作。
默认转换所有变量（<code>variable_names_whitelist=None</code>）。
返回：<code>GraphDef</code>对象。</p>
</blockquote>
<h3 id="导入导出keras模型"><a class="header" href="#导入导出keras模型">导入导出Keras模型</a></h3>
<p>Keras模型包括：</p>
<ul>
<li>架构，即该模型所包含的层及其连接关系配置；</li>
<li>权重值集合，即模型的状态；</li>
<li>优化器（通过编译模型定义）；</li>
<li>损失度量指标（通过编译模型、调用<code>add_loss()</code>或<code>add_metric()</code>定义）。</li>
</ul>
<p>Keras支持将上述所有信息一次性保存（<code>SaveModel</code>或<code>H5</code>格式），或选择其中部分保存（如使用<code>JSON</code>格式保存架构）。</p>
<h5 id="导入导出完整模型数据"><a class="header" href="#导入导出完整模型数据">导入导出完整模型数据</a></h5>
<pre><code class="language-python">from tensorflow import keras
model.save(filepath,overwrite=True,include_optimizer=True,
    save_format=None,  # 'tf'(tf2.x) or 'h5'(tf1.x)
) # signatures=None, options=None, save_traces=True,
keras.models.save_model(model,...)  # --&gt; Model.save()
</code></pre>
<p><code>SaveModel</code>导出数据为一个文件夹，其中模型架构、训练配置（包括优化器、损失和度量指标）保存在<code>saved_model.pb</code>中，训练权重保存在<code>variabes/</code>目录下。相比之下，<code>H5</code>格式为单个<code>HDF5</code>文件，且不包含外部添加（<code>add_loss()</code>或<code>add_metric()</code>）的损失和度量指标（需要在加载模型时重新添加），不包含自定义类的计算图（需要在加载时通过这些对象的代码重构模型）。</p>
<p>如果某种序列化方式不能存储自定义模型或层的Python字节码，则加载时需要通过<code>custom_objects</code>参数来指定这些对象类型的名称和类名映射。如果目标平台无法导入自定义代码，则可以使用<code>pickle</code>等方法导入导出自定义类型的代码数据（不安全且存在兼容性问题）。</p>
<p><code>save_traces=True</code>[tf2.4]：在没有自定义类型的定义代码情况下也能加载模型；否则，自定义对象必须定义<code>get_config/from_config</code>方法，并在加载时通过<code>custom_objects</code>传递的类型定义进行初始化。</p>
<p>加载模型：</p>
<pre><code class="language-python">keras.models.load_model(filepath, custom_objects=None) #  compile=True, options=None 
</code></pre>
<h5 id="导入导出模型结构和权重"><a class="header" href="#导入导出模型结构和权重">导入导出模型结构和权重</a></h5>
<p>将模型架构导出为Python字典或JSON文本，其中包含了各层的类型、参数定义与连接关系。</p>
<pre><code class="language-python">config:dict = model.get_config() # the configuration of the model.
Sequential.from_config(config)   # Model.from_config(config)
</code></pre>
<pre><code class="language-python">config:str = model.to_json() # not include the weights, only the architecture.
model = keras.models.model_from_json()  # recover the model
</code></pre>
<blockquote>
<p>等效API：<code>tf.keras.models.model_to_json()</code>。</p>
<p>YAML格式：<code>model.to_yaml()  </code>和<code>keras.models.model_from_yaml()</code>。</p>
</blockquote>
<p>导入导出模型权重参数：</p>
<pre><code class="language-python">model.get_weights()  # A list of all weight tensors in the model, as Numpy arrays.
model.save_weights() # saves the weights of the model as a HDF5 file.
model.load_weights() # the architecture is expected to be unchanged.
model.set_weights()  # same shape as get_weights()
</code></pre>
<p>此外，还可以<a href="https://www.tensorflow.org/guide/keras/save_and_serialize#saving_loading_only_the_models_weights_values">调用层对象的方法</a>获取层的权重值，适用于迁移学习中权重系数迁移。</p>
<p>加载完模型架构和参数后，需要调用<code>model.compile()</code><a href="%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/TensorFlow.html#%E9%85%8D%E7%BD%AEKeras%E6%A8%A1%E5%9E%8B">重新编译模型</a>（和最初构建时的编译配置相同）。</p>
<p><a href="https://www.tensorflow.org/guide/keras/custom_layers_and_models#saving_loading_only_the_models_weights_values">Saving &amp; loading only the model's weights values</a></p>
<h2 id="应用示例"><a class="header" href="#应用示例">应用示例</a></h2>
<h3 id="softmax模型"><a class="header" href="#softmax模型">SoftMAX模型</a></h3>
<h4 id="数据集介绍"><a class="header" href="#数据集介绍">数据集介绍</a></h4>
<p>MINST(Modified National Institute of Standards and Technology)数据集。</p>
<h5 id="训练数据集mnisttrainimages"><a class="header" href="#训练数据集mnisttrainimages">训练数据集<code>mnist.train.images</code></a></h5>
<p><code>mnist.train.images</code>是一个形状为<code>[60000, 784]</code>的张量</p>
<img src="机器学习/TensorFlow.assets/mnist-train-xs.png" alt="img" style="zoom: 33%;" />
<p>每一张图片包含$28\times28$像素。</p>
<img src="机器学习/TensorFlow.assets/MNIST-Matrix.png" alt="img" style="zoom: 50%;" />
<p>训练数据集标签<code>mnist.train.labels</code>是一个 <code>[60000, 10]</code> 的数字矩阵。 </p>
<img src="机器学习/TensorFlow.assets/mnist-train-ys.png" alt="label" style="zoom: 33%;" />
<h4 id="softmax-regression"><a class="header" href="#softmax-regression">Softmax Regression</a></h4>
<p>给定图片代表每个数字的概率。</p>
<blockquote>
<p>为了得到一张给定图片属于某个特定数字类的证据（evidence），我们对图片像素值进行加权求和。如果这个像素具有很强的证据说明这张图片不属于该类，那么相应的权值低，相反如果这个像素拥有有利的证据支持这张图片属于这个类，对应权值高。</p>
<p>我们也需要加入一个额外的偏置量（bias），因为输入往往会带有一些无关的干扰量。</p>
</blockquote>
<p>对于给定的输入图片$\boldsymbol{x}$，它代表数字$i$的<strong>证据</strong>可以表示为</p>
<p>$$
e_i=\sum_{j}{W_{i,j}x_j+b_i}
$$</p>
<p>其中$\boldsymbol{W}_i$ 代表权重，$\boldsymbol{b}<em>i$代表数字$i$类的偏置量，$j$代表给定图片$\boldsymbol{x}$的第$j$个像素。
$$
y=\mathrm{softmax}(e_i)
$$
这里的$\mathrm{softmax}$可以看成是一个激励函数，把我们定义的线性函数的输出转换成我们想要的格式，也就是关于10个数字类的概率分布。
$$
\begin{align}
y &amp; = \mathrm{softmax}(\boldsymbol{e})=\mathrm{normalize}(\mathrm{exp}(\boldsymbol{e})) \Rightarrow\
y_i&amp;= \mathrm{softmax}(e_i)=\frac{\mathrm{exp}(e_i)}{\sum</em>{j}\mathrm{exp}(e_j)}\Rightarrow\
y&amp;=\mathrm{softmax}(\boldsymbol{W}_i\boldsymbol{x}+\boldsymbol{b})
\end{align}
$$
这个幂运算表示，更大的证据对应假设模型里面更大的乘数权重值。反之，拥有更少的证据意味着在假设模型里面拥有更小的乘数系数。将上述过程表示为图的形式：</p>
<img src="机器学习/TensorFlow.assets/softmax-regression-scalargraph.png" alt="img" style="zoom: 15%;" />
<h4 id="tensorflow实现"><a class="header" href="#tensorflow实现">TensorFlow实现</a></h4>
<ol>
<li>
<p>为<strong>输入图像</strong>和<strong>目标输出类别</strong>创建节点，来开始构建计算图。</p>
<pre><code class="language-python">x = tf.placeholder(&quot;float&quot;, shape=[None, 784])
y_ = tf.placeholder(&quot;float&quot;, shape=[None, 10])
</code></pre>
</li>
<li>
<p>为模型定义权重$W$和偏置$b$。</p>
<pre><code class="language-python">W = tf.Variable(tf.zeros([784,10]))
b = tf.Variable(tf.zeros([10]))
</code></pre>
</li>
<li>
<p>初始化变量</p>
<pre><code class="language-python">sess.run(tf.initialize_all_variables())
</code></pre>
</li>
<li>
<p>回归模型计算图</p>
<p>计算每个分类的softmax概率值：</p>
<pre><code class="language-python">y = tf.nn.softmax(tf.matmul(x,W) + b)
</code></pre>
<p>为训练过程指定最小化误差用的损失函数（目标类别和预测类别之间的交叉熵）：</p>
<pre><code class="language-python">cross_entropy = -tf.reduce_sum(y_*tf.log(y))
</code></pre>
</li>
<li>
<p>训练模型</p>
<p>因为TensorFlow知道整个计算图，它可以使用自动微分法找到对于各个变量的损失的梯度值。TensorFlow有大量内置的优化算法。</p>
<pre><code class="language-python">train_step = tf.train.GradientDescentOptimizer(0.01).minimize(cross_entropy)
</code></pre>
<p>往计算图上添加一个新操作，其中包括计算梯度，计算每个参数的步长变化，并且计算出新的参数值。</p>
<p>整个模型的训练可以通过反复地运行train_step来完成。</p>
<pre><code class="language-python">for i in range(1000):
  batch = mnist.train.next_batch(50)
  train_step.run(feed_dict={x: batch[0], y_: batch[1]})
</code></pre>
<p>每一步迭代，我们都会加载50个训练样本，然后执行一次train_step，并通过<code>feed_dict</code>将<code>x</code> 和 <code>y_</code>张量占位符用训练训练数据替代。</p>
</li>
<li>
<p>评估模型</p>
<pre><code class="language-python">correct_prediction = tf.equal(tf.argmax(y,1), tf.argmax(y_,1))
accuracy = tf.reduce_mean(tf.cast(correct_prediction, &quot;float&quot;))
</code></pre>
</li>
</ol>
<h3 id="多层卷积网络"><a class="header" href="#多层卷积网络">多层卷积网络</a></h3>
<h4 id="深入mnist"><a class="header" href="#深入mnist">深入MNIST</a></h4>
<p><strong>权重初始化</strong>：加入少量的噪声来打破对称性以及避免0梯度。</p>
<p>偏置初始化：由于我们使用的是ReLU神经元，因此比较好的做法是用一个较小的正数来初始化偏置项，以避免神经元节点输出恒为0的问题（dead neurons）。</p>
<pre><code class="language-python">def weight_variable(shape):
  initial = tf.truncated_normal(shape, stddev=0.1)
  return tf.Variable(initial)

def bias_variable(shape):
  initial = tf.constant(0.1, shape=shape)
  return tf.Variable(initial)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pytorch"><a class="header" href="#pytorch">Pytorch</a></h1>
<h2 id="pytorch张量"><a class="header" href="#pytorch张量"><a href="%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5.html#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">PyTorch张量</a></a></h2>
<p>PyTorch张量<code>torch.Tensor</code>表示高维数组结构，方法参考<a href="%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/../Python/Python%E6%95%B0%E5%80%BC%E8%AE%A1%E7%AE%97.html#%E7%9F%A9%E9%98%B5"><code>numpy.ndarray</code></a>，张量运算方法可以通过<code>torch</code>模块<strong>和/或</strong>张量对象访问。</p>
<pre><code class="language-python">x = torch.tensor([1,2,3],dtype=torch.float32)
x = torch.arange(0,12).reshape(3,4)
x.numel()   # =&gt; np.size
</code></pre>
<p>张量对象变换：</p>
<pre><code class="language-python">torch.concat(X,Y,dim=0)  # &lt;=&gt; torch.cat() =&gt; np.concatenate()
</code></pre>
<p>张量与<code>ndarray</code>相互转换（<code>.numpy</code>和<code>.from_numpy</code>方法共享底层内存）。</p>
<pre><code class="language-python">A=X.numpy()   # X=torch.Tensor(A)
</code></pre>
<p>对于大小为1的张量，可通过Python内置函数转换为标量。</p>
<h3 id="运算-2"><a class="header" href="#运算-2">运算</a></h3>
<p>矩阵向量乘积（matrix-vector product）：<code>y=torch.mv(A,x)</code>；</p>
<p><strong>矩阵乘法</strong>（matrix-matrix multiplication）：<code>C=torch.mm(A,B)</code>；</p>
<h5 id="范数"><a class="header" href="#范数">范数</a></h5>
<pre><code class="language-python">x=torch.norm(u,p='fro')   # (L2) norm
x=torch.abs(u).sum()      # =&gt; L1 norm
x=torch.frobenius_norm(A) # matrix L2 norm
</code></pre>
<h3 id="梯度"><a class="header" href="#梯度">梯度</a></h3>
<p>创建张量时可同时分配存储梯度的空间，用于后续反向求导时更新梯度值。PyTorch提供自动计算梯度的功能。</p>
<pre><code class="language-python">x=torch.arange(4.0,requires_grad=True)  # x.requires_grad_(True)
y.backward()  # 方向传导自动计算梯度
x.grad        # 梯度值（未计算前为None）
x.grad.zero_()# 重新计算梯度前需要清除先前的结果，默认会累积梯度
u=y.detach()  # 将u视为常量，不再反向传播 
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="dgl-1"><a class="header" href="#dgl-1">DGL</a></h2>
<p><em><strong>Deep Graph Library</strong></em>基于深度学习框架（PyTorch, MXNet and TensorFlow），用于快速实现图神经网络模型。</p>
<h3 id="节点分类"><a class="header" href="#节点分类">节点分类</a></h3>
<h5 id="semi-supervised-node-classification-with-gnnkipf2016semi"><a class="header" href="#semi-supervised-node-classification-with-gnnkipf2016semi">semi-supervised node classification with GNN[@kipf2016semi]</a></h5>
<h2 id="参考资料-12"><a class="header" href="#参考资料-12">参考资料</a></h2>
<div class="footnote-definition" id="intro-dgl"><sup class="footnote-definition-label">1</sup>
<p><a href="https://docs.dgl.ai/tutorials/blitz/index.html">A Blitz Introduction to DGL — DGL 0.9.1 documentation</a>.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="机器学习与数据挖掘"><a class="header" href="#机器学习与数据挖掘">机器学习与数据挖掘</a></h1>
<p>(<em><strong>Machine Learning and Data Mining</strong></em>)</p>
<h2 id="概念"><a class="header" href="#概念">概念</a></h2>
<p><a href="http://statweb.stanford.edu/%7Etibs/stat315a/glossary.pdf">机器学习与统计学概念</a>对比</p>
<div class="table-wrapper"><table><thead><tr><th>Machine Learning</th><th>Statistics</th></tr></thead><tbody>
<tr><td>网络、图</td><td>模型</td></tr>
<tr><td>权重</td><td>参数</td></tr>
<tr><td>学习</td><td>拟合</td></tr>
<tr><td>监督学习</td><td>回归/分类</td></tr>
<tr><td>无监督学习</td><td>密度估计、聚类</td></tr>
</tbody></table>
</div>
<p>parametric model:  fixed number of parameters.</p>
<p>nonparametric model: the number of parameters grow with the amount of training data.</p>
<h3 id="监督学习"><a class="header" href="#监督学习">监督学习</a></h3>
<h4 id="分类"><a class="header" href="#分类">分类</a></h4>
<p>$$
\newcommand{\bm}[1]{\boldsymbol{#1}} 
\newcommand{\b}[1]{\bold{#1}}
\newcommand{\t}[1]{{#1}^{\top}}
\newcommand{\l}{\left}
\newcommand{\r}{\right}
\bm{x}\rightarrow y\in{1,\cdots,C}
$$</p>
<p>$C=2$：二分类（<em>binary classification</em>）；</p>
<p>$C&gt;2$：多分类（<em>multi-class classification with a single output</em>）；</p>
<p>多重二元分类（multi-label classification）：标签不互斥。</p>
<h5 id="function-approximation"><a class="header" href="#function-approximation">Function Approximation</a></h5>
<p>未知分类函数（<em>hypothesis</em>）：$y=h(\bm{x})$。</p>
<p>目标：根据训练集估计分类函数$\hat{y}=\hat{h}(\bm{x})$。</p>
<p>预测：使用估计函数计算新数据的分类。</p>
<h4 id="经验风险最小化"><a class="header" href="#经验风险最小化">经验风险最小化</a></h4>
<p>Empirical risk minimization</p>
<h5 id="损失函数loss-function"><a class="header" href="#损失函数loss-function">损失函数（loss function）</a></h5>
<p>$$
l(\hat{y},y)=l(h(x),y)
$$</p>
<p>L2范数是常用于损失函数，即：$l(\hat{y},y)=|h(x)-y|^2$</p>
<h5 id="期望风险"><a class="header" href="#期望风险">期望风险</a></h5>
<p>$$
R(h)=\b{E}\left[l(h(x),y\right]=\begin{cases}
\int\limits_{x\in\mathcal{D}}{l(h(x),y)\mathrm{d}P(x,y)}<del>(连续变量)\
\sum\limits_{x\in\mathcal{D}}{l(h(x),y)P(x,y)}</del>(离散变量)
\end{cases}
$$</p>
<p>目标：求最优预测模型（函数$h^<em>$），使得期望风险最小：
$$
h^</em>=\mathop{\mathrm{argmax}}_{h\in\mathcal{H}}{R(h)}
$$</p>
<p>由于联合分布$P(x,y)$通常未知使得$R(h)$无法计算，因此使用训练集上的<strong>经验风险</strong>作为近似：
$$
R_{\mathrm{emp}}(h)=\frac{1}{n}\sum_{i=1}^n{l(h(x_i),y_i)}
$$
即优化目标为最小化经验风险
$$
\hat{h}=\mathop{\mathrm{argmin}}<em>{h\in\mathcal{H}}{R</em>{\mathrm{emp}}(h)}
$$</p>
<h4 id="概率预测probabilistic-predictions"><a class="header" href="#概率预测probabilistic-predictions">概率预测（Probabilistic Predictions）</a></h4>
<p>使用概率作为估计分类函数的输出，以应对模糊的情况。</p>
<p>给定训练集$\mathcal{D}$和输入数据$\bm{x}$，可以表示关于各个分类标签的条件概率$p(y|\bm{x},\mathcal{D})$（使用的预测模型$M$也是条件之一，没有对比模型的情况下省略）。</p>
<p>分类函数：<strong>MAP</strong> (<em>maximum a posteriori</em>，最大后验概率) 估计，选择最大可能的类别。
$$
\hat{y}=\hat{h}(\boldsymbol{x})=\mathop{\mathrm{argmax}}_{c=1}^C{p(y=c|\boldsymbol{x},\mathcal{D})}
$$</p>
<h3 id="无监督学习"><a class="header" href="#无监督学习">无监督学习</a></h3>
<p>发现数据中结构（知识发现）。</p>
<p>目标：估计数据的概率密度分布$p(\bm{x}_i|\bm{\theta})$，其中$\bm{x}_i$ 为数据特征组成的向量，$\bm{\theta}$为数据采样空间的参数，因此这是一个多维概率模型。</p>
<h3 id="半监督学习semi-supervised-learning"><a class="header" href="#半监督学习semi-supervised-learning">半监督学习（Semi-supervised Learning）</a></h3>
<h3 id="强化学习"><a class="header" href="#强化学习">强化学习</a></h3>
<h3 id="迁移学习"><a class="header" href="#迁移学习">迁移学习</a></h3>
<h5 id="领域domain"><a class="header" href="#领域domain">领域（domain）</a></h5>
<p>$$
\mathcal{D}={\mathcal{X},P(\boldsymbol{x})},~\boldsymbol{x}\in\mathcal{X}
$$
$\mathcal{X}$为特征空间，$P(\bm{x})$为边缘概率分布。领域不同$\mathcal{D}_s\ne \mathcal{D}_t$意味着特征空间不同$\mathcal{X}_s\ne \mathcal{X}_t$或边缘分布不同$P_s(x)\ne P_t(x)$。</p>
<h5 id="任务task"><a class="header" href="#任务task">任务（Task）</a></h5>
<p>$$
\mathcal{T}={\mathcal{Y},P(y|\boldsymbol{x})}
$$
$\mathcal{Y}$为类别空间，$P(y|\bm{x})$为预测模型（条件概率分布）。任务不同$\mathcal{T}_s\ne \mathcal{T}_t$意味着类别空间不同$\mathcal{Y}_s\ne \mathcal{Y}_t$或预测模型不同$P_s(Y|X)\ne P_t(Y|X)$。</p>
<p>给定辅助领域的标注数据$\mathcal{D}_s$和学习任务$\mathcal{T}_s$，<strong>目标领域的无标数据</strong>$\mathcal{D}_t$和学习任务$\mathcal{T}_t$，迁移学习是在$\mathcal{D}_s\ne \mathcal{D}_t$或$\mathcal{T}_s\ne \mathcal{T}_t$的情况下，==降低预测模型$P_t(y|\bm{x})$的误差==。</p>
<h5 id="分类-1"><a class="header" href="#分类-1">分类</a></h5>
<p><img src="%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0.assets/image-20191113095242178.png" alt="image-20191113095242178" /></p>
<p>在异构特征空间进行迁移学习，通常==必须依赖领域特定的先验知识==，包括特征空间之间的关联关系（如双语词典）、多模数据每个视图之间的对应关系（如网页中的文本和图像）或社交关联关系。</p>
<p>无监督迁移学习：目标领域没有标注数据的迁移学习任务。</p>
<ul>
<li>
<p><strong>异构特征空间</strong>迁移学习：特征空间不同，类别空间相同。</p>
<ul>
<li>将辅助领域映射（翻译）到目标领域，转换为同构迁移学习问题；
<ul>
<li><strong>跨语言文本分类</strong>：给定标签时词翻译条件概率由双语字典、辅助领域数据、目标领域数据的期望最大化算法协同学习得到。
<blockquote>
<p><em>Shi L, Mihalcea R, Tian M. Cross language text classification by model translation and Semi-Supervised learning. Proceedings of the 2010 Conference on Empirical Methods in Natural Language Processing, 2010.</em></p>
</blockquote>
</li>
</ul>
</li>
<li>将辅助领域和目标领域映射到同一个抽象空间；</li>
<li><strong>翻译学习</strong>：</li>
<li><strong>文本到图像间的知识迁移方法</strong>
<blockquote>
<p><em>Zhu Y, Chen Y, Lu Z, et al. Heterogeneous Transfer Learning for Image Classification. Proceedings of the 25th AAAI Conference on Artificial Intelligence, 2011.</em></p>
</blockquote>
</li>
<li>**异构领域适配：基于特征对齐、 扩充和支持向量机的通用异构迁移学习方法
<blockquote>
<p><em>Li W, Duan L, Xu D, et al. Learning with Augmented Features for Supervised and Semi-supervised Heterogeneous Domain Adaptation. IEEE Transactions on Pattern Analysis and Machine Intelligence, 2014, 99(PrePrints).</em></p>
</blockquote>
</li>
</ul>
</li>
<li>
<p><strong>异构类别空间</strong>迁移学习：</p>
</li>
<li>
<p>同构迁移学习：特征空间和类别空间相同。</p>
<ul>
<li>
<p>数据集偏移：边缘概率分布和条件概率分布不同</p>
<ul>
<li>
<p><strong>实例权重法</strong>：对辅助领域中的实例进行权重调整、提升位 于目标领域高密度区域的辅助领域实例权重，从而更好地与目标领域数据分布匹配。</p>
<blockquote>
<p><em>Bickel S, Bruckner M, Scheffer T. Discriminative learning for differing training and test distributions. Proceedings of the 24th international conference on Machine learning, 2007.</em></p>
</blockquote>
</li>
<li>
<p><strong>特征表示法</strong>：找到原始数据的新特征表示，使得辅助领域和目标领域的数 据分布更加相似、或使得领域相关的具体特征可以被领域无关的抽象特征所表示。</p>
<blockquote>
<p><em>Zhong E, Fan W, Peng J, et al. Cross Domain Distribution Adaptation via Kernel Mapping. Proceedings of the 15th ACM SIGKDD International Conference on Knowledge Discovery and Data Mining, 2009.</em></p>
</blockquote>
<ul>
<li><strong>隐含表征学习法</strong>通过分析辅助领域和目标领域的大量无标样例来构建抽象特征表 示，从而隐式地缩小领域间的分布差异
<ul>
<li>结构对应学习</li>
</ul>
</li>
<li><strong>概率分布适配法</strong>通过惩罚或移除在领域间统计可变的特征、或通过学习子空间嵌入表示来最小化特定距离函数，从而显式地提升辅助领域和目标领域的样本分布相似度。</li>
</ul>
</li>
</ul>
<blockquote>
<p>要求目标领域存在少量标注数据。</p>
</blockquote>
</li>
<li>
<p>领域适配</p>
</li>
<li>
<p>多任务学习</p>
</li>
</ul>
</li>
</ul>
<h3 id="性能度量performance-metrics"><a class="header" href="#性能度量performance-metrics">性能度量（Performance Metrics）</a></h3>
<img src="机器学习/机器学习原理与算法.assets/1lK17g_LKDGcU7UjKlZn1tQ.png" alt="img" style="zoom:40%;" />
<h5 id="准确率accuracy"><a class="header" href="#准确率accuracy">准确率（Accuracy）</a></h5>
<p>$$
\mathrm{Accuracy}=\frac{\mathrm{True Predict}}{\mathrm{Total}}=\frac{TP+TN}{TP+TN+FP+FN}\notag
$$</p>
<h5 id="检出率recall"><a class="header" href="#检出率recall">检出率（Recall）</a></h5>
<p><strong>Detection Rate</strong>：正确预测正例与真实正例数量之比（反映漏报与正确预报之比）：
$$
\mathrm{Recall}=\frac{\mathrm{True Positive}}{\mathrm{TotalActualPositive}}=\frac{TP}{TP+FN}=\frac{1}{1+\frac{FN}{FP}}\notag
$$</p>
<h5 id="精度precision"><a class="header" href="#精度precision">精度（Precision）</a></h5>
<p>正确预测正例与所有预测正例数量之比（反映误报与正确预报之比）：
$$
\mathrm{Precision}=\frac{\mathrm{True Positive}}{\mathrm{TotalPredictPositive}}=\frac{TP}{TP+FP}=\frac{1}{1+\frac{FP}{TP}}\notag
$$</p>
<p>当正样本数非常少时，召回率和精度可以更加准确反映模型的有效性。</p>
<h5 id="f1"><a class="header" href="#f1">F1</a></h5>
<p>$$
\begin{align}
\mathrm{F1}&amp;=2\times\frac{\mathrm{Precision}\times\mathrm{Recall}}{\mathrm{Precision}+\mathrm{Recall}}\notag\
\mathrm{F_{\beta}}&amp;=(1+{\beta}^2)\times\frac{\mathrm{Precision}\times\mathrm{Recall}}{({\beta}^2\mathrm{Precision})+\mathrm{Recall}}\notag
\end{align}
$$</p>
<p><a href="https://developers.google.com/machine-learning/crash-course/classification/roc-and-auc">ROC curve and AUC: Area Under the ROC Curve</a></p>
<h3 id="可解释性"><a class="header" href="#可解释性">可解释性</a></h3>
<p><em><strong>z-score</strong></em>：数据标准化，检查特征偏离中心的程度。</p>
<h2 id="概率模型"><a class="header" href="#概率模型">概率模型</a></h2>
<p>对于观测的随机变量$X$而言，</p>
<ul>
<li>
<p>先验（prior）概率：$p(X)$，未知其他信息的情况下的概率信息；</p>
</li>
<li>
<p>后验（posterior）概率：$p(X|Y=y)$，已知额外信息的情况下的概条件率信息</p>
</li>
<li>
<p>似然（likelihood）函数：$X=x$发生在条件$Y$下的可能性$p(Y|X=x)$，对应后验概率。</p>
</li>
</ul>
<p>贝叶斯定理：
$$
p(X|Y)=\frac{p(X,Y)}{p(Y)}=\frac{p(Y|X)p(X)}{p(Y)}\propto p(Y|X)p(X)
$$</p>
<h3 id="参数估计"><a class="header" href="#参数估计">参数估计</a></h3>
<h4 id="最大似然"><a class="header" href="#最大似然">最大似然</a></h4>
<p><strong>maximum likelihood estimation (MLE)</strong>：使事件$X=x$（样本）的似然函数最大的参数估计：
$$
\hat{\boldsymbol{\theta}}=\mathop{\mathrm{argmax}}_{\boldsymbol{\theta}}{p(X=x|\boldsymbol{\theta})}
$$</p>
<h5 id="最小二乘"><a class="header" href="#最小二乘">最小二乘</a></h5>
<p>最小化观测值与模型预测值的残差。</p>
<blockquote>
<p>当模型是高斯分布时，最大似然估计和最小二乘估计是等价的。</p>
</blockquote>
<p>$$
\begin{align*}
\min {|A\bm{x}-\bm{b}|^2} &amp; 
\Longrightarrow f(\bm{x})=\bm{x}^\top A^\top A\bm{x}-2\bm{b}^\top A\bm{x} + \bm{b}^\top\bm{b}
\Longrightarrow \frac{\mathrm{d}f}{\mathrm{d}\bm{x}}=2A^\top A\bm{x}- 2A^\top\bm{b}=0\
&amp;\Longrightarrow \bm{x}^{\ast}=(A^\top A)^{-1}A^\top\bm{b}
\end{align*}
$$</p>
<blockquote>
<p>通常$A$的行数远大于列数，$A^\top A$为可逆矩阵。</p>
</blockquote>
<h6 id="线性回归"><a class="header" href="#线性回归">线性回归</a></h6>
<p>对于线性模型拟合：$y=\bm{w}^\top \bm{x} + b$，有
$$
\begin{align*}
l(\bm{w},b)&amp;=|\bm{x}_i^\top\bm{w}+b-\bm{y}_i|^2 \
&amp;\Longrightarrow \bm{x}_i^\top\bm{w}+b-\bm{y}_i= [\bm{x}_i^\top,1]\left[\begin{array}{c} \bm{w}\b
\end{array}\right]-y_i
\end{align*}
$$
考虑所有样本可得：$l(\bm{w},b)=|\hat{X}\hat{\bm{w}}-\bm{y}|^2$，其中$\hat{X}=(X^\top,\b{1}),~\hat{\bm{w}}=(\bm{w}^\top,b)^\top,$</p>
<h5 id="最小均方误差"><a class="header" href="#最小均方误差">最小均方误差</a></h5>
<h3 id="贝叶斯推理bayesian-inference"><a class="header" href="#贝叶斯推理bayesian-inference">贝叶斯推理（Bayesian Inference）</a></h3>
<h5 id="最大后验概率"><a class="header" href="#最大后验概率">最大后验概率</a></h5>
<p>$$
\begin{align}
\hat{\boldsymbol{\theta}}&amp;=\mathop{\mathrm{argmax}}<em>{\boldsymbol{\theta}}{p(\boldsymbol{\theta}|X=x)}\notag\
&amp;=\mathop{\mathrm{argmax}}</em>{\boldsymbol{\theta}}{p(X=x|\boldsymbol{\theta})p(\boldsymbol{\theta})}\notag\
&amp;=\mathop{\mathrm{argmax}}_{\boldsymbol{\theta}}{\left{\log{p(X=x|\boldsymbol{\theta})}+\log{p(\boldsymbol{\theta})}\right}}
\end{align}
$$</p>
<p>设$h$为假设采样空间，$\mathcal{D}$为样本集合：
$$
\begin{align}
\hat{h}^{MAP}&amp;=\mathop{\mathrm{argmax}}_h{p(\mathcal{D|h})p(h)}\notag\
&amp;=\mathop{\mathrm{argmax}}_h{\log{p(\mathcal{D|h})}+\log{p(h)}}
\end{align}
$$ {eq_bayes_map}</p>
<blockquote>
<p><em>For example, if we assume the prior distribution to be Gaussian, MAP is equal to MLE with L2 regularization; if we assume the prior distribution to be Laplace, MAP is equal to MLE with L1 regularization.</em></p>
</blockquote>
<p>当样本点足够多时，数据提供的信息将淹没先验信息（<em><strong>data overwhelms the prior</strong></em>），MAP收敛为最大似然估计（<em><strong>maximum likelihood estimate</strong></em>）。
$$
\hat{h}^{MLE}=\mathop{\mathrm{argmax}}_h{p(\mathcal{D|h})}
$$</p>
<h2 id="几何模型"><a class="header" href="#几何模型">几何模型</a></h2>
<h3 id="k-nearest-neighbors"><a class="header" href="#k-nearest-neighbors">K-Nearest Neighbors</a></h3>
<p>距离度量：$D(x,y)={|x-y|_p}$</p>
<p>多数表决：每个邻居节点的权重可以相同，也可以与距离相关（例如$\frac{1}{d}$）。</p>
<blockquote>
<p>比如，我们判断一个人的人品，只需要观察他来往最密切的几个人的人品好坏就可以得出了。</p>
</blockquote>
<ul>
<li>分类：训练集里和预测的样本特征最近的$K$个样本，选取样本中的主要类别作为预测。</li>
<li>回归：平均法，即最近的$K$个样本的样本输出的平均值作为回归预测值。</li>
</ul>
<h4 id="参数选择"><a class="header" href="#参数选择">参数选择</a></h4>
<p>对于$k$值的选择，没有一个固定的经验，一般根据样本的分布，选择一个较小的值，可以通过交叉验证选择一个合适的$k$值。</p>
<h4 id="距离计算"><a class="header" href="#距离计算">距离计算</a></h4>
<h5 id="暴力搜索"><a class="header" href="#暴力搜索">暴力搜索</a></h5>
<p>计算预测样本与训练集所有样本的距离，找出$k$邻近样本，进行多数表决确定预测样本的类型。</p>
<h5 id="kd树k-dimensional-tree"><a class="header" href="#kd树k-dimensional-tree">KD树（K-Dimensional Tree）</a></h5>
<p>在训练阶段建立KD树（模型）。</p>
<ul>
<li>计算样本集合各个特征的取值的方差，用方差最大的第$n$维特征$f_n$来作为根节点的划分标准（<strong>方差越大，则数据在该维度上更加分散</strong>）。</li>
<li>将样本按$f_n$划分为两个子集，作为根节点的左右子节点的输入。</li>
<li>对于左右子节点，重复上述操作。</li>
</ul>
<p>搜索临近节点：</p>
<h5 id="球树"><a class="header" href="#球树">球树</a></h5>
<h4 id="参考资料-13"><a class="header" href="#参考资料-13">参考资料</a></h4>
<ol>
<li><a href="https://www.cnblogs.com/pinard/p/6061661.html">K近邻法(KNN)原理小结</a>。</li>
</ol>
<h3 id="k-means"><a class="header" href="#k-means">K-means</a></h3>
<p>对于给定的样本集，按照样本之间的距离大小，将样本集划分为$K$个簇。让簇内的点尽量紧密的连在一起，而让簇间的距离尽量的大。
$$
\begin{align*}
E &amp;= \sum_{i=1}^k\sum_{x \in C_i} {|x-\mu_i|}<em>2^2\
\mu_i &amp;= \frac{1}{|C_i|}\sum\limits</em>{x \in C_i}x
\end{align*}
$$
$k$值的选择：根据对数据的先验经验选择一个合适的$k$值，如果没有什么先验知识，则可以通过交叉验证选择一个合适的$k$值。</p>
<p>选择$k$个初始化的质心：$k$个初始化的质心的位置选择对最后的聚类结果和运行时间都有很大的影响，因此需要选择合适的$k$个质心，最好这些质心不能太近。</p>
<h4 id="优化-3"><a class="header" href="#优化-3">优化</a></h4>
<h5 id="k-means-1"><a class="header" href="#k-means-1">K-Means++</a></h5>
<p>优化初始质心的选择。</p>
<h5 id="mini-batch-k-means"><a class="header" href="#mini-batch-k-means">Mini Batch K-Means</a></h5>
<h4 id="参考资料-14"><a class="header" href="#参考资料-14">参考资料</a></h4>
<ol>
<li><a href="https://www.cnblogs.com/pinard/p/6164214.html">K-Means聚类算法原理</a>。</li>
</ol>
<h3 id="谱聚类spectral-clustering"><a class="header" href="#谱聚类spectral-clustering">谱聚类（Spectral Clustering）</a></h3>
<h4 id="算法-1"><a class="header" href="#算法-1">算法</a></h4>
<p>聚类问题：不同分组间的边（相似度）权重较低，而相同分组内节点间的边权重较高。</p>
<p>主要思想：==将数据点映射到相似矩阵的特征向量。==</p>
<h5 id="割图graph-cut"><a class="header" href="#割图graph-cut">割图（Graph Cut）</a></h5>
<p>点的聚类近似对应了最小割（min-cut）：即割集（割间的边）的权重之和最小，且割内边权重之和尽可能大。由此得到两种优化目标，即RatioCut和Ncut。</p>
<blockquote>
<p>$$
\begin{align*}
\mathrm{cut}(A,B)&amp;=\sum_{i\in A,j\in B}{w_{ij}}\
\mathrm{cut}(A_1,A_2,\cdots,A_k)&amp;=\sum_{i=1}^k{\mathrm{cut}(A_i,\bar{A}_i)}\notag
\end{align*}
$$</p>
</blockquote>
<p>平衡性：</p>
<p><code>RatioCut</code>：使用子集的节点数调整子集的权重。
$$
\mathrm{RatioCut}(A_1,\cdots,A_k) = \sum_1^k{\frac{\mathrm{Cut}(A_i,\hat{A})}{|A_i|}}
$$</p>
<blockquote>
<p>对应非规范化的拉普拉斯矩阵$L$。</p>
</blockquote>
<p><code>Ncut</code>：使用子集的边权重调整子集的权重。
$$
\mathrm{Ncut}(A_1,\cdots,A_k) = \sum_1^k{\frac{\mathrm{Cut}(A_i,\hat{A})}{\mathrm{vol}(A_i)}}
$$</p>
<blockquote>
<p>对应规范化的拉普拉斯矩阵$L_{\mathrm{rw}}$或$L_{\mathrm{sym}}$。</p>
</blockquote>
<h3 id="logistic-regression"><a class="header" href="#logistic-regression">Logistic Regression</a></h3>
<h2 id="学习框架"><a class="header" href="#学习框架">学习框架</a></h2>
<h3 id="adaboost"><a class="header" href="#adaboost">AdaBoost</a></h3>
<p>调整训练实例的权重已提升弱学习器的准确率。</p>
<h2 id="应用-2"><a class="header" href="#应用-2">应用</a></h2>
<h3 id="分类-2"><a class="header" href="#分类-2">分类</a></h3>
<h4 id="document-classification"><a class="header" href="#document-classification">Document classification</a></h4>
<p>bag of words: a binary document × word co-occurrence matrix</p>
<h4 id="image-classification"><a class="header" href="#image-classification">Image Classification</a></h4>
<p>Object (Face) detection and recognition</p>
<h3 id="回归"><a class="header" href="#回归">回归</a></h3>
<p>Predict tomorrow's stock market price</p>
<p>Predict the location in 3D space of a robot arm end effector</p>
<p>Predict the temperature at any location</p>
<p><a href="%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%8E%9F%E7%90%86%E4%B8%8E%E7%AE%97%E6%B3%95.html#%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92">线性回归（Linear Regression）</a></p>
<h3 id="聚类clustering"><a class="header" href="#聚类clustering">聚类（Clustering）</a></h3>
<ol>
<li>estimate the distribution over the number of clusters, $p(K|D)$</li>
<li>estimate which cluster each point belongs to,  $z^{*}_i = \mathop{\mathrm{argmax}}_k{p(z_i=k|\bm{x}_i,\mathcal{D})}$, where $z_i$ is <strong>hidden</strong> or <strong>latent</strong> variable.</li>
</ol>
<p>model based clustering:  fit a probabilistic model to the data.</p>
<h3 id="discovering-latent-factors"><a class="header" href="#discovering-latent-factors">Discovering latent factors</a></h3>
<h3 id="discovering-graph-structure"><a class="header" href="#discovering-graph-structure">Discovering graph structure</a></h3>
<p>measure a set of correlated variables;  discover which ones are most correlated with which others.
$$
\hat{G}=\mathop{\mathrm{argmax}}{p(G|\mathcal{D})}
$$</p>
<h3 id="matrix-completion"><a class="header" href="#matrix-completion">Matrix Completion</a></h3>
<h5 id="collaborative-filtering"><a class="header" href="#collaborative-filtering">Collaborative filtering</a></h5>
<p>recommendation system</p>
<h3 id="特征选择feature-selection"><a class="header" href="#特征选择feature-selection">特征选择（Feature Selection）</a></h3>
<h2 id="方法-6"><a class="header" href="#方法-6">方法</a></h2>
<h3 id="naive-bayes朴素贝叶斯"><a class="header" href="#naive-bayes朴素贝叶斯">Naive Bayes（朴素贝叶斯）</a></h3>
<p>基于概率预测实际需要建立$p(y|\bm{x},\mathcal{D})$的模型，根据贝叶斯定理可得，
$$
\begin{align}
p(y|\boldsymbol{x})&amp;=\frac{p(\boldsymbol{x},y)}{p(\boldsymbol{x})}\notag\
&amp;=\frac{p(\boldsymbol{x}|y)p(y)}{\sum_i{p(\boldsymbol{x}|y=c_i)p(y=c_i)}} \notag\
&amp;\propto p(\boldsymbol{x}|y)p(y)
\end{align}
$$</p>
<blockquote>
<p>分母与$y$无关。</p>
</blockquote>
<p>因此需要求出联合概率分布或间接求出类别的先验概率$p(y)$和样本关于类别的条件概率。</p>
<p><strong>朴素贝叶斯方法</strong>假设数据服从某种类型的分布，利用样本估计该分布的参数。当获得估计参数后，利用概率模型以及贝叶斯公式即可计算出分类的概率。<strong>首先，每个类别的对应参数$\bm{\theta}^c,c=1,...,C$可能不同；其次，给定类别中数据的每个维度对应一组参数$\bm{\theta}^c_{!j}, j=1,...,F$，各组参数可能并非相对独立</strong>。为了简化计算，假设数据的各个维度的特征（<em>feature</em>）的条件分布独立（因此参数估计是相互独立的，实际情况并不一定成立，因此朴素）。</p>
<blockquote>
<p>设样本点维度为$F$，类别总数为$C$。</p>
</blockquote>
<p>单个样本点发生的概率（似然函数）：
$$
\begin{align}
p(\boldsymbol{x}<em>i,y_i|\boldsymbol{\theta})&amp;=p(\boldsymbol{x}<em>i|y_i,\boldsymbol{\theta})p(y_i|\boldsymbol{\theta})\notag\
&amp;=p(y_i|\boldsymbol{\theta})\prod</em>{c=1}^{C}{p(\boldsymbol{x}<em>i|y_i,\boldsymbol{\theta})^{\mathbb{I}(c=y_i)}}\
&amp;=p(y_i|\boldsymbol{\theta})p(\boldsymbol{x}<em>i|c,\boldsymbol{\theta}^c)|</em>{c=y_i}\
&amp;=p(y_i|\boldsymbol{\pi})p(\boldsymbol{x}<em>i|\boldsymbol{\theta}^c)|</em>{c=y_i}\
&amp;=p(y_i|\boldsymbol{\pi})\prod</em>{j=1}^{F}{p(x</em>{ij}|\boldsymbol{\theta}^c_{!j})|_{c=y_i}}
\end{align}
$$</p>
<p>其中$\bm{\pi}=(\pi_c)|_{c=1,...,C}$为标签$y$的概率分布。由于样本点已知其分类，因此仅考虑其对应分类的概率$p(\bm{x}_i|y_i=c,\bm{\theta})\ne0$。由于参数独立，因此在计算条件概率时，条件只包含样本点所属类别对应特征维度的参数。</p>
<p>样本集合发生的概率为各个样本点发生的联合概率（认为各个点相互独立）
$$
\begin{align}
p(\mathcal{D}|\boldsymbol{\theta})&amp;=\prod_{i=1}^D{\left{p(y_i|\boldsymbol{\pi})\prod_{j=1}^F{p(\boldsymbol{x}<em>{ij}|\boldsymbol{\theta}</em>{!j}^c)|<em>{c=y_j}}\right}}\notag\
&amp;=\prod</em>{i=1}^D{p(y_i|\boldsymbol{\pi})}\prod_{i=1}^D{\prod_{j=1}^F{p(\boldsymbol{x}<em>{ij}|\boldsymbol{\theta}</em>{!j}^c)|<em>{c=y_j}}}\
\log{p(\mathcal{D}|\boldsymbol{\theta})}&amp;=\sum</em>{i=1}^{D}{\log{p(y_i|\boldsymbol{\pi})}}+\sum_{i=1}^D{\sum_{j=1}^F{\log{p(\boldsymbol{x}<em>{ij}|\boldsymbol{\theta^c</em>{!j}})|<em>{c=y_i}}}}\notag\
&amp;=\sum</em>{i=1}^C{N_c\log{\pi_c}}+\sum_{i=1}^D{\sum_{j=1}^F{\log{p(\boldsymbol{x}<em>{ij}|\boldsymbol{\theta^c</em>{!j}})|_{c=y_i}}}}
\end{align}
$$</p>
<p>其中$\N_c$表示所有$D$个样本点中类别为$c$的数量（对应的概率为$\pi_c$）。</p>
<p>采用<strong>最大似然估计</strong>，则是要使（对数）似然函数在考察参数条件下最大化，
$$
\begin{align}
\mathop{\mathrm{argmax}}<em>\boldsymbol{\theta}~&amp;{\log{p(\mathcal{D}|\boldsymbol{\theta})}},\
\mathrm{s.t.~~~} &amp;\sum</em>{c=1}^C{\pi_c}=1. \notag
\end{align}
$$</p>
<h5 id="gaussian-naive-bayes"><a class="header" href="#gaussian-naive-bayes">Gaussian Naive Bayes</a></h5>
<p>连续数据，假设数据的每一个特征服从一个正态分布，</p>
<p>$$
p(\boldsymbol{x}|y=c,\boldsymbol{\theta})=\prod_{j=1}^D\mathcal{N}(x_j|\mu_{!j}^c,{{\sigma}_{!j}^c}^2)
$$</p>
<p>估计分布的期望和方差。</p>
<h5 id="bernoulli-naive-bayes"><a class="header" href="#bernoulli-naive-bayes">Bernoulli Naive Bayes</a></h5>
<p>特征的值由两个取值（0和1），采用伯努利分布$p(\bm{x}|y=c,\bm{\theta})=\prod_{j=1}^D\mathrm{Ber}(x_j|{\mu}_{!j}^c)$，估计每个特征的分布的期望${\mu}_j^c$（即$x=1$的概率）。</p>
<h5 id="multinomial-naive-bayes"><a class="header" href="#multinomial-naive-bayes">Multinomial Naive Bayes</a></h5>
<p>特征可以取多个离散值，在二值基础上推广。</p>
<h4 id="模型拟合"><a class="header" href="#模型拟合">模型拟合</a></h4>
<h3 id="神经网络"><a class="header" href="#神经网络">神经网络</a></h3>
<p>A neural network is a very powerful machine learning mechanism which basically mimics how a human brain learns. The brain receives the stimulus from the outside world, does the processing on the input, and then generates the output.</p>
<p><img src="%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0.assets/content_content_neuron.png" alt="img" /></p>
<h4 id="激活函数activation-function"><a class="header" href="#激活函数activation-function">激活函数（Activation Function）</a></h4>
<img src="机器学习/机器学习.assets/neutron_activate_function.png" alt="neutron activate function" style="zoom: 50%;" />
<p>单个神经元：输入$\bm{x}=(x_i)<em>{i=1,\cdots,n}$，神经元输入权重$W_i=(w_i)</em>{i=1,\cdots,n}$，
$$
\begin{align*}
y_j&amp;=f(b+\sum_{i=1}^{n}{x_iw_i})=f(W_i\bm{x}+b),\
z_j&amp;= b_j+W_i\bm{x} \Longrightarrow y_j=f(z_j)
\end{align*}
$$</p>
<blockquote>
<p><em>A neural network without an activation function is essentially just a linear regression model.</em> </p>
</blockquote>
<p>单层网络：第$k$层神经元序列$\bm{q}^{(k)}=(q_j^{(k)}=(f_j^{(k)},b_j^{(k)}))<em>{j=1,\cdots,m}$，$\bm{f}^{(k)}=(f_j^{(k)})</em>{j=1,\cdots,m}, \bm{b}^{(k)}=(b_j^{(k)})_{j=1,\cdots,m}$。每个神经元的激活函数分别处理一个线性组合输入$z_j$。</p>
<p>可以将各层网络的处理写作迭代的形式：
$$
\begin{align*}
\bm{q}^{(k+1)}(\bm{x}^{(k)})&amp;=\begin{cases}
\bm{z}^{(k+1)}=\bm{b}^{(k+1)}+\bm{W}^{(k+1)}\bm{x}^{(k)} \
\bm{x}^{(k+1)}=\bm{f}^{(k)}(\bm{z}^{(k+1)}) 
\end{cases},~~k=1,2,\cdots\
x^{(k+1)}_j&amp;=f_j^{(k)}(z^{(k+1)}_j)
\end{align*}
$$</p>
<blockquote>
<p>通常每一层使用相同类型的神经元，即激活函数相同$f_j^{(k)}=f^{(k)}$。</p>
</blockquote>
<h5 id="sigmoid"><a class="header" href="#sigmoid">Sigmoid</a></h5>
<p>$$
f(x)=\frac{1}{1+e^{-x}}
$$</p>
<p>This means that in this range small changes in x would also bring about large changes in the value of Y. So the function essentially tries to push the Y values towards the extremes. This is a very desirable quality when we are trying to classify the values to a particular class.</p>
<p><strong>Problem</strong>:</p>
<ul>
<li>when $x$ is large,  the gradient is approaching to zero and the network is not really learning.</li>
</ul>
<h5 id="tanh---scaled-sigmoid"><a class="header" href="#tanh---scaled-sigmoid">Tanh - Scaled Sigmoid</a></h5>
<p>$$
\begin{align}
\mathrm{tanh}(x)&amp;=2\mathrm{sigmoid}(2x)-1 \notag\
&amp; =\frac{2}{1+e^{-2x}} -1 
\end{align}
$$</p>
<p>it ranges from -1 to 1.</p>
<h5 id="relu"><a class="header" href="#relu">ReLU</a></h5>
<p>$$
f(x)=\mathrm{max}(0,x)
$$</p>
<p>The main advantage of using the ReLU function over other activation functions is that it does not activate all the neurons at the same time.</p>
<p><strong>Problems</strong>:  gradients moving towards zero.</p>
<p><strong>Solution</strong>: </p>
<ul>
<li>Leaky ReLU.</li>
</ul>
<p>$$
f(x)=\begin{cases}
ax, &amp; x&lt; 0 \
x,  &amp; x \ge 0
\end{cases} ~~(a\rightarrow0^+)
$$</p>
<ul>
<li>Parameterized ReLU function</li>
</ul>
<h5 id="softmax"><a class="header" href="#softmax">Softmax</a></h5>
<p>$$
\boldsymbol{\sigma}(\boldsymbol{z})<em>j=\frac{e^{z_j}}{\sum</em>{k=1}^{K}{e^{z_k}}},~\forall j=1,\cdots,K.
$$</p>
<p><strong>==Multi-class problem==</strong>: the softmax function would squeeze the outputs for each class between 0 and 1 and would also divide by the sum of the outputs. This essentially gives the probability of the input being in a particular class. </p>
<blockquote>
<ul>
<li>Sigmoid functions and their combinations generally work better in the case of classifiers</li>
<li>Sigmoids and tanh functions are sometimes avoided due to the vanishing gradient problem</li>
<li>ReLU function is a general activation function and is used in most cases these days</li>
<li>If we encounter a case of dead neurons in our networks the leaky ReLU function is the best choice</li>
<li>Always keep in mind that ReLU function should only be used in the hidden layers ???</li>
<li>As a rule of thumb, you can begin with using ReLU function and then move over to other activation functions in case ReLU doesn’t provide with optimum results</li>
</ul>
</blockquote>
<p>https://www.analyticsvidhya.com/blog/2017/10/fundamentals-deep-learning-activation-functions-when-to-use-them/</p>
<p><a href="https://www.asimovinstitute.org/neural-network-zoo/">The Neural Network Zoo - The Asimov Institute</a></p>
<p><img src="%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%8E%9F%E7%90%86%E4%B8%8E%E7%AE%97%E6%B3%95.assets/NeuralNetworkZoo20042019.png" alt="" /></p>
<h4 id="feed-forward-neural-network"><a class="header" href="#feed-forward-neural-network">Feed-forward Neural Network</a></h4>
<h5 id="感知器perceptron"><a class="header" href="#感知器perceptron">感知器（Perceptron）</a></h5>
<p>单层感知器仅能学习线性可分模式。</p>
<p>https://www.simplilearn.com/what-is-perceptron-tutorial</p>
<h5 id="multi-layer-perceptrons-mlps"><a class="header" href="#multi-layer-perceptrons-mlps">Multi-Layer Perceptrons (MLPs)</a></h5>
<h5 id="线性神经网络"><a class="header" href="#线性神经网络">线性神经网络</a></h5>
<p>感知器传输函数是一个二值阈值元件，而线性神经网络的传输函数是线性的。这就决定了感知器只能做简单的分类，而线性神经网络还可以实现==线性==拟合或逼近。</p>
<h5 id="非线性神经网络"><a class="header" href="#非线性神经网络">非线性神经网络</a></h5>
<p>要形成非线性分界面，网状结构和非线性激活函数缺一不可。如果缺乏网状结构（<em>逻辑回归</em>），$\bm{x}$经过投影其信息只在 $W$方向上有变化。若缺乏非线性激活函数，则无论有多少层，<a href="https://zhuanlan.zhihu.com/p/35307826">网络仍然是一个线性回归</a>。</p>
<img src="机器学习/机器学习.assets/1568938883673.png" alt="Feed-forward Neural Network" style="zoom:80%;" />
<p>优化神经网络：调整网络中的参数$W,b$，以最小化损失函数。</p>
<h5 id="参考文献-11"><a class="header" href="#参考文献-11">参考文献</a></h5>
<ol>
<li>https://www.learnopencv.com/understanding-feedforward-neural-networks/</li>
<li>https://www.analyticsvidhya.com/blog/2018/07/using-power-deep-learning-cyber-security/</li>
</ol>
<h4 id="卷积神经网络cnn"><a class="header" href="#卷积神经网络cnn">卷积神经网络CNN</a></h4>
<p>CNNs specifically are inspired by the biological visual cortex<sup class="footnote-reference"><a href="#cnn-python">1</a></sup>.</p>
<blockquote>
<p><em>In this experiment, the researchers showed that <strong>some individual neurons in the brain activated or fired only in the presence of edges of a particular orientation like vertical or horizontal edges</strong>. Hubel and Wiesel found that all of these neurons were well ordered in a columnar fashion and that together they were able to produce visual perception.</em></p>
</blockquote>
<p><img src="%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0.assets/2019-06-19-lenet.png" alt="LeNet-5网络结构" /></p>
<p><img src="%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0.assets/Typical_cnn_kecdep.png" alt="convolutional neural networks python" /></p>
<blockquote>
<p>层间特征的映射关系不是通过<strong>全连接</strong>，而是<strong>局部卷积</strong>构造。</p>
</blockquote>
<h5 id="preprocessing-降采样"><a class="header" href="#preprocessing-降采样">preprocessing: 降采样</a></h5>
<h5 id="convolution"><a class="header" href="#convolution">convolution</a></h5>
<blockquote>
<p>提取局部特征（模式）。</p>
<p><em>卷积核模式匹配无法区分以下模式：设计不同的卷积核可区分以上两种模式，从而避免额外的归一化操作。</em></p>
<img src="机器学习/assets/conv-normalize-needed.png" alt="卷积结果是否需要归一化？" style="zoom:50%;" />
</blockquote>
<p>每一个kernel在一张图上通过卷积运算生成一个feature map（每个卷积核代表了一种图像模式），输入图像本身也相当于一个kernel map（对于RGB图像，每个图像对应三个输入通道，相当于有三个kernel map）。每个输入图像使用同一组卷积核分别进行计算，因此输出feature map数量：<code>n_input_map*n_kenerls_per_map</code>；</p>
<p>输出数据的形状：<code>n_input_map*n_kernels_per_map*(n_rows*n_cols)</code>；</p>
<p>因此每层参数数量：<code>(n_input_map*kernel_size+1)*n_kernels_per_map</code>，每个卷积核对应一个权重系数矩阵和一个<code>bias</code>参数（$y_{ij}=\boldsymbol{wx}_{ij}+b$）。对于输入层，<code>num_input_map=1</code>（对于RGB图像，<code>num_input_map=3</code>，因此<a href="https://stackoverflow.com/a/57268398/6571140">输入层需要三个二维卷积核分别对三个通道进行卷积并将结果求和</a>（<a href="%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/TensorFlow.html#Conv2D">Keras的<code>Conv2D</code></a>）。</p>
<blockquote>
<p><strong>bias</strong>：单个输入图上的卷积核使用独立的bias，但这些bias跨feature map是共享的参数，因此偏置参数的个数为<code>n_kenerls_per_map</code>。（<em>==同一层卷积核在不同feature map是独立的，但偏置是共享的？==</em>）</p>
</blockquote>
<p>==卷积计算实际是权重与数据的内积。卷积核的移动过程类比于数字信号处理中的卷积运算过程==。卷积计算可在feature_map内部（复制image数据）以及feature_map之间并行。</p>
<blockquote>
<p><em>dot product between their <strong>weights</strong> (kernel) and a small receptive field to which they are connected to in the input volume.</em></p>
</blockquote>
<h5 id="subsampling-降低分辨率"><a class="header" href="#subsampling-降低分辨率">subsampling: 降低分辨率</a></h5>
<blockquote>
<p>有助于==减小过拟合==。</p>
</blockquote>
<ul>
<li>
<p><strong>max-pooling</strong>: <em>takes the largest value from the window of the image currently covered by the kernel of the pooling layer.</em></p>
<blockquote>
<p>卷积运算的值越大，意味着对应位置的模式与卷积核越匹配。因此，通过<code>max-pooling</code>运算后，卷积运算提取的模式信息仍能在<code>feature_map</code>中得到保留。</p>
<p><em>池化层窗口移动步长为窗口宽度。</em></p>
</blockquote>
</li>
<li>
<p>full connected layers: 类似传统神经网络的部分</p>
</li>
</ul>
<h5 id="全连接层"><a class="header" href="#全连接层">全连接层</a></h5>
<p>将feature maps转换为1维向量，从而可用于输出层的softmax分类器或sigmoid进行预测。</p>
<div class="footnote-definition" id="cnn-python"><sup class="footnote-definition-label">1</sup>
<p><a href="https://www.datacamp.com/community/tutorials/convolutional-neural-networks-python">Convolutional Neural Networks in Python - DataCamp</a></p>
</div>
<h4 id="损失函数"><a class="header" href="#损失函数">损失函数</a></h4>
<p><a href="%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%8E%9F%E7%90%86%E4%B8%8E%E7%AE%97%E6%B3%95.html#%E7%BB%8F%E9%AA%8C%E9%A3%8E%E9%99%A9%E6%9C%80%E5%B0%8F%E5%8C%96">损失函数</a>以神经网络的输出作为自变量，以训练数据集的标签作为参数。</p>
<p><code>binary_crossentropy</code></p>
<h3 id="autoencoder-1"><a class="header" href="#autoencoder-1"><a href="%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/DimensionalityReduction.html#AutoEncoder">AutoEncoder</a></a></h3>
<h3 id="深度学习"><a class="header" href="#深度学习">深度学习</a></h3>
<ol>
<li>https://www.analyticsvidhya.com/blog/2016/03/introduction-deep-learning-fundamentals-neural-networks/</li>
<li>https://www.analyticsvidhya.com/blog/2018/05/essentials-of-deep-learning-trudging-into-unsupervised-deep-learning/</li>
</ol>
<h4 id="time-series-forecasting--modeling"><a class="header" href="#time-series-forecasting--modeling">Time Series forecasting &amp; modeling</a></h4>
<h5 id="methods"><a class="header" href="#methods">Methods</a></h5>
<ol>
<li>
<p>Moving Average</p>
</li>
<li>
<p>Linear Regression</p>
</li>
<li>
<p>k-Nearest Neighbors</p>
</li>
<li>
<p>Auto ARIMA</p>
</li>
<li>
<p>Prophet</p>
</li>
<li>
<p>Long Short Term Memory (LSTM)</p>
</li>
<li>
<p>https://www.analyticsvidhya.com/blog/2018/10/predicting-stock-price-machine-learningnd-deep-learning-techniques-python/</p>
</li>
<li>
<p>https://www.analyticsvidhya.com/blog/2016/02/time-series-forecasting-codes-python/?utm_source=blog&amp;utm_medium=stockmarketpredictionarticle</p>
</li>
</ol>
<h4 id="gan"><a class="header" href="#gan">GAN</a></h4>
<p>https://www.analyticsvidhya.com/blog/2019/04/top-5-interesting-applications-gans-deep-learning/</p>
<h3 id="训练-1"><a class="header" href="#训练-1">训练</a></h3>
<h4 id="model-selection"><a class="header" href="#model-selection">Model Selection</a></h4>
<h4 id="数据集"><a class="header" href="#数据集">数据集</a></h4>
<h5 id="training-set"><a class="header" href="#training-set">training set</a></h5>
<h5 id="validation-set"><a class="header" href="#validation-set">validation set</a></h5>
<p>We fit all the models on the training set, and evaluate their performance on the validation set, and pick the best.</p>
<p><strong>cross validation</strong>: split the training data into $K$ folds; train on all the folds but the $k$’th, and test on the $k$’th, in a round-robin fashion.</p>
<h5 id="test-set"><a class="header" href="#test-set">test set</a></h5>
<h2 id="优化理论"><a class="header" href="#优化理论">优化理论</a></h2>
<h3 id="梯度搜索算法"><a class="header" href="#梯度搜索算法">梯度搜索算法</a></h3>
<h4 id="stochastic-gradient-descent"><a class="header" href="#stochastic-gradient-descent">Stochastic Gradient Descent</a></h4>
<blockquote>
<p>learning of linear classifiers under convex loss functions such as (linear) Support Vector Machines and Logistic Regression. </p>
<p>SGD has been successfully applied to <em>large-scale</em> and <em>sparse</em> machine learning problems often encountered in text classification and natural language processing.</p>
</blockquote>
<p>Stochastic Gradient Descent：根据一个样本计算梯度；</p>
<p>Batch Gradient Descent：根据所有样本计算平均梯度（计算所有样本的平均误差，以2范数构造损失函数即为均方误差（MSE））；</p>
<p>mini-batch SGD：计算一批样本的平均梯度（兼顾计算效率与收敛速率）。</p>
<h5 id="参考文献-12"><a class="header" href="#参考文献-12">参考文献</a></h5>
<ol>
<li>https://scikit-learn.org/stable/modules/sgd.html#sgd </li>
<li>https://adventuresinmachinelearning.com/stochastic-gradient-descent/</li>
</ol>
<h4 id="adam"><a class="header" href="#adam">ADAM</a></h4>
<h3 id="back-propagation"><a class="header" href="#back-propagation">Back-Propagation</a></h3>
<p><img src="%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0.assets/image-20210111170508921.png" alt="bp" /></p>
<p>利用链式规则对$W_{ij}^{(k)}$反向逐级求导：
$$
\newcommand{\d}[2]{\frac{\partial#1}{\partial#2}}
\begin{align*}
\d{l}{f_1^{(3)}}&amp;=\dot{l}(u),~~u=f_1^{(3)}-y_1\</p>
<p>\d{l}{w_{11}^{(2)}}&amp;=\d{l}{f_1^{(3)}}\d{f_1^{(3)}}{z_1^{(3)}}\d{z_1^{(3)}}{w_{11}^{(2)}}=\d{l}{f_1^{(3)}}\cdot\dot{f}_1^{(3)}\cdot f_1^{(2)}
\end{align*}
$$
其中，通过正向传播并利用初始化的权重系数$W$，可获得各级神经元输入值$z$、激活函数的函数值$f$和导数值$\dot{f}$。</p>
<blockquote>
<p><em>Without the differentiable non linear function, this would not be possible.</em></p>
<p>类似地对$b_i^{(k)}$求导可得：
$$
\d{l}{b_1^{(2)}}=\d{l}{f_1^{(3)}}\d{f_1^{(3)}}{z_1^{(3)}}\d{z_1^{(3)}}{b_1^{(2)}}=\d{l}{f_1^{(3)}}\cdot\dot{f}_1^{(3)}, ~~\left(\d{z_1^{(3)}}{b_1^{(2)}}=1\right)\notag
$$</p>
</blockquote>
<p>利用后一级已有导数信息，可迅速计算当前层级的导数：
$$
\begin{align*}
\d{l}{f_{1}^{(2)}}&amp;=\d{l}{f_1^{(3)}}\d{f_1^{(3)}}{z_1^{(3)}}\d{z_1^{(3)}}{f_{1}^{(2)}}=\d{l}{f_1^{(3)}}\cdot\dot{f}<em>1^{(3)}\cdot w</em>{11}^{(2)}\</p>
<p>\d{l}{w_{11}^{(1)}}&amp;=\d{l}{f_1^{(2)}}\d{f_1^{(2)}}{z_1^{(2)}}\d{z_1^{(2)}}{w_{11}^{(1)}}=\d{l}{f_{1}^{(2)}}\cdot\dot{f}<em>1^{(2)}\cdot f</em>{1}^{(1)}
\end{align*}
$$</p>
<blockquote>
<p>$z_1^{(3)}=w_{11}^{(2)}f_1^{(2)}+b_1^{(2)}$，因此对$w_{11}^{(2)}$求导仅与$f_1^{(2)}$相关。</p>
</blockquote>
<p>如果存在多个输出，或者较浅的层级在求导时，其前置神经元存在多条路径：
$$
\begin{align*}
\d{l}{f_{1}^{(1)}}&amp;=\sum_{i=1}^{n_2}\left{\d{l}{f_i^{(2)}}\d{f_i^{(2)}}{z_i^{(2)}}\d{z_i^{(2)}}{f_1^{(1)}}\right}=\sum_{i=1}^{n_2}\left{\d{l}{f_{i}^{(2)}}\cdot\dot{f}<em>i^{(2)}\cdot w</em>{i1}^{(1)}\right}\</p>
<p>\d{l}{w_{12}^{(0)}}&amp;=\d{l}{f_1^{(1)}}\d{f_1^{(1)}}{z_1^{(1)}}\d{z_1^{(1)}}{w_{12}^{(0)}}=\d{l}{f_1^{(1)}}\dot{f}_1^{(1)}\cdot f_2^{(0)}
\end{align*}
$$</p>
<h5 id="向量化"><a class="header" href="#向量化">向量化</a></h5>
<p>将各级的函数值、导数值信息表示为向量，并根据各级的维度关系，可以得到各级梯度的向量化表示。
$$
\begin{align*}
\bm{d}^{(k)}&amp;=\left(\d{l}{f_{i}^{(2)}}\cdot\dot{f}<em>i^{(k)}\right)</em>{i=1,\cdots,n_k},&amp;
\bm{f}^{(k)}&amp;=\left(f_i^{(k)}\right)_{i=1,\cdots,n_k},\
\frac{\mathrm{d}l}{\mathrm{d}\bm{f}^{(k)}}&amp;={W^{(k)}}^{\top}\cdot\bm{d}^{(k+1)},&amp;
\frac{\mathrm{d}l}{\mathrm{d}\bm{W}^{(k)}}&amp;=\bm{d}^{(k+1)}\cdot{\bm{f}^{(k)}}^{\top}.
\end{align*}
$$
基于梯度信息，我们可以利用梯度下降算法进行迭代从而优化神经网络的参数，以最小化训练数据集的损失。</p>
<h5 id="参考文献-13"><a class="header" href="#参考文献-13">参考文献</a></h5>
<ol>
<li>https://towardsdatascience.com/applied-deep-learning-part-1-artificial-neural-networks-d7834f67a4f6</li>
<li>https://adventuresinmachinelearning.com/neural-networks-tutorial/</li>
</ol>
<h2 id="开源项目"><a class="header" href="#开源项目">开源项目</a></h2>
<h3 id="generative-models-in-tensorflow-2"><a class="header" href="#generative-models-in-tensorflow-2"><a href="https://github.com/timsainb/tensorflow2-generative-models">Generative Models in TensorFlow 2</a></a></h3>
<p>This repository contains TF implementations of multiple generative models, including:</p>
<ul>
<li>Generative Adversarial Networks (GANs)</li>
<li>Autoencoder</li>
<li>Variational Autoencoder (VAE)</li>
<li>VAE-GAN, among others.</li>
</ul>
<h3 id="stumpy--time-series-data-mining"><a class="header" href="#stumpy--time-series-data-mining"><a href="https://github.com/TDAmeritrade/stumpy">STUMPY – Time Series Data Mining</a></a></h3>
<p>Below are a few time series data mining tasks this matrix profile helps us perform:</p>
<ul>
<li>Anomaly discovery</li>
<li>Semantic segmentation</li>
<li>Density estimation</li>
<li>Time series chains (temporally ordered set of subsequence patterns)</li>
<li>Pattern/motif (approximately repeated subsequences within a longer time series) discovery</li>
</ul>
<h3 id="awesome-decision-tree-research-papers"><a class="header" href="#awesome-decision-tree-research-papers"><a href="https://github.com/benedekrozemberczki/awesome-decision-tree-papers">Awesome Decision Tree Research Papers</a></a></h3>
<p>The repository also contains the implementation of each paper.</p>
<h2 id="框架"><a class="header" href="#框架">框架</a></h2>
<h3 id="pytorch-1"><a class="header" href="#pytorch-1">PyTorch</a></h3>
<p>PyTorch is a Python based scientific computing package that is <strong>similar to NumPy, but with the added power of GPUs</strong>. It is also a <strong>deep learning framework that provides maximum flexibility and speed</strong> during implementing and building deep neural network architectures.</p>
<ol>
<li>https://www.analyticsvidhya.com/blog/2019/01/guide-pytorch-neural-networks-case-studies/</li>
</ol>
<blockquote>
<ul>
<li>Use Case 1: Handwritten Digits Classification (Numerical Data, MLP)</li>
<li>Use Case 2: Objects Image Classification (Image Data, CNN)</li>
<li>Use Case 3: Sentiment Text Classification (Text Data, RNN)</li>
<li>Use Case 4: Image Style Transfer (Transfer Learning)</li>
</ul>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="统计学习算法"><a class="header" href="#统计学习算法">统计学习算法</a></h1>
<h2 id="线性回归-1"><a class="header" href="#线性回归-1">线性回归</a></h2>
<p>最小二乘回归：</p>
<pre><code class="language-python">from scipy import stats
m, b, r, p, se = stats.linregress(x, y)
def f(x):  # linear model
    m = 6.3134
    b = -17.9164
    return m*x + b
</code></pre>
<pre><code class="language-python">from sklearn.linear_model import LinearRegression
lr = LinearRegression()  # fit/predict
</code></pre>
<h2 id="基于局部距离信息的算法"><a class="header" href="#基于局部距离信息的算法">基于局部距离信息的算法</a></h2>
<h5 id="knn"><a class="header" href="#knn">KNN</a></h5>
<pre><code class="language-python">from sklearn.neighbors import KNeighborsClassifier
KNeighborsClassifier(k_neighbors=5, weights='uniform', algorithm='auto', leaf_size=30, p=2, metric='minkowski', metric_params=None, n_jobs=None, ...)
</code></pre>
<p><code>weights</code>：权重函数。</p>
<ul>
<li><code>uniform</code>：邻居节点权重相同；</li>
<li><code>distance</code>：另据节点权重与距离成反比；</li>
<li><code>[callable]</code>：用户自定义权重函数。</li>
</ul>
<p><code>algorithm</code>：计算邻居节点算法。</p>
<ul>
<li><code>ball_tree</code></li>
<li><code>kd_tree</code></li>
<li><code>brute</code></li>
<li><code>auto</code>：根据传递给<code>fit</code>方法的数据决定选择的算法。</li>
</ul>
<h5 id="kmeans"><a class="header" href="#kmeans">Kmeans</a></h5>
<blockquote>
<p>The k-means problem is solved using either Lloyd's or Elkan's algorithm.</p>
</blockquote>
<pre><code class="language-python">from sklearn.cluster import KMeans
KMeans(n_clusters=8, init='k-means++', n_init=10, random_state=None)
</code></pre>
<p><code>init</code>：初始化方法，包括<code>k-means++</code>，<code>random</code>（随机选择<code>n_cluster</code>个点作为初始中心点），<code>ndarray</code>（给定初始点），<code>callable</code>（自定义生成初始点的方法）；</p>
<p><code>n_init</code>：k-means算法使用不同中心点运行的次数，最终输出最好的结果。</p>
<p><code>random_state</code>：随机数状态，初始化为整数使得结果确定。</p>
<h6 id="方法-7"><a class="header" href="#方法-7">方法</a></h6>
<pre><code class="language-python">kmeans = Kmeans().fit(X)
labels = kmeans.labels_						# predicted labels
labels = KMeans().fit_predict(X)  # predict labels
x_new = KMeans().fit_transform(X) # to point-centroid distance
</code></pre>
<h2 id="基于分布的算法"><a class="header" href="#基于分布的算法">基于分布的算法</a></h2>
<h3 id="naive-bayes"><a class="header" href="#naive-bayes">Naive Bayes</a></h3>
<pre><code class="language-python">from sklearn.naive_bayes import GaussianNB
</code></pre>
<h2 id="决策树"><a class="header" href="#决策树">决策树</a></h2>
<h3 id="decision-tree"><a class="header" href="#decision-tree">Decision Tree</a></h3>
<pre><code class="language-python">from sklearn.tree import DecisionTreeClassifier
</code></pre>
<h3 id="random-forest"><a class="header" href="#random-forest">Random Forest</a></h3>
<pre><code class="language-python">from sklearn.ensemble import RandomForestClassifier
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sql语法"><a class="header" href="#sql语法">SQL语法</a></h1>
<h2 id="词法"><a class="header" href="#词法">词法</a></h2>
<p>SQL输入由一系列<strong>命令</strong>（<em><strong>command</strong></em>）组成；一个命令由多个由空白（空白、制表符、换行符）分隔的<strong>符号</strong>（<em><strong>token</strong></em>）组成，并以<code>;</code>结束（换行不代表命令结束）。符号可能是<strong>关键字</strong>（<em><strong>keyword</strong></em>）、<strong>标识符</strong>（<em><strong>identifier</strong></em>）、<strong>引用标识符</strong>（<em><strong>quoted identifier</strong></em>）、<strong>字面值</strong>（<em><strong>literal</strong></em>）或<strong>特殊字符</strong>（<em><strong>special character symbol</strong></em>）。</p>
<h3 id="关键字和标识符"><a class="header" href="#关键字和标识符">关键字和标识符</a></h3>
<p>SQL关键字和标识符以字符或下划线开头，其他字符还可以是数字或<code>$</code>。根据SQL标准，</p>
<ul>
<li>标识符不允许使用<code>$</code>，</li>
<li>关键字不包含数字或以下划线开头或结尾。</li>
</ul>
<p>关键字与非引用标识符是==大小写不敏感==的，惯例是关键字使用大写字母，标识符使用小写字母，==解释器会统一转换为小写字母==。</p>
<p>在SQL语句中引用数据库名、表名、列名等标识符，如果标识符的定义包含大写字母、特殊字符或关键字，应该使用引用标识符（使用引号转义），==解释器将保留标识符的输入格式，不做转换==。</p>
<p><code>PostgreSQL</code>使用<code>&quot;&quot;</code>表示引用标识符；<code>MySQL</code>使用<code>`</code>表示。</p>
<pre><code class="language-sql">select &quot;Column A&quot; from &quot;Users&quot;;
</code></pre>
<p>在PostgreSQL数据库中，模式名称和表名称需要分开使用引用标识符，否则会将其视为单个引用标识符。</p>
<pre><code class="language-postgresql">select * from &quot;public&quot;.&quot;Users&quot;;
</code></pre>
<p><code>--</code>或<code>/**/</code>：注释。</p>
<h3 id="字面值-6"><a class="header" href="#字面值-6">字面值</a></h3>
<h4 id="字符串-8"><a class="header" href="#字符串-8">字符串</a></h4>
<p>字符串常量使用<code>''</code>（引用标识符使用<code>&quot;&quot;</code>）。可使用C语言风格转义和Unicode转义。</p>
<pre><code class="language-sql">'This is a string'
E'This is\ta string\\'   -- &quot;This is    a string\&quot; 
U&amp;'\0441\043B\043E\043D'
</code></pre>
<p>PostgresSQL的原始字符串：</p>
<pre><code class="language-sql">$$Dianne's horse$$       --非转义字符串
$TAG$Dianne's horse$TAG$ --添加TAG保证字符串中不出现引用标识
</code></pre>
<h4 id="binary-string"><a class="header" href="#binary-string">Binary String</a></h4>
<p><code>B'1010</code>：比特序列；</p>
<p><code>X'1FF'</code>：半字节序列；</p>
<h4 id="数值常量"><a class="header" href="#数值常量">数值常量</a></h4>
<h3 id="运算符-19"><a class="header" href="#运算符-19">运算符</a></h3>
<pre><code class="language-sql">+ - * / &lt; &gt; = ~ ! @ # % ^ &amp; | ` ?
</code></pre>
<p>下标运算符：<code>[]</code></p>
<p>字段选择：<code>xxx.fieldname</code></p>
<h2 id="变量-10"><a class="header" href="#变量-10">变量</a></h2>
<p><code>DECLARE variable_name datatype(size) DEFAULT default_value;</code></p>
<h2 id="数据库定义sql-ddlmd"><a class="header" href="#数据库定义sql-ddlmd">[数据库定义](SQL DDL.md)</a></h2>
<h2 id="数据操作sql-dmlmd"><a class="header" href="#数据操作sql-dmlmd">[数据操作](SQL DML.md)</a></h2>
<h2 id="流程控制-11"><a class="header" href="#流程控制-11">流程控制</a></h2>
<pre><code class="language-mysql">SELECT IF(var&lt;1000, &quot;YES&quot;, &quot;NO&quot;);

BEGIN
  declare stu_grade float;
  select grade into stu_grade from grade where student_no=stu_no;
  IF stu_grade &gt; 90 THEN
    statement_list;
  ELSEIF stu_grade &gt; 80 THEN
    statement_list;
  ELSE
    statement_list;
  END IF;
END
</code></pre>
<p><a href="https://www.yiibai.com/mysql/stored-procedures-loop.html">MySQL存储过程循环 - MySQL教程™ (yiibai.com)</a></p>
<p>存储过程是存储在数据库目录中的一段声明性SQL语句。</p>
<p><a href="https://www.yiibai.com/mysql/cursor.html">MySQL游标 - 使用MySQL游标来遍历<code>SELECT</code>语句返回的结果集。</a></p>
<p><code>CREATE PROCEDURE</code></p>
<p><a href="https://www.yiibai.com/mysql/stored-function.html">MySQL存储函数 - 使用<code>CREATE FUNCTION</code>语句创建存储的函数。</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="数据库定义语言"><a class="header" href="#数据库定义语言">数据库定义语言</a></h1>
<blockquote>
<p>Data Definition Languages.</p>
</blockquote>
<h2 id="数据库-2"><a class="header" href="#数据库-2">数据库</a></h2>
<h3 id="创建数据库"><a class="header" href="#创建数据库">创建数据库</a></h3>
<pre><code class="language-mysql">CREATE DATABASE [IF NOT EXISTS] database_name
    [[DEFAULT] CHARACTER SET [=] charset_name ]
   	[[DEFAULT] COLLATE [=] collation_name ];
</code></pre>
<p>可选项为数据库使用的字符集和校对规则，不声明则使用默认值。
创建数据库前应该指定所使用的字符集，否则数据表中容易出现乱码。</p>
<blockquote>
<p>在MySQL中：<code>SCHEMA</code>和<code>DATABASE</code>是同义词。在PostgreSQL中，<code>SCHEMA</code>是命名空间，将一个数据库划分为逻辑空间。</p>
</blockquote>
<h3 id="修改数据库"><a class="header" href="#修改数据库">修改数据库</a></h3>
<pre><code class="language-sql">ALTER DATABASE db_name
    [[DEFAULT] CHARACTER SET [=] charset_name ]
    [[DEFAULT] COLLATE [=] collation_name ];
</code></pre>
<p>主要是修改数据的字符集和校对方法。如果<code>db_name</code>没有指定，则是对默认的数据库进行修改。</p>
<h3 id="删除数据库"><a class="header" href="#删除数据库">删除数据库</a></h3>
<pre><code class="language-mysql">DROP DATABASE [IF EXISTS] database_name;
</code></pre>
<h2 id="表"><a class="header" href="#表">表</a></h2>
<h3 id="创建表格"><a class="header" href="#创建表格">创建表格</a></h3>
<pre><code class="language-mysql">CREATE TABLE [IF NOT EXISTS] table_name (
  column_name data_type [column_contraint], ...
)
#[table_options]
#[partition_options]
#[IGNORE | REPLACE];
</code></pre>
<p><code>column_definition</code>表示表的列的声明，每个声明包含：</p>
<pre><code class="language-sql">col_name data_type[(params)]
  [NOT NULL | NULL]
  [DEFAULT value] 
  [AUTO_INCREMENT] [UNIQUE [KEY]] [[PRIMARY] KEY]
  [COMMENT 'string']
</code></pre>
<p><code>column_constraint</code>表示对数值的一个或多个约束，例如<code>NOT NULL</code>、<code>UNIQUE</code>、<code>PRIMARY KEY</code>、<code>AUTO_INCREMENT</code>、比较规则（<code>COLLATE</code>）等；</p>
<p><code>table_options</code>表示设置表的一些属性，例如：引擎（<code>ENGINE</code>）、字符集（<code>CHARACTER SET</code>）、全局比较规则（<code>COLLATE</code>）等，以及约束条件等。</p>
<p><a href="https://dev.mysql.com/doc/refman/8.0/en/create-table.html">MySQL :: MySQL 8.0 Reference Manual :: 13.1.20 CREATE TABLE Statement</a></p>
<p><a href="https://www.postgresql.org/docs/12/sql-createtable.html">PostgreSQL: Documentation: 12: CREATE TABLE</a></p>
<p><a href="%E6%95%B0%E6%8D%AE%E5%BA%93/PostgreSQL.html#%E5%88%9B%E5%BB%BA%E8%A1%A8%E6%A0%BC">PostgreSQL Schema</a>。</p>
<h5 id="注释-3"><a class="header" href="#注释-3">注释</a></h5>
<pre><code class="language-sql">COMMENT ON TABLE &quot;employees&quot; IS '雇员信息';
COMMENT ON COLUMN &quot;employees&quot;.&quot;department&quot; IS '部门名称';
</code></pre>
<h5 id="根据其他表格创建"><a class="header" href="#根据其他表格创建">根据其他表格创建</a></h5>
<p>基于源表的数据类型重新创建数据表并插入数据（<code>WITH NO DATA</code>不插入数据）。</p>
<pre><code class="language-sql">CREATE TABLE dup_table AS (SELECT * FROM table_name);
CREATE TABLE dup_table AS (SELECT * FROM table_name) WITH NO DATA;
</code></pre>
<p>上述方法不会保留源数据表字段的属性。可以使用以下方法复制源表的属性，然后再<a href="%E6%95%B0%E6%8D%AE%E5%BA%93/SQL%20DDL.html#%E4%BB%8E%E8%A1%A8%E6%A0%BC%E5%A4%8D%E5%88%B6">从源表复制数据</a>。</p>
<pre><code class="language-sql">CREATE TABLE dup_table (LIKE table_name INCLUDING ALL);
</code></pre>
<h4 id="查看表的定义"><a class="header" href="#查看表的定义">查看表的定义</a></h4>
<p>查询数据表的属性：</p>
<pre><code class="language-mysql">SELECT table_catalog as db,
       TABLE_SCHEMA as schema, 
       TABLE_NAME, TABLE_TYPE, [VERSION, ]
       TABLE_ROWS as num_rows,
       CREATE_TIME 
   FROM information_schema.tables where table_name='table_name';
</code></pre>
<blockquote>
<p><code>table_schema</code>：MySQL为数据库名，PostgreSQL为模式名（<code>table_catalog</code>为数据库名）；</p>
</blockquote>
<p><a href="%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL.html#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86">MySQL查询方法</a>。</p>
<p><a href="%E6%95%B0%E6%8D%AE%E5%BA%93/PostgreSQL.html#%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BF%A1%E6%81%AF">PostgreSQL查询方法</a>。</p>
<h3 id="索引-2"><a class="header" href="#索引-2">索引</a></h3>
<p><code>PRIMARY KEY</code>：</p>
<p><strong>Foreign Keys</strong>：所定义列取值范围由所引用的外部数据表列确定。</p>
<pre><code class="language-sql">column_name data_type references another_table(col_name)
</code></pre>
<h4 id="创建索引"><a class="header" href="#创建索引">创建索引</a></h4>
<pre><code class="language-mysql">CREATE [UNIQUE] INDEX [[IF NOT EXISTS] index_name] ON table_name [USING method]
    ( {column_name | (expression) }[ASC|DESC][, ...] ) -- index columns
    [ TABLESPACE tablespace_name ]
    [ WHERE predicate ] -- partial index
</code></pre>
<p><code>USING method</code>: PostgreSQL provides the index methods <code>btree</code> (default), <code>hash</code>, <code>gist</code>, <code>spgist</code>, <code>gin</code>, and <code>brin</code>. </p>
<p><code>{column_name|(expression)</code>: Multiple fields can be specified if the index method supports multicolumn indexes. An index field can be an expression computed from the values of one or more columns of the table row. This feature can be used to obtain fast access to data based on some transformation of the basic data. For example, an index computed on <code>upper(col)</code> would allow the clause <code>WHERE upper(col) = 'JIM'</code> to use an index.</p>
<p><code>UNIQUE</code>: 索引列数据有重复值将产生错误。</p>
<h3 id="删除表"><a class="header" href="#删除表">删除表</a></h3>
<pre><code class="language-sql">DROP TABLE table_name;
</code></pre>
<h3 id="修改表"><a class="header" href="#修改表">修改表</a></h3>
<h4 id="修改表的字段类型"><a class="header" href="#修改表的字段类型">修改表的字段类型</a></h4>
<pre><code class="language-sql">ALTER TABLE table_name MODIFY [COLUMN] col_name column_definition [FIRST | AFTER col_name]
</code></pre>
<p>默认不改变列的位置。</p>
<h4 id="修改表的字段名称和类型"><a class="header" href="#修改表的字段名称和类型">修改表的字段名称和类型</a></h4>
<pre><code class="language-sql">ALTER TABLE table_name CHANGE [COLUMN] 
	old_col_name new_col_name column_definition 
	[FIRST|AFTER col_name]
</code></pre>
<p>只修改名称则列的定义应该保持不变，只修改列的定义则<code>old_col_name</code>和 <code>new_col_name</code>应该相同。可以选择更改列的位置。</p>
<h4 id="增加表的字段"><a class="header" href="#增加表的字段">增加表的字段</a></h4>
<pre><code class="language-sql">ALTER TABLE table_name ADD [COLUMN] col_name column_definition [FIRST|AFTER col_name]
</code></pre>
<p>​	FIRST:表示作为表的首个字段；
​	AFTER col_name：表示位于col_name字段之后；
​	默认：增加字段位于表的末端</p>
<h4 id="删除表的字段"><a class="header" href="#删除表的字段">删除表的字段</a></h4>
<pre><code class="language-sql">ALTER TABLE table_name DROP [COLUMN] col_name
</code></pre>
<p>​	</p>
<h4 id="更改表名"><a class="header" href="#更改表名">更改表名</a></h4>
<pre><code class="language-sql">ALTER TABLE table_name RENAME [TO] new_tbl_name
</code></pre>
<pre><code>注意：CHANGE/FIRST/AFTER/COLUMN这些关键字是MySQL在标准SQL上的扩展，在其他数据库上不一定适用。
</code></pre>
<p>https://www.yiibai.com/sql/sql-create-table.html</p>
<h2 id="partitioning"><a class="header" href="#partitioning">Partitioning</a></h2>
<h3 id="bucketing"><a class="header" href="#bucketing">Bucketing</a></h3>
<p><code>CLUSTERED BY</code>声明分组。</p>
<pre><code class="language-sql">CREATE TABLE table_name (column1 data_type, column2 data_type, …) PARTITIONED BY (partition1 data_type, partition2 data_type,….) CLUSTERED BY (clus_col1) SORTED BY (sort_col2) INTO n BUCKETS;
</code></pre>
<blockquote>
<p>分组被存储为文件。</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="数据操作语言"><a class="header" href="#数据操作语言">数据操作语言</a></h1>
<blockquote>
<p>Data Manipulation Languages.</p>
</blockquote>
<h2 id="修改数据表"><a class="header" href="#修改数据表">修改数据表</a></h2>
<h3 id="插入数据记录"><a class="header" href="#插入数据记录">插入数据记录</a></h3>
<pre><code class="language-sql">INSERT INTO table_name [(col_name,...)]
                 VALUES (col_value,...),(...),...
                 WHERE conditions;
</code></pre>
<blockquote>
<p><code>MySQL</code>可省略<code>INTO</code>关键字。</p>
<p>如果未指定列名，则需按列定义顺序给出所有列的值；反之，只需给出指定的列名对应的值（未指定的列的值为<code>NULL</code>）。</p>
<p>非数值类型：使用单引号包含起来，以免发生错误。</p>
</blockquote>
<h3 id="批量插入记录"><a class="header" href="#批量插入记录">批量插入记录</a></h3>
<h4 id="从表格复制"><a class="header" href="#从表格复制">从表格复制</a></h4>
<pre><code class="language-mysql">INSERT INTO target_table (SELECT * from source_table);
</code></pre>
<h3 id="替换数据记录"><a class="header" href="#替换数据记录">替换数据记录</a></h3>
<p><a href="https://dev.mysql.com/doc/refman/8.0/en/replace.html"><code>REPLACE</code></a> works exactly like <a href="https://dev.mysql.com/doc/refman/8.0/en/insert.html"><code>INSERT</code></a>, except that if an old row in the table has the same value as a new row for a <code>PRIMARY KEY</code> or a <code>UNIQUE</code> index, the old row is deleted before the new row is inserted.</p>
<pre><code class="language-mysql">REPLACE INTO table_name [(col_name,...)]
                 VALUES (col_value,...),(...),...;
</code></pre>
<pre><code class="language-mysql">INSERT IGNORE table_name ...;
</code></pre>
<blockquote>
<p>忽略导致错误的行，并将其余行插入到表中。</p>
</blockquote>
<h3 id="更新记录字段"><a class="header" href="#更新记录字段">更新记录字段</a></h3>
<p>将满足条件的表项的字段值更新为设定值。</p>
<pre><code class="language-sql">UPDATE table_name 
SET col_name1=value1[, col_name2=expr1] ...
[WHERE where_condition]
</code></pre>
<h3 id="删除数据记录"><a class="header" href="#删除数据记录">删除数据记录</a></h3>
<h4 id="删除单表记录"><a class="header" href="#删除单表记录">删除单表记录</a></h4>
<pre><code class="language-sql">DELETE FROM tbl_name [WHERE where_condition];
</code></pre>
<h5 id="清空表内容"><a class="header" href="#清空表内容">清空表内容</a></h5>
<pre><code class="language-sql">TRUNCATE TABLE tbl_name -- 类似于使用`DELETE`删除所有记录。
</code></pre>
<p>如果该表有外键约束，则可临时禁用外键约束再清空表内容（可能破坏关联表的数据完整性，需要同时处理相关表）。</p>
<pre><code class="language-mysql">SET FOREIGN_KEY_CHECKS = 0; -- 当前会话禁用约束检查
</code></pre>
<h4 id="删除多表的记录"><a class="header" href="#删除多表的记录">删除多表的记录</a></h4>
<pre><code class="language-sql">DELETE tbl_name[.*] [, tbl_name[.*]] ...
FROM   table_references
[WHERE where_condition];
</code></pre>
<p>示例：</p>
<pre><code class="language-sql">DELETE t1,t2 FROM store_info t1,store_geo t2 where t1.store_name='Boston' AND t2.store_name='Boston';
</code></pre>
<p>注意多表时，<code>FROM</code>后面如果使用了表的别名，则<code>DELETE</code>之后也要使用表的别名，否则会出现错误。
无论是单表还是多表，如果不加<code>WHERE</code>作为条件限制将会导致表的记录全部被删除，因此要小心。</p>
<h2 id="查询数据"><a class="header" href="#查询数据">查询数据</a></h2>
<p>查询使用<code>SELECT</code>命令。一般语法：https://dev.mysql.com/doc/refman/8.0/en/select.html。</p>
<pre><code class="language-sql">SELECT [DISTINCT] field1, field2 AS Name, FUNC(field3), ...
   FROM table_reference 
   [WHERE condition]
   [GROUP BY col_list]
   [ORDER BY col_list]
   [CLUSTER BY col_list | [DISTRIBUTE BY col_list] [SORT BY col_list] ]
   [LIMIT [offset], num_rows];
</code></pre>
<p>使用<code>*</code>代替字段名称，用于查询所有列，<code>AS</code>为返回结果的变量设置列名。查询语句中不仅可以直接使用变量，也可以<a href="%E6%95%B0%E6%8D%AE%E5%BA%93/SQL%20DML.html#%E8%BF%90%E7%AE%97">将函数应用于查询字段或条件中的字段</a>。</p>
<p><code>SELECT DISTINCT</code>关键字用于<strong>查询不重复的记录</strong>。</p>
<h3 id="条件过滤"><a class="header" href="#条件过滤">条件过滤</a></h3>
<p>通常基于字段的值构造逻辑表达式，表达式<strong>返回结果长度与表格行数</strong>一致（返回结果也可以是标量）。</p>
<pre><code class="language-sql">SELECT * FROM store_info WHERE sales&lt;1000;
SELECT * FROM Customers WHERE Country='Germany' AND (City='Berlin' OR City='München');
</code></pre>
<p>条件表达式可以使用比较运算符：“<code>=</code>”（等于）、“<code>&gt;</code>”、“<code>&lt;</code>”、“<code>&gt;=</code>”、“<code>&lt;=</code>”、“<code>!=</code>”/“<code>&lt;&gt;</code>”（不等于）。</p>
<blockquote>
<p>不支持“<code>==</code>”。</p>
</blockquote>
<p>空值判断运算符：<code>IS NULL</code>和<code>IS NOT NULL </code>，空值不支持比较运算符。</p>
<p>时间日期字段可以和字面值进行比较：<code>start_time&gt;='2021-11-01'</code>。</p>
<p><strong>注意</strong>：条件过滤的执行先于<code>SELECT</code>，因此在<code>SELECT</code>语句中声明的查询结果别名无法在<code>WHERE</code>语句中使用。如果查询条件需要用到<code>SELECT</code>计算出的列，可先执行[子查询](# 查询表引用子查询结果)，再从子查询结果中指定过滤条件再次查询。</p>
<h5 id="复合条件"><a class="header" href="#复合条件">复合条件</a></h5>
<p>多个表达式之间还可以使用 <code>AND</code>、<code>OR</code>和<code>NOT</code>等逻辑运算符进行多条件联合查询。</p>
<h4 id="模糊查询"><a class="header" href="#模糊查询">模糊查询</a></h4>
<pre><code class="language-sql">SELECT * FROM table_name WHERE columnN LIKE pattern;
</code></pre>
<p><code>pattern</code>支持通配符：</p>
<ul>
<li><code>%</code>：零个或多个字符；</li>
<li><code>_</code>：一个字符；</li>
<li><code>[]</code>：任何一个在括号中的字符，<code>[^abc]</code>任何不在括号中的字符，<code>[a-z]</code>指定字符区间。</li>
</ul>
<blockquote>
<p>Hive：<code>LIKE</code>支持函数式调用<code>LIKE(A,B)</code>。</p>
</blockquote>
<h4 id="正则表达式-4"><a class="header" href="#正则表达式-4">正则表达式</a></h4>
<blockquote>
<p>MySQL需要8.0版本支持。</p>
</blockquote>
<h5 id="正则表达式函数"><a class="header" href="#正则表达式函数">正则表达式函数</a></h5>
<p><code>REGEXP_LIKE(expr, pat[, match_type])</code>：匹配返回1，否则返回0；若参数为<code>NULL</code>，则返回<code>NULL</code>；<code>REGEXP</code>和<code>RLIKE</code>是作为运算符的同义词，即</p>
<pre><code class="language-sql">key REGEXP pattern
expr NOT_REGEXP pattern, NOT (expr REGEXP pattern)
</code></pre>
<blockquote>
<p>Hive: <code>REGEXP</code> , <code>RLIKE</code>返回<code>true|false|null</code>，同时也支持函数式调用。</p>
</blockquote>
<p><code>REGEXP_SUBSTR(expr, pat[, pos[, occurrence[, match_type]]])</code></p>
<blockquote>
<p><code>pos</code>：匹配起始位置，默认为1；
<code>occurrence</code>：<em>表示返回匹配的序号，默认0表示返回全部匹配</em>；</p>
<p>Hive语法为：<code>REGEXP_EXTRACT(colname, 'pattern', index)</code>，其中<code>index</code>为0表示返回匹配结果，<code>index&gt;0</code>表示返回对应的捕获组。</p>
</blockquote>
<pre><code class="language-sql">select REGEXP_SUBSTR(store_name, '10\.12.*') from test_type 
	where store_name REGEXP '10\.12.*';
</code></pre>
<p><code>REGEXP_REPLACE(expr, pat, repl[, pos[, occurrence[, match_type]]])</code></p>
<h3 id="排序和限制"><a class="header" href="#排序和限制">排序和限制</a></h3>
<pre><code class="language-mysql">SELECT * FROM table_name 
    ORDER BY field1 [DESC|ASC],field2 [DESC|ASC]...
    LIMIT [offset_start,] row_count ;
</code></pre>
<p>根据给出字段，对选出的查询记录进行排序，可以指定升序或降序。如果排序后只希望显示结果的一部分，则可以使用<code>limit</code>关键字来实现。	</p>
<p>记录的索引是从0开始的，如果没有声明<code>offset_start</code>，则默认从第0条显示。
<code>limit</code>经常和<code>order by</code>一起使用，用于分页显示。</p>
<h3 id="运算-3"><a class="header" href="#运算-3">运算</a></h3>
<h4 id="算术运算-1"><a class="header" href="#算术运算-1">算术运算</a></h4>
<pre><code class="language-sql">SELECT 1*2*3 as a, 1+2+3 as b;
SELECT city, (temp_hi+temp_lo)/2 AS temp_avg, date FROM weather;
</code></pre>
<h4 id="字符串运算"><a class="header" href="#字符串运算">字符串运算</a></h4>
<h5 id="大小写转换"><a class="header" href="#大小写转换">大小写转换</a></h5>
<pre><code class="language-sql">SELECT UPPER(Name) FROM Customers where UPPER(Name)='GARY';  -- LOWER
</code></pre>
<h4 id="json函数和运算符"><a class="header" href="#json函数和运算符">JSON函数和运算符</a></h4>
<blockquote>
<p><em>The main difference of json and jsonb data type is json will store the data into the plain text format while jsonb data type will store the data in binary format.</em></p>
</blockquote>
<h5 id="postgresql"><a class="header" href="#postgresql">PostgreSQL</a></h5>
<pre><code class="language-sql">SELECT json_field::json-&gt;0     as f FROM table;  # 获取JSON数组的元素
SELECT json_field::json-&gt;'key' as f FROM table;  # 获取JSON对象的值
SELECT json_field::json#&gt;'{key_idx,subkey_idx,...}' as f FROM table;  # 查询嵌套对象的元素
</code></pre>
<p>另外，运算符<code>-&gt;&gt;,#&gt;&gt;</code>将返回值转换为文本类型。</p>
<p><code>jsonb</code>类型支持比较运算符而<code>json</code>类型不支持，此外<code>jsonb</code>还支持以下特殊比较运算。</p>
<pre><code class="language-sql">json_a::jsonb @&gt; json_b::jsonb  # A是否包含B，&quot;&lt;@&quot; 反之
json_a::jsonb ? 'key'           # A的顶层键名/元素是否包含'key'
json_a::jsonb ?| array['key1', 'key2'] # 是否包含任意键名/元素，&quot;?&amp;&quot;包含所有键名/元素
</code></pre>
<p><a href="https://www.postgresql.org/docs/9.5/functions-json.html">JSON处理函数</a>。</p>
<h3 id="连接-2"><a class="header" href="#连接-2">连接</a></h3>
<p>当需要同时显示多个表中的字段时，就可以使用连接来实现。
连接可分为内连接和外连接。它们之间最主要的区别在于内连接只选出表中互相匹配的记录，而外连接会选出其他不匹配的记录。</p>
<h4 id="内连接"><a class="header" href="#内连接">内连接</a></h4>
<pre><code class="language-mysql">SELECT * | T1.cm [AS A1],T2.cn [AS A2][,...]
	FROM table_1 [AS] T1,table_2 [AS] T2
	WHERE T1.cx=T2.cy;
SELECT * FROM weather 
  [INNER] JOIN cities 
  ON (weather.city = cities.name);
</code></pre>
<p>当两个表存在相同列名时，需要使用表名（或别名）来区分引用同名列。</p>
<blockquote>
<p>在使用内连接时，必须注意<code>WHERE</code>语句的条件一定要是两个表的匹配条件，如果该条件是错误的（不匹配），则会产生笛卡尔连接，导致产生巨大的查询结果。</p>
</blockquote>
<h4 id="外连接"><a class="header" href="#外连接">外连接</a></h4>
<p>外连接又分为：</p>
<ul>
<li>全连接：包含所有</li>
<li>左连接：包含所有左边表中的记录，右表没有的记录填充<code>NULL</code>；</li>
<li>右连接：包含右边表中的所有记录，左表没有的记录填充<code>NULL</code>；</li>
</ul>
<p>外连接语法：</p>
<pre><code class="language-mysql">SELECT * FROM table_1 [[AS] T1]
    [LEFT|RIGHT|FULL] OUTER JOIN table_2 [[AS] T2]
    ON (T1.cx=T2.cy);
</code></pre>
<p>交换<code>FROM</code>后表的顺序，则左连接和右连接可以相互转换。</p>
<h3 id="子查询"><a class="header" href="#子查询">子查询</a></h3>
<p>查询语句中引用的数据，例如表或查询条件的值，可以是其他查询的返回值。</p>
<h5 id="查询表引用子查询结果"><a class="header" href="#查询表引用子查询结果">查询表引用子查询结果</a></h5>
<pre><code class="language-sql">SELECT * FROM ( SELECT sql_func(col) AS F FROM table) AS T where F = 'some_value'; 
</code></pre>
<h5 id="查询条件引用子查询结果"><a class="header" href="#查询条件引用子查询结果">查询条件引用子查询结果</a></h5>
<pre><code class="language-sql">SELECT * FROM table_name WHERE field_n OPERATOR (sub_select)
SELECT city FROM weather WHERE temp_lo = (SELECT max(temp_lo) FROM weather)；
</code></pre>
<h3 id="视图-1"><a class="header" href="#视图-1">视图</a></h3>
<p>将查询语句保存为视图。相比于子查询，方便后续重复引用。</p>
<pre><code class="language-sql">CREATE VIEW myview AS
    SELECT col_names FROM weather, cities WHERE city = name;
SELECT * from myview;
</code></pre>
<h2 id="聚合与分组"><a class="header" href="#聚合与分组">聚合与分组</a></h2>
<pre><code class="language-sql">SELECT [field,...] agg_func(field_i)	FROM table_name
	[GROUP BY field1,field2,...,fieldn [WITH ROLLUP]]
	[HAVING where_condition]
</code></pre>
<p><code>agg_func</code>：表示聚合函数，即对表的某一列进行的统计运算。常用的有<code>sum</code>、<code>count</code>（计数）、<code>max</code>（最大值）、<code>min</code>（最小值）。
<code>GROUP BY</code>：对查询的表首先根据字段进行分组 ，然后对每个子类进行运算统计（聚合）。<code>WITH ROLLUP</code>（汇总）：表示将分组统计结果作为一个整体，再次进行聚合运算，并将结果附加到分组计算结果之后。
<code>HAVING</code>：类似于<code>WHERE</code>，只是<code>HAVING</code>是在聚合之后对结果进行过滤，而<code>WHERE</code>是在聚合之前对原表进行过滤。</p>
<h3 id="window-functions"><a class="header" href="#window-functions">Window Functions</a></h3>
<p>进行分组并调用聚合函数，但聚合结果将关联到对应组的所有行，而非聚合为单条记录。</p>
<pre><code class="language-mysql">SELECT depname, salary, avg(salary) OVER (PARTITION BY depname) 
  FROM empsalary;
</code></pre>
<h2 id="事务transactions"><a class="header" href="#事务transactions">事务（Transactions）</a></h2>
<p>将多个操作步骤组合到一起形成原子操作，保证该组操作仅处于完全完成或未执行的状态。</p>
<blockquote>
<p><em>A transactional database guarantees that all the updates made by a transaction are logged in permanent storage (i.e., on disk) before the transaction is reported complete.</em></p>
</blockquote>
<pre><code class="language-mysql">BEGIN;
-- SQL statements
ROLLBACK; -- cancel the transaction
COMMIT; -- complete the transaction
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sql数据类型"><a class="header" href="#sql数据类型">SQL数据类型</a></h1>
<h2 id="mysql"><a class="header" href="#mysql">MySQL</a></h2>
<h3 id="数值类型-1"><a class="header" href="#数值类型-1">数值类型</a></h3>
<div class="table-wrapper"><table><thead><tr><th>类型</th><th>说明</th></tr></thead><tbody>
<tr><td><code>BIT(size)</code></td><td><code>size=[1,64](1)</code></td></tr>
<tr><td><code>TINYINT(size)</code></td><td>8-bit int</td></tr>
<tr><td><code>SMALLINT(size)</code></td><td>16bit int</td></tr>
<tr><td><code>MEDIUMINT(size)</code></td><td>24bit int</td></tr>
<tr><td><code>INT(size)</code></td><td>32bit int, as <code>INTEGER(size)</code></td></tr>
<tr><td><code>BIGINT(size)</code></td><td>64bit int</td></tr>
<tr><td><code>FLOAT(p)</code></td><td>$p\le 24$ as <code>FLOAT()</code><br/>$25\le p\le53$ as <code>DOUBLE()</code></td></tr>
<tr><td><code>DOUBLE(size, d)</code></td><td><code>size</code>: number of total digits<br/><code>d</code>: 小数点后位数</td></tr>
<tr><td><code>DECIMAL(size, d)</code></td><td>as <code>DEC(size, d)</code></td></tr>
<tr><td><code>BOOL</code></td><td>as <code>BOOLEAN</code>, <br/>zero (false) or nonzero (true)</td></tr>
</tbody></table>
</div>
<blockquote>
<p><code>DOUBLE PRECISION(size, d)</code></p>
</blockquote>
<h4 id="可选属性"><a class="header" href="#可选属性">可选属性</a></h4>
<p><code>UNSIGNED</code> 
<code>ZEROFILL</code>：用于显示格式，告知MySQL用0将数值的空格补齐，而不是空着。<code>ZEROFILL</code>也会自动添加<code>UNSIGNED</code>属性。整形数据后面括号中的数表示数据的显示宽度。当数据的宽度小于显示宽度的时候将会使用空格补齐，如果声明了ZEROFILL，则以0填充；如果数据的宽度大于显示宽度，则按数据的实际宽度显示。
<code>AUTO_INCREMENT</code>：用于类型为整数的列，且一个表中只能有一列可以有该属性，当插入的行的该列的值为<code>NULL</code>，该列的值会被自动设置成该列的最大值加1。对于要使用<code>AUTO_INCREMENT</code>属性的列，应该定义为<code>NOT_NULL</code>，并定义为<code>PRIMARY KEY</code>或定义为<code>UNIQUE</code>。可按下列方式定义AUTO_INCREMENT列：</p>
<pre><code class="language-sql">CREATE TABLE table_name(id INT AUTO_INCREMENT NOT NULL PRIMARY KEY);
CREATE TABLE table_name(id INT AUTO_INCREMENT NOT NULL, PRIMARY KEY(id));
CREATE TABLE table_name(id INT AUTO_INCREMENT NOT NULL, UNIQUE(id));
</code></pre>
<h3 id="字符串数据"><a class="header" href="#字符串数据">字符串数据</a></h3>
<div class="table-wrapper"><table><thead><tr><th>类型</th><th>说明</th><th></th></tr></thead><tbody>
<tr><td><code>CHAR(size)</code></td><td><code>size=[0,255](1)</code></td><td>固定长度，填充空白（读取时移除填充）</td></tr>
<tr><td><code>VARCHAR(size)</code></td><td><code>size=[0,65535]</code></td><td>储存长度和值，最大长度还受限于行记录最大长度65535以及使用的编码方法。</td></tr>
<tr><td><code>TINYTEXT</code></td><td><code>[0,255]</code></td><td></td></tr>
<tr><td><code>TEXT(size)</code></td><td><code>size=[0,65535]</code></td><td></td></tr>
<tr><td><code>MEDIUMTEXT</code></td><td><code>[0,16777215]</code></td><td>16MB</td></tr>
<tr><td><code>LONGTEXT</code></td><td><code>[0,4294967295]</code></td><td>4GB，字符数限制与编码方法相关。</td></tr>
<tr><td><code>SET(val1, ...)</code></td><td>枚举字符串（最多64个）</td><td></td></tr>
<tr><td><code>ENUM(val1, ...)</code></td><td>枚举字符串（最多65535个）</td><td></td></tr>
</tbody></table>
</div>
<p>字符串类型列声明时可指定字符集的属性（覆盖数据库默认属性）：</p>
<pre><code class="language-mysql">CREATE TABLE t
(
    c1 VARCHAR(20) CHARACTER SET utf8mb4,
    c2 TEXT CHARACTER SET latin1 COLLATE latin1_general_cs
);
</code></pre>
<h4 id="json数据类型"><a class="header" href="#json数据类型">JSON数据类型</a></h4>
<p>使用JSON数据类型相比于字符串类型有以下优点：</p>
<ul>
<li>自动校验；</li>
<li>优化存储格式，支持快速访问（直接通过建或索引访问子对象，无需读取整个JSON文档）。</li>
</ul>
<p>JSON类型的存储空间需求与<code>LONGTEXT</code>相似。</p>
<pre><code class="language-mysql">CREATE TABLE t1 (jdoc JSON);
INSERT INTO t1 VALUES('{&quot;key1&quot;: &quot;value1&quot;, &quot;key2&quot;: &quot;value2&quot;}');
</code></pre>
<p><a href="https://dev.mysql.com/doc/refman/8.0/en/json-creation-functions.html#function_json-array"><code>JSON_ARRAY()</code></a>：构造JSON数组。</p>
<p><a href="https://dev.mysql.com/doc/refman/8.0/en/json-creation-functions.html#function_json-object"><code>JSON_OBJECT()</code></a>：构造JSON对象。</p>
<blockquote>
<p><em>The <a href="https://dev.mysql.com/doc/refman/8.0/en/update.html"><code>UPDATE</code></a> statement uses any of the three functions <a href="https://dev.mysql.com/doc/refman/8.0/en/json-modification-functions.html#function_json-set"><code>JSON_SET()</code></a>, <a href="https://dev.mysql.com/doc/refman/8.0/en/json-modification-functions.html#function_json-replace"><code>JSON_REPLACE()</code></a>, or <a href="https://dev.mysql.com/doc/refman/8.0/en/json-modification-functions.html#function_json-remove"><code>JSON_REMOVE()</code></a> to update the column.</em></p>
<p><em>The input column and the target column must be the same column; a statement such as <code>UPDATE mytable SET jcol1 = JSON_SET(jcol2, '$.a', 100)</code> cannot be performed as a partial update.</em></p>
</blockquote>
<p><a href="https://dev.mysql.com/doc/refman/8.0/en/json.html">MySQL :: MySQL 8.0 Reference Manual :: 11.5 The JSON Data Type</a></p>
<h3 id="binary类型"><a class="header" href="#binary类型">Binary类型</a></h3>
<p>与相应的字符串类型类似，但存储字节串。</p>
<div class="table-wrapper"><table><thead><tr><th>类型</th><th>说明</th></tr></thead><tbody>
<tr><td><code>BINARY(size)</code></td><td></td></tr>
<tr><td><code>VARBINARY(size)</code></td><td></td></tr>
<tr><td><code>TINYBLOB</code></td><td></td></tr>
<tr><td><code>BLOB(size)</code></td><td></td></tr>
<tr><td><code>MEDIUMBLOB</code></td><td></td></tr>
<tr><td><code>LONGBLOB</code></td><td></td></tr>
</tbody></table>
</div>
<h3 id="日期时间类型"><a class="header" href="#日期时间类型">日期时间类型：</a></h3>
<div class="table-wrapper"><table><thead><tr><th>类型</th><th>说明</th><th></th></tr></thead><tbody>
<tr><td><code>DATE</code></td><td><code>YYYY-MM-DD</code></td><td></td></tr>
<tr><td><code>DATETIME(fsp)</code></td><td><code>YYYY-MM-DD hh:mm:ss</code></td><td></td></tr>
<tr><td><code>TIMESTAMP(fsp)</code></td><td></td><td></td></tr>
<tr><td><code>TIME(fsp)</code></td><td><code>hh:mm:ss</code></td><td></td></tr>
<tr><td><code>YEAR</code></td><td><code>1901-2155, 0000</code></td><td></td></tr>
</tbody></table>
</div>
<h2 id="postgresql-1"><a class="header" href="#postgresql-1">PostgreSQL</a></h2>
<h2 id="sql-server"><a class="header" href="#sql-server">SQL Server</a></h2>
<h3 id="字符类型"><a class="header" href="#字符类型">字符类型</a></h3>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Data type</th><th style="text-align: left">Description</th><th style="text-align: left">Max size</th><th style="text-align: left">Storage</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>char(n)</code></td><td style="text-align: left">定长字符序列</td><td style="text-align: left">8000 chars</td><td style="text-align: left"><code>n</code> chars</td></tr>
<tr><td style="text-align: left"><code>varchar(n)</code></td><td style="text-align: left">变长字符序列</td><td style="text-align: left">8000 chars</td><td style="text-align: left"><code>2+n</code> chars</td></tr>
<tr><td style="text-align: left"><code>varchar(max)</code></td><td style="text-align: left">变长字符序列</td><td style="text-align: left">1073741824 chars</td><td style="text-align: left"><code>2+n</code> chars</td></tr>
<tr><td style="text-align: left"><code>text</code></td><td style="text-align: left">变长字符序列</td><td style="text-align: left">2GB of text data</td><td style="text-align: left"><code>4+n</code> chars</td></tr>
<tr><td style="text-align: left"><code>nchar</code><br/><code>nvarchar</code></td><td style="text-align: left">定长Unicode字符串</td><td style="text-align: left">4000 chars</td><td style="text-align: left"><code>2n</code> bytes</td></tr>
<tr><td style="text-align: left"><code>nvarchar(max)</code></td><td style="text-align: left">变长Unicode字符串</td><td style="text-align: left">536870912 chars</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left"><code>ntext</code></td><td style="text-align: left">变长Unicode字符串</td><td style="text-align: left">2GB of text data</td><td style="text-align: left"></td></tr>
</tbody></table>
</div>
<h3 id="binary类型-1"><a class="header" href="#binary类型-1">Binary类型：</a></h3>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Data type</th><th style="text-align: left">Description</th><th style="text-align: left">Max size</th><th style="text-align: left">Storage</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>binary(n)</code></td><td style="text-align: left">定长字节序列</td><td style="text-align: left">8,000 bytes</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left"><code>varbinary</code></td><td style="text-align: left">变长字节序列</td><td style="text-align: left">8,000 bytes</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left"><code>varbinary(max)</code></td><td style="text-align: left">变长字节序列</td><td style="text-align: left">2GB</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left"><code>image</code></td><td style="text-align: left">变长字节序列</td><td style="text-align: left">2GB</td><td style="text-align: left"></td></tr>
</tbody></table>
</div>
<h3 id="数值类型-2"><a class="header" href="#数值类型-2">数值类型：</a></h3>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Data type</th><th style="text-align: left">Description</th><th style="text-align: left">Storage</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>bit</code></td><td style="text-align: left">0, 1, or NULL</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left"><code>tinyint</code></td><td style="text-align: left">8-bit int 0 to 255</td><td style="text-align: left">1 byte</td></tr>
<tr><td style="text-align: left"><code>smallint</code></td><td style="text-align: left">16-bit int, -32,768 and 32,767</td><td style="text-align: left">2 bytes</td></tr>
<tr><td style="text-align: left"><code>int</code></td><td style="text-align: left">32-bit int</td><td style="text-align: left">4 bytes</td></tr>
<tr><td style="text-align: left"><code>bigint</code></td><td style="text-align: left">64-bit int</td><td style="text-align: left">8 bytes</td></tr>
<tr><td style="text-align: left"><code>decimal(p,s)</code></td><td style="text-align: left"></td><td style="text-align: left">5-17 bytes</td></tr>
<tr><td style="text-align: left"><code>numeric(p,s)</code></td><td style="text-align: left"></td><td style="text-align: left">5-17 bytes</td></tr>
<tr><td style="text-align: left"><code>smallmoney</code></td><td style="text-align: left">Monetary data</td><td style="text-align: left">4 bytes</td></tr>
<tr><td style="text-align: left"><code>money</code></td><td style="text-align: left">Monetary data</td><td style="text-align: left">8 bytes</td></tr>
<tr><td style="text-align: left"><code>float(n)</code></td><td style="text-align: left"></td><td style="text-align: left">4 or 8 bytes</td></tr>
<tr><td style="text-align: left"><code>real</code></td><td style="text-align: left"></td><td style="text-align: left">4 bytes</td></tr>
</tbody></table>
</div>
<h3 id="日期时间类型-1"><a class="header" href="#日期时间类型-1">日期时间类型：</a></h3>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Data type</th><th style="text-align: left">Description</th><th style="text-align: left">Storage</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>datetime</code></td><td style="text-align: left"><code>1753/1/1-9999/12/31</code> , 3.33 milliseconds</td><td style="text-align: left">8 bytes</td></tr>
<tr><td style="text-align: left"><code>datetime2</code></td><td style="text-align: left"><code>0001/1/1-9999/12/31</code>, accuracy of 100 nanoseconds</td><td style="text-align: left">6-8 bytes</td></tr>
<tr><td style="text-align: left"><code>smalldatetime</code></td><td style="text-align: left"><code>1900/1/1-2079/6/6</code>, accuracy of 1 minute</td><td style="text-align: left">4 bytes</td></tr>
<tr><td style="text-align: left"><code>date</code></td><td style="text-align: left"><code>0001/1/1-9999/12/31</code> , date only</td><td style="text-align: left">3 bytes</td></tr>
<tr><td style="text-align: left"><code>time</code></td><td style="text-align: left">time only, accuracy of 100 nanoseconds</td><td style="text-align: left">3-5 bytes</td></tr>
<tr><td style="text-align: left"><code>datetimeoffset</code></td><td style="text-align: left">as datetime2 ,with time zone offset</td><td style="text-align: left">8-10 bytes</td></tr>
<tr><td style="text-align: left"><code>timestamp</code></td><td style="text-align: left"></td><td style="text-align: left"></td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="mysql-1"><a class="header" href="#mysql-1">MySQL</a></h1>
<img src="数据库/MySQL.assets/mariadb-vs-mysql.png" alt="MariaDB vs MySQL" style="zoom: 33%;" align="center" />
<p><a href="https://kinsta.com/blog/mariadb-vs-mysql/">MariaDB vs MySQL, a Database Technologies Rundown (kinsta.com)</a></p>
<h2 id="安装运行"><a class="header" href="#安装运行">安装运行</a></h2>
<h3 id="本机安装运行"><a class="header" href="#本机安装运行">本机安装运行</a></h3>
<pre><code class="language-shell">sudo apt install mysql-server mysql-client  # 可选
</code></pre>
<blockquote>
<p>图形界面：<code>MySQL Workbench</code>。</p>
</blockquote>
<h4 id="使用yum源安装mysql"><a class="header" href="#使用yum源安装mysql">使用Yum源安装MySQL</a></h4>
<p><strong>自动添加源信息</strong>：<a href="https://dev.mysql.com/downloads/repo/yum/">下载RPM包</a>，使用安装包自动添加源信息。</p>
<pre><code class="language-shell">sudo yum localinstall mysql80-community-release-fc34-1.noarch.rpm
yum repolist enabled | grep &quot;mysql.*-community.*&quot;
</code></pre>
<p><a href="https://repo.mysql.com/">软件源</a>提供多个版本的源信息，但安装官方未提供支持的版本可能出现问题。</p>
<blockquote>
<p><em>MySQL 5.7 does not support Fedora; support was removed in MySQL 5.7.30.</em></p>
</blockquote>
<p><strong>手动添加源信息</strong>：<code>/etc/yum.rpo.d/mysql-community.repo</code></p>
<pre><code class="language-shell">sudo dnf remove @mysql
sudo dnf module reset mysql &amp;&amp; sudo dnf module disable mysql
</code></pre>
<pre><code class="language-shell">[mysql57-community]
name=MySQL 5.7 Community Server
baseurl=http://repo.mysql.com/yum/mysql-5.7-community/el/7/$basearch/
enabled=1
gpgcheck=0
[mysql-connectors-community]
name=MySQL Connectors Community
baseurl=http://repo.mysql.com/yum/mysql-connectors-community/el/7/$basearch/
enabled=1
gpgcheck=0
[mysql-tools-community]
name=MySQL Tools Community
baseurl=http://repo.mysql.com/yum/mysql-tools-community/el/7/$basearch/
enabled=1
gpgcheck=0
</code></pre>
<p><strong>执行安装</strong>：</p>
<pre><code class="language-shell">sudo dnf config-manager --disable mysql80-community
sudo dnf config-manager --enable mysql57-community
sudo dnf install mysql-community-server
sudo systemctl enable --now mysqld
</code></pre>
<blockquote>
<p>如果系统中由<code>maria-db</code>相关库，可能导致依赖检查失败，需要首先手动卸载<code>maria-db</code>相关库。</p>
</blockquote>
<p>修改管理员登录密码：</p>
<pre><code class="language-shell"># [CentOS] 获取临时密码,Ubuntu下初始密码为空
# sudo grep 'A temporary password' /var/log/mysqld.log |tail -1
sudo mysql_secure_installation   
# 或使用 mysql -u root -p &lt;&lt;&lt; &lt;temp_passwd&gt;
# 然后修改密码：ALTER USER 'root'@'localhost' IDENTIFIED BY 'MyNewPass4!';
</code></pre>
<blockquote>
<p><em>The default password policy implemented by <code>validate_password</code> requires that passwords contain at least <strong>one uppercase letter, one lowercase letter, one digit, and one special character</strong>, and that the total password length is at least 8 characters.</em></p>
</blockquote>
<blockquote>
<ol>
<li>
<p><a href="https://dev.mysql.com/doc/refman/5.7/en/linux-installation-yum-repo.html">MySQL :: MySQL 5.7 Reference Manual :: 2.5.1 Installing MySQL on Linux Using the MySQL Yum Repository</a></p>
</li>
<li>
<p><a href="https://www.systempandit.com/install-mysql-5-7-on-centos-8-rhel-8-linux/">Install MySQL 5.7 on CentOS 8 / RHEL 8 Linux - SystemPandit</a></p>
</li>
</ol>
</blockquote>
<h4 id="使用docker容器"><a class="header" href="#使用docker容器">使用Docker容器</a></h4>
<p>使用<code>docker-compose</code>运行<a href="https://1drv.ms/u/s!AneoYr65dYDMrq5sHfoqxkbBpgFVyA?e=kc6qha">配置文件</a>：</p>
<pre><code class="language-yaml">version: &quot;3.1&quot;
services:
  db:
    image: mysql:5.7
    container_name: mysql57
    environment:
      - &quot;MYSQL_ROOT_PASSWORD=gang2019&quot;   # 设置管理员密码
      - &quot;MYSQL_DATABASE=exchange&quot;        # 设置默认数据库
      - &quot;MYSQL_USER=gary&quot;                # 添加数据库用户（授权访问上述数据库）
      - &quot;MYSQL_PASSWORD=gang2019&quot;        # 设置用户密码（测试）
    command: --default-authentication-plugin=mysql_native_password
    volumes:
      - mysql:/var/lib/mysql                   # 数据库文件的存储位置
      - mysqlinit:/docker-entrypoint-initdb.d  # 初始化脚本目录(可选)
      - mysqlconf:/etc/mysql/conf.d            # 自定义配置目录(可选)
    ports:
      - 3306:3306   # host -&gt; docker
    restart: always

  adminer:           # 管理服务
    image: adminer
    restart: always
    ports:
      - 18080:8080

volumes: 
  mysql:
    driver: local
  ......
</code></pre>
<blockquote>
<p>目录<code>mysql</code>和<code>mysql-init</code>不要嵌套。</p>
<p>环境变量<code>MYSQL_ROOT_PASSWORD_FILE=/run/secrets/mysql-root</code>设置从本地文件读取密码，类似地还有<code>MYSQL_PASSWORD</code>等。</p>
</blockquote>
<p>或使用脚本运行：</p>
<pre><code class="language-shell">#!/bin/bash
docker run -d \
	--name mysql57 \
	-v /home/gary/mysql:/var/lib/mysql \
	-v /home/gary/mysql-init:/docker-entrypoint-initdb.d \
	-v /my/custom:/etc/mysql/conf.d \  
	-e MYSQL_ROOT_PASSWORD=gang2019 \
	-e MYSQL_USER=gary \
	-e MYSQL_PASSWORD=gang2019 \
	-e MYSQL_DATABASE=exchange  \
	mysql:5.7 \
	--default-authentication-plugin=mysql_native_password
</code></pre>
<h3 id="运行环境和配置"><a class="header" href="#运行环境和配置">运行环境和配置</a></h3>
<h4 id="配置-9"><a class="header" href="#配置-9">配置</a></h4>
<p>配置文件路径：</p>
<p>Ubuntu：<code>/etc/mysql/mysql.cond.d/mysqld.conf  </code>；</p>
<p>CentOS：<code>/etc/my.cnf</code>；</p>
<h5 id="数据存储路径"><a class="header" href="#数据存储路径">数据存储路径</a></h5>
<pre><code class="language-shell">datadir=/var/lib/mysql
</code></pre>
<blockquote>
<p>如果系统启用了<a href="%E6%95%B0%E6%8D%AE%E5%BA%93/../Linux/Linux%E9%85%8D%E7%BD%AE%E5%92%8C%E7%AE%A1%E7%90%86.html#Security-Enhanced-Linux">SELinux</a>或appamor，则直接修改路径配置将导致服务无法启动。在保证相应目录的文件权限设置正确的情况下，需要检查SELinux的策略配置。</p>
<p><a href="https://dev.mysql.com/doc/refman/8.0/en/selinux-file-context.html">MySQL :: MySQL 8.0 Reference Manual :: 6.7.4 SELinux File Context</a></p>
</blockquote>
<h4 id="版本信息"><a class="header" href="#版本信息">版本信息</a></h4>
<pre><code class="language-shell">mysql --version  # mysql客户端版本信息
mysql            # 登录后客户端显示服务器版本信息
</code></pre>
<pre><code class="language-mysql">SHOW VARIABLES LIKE 'version';
SELECT VERSION() as version;
STATUS;                         # 包括服务器版本信息
</code></pre>
<h4 id="目录信息-1"><a class="header" href="#目录信息-1">目录信息</a></h4>
<pre><code class="language-shell">/etc/mysql/mysql.conf.d/mysqld.cnf # mysql-server配置文件
</code></pre>
<p><a href="https://www.digitalocean.com/community/tutorials/how-to-move-a-mysql-data-directory-to-a-new-location-on-ubuntu-18-04">How To Move a MySQL Data Directory to a New Location on Ubuntu 18.04 | DigitalOcean</a></p>
<h4 id="插件管理"><a class="header" href="#插件管理">插件管理</a></h4>
<pre><code class="language-mysql">SHOW PLUGINS;
</code></pre>
<h3 id="查看mysql服务状态"><a class="header" href="#查看mysql服务状态">查看MySQL服务状态</a></h3>
<pre><code class="language-shell">sudo netstat -nlp
</code></pre>
<p>使用系统服务管理程序（<code>systemctl</code>、<code>service</code>等）管理MySQL服务。</p>
<h3 id="访问mysql"><a class="header" href="#访问mysql">访问MySQL</a></h3>
<h4 id="命令行工具-2"><a class="header" href="#命令行工具-2">命令行工具</a></h4>
<h5 id="登录"><a class="header" href="#登录">登录</a></h5>
<pre><code class="language-sh">mysql -u &lt;username&gt; -p [&lt;database&gt;];
mysql -u root -p  # 使用root用户登录数据库的root账号
</code></pre>
<p><code>username</code>表示要登录的用户的用户名，<code>-p</code>表示如果用户设置了密码，则在登录时要输入密码。</p>
<p>以下问题可能发生：</p>
<ol>
<li>
<p>Shell登录用户密码验证失败：未创建本地访问账户（<code>user@localhost</code>）或本地账户与远程账户密码不一致。</p>
</li>
<li>
<p>不允许主机访问：未对相应的主机/域名上的用户进行授权，需要在本机<a href="%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL.html#%E5%88%9B%E5%BB%BA%E8%B4%A6%E5%8F%B7">创建对应的用户账号</a>。</p>
</li>
<li>
<p><code>root</code>无法通过密码登录：<a href="https://dev.mysql.com/doc/refman/8.0/en/resetting-permissions.html">为管理员账号设置密码（Generic Instructions）</a>。</p>
<p>Ubuntu系统下，MySQL 默认以安装软件的用户（通常为<code>root</code>）为数据的内置账户，通过系统中的用户身份进行登录验证（<code> auth_socket</code>），无需MySQL用户密码。因此，首先尝试使用<code>sudo mysql [-u root]</code>命令进行登录（<code>sudo</code>命令表示以<code>root</code>用户登录数据库，其后的用户参数不一定要使用<code>root</code>，仅使用该用户的信息进行验证）；</p>
<p>如果失败或者是需要从远程登录，则需要修改MySQL对用户的认证方式。在安全模式下启动MySQL：</p>
<pre><code class="language-shell">systemctl stop mysql  # =&gt; service mysql stop
sudo mkdir -p /var/run/mysqld &amp;&amp; chown mysql:mysql /var/run/mysqld  
sudo mysqld_safe --skip-grant-tables &amp;
mysql -u root    # login without password
service mysql restart
</code></pre>
<blockquote>
<p>==如果未取消==<code>skip-grant-tables</code>，则无法<a href="%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL.html#%E8%BF%9C%E7%A8%8B%E8%AE%BF%E9%97%AE">使用网络连接访问</a>（为了安全起见，服务器未开启网络监听端口）。</p>
</blockquote>
<p>修改数据库中<code>root</code>用户的==认证方式==和<a href="%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL.html#%E4%BF%AE%E6%94%B9%E5%AF%86%E7%A0%81">修改密码</a>：</p>
<pre><code class="language-mysql">USE mysql;
UPDATE user SET plugin=&quot;mysql_native_password&quot; WHERE User='root'; 
ALTER USER root@localhost IDENTIFIED BY 'NewPassword'; 
flush privileges;
</code></pre>
<p>终止服务进程并重启服务再尝试登录。</p>
</li>
<li>
<p><em>warning: cannot change directory to /nonexistent: No such file or directory</em>：https://stackoverflow.com/a/63040661/6571140。该问题导致用户登录无法认证。</p>
<pre><code class="language-shell">sudo usermod -d /var/lib/mysql/ mysql
sudo systemctl start mysql.service  # service mysql start
</code></pre>
</li>
<li>
<p>使用<code>init</code>的系统（例如WSL2）无法正常停止MySQL：为<code>debian-sys-maint</code>配置数据库账户。</p>
<pre><code class="language-mysql">CREATE USER 'debian-sys-maint'@localhost identified by 'password'
GRANT ALL PRIVILEGES ON *.* TO 'debian-sys-maint'@localhost
</code></pre>
</li>
<li>
<p><em><code>Host xxx is blocked</code></em>：使用<code>mysqladmin -h MYSQL_HOST flush_hosts</code>刷新客户端主机地址缓存。</p>
</li>
</ol>
<h4 id="远程访问-2"><a class="header" href="#远程访问-2">远程访问</a></h4>
<p>MySQL 8.0默认开放UNIX套接字<code>/var/run/mysqld/mysqld.sock</code>和本地TCP/IP套接字访问<code>localhost/127.0.0.1</code>；因此无法从远程机器连接到数据库（<em>Connection refused error</em>）。</p>
<blockquote>
<p><a href="https://dev.mysql.com/doc/refman/8.0/en/can-not-connect-to-server.html">A Unix socket file is used if you do not specify a host name or if you specify the special host name localhost.</a></p>
</blockquote>
<p>修改MySQL Server配置文件，令<code>bind-address=0.0.0.0</code>，以允许本地回环地址以外的主机访问数据库。</p>
<blockquote>
<p><code>注意</code>：如果错误地将<code>bind-address</code>绑定到非本机IP将导致无法创建TCP套接字。</p>
</blockquote>
<p>测试网络访问：</p>
<pre><code class="language-shell">sudo mysqladmin version  
mysqladmin \ # no address option for local connect with root
    -h $(hostname)|&lt;host_ip&gt; [--port=3306] \ # TCP/IP with user@hostname
    --protocol=SOCKET --socket=/var/run/mysqld/mysqld.sock \ # UNIX SOCKET
    -u mysqluser \
    -p \ # specify user and password
    version 
</code></pre>
<blockquote>
<p><code>--protocol=tcp,socket,pipe,memory</code></p>
</blockquote>
<h3 id="账户管理"><a class="header" href="#账户管理">账户管理</a></h3>
<h5 id="创建删除角色"><a class="header" href="#创建删除角色">创建删除角色</a></h5>
<pre><code class="language-sql">CREATE ROLE [IF NOT EXISTS] role [, role ...] 
DROP ROLE [IF EXISTs] role
</code></pre>
<p>给定<code>IF NOT EXISTS</code>或<code>IF EXISTS</code>，则在不满足条件时产生警告而非错误。</p>
<p>示例：</p>
<pre><code class="language-sql">CREATE ROLE 'administrator', 'developer';
CREATE ROLE 'webapp'@'localhost';
</code></pre>
<h5 id="创建用户-2"><a class="header" href="#创建用户-2">创建用户</a></h5>
<pre><code class="language-mysql">CREATE [OR REPLACE] USER [IF NOT EXISTS] user_name 
    [IDENTIFIED BY {'password' | PASSWORD 'password_hash'}] # 使用默认认证方法
   |[IDENTIFIED WITH auth_plugin ]                          # 显式指定认证方法（后续再设置密码）
   |[IDENTIFIED WITH auth_plugin BY PASSWORD('password')]   # mariadb使用USING-&gt;BY
   DEFAULT ROLE role;  # Only MySQL
RENAME USER old_user TO new_user;
SET DEFAULT ROLE
    {NONE | ALL | role [, role ...]}
    TO user[, user ...]
SET ROLE { 
	DEFAULT | NONE | ALL [except role[,...]] | role[, role ...]}

</code></pre>
<p><code>username</code>用户名和域名组成<code>'&lt;username&gt;'@'domain'</code>（默认省略域名，等效于以<code>%</code>表示）中如果有特殊字符（例如<code>-</code>）则需要使用引号，密码必须置于引号中。</p>
<blockquote>
<p>MySQL/Mariadb 5.x不支持同时设置密码和验证方法，可先创建用户并设定验证方法，<a href="%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL.html#%E4%BF%AE%E6%94%B9%E5%AF%86%E7%A0%81">随后设置密码</a>。</p>
</blockquote>
<p><code>SET ROLE</code>设置当前用户当前会话的有效角色。</p>
<p>查看用户信息：</p>
<pre><code class="language-mysql">SELECT Host, User FROM mysql.user;
</code></pre>
<h4 id="删除用户-2"><a class="header" href="#删除用户-2">删除用户</a></h4>
<pre><code class="language-mysql">DROP USER 'bloguser'@'localhost';
</code></pre>
<h4 id="修改密码"><a class="header" href="#修改密码">修改密码</a></h4>
<pre><code class="language-sh">ALTER USER '&lt;username&gt;'@'domain' IDENTIFIED 
      [WITH mysql_native_password] 
      BY '&lt;password&gt;';
SET PASSWORD FOR &lt;user&gt; = PASSWORD('pass_word')  # 设置密码Hash值
</code></pre>
<h4 id="权限管理-2"><a class="header" href="#权限管理-2">权限管理</a></h4>
<h5 id="授权给用户或角色"><a class="header" href="#授权给用户或角色">授权给用户或角色</a></h5>
<pre><code class="language-sql">GRANT priv_type ON priv_level TO user_or_role;
priv_level: { *  | *.*  | db_name.*
  | db_name.tbl_name  | tbl_name  | db_name.routine_name };
GRANT role TO user_or_role;
</code></pre>
<p><code>priv_type</code>表示对数据库的各类操作类型。</p>
<p>示例：</p>
<pre><code class="language-sh">GRANT ALL [PRIVILEGES] ON *.* TO  'garywang';
GRANT ALL ON db1.* TO jeffrey@localhost;
GRANT SELECT, INSERT ON world.* TO 'role3';
GRANT 'role1', 'role2' TO user1, user2;
</code></pre>
<p>授权的对象必须存在，否则出错。</p>
<blockquote>
<p><em>ERROR 1410 (42000): You are not allowed to create a user with GRANT.</em></p>
</blockquote>
<pre><code class="language-sql">SHOW GRANTS FOR 'bloguser'@'localhost';
</code></pre>
<h5 id="撤销权限"><a class="header" href="#撤销权限">撤销权限</a></h5>
<pre><code class="language-sql">REVOKE ALL PRIVILEGES, GRANT OPTION FROM '&lt;username&gt;';
REVOKE INSERT ON *.* FROM jeffrey@localhost;  # revoke insert privilage
REVOKE 'role1', 'role2' FROM user1, user2;
REVOKE SELECT ON world.* FROM role3;
mysql&gt; FLUSH PRIVILEGES;
</code></pre>
<p>https://dev.mysql.com/doc/refman/8.0/en/grant.html</p>
<p>退出客户端：</p>
<pre><code class="language-sh">exit;
</code></pre>
<h3 id="sql脚本"><a class="header" href="#sql脚本">SQL脚本</a></h3>
<p>在MySQL命令行执行SQL脚本：</p>
<pre><code class="language-mysql">source path/to/mysql.sql
</code></pre>
<p>在终端执行MySQL命令或SQLSQL脚本：</p>
<pre><code class="language-shell">mysql -u USER -p -e &quot;sql_command&quot;
mysql -u USER -p DATABASE &lt; msyql.sql
</code></pre>
<h2 id="sql命令"><a class="header" href="#sql命令">SQL命令</a></h2>
<ul>
<li>每条命令以“<code>;</code>”或“<code>\g</code>”结束；</li>
<li>命令的关键字和标识符默认不区分大小写；</li>
</ul>
<blockquote>
<ul>
<li>命令行输入可以使用“tab键”自动补全；</li>
<li>通过上下键可以查询输入历史；</li>
<li>SQL 语法表述中“<code>[]</code>”中包含的内容是可选的，如果没有指明，则表示使用默认的命令；</li>
</ul>
</blockquote>
<p>在交互式命令行通过<code>help</code>命令，查看SQL命令文档。</p>
<pre><code class="language-mysql">help CREATE TABLE;
help SELECT;
</code></pre>
<h3 id="数据库管理"><a class="header" href="#数据库管理">数据库管理</a></h3>
<pre><code class="language-mysql">SHOW DATABASES;
USE database_name;
SHOW TABLES;        -- 查看数据库的表
DESC table_name;    -- =&gt; describe 显示表的字段定义
SHOW COLLATION;     -- 显示内置的比较规则
</code></pre>
<p>使用<code>SHOW CREATE TABLE</code>查看创建分区的语句；</p>
<h5 id="查看对象的定义"><a class="header" href="#查看对象的定义">查看对象的定义</a></h5>
<p>通过输出的语句，可重新创建相同定义的对象。</p>
<pre><code class="language-mysql">SHOW CREATE DATABASE  db_name \G;  # 显示数据库定义
SHOW CREATE TABLE     tb_name \G;  # 显示表的定义
SHOW CREATE PROCEDURE sp_name \G;  # 显示过程定义
SHOW CREATE FUNCTION  sp_name \G;
</code></pre>
<h3 id="分区"><a class="header" href="#分区">分区</a></h3>
<p><em><strong>every unique key on the table must use every column in the table's partitioning expression</strong></em>.</p>
<p>当声明unique key（primary key）时，其组成部分必须包含分区的列。</p>
<pre><code class="language-sql">UNIQUE KEY (col1, col2)  -- col2 used for partitioning
</code></pre>
<h4 id="range-partition"><a class="header" href="#range-partition">Range Partition</a></h4>
<pre><code class="language-mysql">CREATE TABLE table_name (column_name type contraints,...)
  PARTITION BY RANGE (column_name_x) (
     PARTITION part_name_a VALUES LESS THAN (n0),    # () 是必要的
     ...
     PARTITION part_name_x VALUES LESS THAN MAXVALUE # 不需要括号
  )
</code></pre>
<p>可以在创建表后（即使已经添加数据）再修改表的定义添加分区定义：</p>
<pre><code class="language-mysql">ALTER TABLE table_name PARTITION BY RANGE (column_name_x) (...)
</code></pre>
<p>也可以为表格添加一个或多个新的分区：</p>
<pre><code class="language-mysql">ALTER TABLE table_name ADD PARTITION (...)
</code></pre>
<p>划分已有分区（不会丢失数据）：</p>
<pre><code class="language-mysql">ALTER TABLE table_name REORGANIZE PARTITION exist_part INTO (
    PARTITION s0 VALUES LESS THAN (n00),
    PARTITION s1 VALUES LESS THAN (n01)
);
</code></pre>
<p>调整分区定义（只能调整连续分区）：</p>
<pre><code class="language-mysql">ALTER TABLE table_name REORGANIZE PARTITION p0,p1,... INTO (
    PARTITION p0 VALUES LESS THAN (n01)
);
ALTER TABLE tbl_name REORGANIZE PARTITION partition_list
    INTO (partition_definitions);
</code></pre>
<h5 id="list-partition"><a class="header" href="#list-partition">List Partition</a></h5>
<h5 id="hash-partition"><a class="header" href="#hash-partition">Hash Partition</a></h5>
<h5 id="key-partition"><a class="header" href="#key-partition">Key Partition</a></h5>
<h4 id="分区信息"><a class="header" href="#分区信息">分区信息</a></h4>
<pre><code class="language-mysql">SELECT TABLE_SCHEMA,TABLE_NAME,PARTITION_NAME,
       PARTITION_ORDINAL_POSITION as part_idx,
       PARTITION_METHOD as method,
       PARTITION_EXPRESSION as part_expr,
       PARTITION_DESCRIPTION as part_desc,
       TABLE_ROWS as num_rows,
       CREATE_TIME 
   FROM INFORMATION_SCHEMA.PARTITIONS WHERE TABLE_NAME = 'table_name';
</code></pre>
<h4 id="分区筛选"><a class="header" href="#分区筛选">分区筛选</a></h4>
<p>支持分区筛选的命令包括：<code>SELECT</code>、<code>DELETE</code>、<code>INSERT</code>、<code>REPLACE</code>、<code>UPDATE</code>、<code>LOAD DATA</code>、<code>LOAD XML</code>。</p>
<pre><code class="language-mysql">SELECT * FROM table_name partition (p1,p2,...) WHERE ...
</code></pre>
<h3 id="变量-11"><a class="header" href="#变量-11">变量</a></h3>
<h4 id="用户变量"><a class="header" href="#用户变量">用户变量</a></h4>
<pre><code class="language-mysql">set @var_name = EXPRESSION,...;   -- =&gt; SELECT @test;
</code></pre>
<blockquote>
<p>一条语句可设置多个变量。</p>
</blockquote>
<h4 id="参数和局部变量"><a class="header" href="#参数和局部变量">参数和局部变量</a></h4>
<pre><code class="language-mysql">CREATE PROCEDURE p(increment INT)
BEGIN
  DECLARE counter INT DEFAULT 0;
  WHILE counter &lt; 10 DO
    -- ... do work ...
    SET counter = counter + increment;
  END WHILE;
END//
</code></pre>
<h4 id="系统变量"><a class="header" href="#系统变量">系统变量</a></h4>
<p>系统变量影响数据库行为，其中，全局变量影响当前会话以及其后建立的会话，会话变量仅影响当前会话。要设置永久性的系统变量，应该在选项文件中配置。</p>
<h5 id="全局系统变量"><a class="header" href="#全局系统变量">全局系统变量</a></h5>
<pre><code class="language-mysql">SET GLOBAL max_connections = 1000;  -- =&gt; SET @@GLOBAL.max_connections = 1000;
</code></pre>
<blockquote>
<p>要设置的系统变量必须是系统已经定义的，不能通过<code>SET</code>创建全局变量。</p>
</blockquote>
<h5 id="会话系统变量"><a class="header" href="#会话系统变量">会话系统变量</a></h5>
<pre><code class="language-mysql">SET SESSION sql_mode = 'TRADITIONAL'; 
-- =&gt; SET @@SESSION.sql_mode = 'TRADITIONAL';
SET LOCAL sql_mode = 'TRADITIONAL';   
-- =&gt; SET @@LOCAL.sql_mode = 'TRADITIONAL';
SET sql_mode = 'TRADITIONAL';         
-- =&gt; SET @@sql_mode = 'TRADITIONAL';
SET max_join_size = DEFAULT;          
-- =&gt; SET max_join_size = @@GLOBAL.max_join_size;
</code></pre>
<h5 id="显示系统变量"><a class="header" href="#显示系统变量">显示系统变量</a></h5>
<pre><code class="language-mysql">SELECT @@GLOBAL.sql_mode;           -- =&gt; 'TRADITIONAL';
SELECT @@sql_mode                   -- 局部变量
SHOW VARIABLES                      -- 显示所有系统变量的名称和值
</code></pre>
<h3 id="过程"><a class="header" href="#过程">过程</a></h3>
<p><a href="%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL.html#%E6%9F%A5%E7%9C%8B%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9A%E4%B9%89">创建过程的语法</a>如下：</p>
<pre><code class="language-mysql">-- CREATE ROUTINE privilege of DEFINER
delimiter //  --*
CREATE [DEFINER = user] PROCEDURE [IF NOT EXISTS] 
routine_name ([proc_parameter[,...]]) 
[characteristic ...] 
    routine_body
CREATE [DEFINER = user] FUNCTION [IF NOT EXISTS] 
routine_body_name ([func_parameter[,...]]) RETURNS type 
[characteristic ...] 
    routine_body
delimiter ;  --*
</code></pre>
<p>过程默认保存在当前使用的数据库，可显式指定关联数据库<code>db_name.routine_name</code>。</p>
<p><code>routine_body</code>过程内容：可以为单条SQL语句，或由<code>BEGIN...END</code>语句块包含多条SQL语句。</p>
<blockquote>
<p><code>*</code>：过程中==包含多条SQL语句==时，过程本身的结束标识和过程内容<code>routine_body</code>中的语句结束标识不能一致，因此修改当前环境的结束标识为<code>//</code>。</p>
</blockquote>
<p><code>PROCEDURE</code>参数列表：<code>[IN|OUT|INOUT] param_name type</code>，默认为<code>IN</code>（输入参数），<code>OUT</code>（输出参数，初始值为<code>NULL</code>）可将值返回给调用者。</p>
<p><code>FUNCTION</code>参数列表：<code>param_name type</code>，函数形式通过<code>RETURN</code>语句返回结果，<code>RETURNS</code>语句声明返回结果的类型。</p>
<h5 id="调用过程"><a class="header" href="#调用过程">调用过程</a></h5>
<pre><code class="language-mysql">call db_name.routine_name(proc_parameter,...)
</code></pre>
<h2 id="数据导入导出"><a class="header" href="#数据导入导出">数据导入导出</a></h2>
<h3 id="sql脚本-1"><a class="header" href="#sql脚本-1">SQL脚本</a></h3>
<blockquote>
<p>MySQL中如果表和表之间建立的外键约束，则无法删除表及修改表结构。解决方法是在Mysql中取消外键约束: <code>SET FOREIGN_KEY_CHECKS=0</code>；然后将原来表的数据导出到sql语句，重新创建此表后，再把数据使用sql导入，然后再设置外键约束: <code>SET FOREIGN_KEY_CHECKS=1</code>;</p>
</blockquote>
<h4 id="命令行导入导出工具"><a class="header" href="#命令行导入导出工具">命令行导入导出工具</a></h4>
<p><code>mysqldump</code>生成SQL语句以重新申城原数据库对象的定义以及数据表的数据，用于备份数据库或传输到其他SQL服务器，<code>mysqldump</code>命令还可以输出CSV、其他分隔符文件或XML文件。</p>
<pre><code class="language-shell">mysqldump -u root -p DATABASE_NAME [TABLE_NAME...] \
    --result-file=database_name.db   # 导出一个库的某些表
    --databases db_name ...          # 导出指定的库
    --all-databases                  # 导出所有库
    -d, --no-data                    # 不导出数据仅导出定义
mysqldump [options] --tab=dirname \  # 仅用于服务器所在机器，因为服务器要在指定目录创建文件
    --fields-terminated-by=... --fields-enclosed-by=... --fields-escaped-by=... \
    --lines-terminated-by=...  # mysqldump独立生成数据表创建文件和MYSQL服务导出数据文件
</code></pre>
<blockquote>
<p><code>mysqldump</code>使用和<code>mysql</code>相同参数连接数据库服务。</p>
</blockquote>
<p><code>mysqldump</code>可以方便查看和编辑导出的数据，适用于测试开发目的；但并不是一种快速或可扩展的备份大量数据的方法，因为恢复数据时执行SQL语句将产生大量插入、创建索引等磁盘I/O，导致恢复过程及其缓慢。对于大数据备份和恢复，可直接复制数据库文件目录。</p>
<h5 id="问题-3"><a class="header" href="#问题-3">问题</a></h5>
<ol>
<li>
<p><em>'Access denied; you need (at least one of) the PROCESS privilege(s) for this operation' when trying to dump tablespaces</em>：<a href="https://dba.stackexchange.com/questions/271981/access-denied-you-need-at-least-one-of-the-process-privileges-for-this-ope">指定<code>--no-tablespaces</code>选项</a>。</p>
</li>
<li>
<p><em>error: 1227: Access denied; you need (at least one of) the FILE privilege(s) for this operation when executing 'SELECT INTO OUTFILE'</em>：<a href="%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL.html#https://stackoverflow.com/a/39963216/6571140">指定全局文件权限</a><code>GRANT FILE ON *.* TO user;</code></p>
</li>
<li>
<p><em>error: 1290: The MySQL server is running with the --secure-file-priv option so it cannot execute this statement when executing 'SELECT INTO OUTFILE'</em>：当指定<code>--tab</code>选项时，<a href="https://stackoverflow.com/questions/32737478/how-should-i-tackle-secure-file-priv-in-mysql">仅能从<code>secure-file-priv</code>指定的目录读写数据</a>或在配置文件中将指定路径清空。</p>
<blockquote>
<pre><code class="language-mysql">SHOW VARIABLES LIKE &quot;secure_file_priv&quot;
</code></pre>
<pre><code class="language-ini">[mysqld]
secure-file-priv = &quot;&quot;
</code></pre>
</blockquote>
</li>
</ol>
<pre><code class="language-shell">mysql -u USER -p DB_NAME &lt; database_name.db
mysql db_name &lt; backup-file.sql
mysql -e &quot;source /path-to-backup/backup-file.sql&quot; db_name
</code></pre>
<p>导入文本数据（CSV）</p>
<pre><code class="language-shell">mysqlimport [options] db_name textfile1 [textfile2 ...]
</code></pre>
<pre><code class="language-mysql">LOAD DATA [LOCAL] INFILE 'path/to/file.csv' INTO TABLE table_name
     FIELDS TERMINATED BY ',' 
     ENCLOSED BY '&quot;'
     LINES TERMINATED BY '\n' 
     IGNORE 1 ROWS;  -- 忽略表头
</code></pre>
<p>如果使用<code>--tab</code>导出的数据，可分别导入<code>.sql</code>文件和文本文件。</p>
<h4 id="mysql命令行导入导出工具"><a class="header" href="#mysql命令行导入导出工具"><em>MySQL命令行导入导出工具</em></a></h4>
<h2 id="mysql连接器"><a class="header" href="#mysql连接器">MySQL连接器</a></h2>
<h5 id="java-1"><a class="header" href="#java-1">Java</a></h5>
<p>使用包管理器（<code>rpm</code>或<code>deb</code>）安装连接器的库还需要顺带安装依赖包。</p>
<pre><code class="language-shell">========================================================================
 Package                       Arch     Version                    Size
========================================================================
Installing:
 mysql-connector-java          noarch   1:8.0.26-1.el7            2.7 M
Installing for dependencies:
 avahi-libs                    x86_64   0.6.31-20.el7              62 k
 copy-jdk-configs              noarch   3.3-10.el7_5               21 k
 cups-libs                     x86_64   1:1.6.3-51.el7            359 k
 java-1.8.0-openjdk-headless   x86_64   1:1.8.0.302.b08-0.el7_9    33 M
 javapackages-tools            noarch   3.4.1-11.el7               73 k
 libjpeg-turbo                 x86_64   1.2.90-8.el7              135 k
 libxslt                       x86_64   1.1.28-6.el7              242 k
 lksctp-tools                  x86_64   1.0.17-2.el7               88 k
 pcsc-lite-libs                x86_64   1.8.8-8.el7                34 k
 python-javapackages           noarch   3.4.1-11.el7               31 k
 python-lxml                   x86_64   3.2.1-4.el7               758 k
 tzdata-java                   noarch   2021a-1.el7               191 k
</code></pre>
<p>如果只需要连接器的库，可下载平台无关的档案文件。</p>
<h2 id="常见问题-9"><a class="header" href="#常见问题-9">常见问题</a></h2>
<ol>
<li><em><code>ERROR 1071 (42000): Specified key was too long; max key length is 767 bytes</code></em>：将键对应的列的数据类型长度减小。<a href="https://cloud.tencent.com/developer/article/1005696">MySQL 经典案例分析：Specified key was too long - 云+社区 - 腾讯云 (tencent.com)</a>。</li>
<li></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="postgresql-2"><a class="header" href="#postgresql-2">PostgreSQL</a></h1>
<h2 id="安装-27"><a class="header" href="#安装-27">安装</a></h2>
<h5 id="ubuntu-1"><a class="header" href="#ubuntu-1">Ubuntu</a></h5>
<pre><code class="language-shell">sudo apt install postgresql postgresql-client
</code></pre>
<h5 id="centos-1"><a class="header" href="#centos-1">CentOS</a></h5>
<pre><code class="language-shell">wget https://download.postgresql.org/pub/repos/yum/reporpms/EL-7-x86_64/pgdg-redhat-repo-latest.noarch.rpm
yum install -y ./pgdg-redhat-repo-latest.noarch.rpm
yum install -y postgresql12-server  # or postgresql-server
</code></pre>
<h5 id="docker-1"><a class="header" href="#docker-1">docker</a></h5>
<pre><code class="language-yaml">version: &quot;3.1&quot;
services:
  db_postgres:
    image: postgres:12
    container_name: postgresql-server
    environment:
      - &quot;POSTGRES_PASSWORD=gang2019&quot;
      # POSTGRES_PASSWORD_FILE=/run/secrets/postgres-passwd
    volumes:
      - pgdata:/var/lib/postgresql/data
      - pginit:/docker-entrypoint-initdb.d   # contains init-user-db.sh
    ports:
      - 5432:5432
volumes: 
  pgdata:
    driver: local
  pginit:
    driver: local
</code></pre>
<blockquote>
<p>可以和<code>adminer</code><a href="%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL.html#%E4%BD%BF%E7%94%A8Docker%E5%AE%B9%E5%99%A8">部署</a>在同一集群，从而方便数据库管理。</p>
</blockquote>
<p><a href="https://www.postgresql.org/support/versioning/">PostgreSQL: Versioning Policy</a></p>
<h3 id="配置-10"><a class="header" href="#配置-10">配置</a></h3>
<h4 id="远程访问-3"><a class="header" href="#远程访问-3">远程访问</a></h4>
<p>设置访问地址和端口（默认监听<code>localhost</code>）：</p>
<pre><code class="language-shell"># edit: /var/lib/pgsql/12/data/postgresql.conf
listen_addresses = '*'  # listen to all address
port = 5432     
</code></pre>
<h5 id="网络访问规则"><a class="header" href="#网络访问规则">网络访问规则</a></h5>
<p>用户访问时规则从上到下匹配，匹配到规则后按相应规则校验是否能访问数据库，不再使用后续规则。因此，匹配范围大的规则通常放在靠后位置。</p>
<pre><code class="language-shell"># edit: /var/lib/pgsql/12/data/pg_hba.conf
# IPv4 local connections:
# TYPE  DATABASE        USER            ADDRESS                 METHOD
  host    all           gary            0.0.0.0/0               md5  #*
  host    all           all             127.0.0.1/32            ident
</code></pre>
<blockquote>
<p><code>*</code>：密码认证方法，可使用<code>md5</code>或<code>scram-sha-256</code>（推荐）。对于已有用户切换密码验证方法，参考：<a href="https://www.modb.pro/db/40292">PostgreSQL中使用scram-sha-256认证 - 墨天轮 (modb.pro)</a>。</p>
</blockquote>
<p>设置防火墙规则：</p>
<pre><code class="language-shell">sudo firewall-cmd --add-service=postgresql --permanent
</code></pre>
<h4 id="数据存储位置"><a class="header" href="#数据存储位置">数据存储位置</a></h4>
<p>新的数据存储位置的所有者需要是数据库服务进程的用户（<code>postgres</code>），同时访问权限应该为<code>700/750</code>（即不能包含others访问权限）。如果已经经过初始化，则需要将原数据存储目录下的内容复制到新目录下（<code>cp -ra</code>）。</p>
<h3 id="启动服务-2"><a class="header" href="#启动服务-2">启动服务</a></h3>
<p>==初始化数据库==（CentOS）：</p>
<pre><code class="language-shell">sudo /usr/pgsql-12/bin/postgresql-12-setup initdb  # or postgresql-setup initdb
</code></pre>
<p>启动数据库：</p>
<pre><code class="language-shell">sudo service postgresql start  # =&gt; WSL2
sudo systemctl enable --now postgresql-12
</code></pre>
<p>服务的日志数据位于：<code>/var/lib/pgsql/data/log/</code>。</p>
<h2 id="命令行工具-3"><a class="header" href="#命令行工具-3">命令行工具</a></h2>
<h3 id="访问数据库"><a class="header" href="#访问数据库">访问数据库</a></h3>
<p>安装完毕后，会在系统中创建一个超级用户<code>postgres</code>（密码为空）。使用该用户管理据库。</p>
<pre><code class="language-shell">sudo -i -u postgres
</code></pre>
<pre><code class="language-shell">psql \
    -h,--host=PGHOST \    # 服务器地址或UNIX套接字地址：/var/run/postgresql*
    -p,--port=PGPORT \    # 端口：5432
    -U,--username=NAME \  # 用户名：postgres，使用相应地系统账号登录
    -w,--no-password \    # 不提供密码
    -W,--password \       # 输入密码提示
    [dbname]              # 默认：与用户名同名的数据库
</code></pre>
<blockquote>
<p><code>*</code>：如果未指定主机IP地址，则默认连接本地套接字地址。</p>
</blockquote>
<p>查看数据库服务版本：</p>
<pre><code class="language-sql">SELECT version();
</code></pre>
<p>使用<code>\q</code>退出数据库终端。</p>
<p><a href="https://stackoverflow.com/a/12721020/6571140">Peer authentication and password authentication.</a></p>
<p>本地账号默认使用<code>peer</code>方式登录，即使用当前系统用户的身份凭据作为数据库的身份凭据。如果要在当前系统用户登录其他账户，应该采用密码认证模式，将认证方式从<code>peer</code>改为<code>md5</code>。针对默认账户<code>postgres</code>，首先使用<code>peer</code>模式登录系统后为其设置密码<code>\password postgres</code>。</p>
<pre><code class="language-shell"># edit: /etc/postgresql/12/main/pg_hba.conf
# TYPE  DATABASE   USER      ADDRESS  METHOD
  local   all      postgres            md5
</code></pre>
<blockquote>
<p><code>local</code>代表UNIX域套接字。</p>
</blockquote>
<h5 id="导入导出数据-1"><a class="header" href="#导入导出数据-1">导入导出数据</a></h5>
<pre><code class="language-shell">pg_dump -h src_host -U src_user src_db &gt; table-to-copy.sql
        -f,--filename=FILENAME  # 代替重定向命令输出
        -a,--data-only          # 仅导出数据(不包含模式)
        -s,--schema-only        # 仅导出表结构定义
        -C,--create             # 包含创建数据库的命令
        -n,--schema=SCHEMA      # 只导出指定名称的模式
        -N,--exclude-schema=SCHEMA # 不导出指定名称的模式
        -t,--table=TABLE        # 仅导出指定名称的表
        
psql -h dst_host -U dst_user -d dst_db -f table-to-copy.sql
</code></pre>
<blockquote>
<p>可多次使用<code>-t</code>选项一次性导出多个表。</p>
</blockquote>
<h3 id="用户管理-5"><a class="header" href="#用户管理-5">用户管理</a></h3>
<p>命令行模式：</p>
<pre><code class="language-shell">createuser -h localhost USERNAME -P  # 最后需要输入postgres的密码*
</code></pre>
<blockquote>
<p><code>*</code>：如果使用密码登录，则需在数据库访问规则中添加<a href="%E6%95%B0%E6%8D%AE%E5%BA%93/PostgreSQL.html#%E7%BD%91%E7%BB%9C%E8%AE%BF%E9%97%AE%E8%A7%84%E5%88%99">密码访问规则</a>（<code>md5</code>）。</p>
</blockquote>
<p>显示用户信息：</p>
<pre><code class="language-sql">\du -- lists all user
</code></pre>
<h4 id="授权"><a class="header" href="#授权">授权</a></h4>
<p>使用管理员账户登录为用户授权。</p>
<p>授权数据库访问权限：</p>
<pre><code class="language-sql">GRANT CREATE ON DATABASE database_name TO [GROUP] role_name;
</code></pre>
<p>权限声明包括：<code>CREATE,CONNECT,TEMPORARY,TEMP</code>或全部权限<code>ALL [PRIVILEGES]</code>。</p>
<p>授权表的访问权限：</p>
<pre><code class="language-sql">\c DB_NAME  # use ngsoc
GRANT SELECT ON TABLE table_name TO [GROUP] role_name;
GRANT ... ON ALL TABLES IN SCHEMA schema_name TO [GROUP] role_name;
</code></pre>
<p>权限声明包括一个或多个：<code>SELECT,INSERT,UPDATE,DELETE,TRUNCATE,REFERENCES,TRIGGER</code>或使用<code>ALL</code>表示所有权限。</p>
<p><a href="https://www.postgresql.org/docs/9.0/sql-grant.html">PostgreSQL: Documentation: 9.0: GRANT</a></p>
<h3 id="执行sql脚本"><a class="header" href="#执行sql脚本">执行SQL脚本</a></h3>
<pre><code class="language-shell">psql obejctrocket [options] -d db_name -f test.sql
</code></pre>
<p>在交互式环境下执行SQL脚本：</p>
<pre><code class="language-postgresql">\c db_name
\i /path/TO/file_name.sql
</code></pre>
<h2 id="数据库管理命令"><a class="header" href="#数据库管理命令">数据库管理命令</a></h2>
<h3 id="database管理"><a class="header" href="#database管理">Database管理</a></h3>
<pre><code class="language-sql">\l               -- list databases
\c db_name       -- use database
select * from pg_catalog.pg_collation;               -- show collation
</code></pre>
<blockquote>
<p><em>Basically, <a href="https://www.postgresql.org/docs/9.1/static/information-schema.html">information schema is a set of views of pg_catalog</a>.</em></p>
</blockquote>
<p>PostgreSQL supports the standard SQL types <code>int</code>, <code>smallint</code>, <code>real</code>, <code>double precision,</code> <code>char(N)</code>, <code>varchar(N)</code>, <code>date</code>, <code>time</code>, <code>timestamp</code>, and <code>interval</code>, as well as other types of general utility and a rich set of geometric types. PostgreSQL can be customized with an arbitrary number of user-defined data types. </p>
<p>Constants that are not simple numeric values usually must be surrounded by single quotes (').</p>
<h4 id="创建database"><a class="header" href="#创建database">创建database</a></h4>
<p>使用<a href="%E6%95%B0%E6%8D%AE%E5%BA%93/SQL%20DDL.html#%E5%88%9B%E5%BB%BA%E6%95%B0%E6%8D%AE%E5%BA%93">SQL语句</a>创建数据库。或使用数据库命令行工具，创建：</p>
<pre><code class="language-shell">createdb mydb  # &lt;-&gt; CREATE DATABASE mydb
</code></pre>
<h4 id="删除database"><a class="header" href="#删除database">删除database</a></h4>
<pre><code class="language-shell">dropdb mydb    # DROP DATABASE mydb
</code></pre>
<h3 id="schema管理"><a class="header" href="#schema管理">Schema管理</a></h3>
<h4 id="获取命名空间信息"><a class="header" href="#获取命名空间信息">获取命名空间信息</a></h4>
<p>命名空间（schema）是一个数据库所包含数据表的逻辑分组。</p>
<pre><code class="language-postgresql">SELECT catalog_name,schema_name,schema_owner
  FROM information_schema.schemata;
SELECT nspname,nsponwer,nspacl FROM pg_catalog.pg_namespace;
</code></pre>
<blockquote>
<p><code>schema_name</code>和<code>nspname</code>是一一对应的。</p>
</blockquote>
<h4 id="创建schema"><a class="header" href="#创建schema">创建Schema</a></h4>
<pre><code class="language-mysql">CREATE SCHEMA [IF NOT EXISTS] schema_name [AUTHORIZATION user_name] 
    [schema_element [...]];
DROP SCHEMA schema_name;
</code></pre>
<p><em><code>schema_name</code>：defaults to <code>user_name</code>.</em> </p>
<p><code>user_name</code>：the new schema's owner, defaults to the current user.</p>
<p><code>schema_element</code>：Schema中需要创建的内容（包括<code>TABLE, VIEW, INDEX, GRANT</code>等），也可在创建Schema之后创建内容。</p>
<h4 id="切换schema"><a class="header" href="#切换schema">切换Schema</a></h4>
<pre><code class="language-postgresql">set search_path to schema_name;
</code></pre>
<h3 id="table管理"><a class="header" href="#table管理">Table管理</a></h3>
<h4 id="获取数据表"><a class="header" href="#获取数据表">获取数据表</a></h4>
<p><code>pgsql</code>命令：</p>
<pre><code class="language-postgresql">\d[+]            -- show tables [and schema]
-- Schema |      Name      |       Type        |  Owner
-- -------+----------------+-------------------+----------
-- public | pokemon        | partitioned table | postgres
-- public | pokemon_gen_01 | table             | postgres
\dn -- show user created schema
</code></pre>
<p>SQL语句：</p>
<pre><code class="language-sql">SELECT schemaname,tablename,tableowner,* 
  FROM pg_catalog.pg_tables
  WHERE schemaname != 'pg_catalog' 
    AND schemaname != 'information_schema';
SELECT table_schema,table_name
  FROM information_schema.tables
  WHERE table_schema = 'public';
</code></pre>
<h4 id="获取数据表详细信息"><a class="header" href="#获取数据表详细信息">获取数据表详细信息</a></h4>
<p><code>pgsql</code>命令：</p>
<pre><code class="language-postgresql">\d[+] table_name -- -&gt; DESC table: '+'显示更多列和分区定义
</code></pre>
<p>SQL语句：</p>
<pre><code class="language-sql">SELECT column_name,data_type 
  FROM information_schema.columns
  WHERE table_schema = 'table_name';
</code></pre>
<h4 id="创建数据表"><a class="header" href="#创建数据表"><a href="%E6%95%B0%E6%8D%AE%E5%BA%93/SQL%20DDL.html#%E5%88%9B%E5%BB%BA%E8%A1%A8%E6%A0%BC">创建数据表</a></a></h4>
<p>If a schema name is given (for example, <code>CREATE TABLE myschema.mytable ...</code>) then the table is created in the specified schema. Otherwise it is created in the current schema. Temporary tables exist in a special schema, so a schema name cannot be given when creating a temporary table. The name of the table must be distinct from the name of any other table, sequence, index, view, or foreign table in the same schema.</p>
<h5 id="复制数据表"><a class="header" href="#复制数据表"><a href="%E6%95%B0%E6%8D%AE%E5%BA%93/SQL%20DDL.html#%E6%A0%B9%E6%8D%AE%E5%85%B6%E4%BB%96%E8%A1%A8%E6%A0%BC%E5%88%9B%E5%BB%BA">复制数据表</a></a></h5>
<h5 id="跨数据库复制数据表"><a class="header" href="#跨数据库复制数据表">跨数据库复制数据表</a></h5>
<p>不支持直接跨数据库复制表格，需要首先将数据<a href="%E6%95%B0%E6%8D%AE%E5%BA%93/PostgreSQL.html#%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA%E6%95%B0%E6%8D%AE">从一个数据库导出，再导入另一个数据库</a>。</p>
<h4 id="修改表格"><a class="header" href="#修改表格">修改表格</a></h4>
<pre><code class="language-mysql">ALTER TABLE [IF EXISTS] name RENAME TO new_name
ALTER TABLE [IF EXISTS] name SET SCHEMA new_schema
ALTER TABLE [IF EXISTS] name RENAME [COLUMN] column_name TO new_column_name
</code></pre>
<h4 id="数据表分区"><a class="header" href="#数据表分区">数据表分区</a></h4>
<blockquote>
<p><em>The partitioned table itself is a “virtual” table having no storage of its own. Instead, the storage belongs to partitions, which are otherwise-ordinary tables associated with the partitioned table. Each partition stores a subset of the data as defined by its partition bounds. All rows inserted into a partitioned table will be routed to the appropriate one of the partitions based on the values of the partition key column(s). Updating the partition key of a row will cause it to be moved into a different partition if it no longer satisfies the partition bounds of its original partition.</em></p>
</blockquote>
<p>分区引用的列使用<code>PARTITION BY</code>声明。</p>
<pre><code class="language-mysql">CREATE TABLE table_name (column1 data_type, column2 data_type, …)     
  PARTITION BY RANGE(col_name1,...);
CREATE TABLE table_part_xx PARTITION OF table_name
  FOR VALUES FROM ('2006-02-01') TO ('2006-03-01');
</code></pre>
<blockquote>
<p>每个分区被存储为一个目录。</p>
</blockquote>
<pre><code class="language-mysql">INSERT INTO TABLE table_name 
  PARTITION (partition1='partition1_val', partition2='partition2_val', ...)
  VALUES (col1_val, col2_val, …, partition1_val, partition2_val, …);
</code></pre>
<p>必须在创建时定义分区，创建分区表后，仅能添加或移除分区。</p>
<pre><code class="language-mysql">ALTER TABLE [ IF EXISTS ] name
    ATTACH PARTITION partition_name { FOR VALUES partition_bound_spec | DEFAULT }
ALTER TABLE [IF EXISTS] name DETACH PARTITION partition_name
</code></pre>
<p>不支持分区和分解和合并，可以将相关分区先移出父表，再修改分区定义，并将移出的子表格数据写回父表。</p>
<h2 id="数据类型-6"><a class="header" href="#数据类型-6">数据类型</a></h2>
<p><a href="https://www.runoob.com/postgresql/postgresql-data-type.html">PostgreSQL 数据类型 | 菜鸟教程 (runoob.com)</a></p>
<h2 id="继承-4"><a class="header" href="#继承-4">继承</a></h2>
<pre><code class="language-sql">CREATE TABLE cities (
 name text,
 population real,
 elevation int -- (in ft)
);
CREATE TABLE capitals (
 state char(2) UNIQUE NOT NULL
) INHERITS (cities);   -- 继承表的定义并进行扩展
</code></pre>
<p><code>ONLY</code></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hive-sql"><a class="header" href="#hive-sql">Hive SQL</a></h1>
<p>Hive是基于Hadoop的数据库，底层数据存储采用HDFS，提供HQL（Hive SQL）查询功能。</p>
<p>Hive将SQL语句转换为MapReduce任务运行。</p>
<p>Hive用于做海量离线数据统计分析：</p>
<ul>
<li>不支持记录级别的增删改操作，可以将查询结果导出到文件</li>
<li>查询延时很严重，因为 MapReduce任务的启动过程消耗很长时间，所以不能用在交互查询系统中。</li>
<li>不支持事务，因为没有增删改操作，所以主要用来做 OLAP（联机分析处理），而不是 OLTP（联机事务处理）。</li>
</ul>
<h2 id="配置-11"><a class="header" href="#配置-11">配置</a></h2>
<p>Hive命令行回显结果不显示表名：</p>
<pre><code class="language-sql">hive&gt; set hive.resultset.use.unique.column.names=false;
</code></pre>
<h2 id="定义数据库"><a class="header" href="#定义数据库">定义数据库</a></h2>
<pre><code class="language-sql">CREATE DATABASE|SCHEMA [IF NOT EXISTS] database_name
  [COMMENT 'database comment']
  [WITH DBPROPERTIES (property_name=property_value, ...)];
DROP DATABASE|SCHEMA [IF EXISTS] database_name [RESTRICT|CASCADE];
</code></pre>
<blockquote>
<p><code>CASCADE</code>删除数据库前先删除表格，默认情况<code>RESTRICT</code>如果数据库非空则删除操作失败。</p>
</blockquote>
<h3 id="定义数据表"><a class="header" href="#定义数据表">定义数据表</a></h3>
<pre><code class="language-sql">CREATE TABLE tablename (
   col_name DATA_TYPE [constraints] [COMMENT col_comment], ...)
   [COMMENT 'table comment']                   -- 表格说明
   [PARTITIONED BY (col_name data_type,...)]   -- 分片: 必须声明为(col type)格式
   ROW FORMAT DELIMITED      -- 分隔符文件
   FIELDS TERMINATED BY '\t' -- 分隔符
   -- LINES TERMINATED BY '\n' 
   STORED AS TEXTFILE        -- 存储格式：默认TEXTFILE，其他PARQUET、AVRO、ORC、JSONFILE等
   TBLPROPERTIES(&quot;skip.header.line.count&quot; = &quot;1&quot;,...);  
DROP TABLE tablename [purge];
</code></pre>
<p>==分片的列单独声明==，不应在列定义中重复声明；<code>STORED AS TEXTFILE</code>应该放在其他格式声明之后。</p>
<p>数据表属性声明：</p>
<ul>
<li><code>skip.header.line.count=1</code>：使用Hive查询时，跳过数据文件中的首行（包含表头的情况，列名不要包含特殊字符，如<code>#</code>，空格等）。</li>
</ul>
<p>对于具有表头的原始数据，可以去除表头后再导入HDFS（从而<a href="%E6%95%B0%E6%8D%AE%E5%BA%93/../%E6%9C%8D%E5%8A%A1%E5%99%A8/Spark%20Python%20API.html#Hive%E6%95%B0%E6%8D%AE%E6%BA%90%E6%A0%BC%E5%BC%8F">与Spark读取处理方式兼容</a>）。</p>
<pre><code class="language-shell">tail -n +2 data.csv &gt; data_nohead.csv
hdfs dfs -put data_nohead.csv /datasets/data.csv
</code></pre>
<blockquote>
<p>对于较大数据量，使用<code>tail</code>处理时间较长（需要复制数据）。</p>
</blockquote>
<h5 id="查看表的定义-1"><a class="header" href="#查看表的定义-1">查看表的定义</a></h5>
<pre><code class="language-sql">DESC table_name;  -- DESCRIBE
SHOW CREATE TABLE table_name;
# STORED AS TEXTFILE &lt;=&gt; STORED AS INPUTFORMAT 'org.apache.hadoop.mapred.TextInputFormat'
# OUTPUTFORMAT 'org.apache.hadoop.hive.ql.io.HiveIgnoreKeyTextOutputFormat'
# LOCATION 'hdfs://CLUSTER_ADDR/hive/warehouse/DBNAME.db/TABLE_FILE'
</code></pre>
<p>从定义中可看到表的底层数据在HDFS上的存储位置。</p>
<h5 id="自动获取数源的定义"><a class="header" href="#自动获取数源的定义">自动获取数源的定义</a></h5>
<p>使用Pandas可加载数据文件并自动推导数据类型定义，然后生成数据表的定义。</p>
<pre><code class="language-python">table_schema = pd.io.sql.get_schema(df.drop(columns=parition_cols), 'table_name')\
                        .replace('&quot;', '`')\
                        .replace('TEXT', 'STRING')\
                        .replace('INTEGER', 'INT')
# print(table_schema)
# CREATE TABLE `table_name` (
# `field1` STRING,
# `field2` INT
# )
</code></pre>
<p>转换后的SQL语句语法不完全与HQL兼容，例如需要将标识符范围限定符<code>&quot;</code>（PosgreSQL）替换为<code>ˋ</code>（MySQL）；某些类型关键字转换（如<code>TEXT</code>转换为<code>STRING</code>）。此外，为了支持设置分片列声明，可提前将分片列从源数据中分离出来并单独生成类型声明。</p>
<pre><code class="language-python">part_schema = pd.io.sql.get_schema(df[parition_cols], 'part_name')\
                       .replace('&quot;', '`')\
                       .replace('TEXT', 'STRING')
part_schema = ''.join(part_schema.split('\n')[1:-1])     
</code></pre>
<p>基于上述结果，可继续添加Hive表格属性限定声明（如分片、分隔符、存储格式等），从而生成Hive表格定义。</p>
<pre><code class="language-python">table_schema = '\n'.join(table_schema, f&quot;PARTITIONED BY ({part_schema})&quot;, 
                         &quot;ROW FORMAT DELIMITED&quot;, &quot;STORED AS TEXTFILE&quot;, ...)
</code></pre>
<p>如果使用Spark加载数据文件为表格，类似地，能基于自动推导生成表格定义（需要自行生成SQL语句）。</p>
<pre><code class="language-python">def spark_get_schema(df, tablename):
  ts = []
  ts.append(f'CREATE TABLE `{tablename}` (')
  tts = []
  for x in df.schema: 
    tts.append('`{0}` {1}'.format(x.name, x.dataType.typeName()))
  ts.append(',\n'.join(tts))
  ts.append(')')
  table_schema = '\n'.join(ts)
  return table_schema
</code></pre>
<h5 id="修改表定义"><a class="header" href="#修改表定义">修改表定义</a></h5>
<pre><code class="language-sql">ALTER TABLE table_name RENAME TO new_table_name;  # 修改表名
ALTER TABLE invites REPLACE COLUMNS (foo INT, bar STRING, ...);
</code></pre>
<p>修改表的<code>Schema</code>，不在参数声明中的列将被丢弃。</p>
<h5 id="修改表属性"><a class="header" href="#修改表属性">修改表属性</a></h5>
<pre><code class="language-sql">ALTER TABLE pokemon SET TBLPROPERTIES (&quot;skip.header.line.count&quot;=&quot;1&quot;);
</code></pre>
<h4 id="数据类型-7"><a class="header" href="#数据类型-7">数据类型</a></h4>
<h5 id="基本类型-1"><a class="header" href="#基本类型-1">基本类型</a></h5>
<div class="table-wrapper"><table><thead><tr><th>分类</th><th>数据类型</th></tr></thead><tbody>
<tr><td>逻辑类型</td><td><code>BOOLEAN</code></td></tr>
<tr><td>整数</td><td><code>TINYINT,SMALLINT,INT,BIGINT</code></td></tr>
<tr><td>浮点数</td><td><code>FLOAT,DOUBLE</code></td></tr>
<tr><td>高精度浮点数</td><td><code>DECIMAL,DECIMAL(precision, scale)</code></td></tr>
<tr><td>字符文本</td><td><code>STRING,VARCHAR,CHAR</code></td></tr>
<tr><td>时间日期</td><td><code>TIMESTAMP,DATE</code></td></tr>
<tr><td>原始数据</td><td><code>BINARY</code></td></tr>
</tbody></table>
</div>
<h2 id="导入数据"><a class="header" href="#导入数据">导入数据</a></h2>
<p>将本地文件导入Hive数据仓库：</p>
<pre><code class="language-sql">LOAD DATA [LOCAL] INPATH './examples/files/kv1.txt' OVERWRITE INTO TABLE pokes;
LOAD DATA [LOCAL] INPATH './examples/files/kv2.txt' OVERWRITE INTO TABLE invites PARTITION (ds='2008-08-15');
</code></pre>
<p><code>LOCAL</code>：从本地文件系统上传（省略则从HDFS中查找文件并移动到hive目录下）；<code>OVERWRITE</code>覆盖当前已有数据（省略则==追加==到当前数据）；如果是已定义分区的数据表，则必须指定<code>PARTITION</code>指定要写入数据的分区（分区字段将被写入设置的值，而非源数据中的值）。</p>
<blockquote>
<p>不会验证数据的<code>schema</code>；</p>
</blockquote>
<h2 id="读取数据-2"><a class="header" href="#读取数据-2">读取数据</a></h2>
<p>使用SQL<code>SELECT</code>语句进行查询，结果将输出至标准输出。</p>
<p>查询的列名可使用正则表达式模糊匹配。</p>
<h5 id="保存数据"><a class="header" href="#保存数据">保存数据</a></h5>
<p>使用Hive<code>INSERT</code>命令将查询结果写入Hive表、HDFS或本地存储。</p>
<pre><code class="language-sql">INSERT OVERWRITE [LOCAL] DIRECTORY 'directory1'
  [ROW FORMAT row_format] [STORED AS file_format]
  SELECT ... FROM ...;
-- row_format
:DELIMITED [FIELDS TERMINATED BY char [ESCAPED BY char]] 
		[COLLECTION ITEMS TERMINATED BY char]
        [MAP KEYS TERMINATED BY char] 
        [LINES TERMINATED BY char]
        [NULL DEFINED AS char]
INSERT OVERWRITE DIRECTORY '/tmp/hdfs' SQL_STATEMENT;   -- to HDFS
INSERT OVERWRITE TABLE events;                          -- to hive table
INSERT OVERWRITE LOCAL DIRECTORY '/tmp' SQL_STATEMENT;  -- to local storage
</code></pre>
<blockquote>
<p><em>Hive-on-MR is deprecated in Hive 2 and may not be available in the future versions. Consider using a different execution engine (i.e. spark, tez) or using Hive 1.X releases.</em></p>
</blockquote>
<h5 id="基于分区的查询"><a class="header" href="#基于分区的查询">基于分区的查询</a></h5>
<h3 id="计算-1"><a class="header" href="#计算-1">计算</a></h3>
<p>在查询语句使用<code>TRANSFORM</code>和<code>USING</code>，可以调用外部程序（例如使用Python脚本）处理数据。</p>
<pre><code class="language-python">import sys
import datetime
for line in sys.stdin:   # 从标准输入读取一行数据
  line = line.strip()
  userid, movieid, rating, unixtime = line.split('\t')
  weekday = datetime.datetime.fromtimestamp(float(unixtime)).isoweekday()
  print '\t'.join([userid, movieid, rating, str(weekday)])  # 输出结果到标准输出
</code></pre>
<pre><code class="language-sql">add FILE weekday_mapper.py;
INSERT OVERWRITE TABLE u_data_new
   SELECT
     TRANSFORM (userid, movieid, rating, unixtime)
     USING 'python weekday_mapper.py'  -- 运行Python程序处理每一行记录
     AS (userid, movieid, rating, weekday)
   FROM u_data;
</code></pre>
<p><a href="https://cwiki.apache.org/confluence/display/Hive/GettingStarted#GettingStarted-DDLOperations">GettingStarted - Apache Hive - Apache Software Foundation</a></p>
<p><a href="https://cwiki.apache.org/confluence/display/Hive/Tutorial">Tutorial - Apache Hive - Apache Software Foundation</a></p>
<p><a href="https://cwiki.apache.org/confluence/display/Hive/LanguageManual+DDL">LanguageManual DDL - Apache Hive - Apache Software Foundation</a></p>
<p><a href="https://cwiki.apache.org/confluence/display/Hive/LanguageManual+DML">LanguageManual DML - Apache Hive - Apache Software Foundation</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="elasticsearch"><a class="header" href="#elasticsearch">Elasticsearch</a></h1>
<h2 id="准备工作"><a class="header" href="#准备工作">准备工作</a></h2>
<h3 id="安装elasticsearch"><a class="header" href="#安装elasticsearch">安装Elasticsearch</a></h3>
<h4 id="ubuntu-2"><a class="header" href="#ubuntu-2">Ubuntu</a></h4>
<h5 id="apt-1"><a class="header" href="#apt-1">apt</a></h5>
<pre><code class="language-shell">wget -qO - https://artifacts.elastic.co/GPG-KEY-elasticsearch | sudo apt-key add -
sudo apt-get install apt-transport-https
echo &quot;deb https://artifacts.elastic.co/packages/7.x/apt stable main&quot; | sudo tee /etc/apt/sources.list.d/elastic-7.x.list
sudo apt-get update &amp;&amp; sudo apt-get install elasticsearch logstash filebeat
</code></pre>
<blockquote>
<p>程序的安装位置为<code>/usr/share</code>。</p>
</blockquote>
<h5 id="deb"><a class="header" href="#deb"><a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.15/deb.html#install-deb">deb</a></a></h5>
<h4 id="centos-2"><a class="header" href="#centos-2">CentOS</a></h4>
<h5 id="软件仓库安装"><a class="header" href="#软件仓库安装">软件仓库安装</a></h5>
<h5 id="rpm包安装"><a class="header" href="#rpm包安装">rpm包安装</a></h5>
<pre><code class="language-shell">wget https://artifacts.elastic.co/.../elasticsearch-7.14.1-x86_64.rpm
wget https://artifacts.elastic.co/.../elasticsearch-7.14.1-x86_64.rpm.sha512
shasum -a 512 -c elasticsearch-7.14.1-x86_64.rpm.sha512 
sudo rpm --install elasticsearch-7.14.1-x86_64.rpm
</code></pre>
<h4 id="docker-2"><a class="header" href="#docker-2">Docker</a></h4>
<p>安装最新版ElasticSearch必须带具体标签（<code>latest</code>标签未绑定至最新版本）。</p>
<h5 id="development-mode-single-node"><a class="header" href="#development-mode-single-node">Development Mode （Single Node）</a></h5>
<pre><code class="language-sh">docker network create elastic
docker run -d --name elasticsearch --net elastic -p 9200:9200 -p 9300:9300 -e &quot;discovery.type=single-node&quot; elasticsearch:tag
</code></pre>
<blockquote>
<p><strong>Note:</strong> Pulling an images requires using a specific version number tag. The <code>latest</code> tag is not supported.</p>
</blockquote>
<h5 id="production-mode"><a class="header" href="#production-mode">Production Mode</a></h5>
<p>https://www.elastic.co/guide/en/elasticsearch/reference/7.12/docker.html</p>
<p>The <code>vm.max_map_count</code> kernel setting must be set to at least <code>262144</code> for production use.</p>
<blockquote>
<p>Error: </p>
<pre><code class="language-shell">&gt; ERROR: for kib01  Container &quot;7d61ad9aeddd&quot; is unhealthy.
&gt; bootstrap check failure [1] of [1]: max virtual memory areas vm.max_map_count [65530] is too low, increase to at least [262144]
</code></pre>
</blockquote>
<pre><code class="language-sh">vi /etc/sysctl.conf
vm.max_map_count=262144                  # permanent settings for Linux
sudo sysctl -w vm.max_map_count=262144   # enable now for WSL (/etc/rc.local =&gt; u+x)
</code></pre>
<h6 id="kibana"><a class="header" href="#kibana">kibana</a></h6>
<p>kibana用于Elasticsearch数据的可视化分析，可以与Elasticsearch安装在同一集群。</p>
<p>https://www.elastic.co/guide/en/kibana/current/docker.html</p>
<p><a href="%E6%95%B0%E6%8D%AE%E5%BA%93/./scripts/docker-compose-elasticsearch.yaml">配置文件</a></p>
<pre><code class="language-yaml">services:
  kibana:
    image: kibana:7.9.2
    container_name: kibana7
    environment:
      ELASTICSEARCH_HOSTS: http://es_node:9200
    ports:
      - &quot;5601:5601&quot;
</code></pre>
<p>默认的Elasticsearch集群主节点名为<code>elasticsearch</code>，如果不是，通过环境变量<code>ELASTICSEARCH_HOSTS</code>设置，否则无法与集群建立连接。</p>
<h6 id="启用安全配置"><a class="header" href="#启用安全配置">启用安全配置</a></h6>
<p>启用HTTPS/TLS：https://www.elastic.co/guide/en/elastic-stack-get-started/7.12/get-started-docker.html。启用HTTP后，访问elasticsearch/kibana都需要用户名和密码进行验证。</p>
<pre><code class="language-shell"># 重启集群应用密码
docker-compose -f elastic-docker-tls.yml stop
docker-compose -f elastic-docker-tls.yml up -d
# 清理环境
docker-compose -f elastic-docker-tls.yml down -v
</code></pre>
<p>WSL中的证书文件：<code>\\wsl$\docker-desktop-data\version-pack-data\community\docker\volumes\es_certs\_data</code>（安装证书到系统）</p>
<h5 id="问题-4"><a class="header" href="#问题-4">问题</a></h5>
<ol>
<li>
<p>*WSL2文件系统访问权限问题</p>
<p><em>&quot;Causedby:java.nio.file.NoSuchFileException:/usr/share/elasticsearch/data/nodes/0/node.lock&quot;</em></p>
<p>原因：可能是镜像对挂载的数据卷（位于docker的<a href="%E6%95%B0%E6%8D%AE%E5%BA%93/">卷目录</a>下，在WSL中实际映射到Windows的文件系统中）没有正确的读写权限。==该问题在Linux虚拟机中不曾出现，且在删除出错的服务和数据卷后重新创建服务后该问题没有复现==。</p>
</li>
<li>
<p>问题：<em>Exception in thread &quot;main&quot; java.nio.file.FileSystemException: /tmp/elasticsearch-15594239510299122966: No space left on device</em>。</p>
<p>原因：宿主机存储空间不足，无法创建数据卷。清理磁盘或增加磁盘容量。</p>
</li>
</ol>
<h3 id="配置-12"><a class="header" href="#配置-12">配置</a></h3>
<p>系统配置（<code>/etc/default/elasticsearch</code>[Ubuntu]或<code>/etc/sysconfig/elasticsearch</code>[CentOS]）：包括ES运行相关的系统环境变量。</p>
<pre><code class="language-shell">ES_PATH_CONF=/etc/elasticsearch  # default
ES_JAVA_HOME=/usr/share/elasticsearch/jdk/bin/java
MAX_OPEN_FILES=65535
</code></pre>
<p>配置文件位于<code>/etc/elasticsearch/elasticsearch.yml</code>。重要配置项：</p>
<pre><code class="language-yml">ES_TMPDIR: /data/tmp/es  # 不使用默认临时文件目录防止被以外删除
node.name: es_005_data   # 默认为$(hostname)
path:
  data: /path/to/data  # Multiple data paths deprecated in 7.13
  logs: /path/to/logs
path.plugins: /path/to/plugins
network.host: 0.0.0.0  # 默认仅监听loopback
action.auto_create_index: *
</code></pre>
<blockquote>
<p>ElasticSearch自带Java运行环境。ElasticSearch默认监听端口9200，如果被占用，将自动向后查询可用端口。</p>
</blockquote>
<p>集群环境配置：</p>
<pre><code class="language-yaml">cluster.name: es_cluster  # 集群名相同的节点才能加入集群
discovery.seed_hosts:  # 发现集群节点,默认会扫描同一机器上的实例（9300 to 9305）
   - node-1
   - 192.168.1.11:9300  
   - seeds.mydomain.com
cluster.initial_master_nodes:
   - node-1   # =&gt; node.name
   - node-2
# at least one of [discovery.seed_hosts, discovery.seed_providers, cluster.initial_master_nodes] must be configured
</code></pre>
<blockquote>
<p>当一个节点联系到单播列表中的成员时，它就会得到整个集群所有节点的状态，然后它会联系 master节点，并加入集群。</p>
</blockquote>
<p><a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/important-configuration-changes.html#_%E9%9B%86%E7%BE%A4%E6%81%A2%E5%A4%8D%E6%96%B9%E9%9D%A2%E7%9A%84%E9%85%8D%E7%BD%AE">集群恢复</a>：在集群重启的时候避免过多的分片交换。这可能会让数据恢复从数个小时缩短为几秒钟。</p>
<pre><code class="language-yaml"># gateway.recover_after_nodes: 3   # 集群至少有3个节点可用才开始恢复数据
gateway.recover_after_master_nodes: 1
gateway.recover_after_data_nodes: 3
# gateway.expected_nodes           # 等待达到4个节点或持续5min钟后开始恢复
gateway.expected_data_nodes: 3   
gateway.expected_master_nodes: 1
gateway.recover_after_time: 5m  
</code></pre>
<h4 id="配置插件"><a class="header" href="#配置插件">配置插件</a></h4>
<pre><code class="language-shell">elasticsearch-plugin install [plugin_name]  # curl host:9200/_cat/plugins
</code></pre>
<h4 id="配置logstash"><a class="header" href="#配置logstash">配置logstash</a></h4>
<h5 id="插件管理-1"><a class="header" href="#插件管理-1">插件管理</a></h5>
<p>Logstash包含了常用插件。</p>
<pre><code class="language-shell">bin/logstash-plugin list --verbose
                         --group output|input|filter|codec
</code></pre>
<h5 id="在线安装插件"><a class="header" href="#在线安装插件">在线安装插件</a></h5>
<p>从<a href="https://rubygems.org/">RubyGems.org</a>获取插件：</p>
<pre><code class="language-shell">logstash-plugin install|remove logstash-input-github
logstash-plugin install /path/to/logstash-output-kafka-1.0.0.gem  # 安装本地插件
logstash-plugin update [logstash-input-github] # 默认更新所有插件
</code></pre>
<p>离线安装和更新插件：</p>
<pre><code class="language-shell">logstash-plugin prepare-offline-pack --output OUTPUT.zip --overwrite [PLUGINS]
logstash-plugin install|update file:///path/to/logstash-offline-plugins.zip
</code></pre>
<blockquote>
<p><code>PLUGINS</code>表示要打包的插件（可使用通配符<code>*</code>）。</p>
</blockquote>
<h5 id="logstash执行环境"><a class="header" href="#logstash执行环境">logstash执行环境</a></h5>
<p><a href="https://www.elastic.co/guide/en/logstash/7.15/logstash-settings-file.html"><code>logstash.yml</code></a>：</p>
<pre><code class="language-yml">node.name: ${HOSTNAME}
path.data: LOGSTASH_HOME/data
timzzone？
</code></pre>
<p><code>pipelines.yml</code>：</p>
<h5 id="logstash管道配置"><a class="header" href="#logstash管道配置">logstash管道配置</a></h5>
<p><code>/etc/logstash/conf.d</code></p>
<blockquote>
<p>The default Logstash installation includes the Beats input plugin. The Beats input plugin enables Logstash to receive events from the Elastic Beats framework, which means that any Beat written to work with the Beats framework, such as Packetbeat and Metricbeat, can also send event data to Logstash.]</p>
</blockquote>
<p>可定义多个输入数据源和输出目标。</p>
<pre><code class="language-conf">input {
  beats {
    port =&gt; &quot;5044&quot;
  }
  file {
    path =&gt; &quot;/var/log/messages&quot;
    type =&gt; &quot;syslog&quot;
  }
   kafka{
     bootstrap_servers=&gt;&quot;192.168.13.10:9092&quot;
     topics=&gt;[&quot;kafka_es_test&quot;]
     group_id=&gt;&quot;logstash_kafka_test&quot;
   }
}
filter {
  grok {
    # parse apache web logs
    match =&gt; { &quot;message&quot; =&gt; &quot;%{COMBINEDAPACHELOG}&quot;} 
  }
}
output {
  stdout { codec =&gt; rubydebug }
  elasticsearch {
    hosts =&gt; [ &quot;localhost:9200&quot; ]
    index =&gt; &quot;logstash_kafka_test&quot;
  }
}
</code></pre>
<h5 id="测试-2"><a class="header" href="#测试-2">测试</a></h5>
<p><code>&quot;@timestamp&quot;</code>日志收集时间，非日志中表示时间的字段。</p>
<pre><code class="language-shell">bin/logstash -f first-pipeline.conf --config.test_and_exit  # 测试配置文件
bin/logstash -f first-pipeline.conf --config.reload.automatic  # 启用管道
</code></pre>
<h3 id="启用服务"><a class="header" href="#启用服务">启用服务</a></h3>
<pre><code class="language-shell">sudo systemctl daemon-reload
sudo systemctl enable --now elasticsearch.service  # sudo is required
sudo systemctl start logstash.service
</code></pre>
<h4 id="查看状态-1"><a class="header" href="#查看状态-1">查看状态</a></h4>
<h5 id="查看集群状态"><a class="header" href="#查看集群状态">查看集群状态</a></h5>
<pre><code class="language-http">http://hostip:9200/   # 访问elasticsearch
http://hostip:5601/   # 访问kibana
GET /_cat/health?v
GET _cluster/health
</code></pre>
<blockquote>
<p>The cluster status will remain yellow if you are only running a single instance of Elasticsearch.</p>
</blockquote>
<h5 id="查看日志-2"><a class="header" href="#查看日志-2">查看日志</a></h5>
<pre><code class="language-shell">sudo journalctl --unit elasticsearch \
                --since  &quot;2016-10-30 18:17:16&quot;
</code></pre>
<h3 id="api"><a class="header" href="#api">API</a></h3>
<p>使用REST接口访问Elasticsearch以<a href="%E6%95%B0%E6%8D%AE%E5%BA%93/Elasticsearch.html#%E6%9F%A5%E8%AF%A2%E6%95%B0%E6%8D%AE">查询</a>或<a href="%E6%95%B0%E6%8D%AE%E5%BA%93/Elasticsearch.html#%E5%86%99%E5%85%A5%E6%95%B0%E6%8D%AE">写入</a>数据。使用<code>curl</code>提交数据访问请求：</p>
<pre><code class="language-sh">curl -X&lt;VERB&gt; '&lt;PROTOCOL&gt;://&lt;HOST&gt;:&lt;PORT&gt;/&lt;PATH&gt;?&lt;QUERY_STRING&gt;' -d '&lt;BODY&gt;'
</code></pre>
<p><code>VERB</code>：<code>GET</code>, <code>POST</code>, <code>PUT</code>, <code>HEAD</code>, or <code>DELETE</code>.</p>
<p><code>PROTOCOL</code>：<code>http</code> or <code>https</code></p>
<p><code>PATH</code>：数据路径。</p>
<p><code>BODY</code>：JSON请求体。</p>
<p>示例：</p>
<pre><code class="language-shell">curl -XGET http://localhost:9200/_index/_doc/_id
</code></pre>
<h5 id="查看可用管理接口"><a class="header" href="#查看可用管理接口">查看可用管理接口</a></h5>
<pre><code class="language-shell">_/cat   # 列出可用接口
</code></pre>
<p>列出的接口通常有两种调用方式：</p>
<pre><code class="language-shell">_cat/ACTION?v # 返回简要信息（表格，v显示表头）
_ACTION       # 返回详细信息（JSON）
</code></pre>
<p><code>/_cat/snapshots</code>对应的API是<code>/_snapshot[/{repo_name}]</code></p>
<p>常用接口：</p>
<pre><code class="language-shell">GET /_cat/indices/{index}?v # 查看(指定索引模式)索引列表
GET /_cat/templates/?v      # 查看索引模板
# health status index uuid  pri  rep  docs.count ... store.size ...
GET /_cat/tasks?v           # 查看正在运行的任务
# action  task_id ... type start_time ... running_time ip node
GET /_cat/health?v          # 查看集群状态
GET /_cat/master?v          # 查看主节点信息
GET /_cat/nodes?v           # 查看主节点信息
GET /_cat/plugins?v         # 查看各节点安装的插件信息
GET /_cat/repositories      # 查看快照仓库列表
GET /_cat/count/{index}?v   # 查看(指定索引模式)文档数量
</code></pre>
<h5 id="查看索引定义"><a class="header" href="#查看索引定义">查看索引定义</a></h5>
<pre><code class="language-http">GET /&lt;index&gt;
GET /&lt;index&gt;/{_mapping|_mappings}
GET /&lt;index&gt;/_mapping/field/fieldname   //显式定义的映射才有返回结果
GET /&lt;index&gt;/_settings
GET /&lt;index&gt;/{_alias|_aliases}
GET _data_stream
GET _data_stream/{data_stream_name}
</code></pre>
<blockquote>
<p><code>index</code>可以包含通配符，<code>_all</code>代表所有索引（等效于<code>*</code>或省略索引）。</p>
</blockquote>
<h3 id="索引生命周期管理"><a class="header" href="#索引生命周期管理">索引生命周期管理</a></h3>
<p>将旧数据移动到较为便宜的存储设备中，从而提高性能并减小开销。</p>
<h4 id="data-tiers"><a class="header" href="#data-tiers">data tiers</a></h4>
<div class="table-wrapper"><table><thead><tr><th>tiers</th><th>necessity</th><th>description</th></tr></thead><tbody>
<tr><td>hot<br/>warm</td><td>required<br/>optional</td><td>高性能节点<br />快速索引和搜索最近数据</td></tr>
<tr><td>content</td><td>required</td><td>非时序数据</td></tr>
<tr><td>cold<br/>frozen</td><td>optional</td><td>慢速便宜节点</td></tr>
</tbody></table>
</div>
<p>在节点的配置文件中声明节点对应的<code>tier</code>。一个节点可以对应一个或多个<code>tier</code>。</p>
<pre><code class="language-yml">node.roles: [ data_content, data_hot, data_warm ]
</code></pre>
<h5 id="searchable-snapshot"><a class="header" href="#searchable-snapshot">Searchable Snapshot</a></h5>
<p>使用可搜索快照以减小本地存储开销。</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/plugins/7.14/repository-hdfs.html">Hadoop HDFS Repository Plugin | Elasticsearch Plugins and Integrations 7.14 | Elastic</a>。</p>
<pre><code class="language-json">// PUT _snapshot/my_hdfs_repository
{
  &quot;type&quot;: &quot;hdfs&quot;,
  &quot;settings&quot;: {
    &quot;uri&quot;: &quot;hdfs://namenode:8020/&quot;,
    &quot;path&quot;: &quot;elasticsearch/repositories/my_hdfs_repository&quot;,
    &quot;conf.dfs.client.read.shortcircuit&quot;: &quot;true&quot;
  }
}
</code></pre>
<h4 id="生命周期策略"><a class="header" href="#生命周期策略">生命周期策略</a></h4>
<p>内置生命周期策略：<code>logs,metrics,synthetics</code>。</p>
<pre><code class="language-http">GET _ilm/policy
GET _ilm/policy/logs
</code></pre>
<pre><code class="language-http">PUT _ilm/policy/my-lifecycle-policy
{...}
</code></pre>
<h2 id="写入数据"><a class="header" href="#写入数据">写入数据</a></h2>
<p>将JSON文档存入Elasticsearch索引。</p>
<ul>
<li>按需创建索引：添加数据时创建对应的索引，使用动态映射；</li>
<li>手动<a href="%E6%95%B0%E6%8D%AE%E5%BA%93/Elasticsearch.html#%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95">创建索引</a>：
<ul>
<li>使用显式映射；</li>
<li>使用动态映射；</li>
</ul>
</li>
<li>基于模板自动创建索引：添加映射模板和设置模板（生命周期管理）；</li>
</ul>
<h3 id="术语"><a class="header" href="#术语">术语</a></h3>
<h5 id="索引-3"><a class="header" href="#索引-3">索引</a></h5>
<p>索引名称：在API中索引名称可使用日期函数动态生成查询索引名。表达式：</p>
<pre><code>&lt;static_name{now/d{yyyy.MM.dd-HH:mm:ss|+08:00}}&gt;
</code></pre>
<p>索引名称中的包含的特殊字符必须使用URL编码：</p>
<pre><code class="language-python">from urllib.parse import quote
index = quote_plus(index_expr)  # quote_plus对&quot;/&quot;也进行编码，以与路径分隔符区分开
</code></pre>
<blockquote>
<p>浏览器等Web客户端通常会自动编码，而使用API时需要手动进行上述编码转换。</p>
</blockquote>
<h5 id="文档-3"><a class="header" href="#文档-3"><img src="数据库/Elasticsearch.assets/image-20210921134406228.png" alt="image-20210921134406228" style="float:right; zoom:50%;" />文档</a></h5>
<p>JSON对象。</p>
<blockquote>
<p>文档类型<code>type</code>，即一个索引可声明一个或多个映射类型，在提交或查询数据时指定<code>type</code>，则按指定类型映射进行处理。如果一个索引的多个映射类型包含同一字段，但其数据类型不同，则<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/removal-of-types.html">在索引或查询数据时会产生冲突</a>。</p>
<p>5.6版本设置<code>index.mapping.single_type: true</code>使索引仅支持单个映射类型；6.x版本仅支持定义单个<code>type</code>（可以是任意合法标识），且为了与7.x版本兼容，最好声明为<code>_doc</code>；7.x版本将弃用<code>type</code>声明（在API请求中声明参数<code>include_type_name=true</code>将产生启用警告），8.x版本将不再支持声明<code>type</code>。</p>
<p>在新版本中索引的API中，<code>type=_doc</code>且不再表示文档类型，仅作为API路径（类似于<code>_mappings</code>和<code>_settings_</code>）：</p>
<pre><code class="language-http">PUT {index}/_doc/{id} 
POST {index}/_doc
</code></pre>
</blockquote>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.14/runtime.html">Runtime fields</a>：查询时进行计算的字段。</p>
<h3 id="索引文档"><a class="header" href="#索引文档">索引文档</a></h3>
<h4 id="创建索引-1"><a class="header" href="#创建索引-1">创建索引</a></h4>
<p>如果没有配置自动创建索引，那么在索引文档前，需要首先创建索引。</p>
<pre><code class="language-json">// PUT /my-index-000001
{
   &quot;settings&quot;: {
      &quot;index&quot;: {
         &quot;number_of_shards&quot;: 3,  
         &quot;number_of_replicas&quot;: 2 
      }
   },
   &quot;mappings&quot;: {
      &quot;properties&quot;: {
         &quot;field1&quot;: { &quot;type&quot;: &quot;text&quot; }
      }
   }   
}
</code></pre>
<p>创建索引时，可选择指定索引的配置、<a href="%E6%95%B0%E6%8D%AE%E5%BA%93/Elasticsearch.html#%E6%98%A0%E5%B0%84">映射</a>等信息。如果未指定映射，则索引将使用默认的自动映射规则。创建完成后返回执行状态。</p>
<pre><code class="language-python">{'acknowledge': True, 'shards_acknowledged': True}
</code></pre>
<h5 id="删除索引"><a class="header" href="#删除索引">删除索引</a></h5>
<pre><code class="language-http">DELETE /&lt;index_name&gt;  
</code></pre>
<p>不支持通配符批量删除。</p>
<h4 id="索引的数据类型映射"><a class="header" href="#索引的数据类型映射">索引的数据类型映射</a></h4>
<p>将文档中的数据字段转换为ES存储的目标<a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.14/mapping-types.html">数据类型</a>，在创建索引时为索引指定映射设置。</p>
<h5 id="显式类型映射"><a class="header" href="#显式类型映射">显式类型映射</a></h5>
<p>映射定义了文档字段的数据类型、格式等。<a href="%E6%95%B0%E6%8D%AE%E5%BA%93/Elasticsearch.html#%E6%9F%A5%E7%9C%8B%E7%B4%A2%E5%BC%95%E5%AE%9A%E4%B9%89">查看映射的定义</a>。</p>
<pre><code class="language-json">//PUT /my-index-000001
{
   &quot;mappings&quot;: {
      &quot;&lt;doc_type&gt;&quot;:{   // *
         &quot;properties&quot;: {
            &quot;age&quot;:    { &quot;type&quot;: &quot;integer&quot; },
            &quot;email&quot;:  { &quot;type&quot;: &quot;keyword&quot;  },
            &quot;name&quot;:   { &quot;type&quot;: &quot;text&quot;  }
         } } } }
</code></pre>
<blockquote>
<p><code>*</code>：<code>doc_type</code>已弃用(7.x)无须声明，直接将<code>properties</code>声明在<code>mappings</code>中。<code>5.x</code>需要声明。</p>
</blockquote>
<p>更新映射：添加一个字段。注意，通常无法修改已经定义的字段，否则会与已有数据冲突。</p>
<pre><code class="language-json">//PUT /my-index-000001/_mapping   # =&gt; 
{
   &quot;properties&quot;: {
      &quot;city&quot;: {
         &quot;type&quot;: &quot;text&quot;,
         &quot;fields&quot;: {    // 该字段的属性
            &quot;name&quot;: { 
               &quot;type&quot;:  &quot;keyword&quot;
            }
         }
   }
}
</code></pre>
<h5 id="动态类型映射"><a class="header" href="#动态类型映射">动态类型映射</a></h5>
<p>ES自动解析数据并设定对应的字段的类型。</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.14/dynamic-field-mapping.html">Dynamic field mapping | Elasticsearch Guide 7.14 | Elastic</a></p>
<ol>
<li>
<p><strong>自动类型映射</strong>：修改自动映射配置（如果索引不存在将自动创建索引）：</p>
<pre><code class="language-json">//PUT my-index-000001
{
   &quot;mappings&quot;: {
       &quot;&lt;doc_type&gt;&quot;: {  // *
          &quot;dynamic&quot;: true,
          &quot;date_detection&quot;: true,                 // 转换日期类型
          &quot;dynamic_date_formats&quot;: [&quot;MM/dd/yyyy&quot;], // 日期转换格式
          &quot;numeric_detection&quot;: true 
       }
   }
}
</code></pre>
<blockquote>
<p><code>*</code>：<code>doc_type</code>已弃用(7.x)无须声明，直接将<code>properties</code>声明在<code>mappings</code>中。<code>5.x</code>需要声明。</p>
</blockquote>
</li>
<li>
<p><strong>基于规则的动态类型映射</strong>：基于规则进行类型映射。</p>
</li>
</ol>
<pre><code class="language-json">{
   &quot;mappings&quot;:{
      &quot;dynamic_templates&quot;:[  // 可定义多个动态映射模板
         {
            &quot;as_integer&quot;:{   // 模板名称
               &quot;match_mapping_type&quot;: &quot;long&quot;, // 匹配检测到的数据类型*
               &quot;norms&quot;: false,        // 不存储index-time scoring factor
               &quot;mapping&quot;:{
                  &quot;type&quot;: &quot;integer&quot;，
                  &quot;index&quot;: false      // 不索引该字段**
               }
            }
         },
         {
            &quot;as_date&quot;:{
               &quot;match_pattern&quot;: &quot;regex&quot;,
               &quot;match&quot;: &quot;_time$&quot;,      // 匹配字段名
               &quot;unmatch&quot;: &quot;^collect&quot;,
               &quot;mapping&quot;:{ }
            }
         },
         {
            &quot;as_keyword&quot;:{
               &quot;path_match&quot;:   &quot;name.*&quot;,  // 匹配路径名
               &quot;path_unmatch&quot;: &quot;*.middle&quot;,
               &quot;mapping&quot;: {},
               &quot;runtime&quot;: {},             // 查询时将字符串转换为keyword
         }
      ]
   }
}
</code></pre>
<blockquote>
<p><code>*</code>：匹配条件：如果未指定<code>match_mapping_type,match,path_match</code>中的任意一个，则该动态模板不会匹配任何字段。</p>
</blockquote>
<h5 id="查询时映射"><a class="header" href="#查询时映射"><a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.14/runtime-mapping-fields.html">查询时映射</a></a></h5>
<ol>
<li>通过脚本生成运行时的字段。</li>
<li>在执行搜索时定义运行时字段。</li>
</ol>
<h4 id="索引模板"><a class="header" href="#索引模板">索引模板</a></h4>
<p>如果索引名不存在且匹配该模板，则ES将根据该模板创建索引。</p>
<h5 id="创建模板组件"><a class="header" href="#创建模板组件">创建模板组件</a></h5>
<p>索引模板组件通常由映射(mappings)和索引设置(index settings)模板组成。模板组件从模板定义中被抽离出来从而可以被==复用==（索引生命周期策略配置同理）。</p>
<h6 id="映射模板"><a class="header" href="#映射模板">映射模板</a></h6>
<pre><code class="language-json">// PUT _component_template/my-mappings # =&gt; Create a mappings template
{
  &quot;template&quot;: {
    &quot;mappings&quot;: {
      &quot;properties&quot;: {
        &quot;@timestamp&quot;: {
          &quot;type&quot;: &quot;date&quot;,    // 数据类型
          &quot;format&quot;: &quot;date_optional_time||epoch_millis&quot;  // 格式
        },
        &quot;message&quot;: {
          &quot;type&quot;: &quot;wildcard&quot;
        }
}}},
  &quot;_meta&quot;: {
    &quot;description&quot;: &quot;Mappings for @timestamp and message fields&quot;,
    &quot;my-custom-meta-field&quot;: &quot;自定义元数据&quot;
}}
</code></pre>
<h6 id="索引设置模板"><a class="header" href="#索引设置模板">索引设置模板</a></h6>
<p>索引设置定义了索引的<a href="%E6%95%B0%E6%8D%AE%E5%BA%93/Elasticsearch.html#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%AD%96%E7%95%A5">生命周期策略</a>。</p>
<pre><code class="language-json">//PUT _component_template/my-settings # Create a index settings template
{
  &quot;template&quot;: {
    &quot;settings&quot;: {
      &quot;index.lifecycle.name&quot;: &quot;my-lifecycle-policy&quot; // 索引生命周期策略
}},
  &quot;_meta&quot;: {
    &quot;description&quot;: &quot;Settings for ILM&quot;,
    &quot;my-custom-meta-field&quot;: &quot;自定义元数据&quot;
}}
</code></pre>
<h5 id="创建索引模板"><a class="header" href="#创建索引模板">创建索引模板</a></h5>
<pre><code class="language-json">//PUT _index_template/my-index-template
{
  &quot;index_patterns&quot;: [&quot;my-data-stream*&quot;],   // 匹配索引/数据流的名称
  &quot;data_stream&quot;: { },                      // data stream enabled
  &quot;composed_of&quot;: [ &quot;my-mappings&quot;, &quot;my-settings&quot; ], // 模板组件
  &quot;priority&quot;: 500,                         // 优先级&gt;=200，避免与内置索引模板冲突
  &quot;_meta&quot;: {
    &quot;description&quot;: &quot;Template for my time series data&quot;,
    &quot;my-custom-meta-field&quot;: &quot;More arbitrary metadata&quot;
}}
</code></pre>
<h4 id="创建文档"><a class="header" href="#创建文档">创建文档</a></h4>
<h5 id="使用putpost提交文档"><a class="header" href="#使用putpost提交文档">使用PUT/POST提交文档</a></h5>
<p>将JSON文档存储为ES索引对象。API接口格式：</p>
<pre><code class="language-json">// PUT  /&lt;index&gt;/_doc/&lt;_id&gt;      # 创建或更新指定id文档 *
// POST /&lt;index&gt;/_doc/           # 创建文档并自动创建id **
// PUT  /&lt;index&gt;/_create/&lt;_id&gt;   # 显式创建指定id的文档
// POST /&lt;index&gt;/_create/&lt;_id&gt;   # 显式创建指定id的文档
{
  &quot;fristName&quot;: &quot;sunke&quot;,
  &quot;lastName&quot; : &quot;Lee&quot; ,
  &quot;tags&quot; : [&quot;guitar&quot;,&quot;ball&quot;]
}
// POST /users/_doc/1   =&gt; index/type_id 

</code></pre>
<ul>
<li><code>index</code>：索引或数据流名称。如果目标不存在，则自动创建。</li>
</ul>
<blockquote>
<p><code>*</code>：<code>5.x</code>：API第二级为<code>&lt;doc_type&gt;</code>，后续版本弃用<code>doc_type</code>，使用<code>_doc/_create</code>代替。</p>
<p><code>**</code>：要自动创建ID，需要使用<code>POST</code>方法，<code>op_type</code>设置为<code>create</code>。</p>
</blockquote>
<p>API查询参数：</p>
<ul>
<li><code>version</code>：显式指定文档的版本号（整数）；</li>
<li><code>op_type</code>：<code>create</code>如果文档存在则返回创建失败，默认<code>index</code>为创建或更新已有文档。等效于在API后添加<code>/_create</code>。</li>
<li><code>timeout</code>：等待主分片可用的超时时长，默认为<code>1m</code>（1分）。</li>
</ul>
<h5 id="批量提交文档索引操作"><a class="header" href="#批量提交文档索引操作">批量提交文档索引操作</a></h5>
<p>将文档索引操作数据放在HTTP请求主体中。每条操作数据需要包含操作说明和可选的文档数据，并以换行结束。</p>
<pre><code class="language-json">// PUT logs-my_app-default/_bulk?_source=false
{ &quot;create&quot;: { } }    // action and meta data   =&gt; [PUT]
{ &quot;@timestamp&quot;: &quot;2099-05-07T16:24:32.000Z&quot;, &quot;event&quot;: { &quot;original&quot;: &quot;192.0.2.242 - - [07/May/2020:16:24:32 -0500] \&quot;GET /images/hm_nbg.jpg HTTP/1.0\&quot; 304 0&quot; } } // data
{ &quot;index&quot;: { &quot;_id&quot;:&quot;1&quot;, &quot;_type&quot;: &quot;_doc&quot;} } // =&gt; {POST}
{ &quot;@timestamp&quot;: &quot;2099-05-08T16:25:42.000Z&quot;, &quot;event&quot;: { &quot;original&quot;: &quot;192.0.2.255 - - [08/May/2099:16:25:42 +0000] \&quot;GET /favicon.ico HTTP/1.0\&quot; 200 3638&quot; } }
// new line
</code></pre>
<p>操作方式包括：<code>create</code>， <code>index</code>，<code>update</code>，<code>delete</code>（无数据行）。由于数据以<code>\n</code>区分记录，因此要确保JSON文件不能格式化换行缩进。如果数据量较大，也可指定传输的文件。</p>
<pre><code class="language-shell">curl -H &quot;Content-Type: application/json&quot; -XPOST &quot;localhost:9200/bank/_bulk?pretty&amp;refresh&quot; --data-binary &quot;@accounts.json&quot;
</code></pre>
<p>如果未指定目标索引，则需要在<code>action</code>数据中指定<code>&quot;_index&quot;</code>参数：</p>
<pre><code class="language-json">// PUT _bulk  
{ &quot;create&quot; : { &quot;_index&quot; : &quot;test&quot;, &quot;_id&quot; : &quot;3&quot; } }
{ &quot;field1&quot; : &quot;value3&quot; }
</code></pre>
<h6 id="请求参数"><a class="header" href="#请求参数">请求参数</a></h6>
<ul>
<li><code>_source</code>是否返回提交的数据，或要返回的数据字段。</li>
</ul>
<p>参考：https://www.elastic.co/guide/en/elasticsearch/reference/7.10/getting-started-index.html。</p>
<h3 id="数据流-1"><a class="header" href="#数据流-1">数据流</a></h3>
<p>数据流适用于日志、事件、指标等自动生成数据。一个数据流由一个或多个后台索引组成。</p>
<p>数据流需要一个匹配的<a href="%E6%95%B0%E6%8D%AE%E5%BA%93/Elasticsearch.html#%E7%B4%A2%E5%BC%95%E6%A8%A1%E6%9D%BF">索引模板</a>。</p>
<blockquote>
<p><em>Every document indexed to a data stream must contain a <code>@timestamp</code> field, mapped as a <a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.14/date.html"><code>date</code></a> or <a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.14/date_nanos.html"><code>date_nanos</code></a> field type.</em></p>
</blockquote>
<h4 id="filebeat"><a class="header" href="#filebeat">Filebeat</a></h4>
<p><code>/var/lib/filebeat/registry</code>存储了文件读取记录，进行重复测试时需要删除该目录。</p>
<pre><code class="language-yml">filebeat.inputs:
- type: log
  paths:
    - /path/to/file/logstash-tutorial.log 
output.logstash:
  hosts: [&quot;localhost:5044&quot;]
</code></pre>
<h4 id="kafka"><a class="header" href="#kafka">Kafka</a></h4>
<blockquote>
<p>The Logstash Kafka consumer handles group management and uses the default offset management strategy using Kafka topics.</p>
<p>Logstash instances by default form a single logical group to subscribe to Kafka topics Each Logstash Kafka consumer can run multiple threads to increase read throughput. </p>
</blockquote>
<p><a href="https://cloud.tencent.com/developer/article/1362320">当Elasticsearch遇见Kafka--Logstash kafka input插件 - 云+社区 - 腾讯云 (tencent.com)</a></p>
<pre><code class="language-json">input {
   kafka {
     bootstrap_servers=&gt;&quot;kafka_server:9092&quot;
     topics=&gt;[&quot;kafka_es_test&quot;]
     group_id=&gt;&quot;logstash&quot;
     client_id=&gt;&quot;logstash&quot;
     auto_offset_resetedit=&gt;&quot;latest&quot;
     consumer_threads=&gt;N_PARTITIONS
     decorate_events=&gt;&quot;basic&quot;|&quot;extended&quot;    // 添加Kafka元数据 =&gt;@metadata
     security_protocol=&gt;&quot;PLAINTEXT&quot;
     topics_pattern=&gt;&quot;kafka*&quot;
     add_field=&gt;{     }
     codec=&gt;&quot;plain&quot;
     enable_metric=&gt;true  // 记录插件的性能日志
     id=&gt;&quot;plugin_id&quot;      // 插件ID
     tags=&gt;[&quot;TAG_a&quot;, &quot;TAG_b&quot;]
     type=&gt;&quot;log_type&quot;
   }
}
filter {
   mutate { 
      add_field =&gt; { &quot;[@metadata][target_index]&quot; =&gt; &quot;prod-%{+YYYY.MM.dd}&quot; } 
   }
}
output {
   elasticsearch {
       hosts =&gt; [ &quot;localhost:9200&quot; ]
       index =&gt; &quot;logstash_kafka_test&quot;
       index =&gt; &quot;%{[some_field][sub_field]}-%{+YYYY.MM.dd}&quot; // 动态生成索引名
       index =&gt; &quot;%{[@metadata][target_index]}&quot;              // 使用添加的元数据作为索引名
       id=&gt;&quot;plugin_id&quot;
       enable_metric=&gt;true  // 记录插件的性能日志
  }
  elasticsearch { // 数据流
     hosts =&gt; [ &quot;localhost:9200&quot; ]
     data_stream =&gt; &quot;true&quot;
     data_stream_type =&gt; &quot;metrics&quot;
     data_stream_dataset =&gt; &quot;foo&quot;
     data_stream_namespace =&gt; &quot;bar&quot;
     ilm_rollover_alias =&gt; &quot;custom&quot;
     ilm_pattern =&gt; &quot;000001&quot;
     ilm_policy =&gt; &quot;custom_policy&quot;
  }
}
</code></pre>
<blockquote>
<p>元数据：</p>
<p><code>[@metadata][kafka][topic]</code>
<code>[@metadata][kafka][offset]</code>
<code>[@metadata][kafka][timestamp]</code></p>
</blockquote>
<h2 id="查询文档数据"><a class="header" href="#查询文档数据">查询文档数据</a></h2>
<h3 id="query-dsl"><a class="header" href="#query-dsl">Query DSL</a></h3>
<p>使用索引名称<code>index</code>可<a href="%E6%95%B0%E6%8D%AE%E5%BA%93/Elasticsearch.html#REST-API">查询</a>该索引中的文档<code>doc</code>内容<sup class="footnote-reference"><a href="#search">1</a></sup>。</p>
<pre><code class="language-shell">POST http://hostip:9200/index_name[/&lt;doc_type&gt;]/_search # *
POST http://hostip:9200/index1,index2,.../_search       # &quot;,&quot; =&gt; &quot;%2C&quot;
</code></pre>
<blockquote>
<p><code>*</code>：由于<code>doc_type</code>属性已弃用（<code>7.x</code>），查询时可不用指定。</p>
</blockquote>
<ul>
<li><code>index</code>：索引名支持通配符<code>*</code>，使用<code>*</code>或<code>_all</code>查询所有索引。</li>
</ul>
<h4 id="查询参数"><a class="header" href="#查询参数">查询参数</a></h4>
<p>结构简单的查询参数可通过URL参数设置，所有参数均可通过HTTP请求体字段设置，<a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.2/search-search.html#search-search-api-query-params">URL参数优先级高于请求体字段</a>。请求体使用JSON对象可表示复杂的序列或字典对象参数。</p>
<pre><code class="language-json">// POST http://hostname:9200/index_name/_search
{
  &quot;query&quot;: {&lt;query_specifications&gt;},
  &quot;sort&quot;: sort_specs,
  &quot;from&quot;: 10,  // default=0
  &quot;size&quot;: 10,  // default=10
  &quot;_source&quot;: [&quot;account_number&quot;, &quot;firstname&quot;]
}
</code></pre>
<ul>
<li><code>query</code>：DSL查询语句声明，包括[单项查询]( #Term-level queries)、[复合查询]( #Compound queries)等。</li>
<li><code>allow_no_indices=true</code>：如果为<code>false</code>，目标索引==存在任何==缺失或关闭则返回错误；</li>
<li><code>_source/_source_include/_source_exclude</code>：是否要在返回结果中包含文档的字段数据，以及需要包含/排除的字段（支持字段名模糊匹配）。</li>
<li><code>size=10</code>：返回文档数量。</li>
<li><code>from</code>：指定返回记录偏移；<em><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/paginate-search-results.html#search-after">Avoid using from and size to page too deeply or request too many results at once</a>. By default, you cannot use</em> <code>from</code> <em>and</em> <code>size</code> <em>to page through more than 10,000 hits.</em> ==<code>from+size&lt;=10000</code>==：<a href="https://www.elastic.co/guide/en/elasticsearch/reference/5.1/search-request-search-after.html">search requests take heap memory and time proportional</a> to <code>from + size</code>. </li>
<li><code>timeout</code>：等待每个分片响应的超时时长。</li>
<li><code>version=false</code>：返回文档的版本信息。</li>
</ul>
<h5 id="生成字段"><a class="header" href="#生成字段">生成字段</a></h5>
<p>通过脚本计算生成新的字段（也可使用<a href="%E6%95%B0%E6%8D%AE%E5%BA%93/Elasticsearch.html#%E6%9F%A5%E8%AF%A2%E6%97%B6%E6%98%A0%E5%B0%84">查询时映射</a>计算新的字段）；</p>
<pre><code class="language-json">&quot;script_fields&quot;: {
   &quot;field_name&quot;: {
       &quot;script&quot;: {
         &quot;lang&quot;: &quot;painless&quot;,  // the script language, default to &quot;painless&quot;
         &quot;source&quot;: &quot;field1 * field2&quot;
}}}
</code></pre>
<blockquote>
<p><strong>字符串拼接</strong>脚本：默认禁用文本字段计算，可使用<code>keyword</code>运算。</p>
<pre><code class="language-json">doc['firstname.keyword'].value + ' ' + doc['lastname.keyword'].value
</code></pre>
<p>使用<code>keyword</code>得到的结果带“<code>[]</code>”，使用<code>.value</code>获取其字符串值。</p>
</blockquote>
<h4 id="查询视图"><a class="header" href="#查询视图">查询视图</a></h4>
<p>搜索请求默认获取当前可用的最新数据，使用查询视图可保证每次查询访问一致的数据。</p>
<h5 id="分页视图"><a class="header" href="#分页视图">分页视图</a></h5>
<ul>
<li>
<p><code>scroll=1m</code>：分页搜索上下文的保存时长。由于后续请求会刷新上下文的保存时长，因此该值的设置只要大于一批数据处理的时长即可。</p>
<p>查询结果返回<code>_scroll_id</code>（每次查询后返回的值可能会发生变化，应使用最新值），后续查询使用<code>_scroll_id</code>继续获取数据。</p>
<p>每次调用<code>scroll</code>API返回下一批数据直到获取所有查询结果（即返回查询结果为空）；如果查询语句包含聚合查询，仅第一次响应包含聚合查询结果。</p>
<pre><code class="language-json">// GET  /my-index-000001/_search    -&gt; _scroll_id
{
    &quot;scroll&quot;: &quot;1m&quot;
}
// POST /_search/scroll
{
    &quot;scroll&quot; : &quot;1m&quot;,   // 后续请求将更新分页上下文的保存时长*
    &quot;scroll_id&quot;: _scroll_id
}
</code></pre>
<blockquote>
<p><code>*</code>：如果后续请求未指定<code>scroll</code>参数，后台将删除该搜索上下文。也可通过<a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.2/paginate-search-results.html#clear-scroll"><code>DELETE /_search/scroll</code>接口</a>删除搜索上下文以释放资源。</p>
<p>分页搜索的结果在首次请求搜索时已经确定，后续分页返回结果不受文档更新的影响。</p>
<p>We no longer recommend using the scroll API for deep pagination. If you need to preserve the index state while paging through more than 10,000 hits, use the search_after parameter with a point in time (<a href="%E6%95%B0%E6%8D%AE%E5%BA%93/Elasticsearch.html#PIT">PIT</a>).</p>
</blockquote>
</li>
</ul>
<h5 id="排序视图"><a class="header" href="#排序视图">排序视图</a></h5>
<ul>
<li>
<p><code>sort</code>：排序字段，命令行参数格式为<code>field1:asc,field:desc,...</code>；使用<code>sort</code>语句后，返回的结果包含<code>sort</code>字段，表示当前文档的排序字段的值。</p>
<pre><code class="language-json">{
    &quot;sort&quot;: [ 
        &quot;_doc&quot;,  // simplest with default order
        { &quot;account_number&quot;: &quot;asc&quot; },   //simple： asc|desc
        { &quot;post_date&quot; : {&quot;order&quot; : &quot;asc&quot;, &quot;format&quot;: &quot;yyyy-mm-dd&quot;}}, //complex
    ],
    &quot;from&quot;: 0  // 设置为0或-1
}
</code></pre>
</li>
<li>
<p><code>search_after</code>：分页返回排序查询结果。包含<code>sort</code>声明的查询返回文档<code>hits</code>每条记录中包含额外的<code>sort</code>字段，将该字段值设置为<code>search_after</code>参数的值以返回排序结果的下一页。</p>
</li>
</ul>
<h5 id="pit"><a class="header" href="#pit">PIT</a></h5>
<p>Point in time接口生成查询发起时的轻量级数据视图，从而保证在一段时间内使用查询接口可获取一致的数据而不受数据更新的影响。<code>[7.10+]</code></p>
<pre><code class="language-json">// POST /my-index-000001/_pit?keep_alive=1m  // create pit view -&gt; pit_id
// POST /_search // pit search not specify index name
{
    &quot;query&quot;: {},
    &quot;pit&quot;: { &quot;id&quot;: &quot;&lt;pit_id&gt;&quot;, &quot;keep_alive&quot;: &quot;1m&quot; }
}
// DELETE /_pit
{ &quot;id&quot; : pit_id }  // 完成搜索任务后删除视图释放资源
</code></pre>
<h5 id="分片查询"><a class="header" href="#分片查询">分片查询</a></h5>
<p>当查询大量文档时，可将其分片，并分别请求每个分片的查询结果。</p>
<pre><code class="language-json">// GET /_search
{
  &quot;slice&quot;: {
    &quot;id&quot;: 0,   // 当前分片                      
    &quot;max&quot;: 2   // 分片最大数量                   
  },
  &quot;query&quot;: {},
  &quot;pit&quot;: { &quot;id&quot;: &quot;&lt;pit_id&gt;&quot; }
}
</code></pre>
<h5 id="分页返回排序结果"><a class="header" href="#分页返回排序结果">分页返回排序结果</a></h5>
<p>如果查询语句包含排序参数声明，则返回结果包含更新的pit ID，同时返回的最后一条数据包含搜索分界编号：</p>
<pre><code class="language-json">{
  &quot;pit_id&quot; : &quot;&lt;updated_pit_id&gt;&quot;, 
  &quot;hits&quot; : {
    &quot;hits&quot; : [
      //... hitted documents
      {
        &quot;sort&quot; : [ &quot;2021-05-20T05:30:04.832Z&quot;, 4294967298 ]
      }
    ]
  }
}
</code></pre>
<p>基于上述返回信息，可查询排序结果的下一页数据（类似于排序视图）：</p>
<pre><code class="language-json">// GET /_search
{
  // query 和 sort 声明需要保持不变
  &quot;pit&quot;: { &quot;id&quot;:  &quot;&lt;updated_pit_id&gt;&quot;,  &quot;keep_alive&quot;: &quot;1m&quot; },
  &quot;search_after&quot;: [ &quot;2021-05-20T05:30:04.832Z&quot;, 4294967298 ],
  &quot;track_total_hits&quot;: false // speed up pagination.
}
</code></pre>
<h4 id="参数值的单位约定"><a class="header" href="#参数值的单位约定">参数值的单位约定</a></h4>
<div class="table-wrapper"><table><thead><tr><th><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.2/api-conventions.html#size-units">纯量</a></th><th><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.2/api-conventions.html#byte-units">字节</a></th><th><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.2/api-conventions.html#distance-units">长度</a></th><th><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.2/api-conventions.html#time-units">时间</a></th></tr></thead><tbody>
<tr><td></td><td><code>b</code>: bytes</td><td></td><td><code>nanos</code></td></tr>
<tr><td><code>k</code>: kilo</td><td><code>kb</code></td><td><code>nmi</code></td><td><code>micros</code></td></tr>
<tr><td><code>m</code>: mega</td><td><code>mb</code></td><td><code>mm</code></td><td><code>ms</code></td></tr>
<tr><td><code>g</code>: giga</td><td><code>gb</code></td><td><code>cm</code></td><td><code>s</code>: seconds</td></tr>
<tr><td><code>t</code>: tera</td><td><code>tb</code></td><td><code>m</code>: meters</td><td><code>m</code>: minutes</td></tr>
<tr><td><code>p</code>: peta</td><td><code>pb</code></td><td><code>km</code></td><td><code>h</code>: hours</td></tr>
<tr><td></td><td></td><td></td><td><code>d</code>: days</td></tr>
</tbody></table>
</div>
<h3 id="term-level-queries"><a class="header" href="#term-level-queries">Term-level queries</a></h3>
<blockquote>
<p><em>You can use term-level queries to find documents based on precise values in structured data. Examples of structured data include date ranges, IP addresses, prices, or product IDs.</em></p>
</blockquote>
<h4 id="查询文档属性"><a class="header" href="#查询文档属性">查询文档属性</a></h4>
<p><code>type</code> query
Returns documents of the specified type.</p>
<p><code>ids</code> query
Returns documents based on their document IDs.</p>
<h4 id="查询文档字段"><a class="header" href="#查询文档字段">查询文档字段</a></h4>
<h5 id="exists"><a class="header" href="#exists">exists</a></h5>
<p>返回索引中包含指定字段的文档。文档不含某个字段的原因包括：</p>
<ul>
<li>JSON文档字段的值为<code>null</code>或<code>[]</code>；</li>
<li>在映射模板中，该字段设置了<code>&quot;index&quot;: false</code>、该字段长度超过<code>ignore_above</code>或触发<code>ignore_malformed</code>（字段值格式不正确）；</li>
</ul>
<pre><code class="language-json">&quot;exists&quot;: {
   &quot;field&quot;: &quot;user&quot;
}
</code></pre>
<h5 id="term"><a class="header" href="#term">term</a></h5>
<p><code>term</code> query：Returns documents that contain an exact term in a provided field.</p>
<pre><code class="language-json">&quot;term&quot; : { &quot;tags&quot; : &quot;production&quot; }
</code></pre>
<p><code>terms</code> query: Returns documents that contain one or more exact terms in a provided field.</p>
<pre><code class="language-json">&quot;terms&quot; : { &quot;tags&quot; : [&quot;production&quot;, &quot;price&quot;] }
</code></pre>
<h5 id="range"><a class="header" href="#range">range</a></h5>
<p><code>range</code> query：返回给定区间的记录，区间可以为数值或时间。</p>
<pre><code class="language-json">&quot;range&quot;: {
  &quot;query_field&quot;: {
    &quot;gte&quot;: 10, &quot;lte&quot;: 20,
    &quot;format&quot;: &quot;yyyy-MM-dd&quot;
  }
}
</code></pre>
<blockquote>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping-date-format.html#built-in-date-formats">内置时间格式</a>。</p>
</blockquote>
<blockquote>
<p>IP地址类型匹配方式：支持<code>term</code>或<code>range</code>匹配方式：</p>
<pre><code class="language-json">&quot;term&quot; : { &quot;ip_addr&quot; : &quot;172.28.76.0/24&quot; }  // &quot;/24&quot;用于匹配子网
&quot;range&quot;: {
     &quot;ipaddr&quot;: {
       &quot;gt&quot;: &quot;10.0.1.3&quot;, &quot;lt&quot;: &quot;10.0.1.14&quot;}  // 用于匹配非完整子网
}
</code></pre>
</blockquote>
<h5 id="关键字匹配"><a class="header" href="#关键字匹配">关键字匹配</a></h5>
<p><code>prefix</code> 前缀：匹配一个字段的前缀。</p>
<p><code>wildcard</code>通配符：<code>*</code>匹配零或多个字符，<code>?</code>恰匹配一个字符。</p>
<p><code>regexp</code>正则表达式。模式必须与字段的值完整匹配（即默认包含起始和结束锚点<code>^...$</code>）。</p>
<pre><code class="language-json">&quot;regexp&quot;: { &quot;collect_time_hour&quot;: &quot;[0-9]{8}(18|19|20|21|22)&quot;} // 简写，仅提供字段与模式
&quot;regexp&quot;: { // 完整语法，提供额外选项
  &quot;collect_time_hour&quot;: {
     &quot;value&quot;: &quot;[0-9]{8}(18|19|20|21|22)&quot;,
     &quot;flags&quot;: &quot;ALL&quot;, // enables all optional regexp syntax.
     &quot;case_insensitve&quot;: false // 7.10.0起支持
  }
}
</code></pre>
<blockquote>
<p>Elasticsearch未使用Perl兼容正则表达式，非捕获组（<code>?:</code>）不能正常使用。</p>
<p><code>flags</code>为正则表达式语法可选项标识，用<code>|</code>连接一个或多个标识。其中包括：</p>
<ul>
<li><code>INTERVAL</code>：<code>&lt;001-200&gt;</code>用于匹配一个区间的数字（字符串）；</li>
<li><code>INTERSECTION</code>：启用<code>&amp;</code>运算符（交集），即一个字符串同时满足两个匹配模式；</li>
<li><code>COMPLEMENT</code>：启用<code>~</code>运算符（补集）；</li>
</ul>
</blockquote>
<p>使用<code>wildcard</code>或<code>regexp</code>时，应该避免起始位置为通配符或正则表达式的匹配模式，应该使用一个确定前缀以提高匹配效率。字段类型为<code>keyword</code>类型；如果字段为<code>text</code>类型，上述匹配方式无效，需要使用<code>match</code>查询。</p>
<h4 id="全文查询"><a class="header" href="#全文查询"><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/full-text-queries.html">全文查询</a></a></h4>
<p><code>match</code>：在文档所有内容中匹配一个或多个单词，计算匹配分数。</p>
<pre><code class="language-json">{
   &quot;match_all&quot;: {}, // 特殊匹配：匹配所有内容
   &quot;match&quot;: {
      &quot;message&quot;: {
         &quot;query&quot;: &quot;this is a test&quot;,
         &quot;operator&quot;: &quot;AND&quot;,   // AND | OR 匹配所有/任意单词
         &quot;minimum_should_match&quot;: 1
      }
   },
   &quot;match&quot;: { &quot;message&quot;: &quot;this is a test&quot; }
}
</code></pre>
<p><code>math_phrase</code>：匹配整个词组，语法类似<code>match</code>。</p>
<p><code>match_phrase_prefix</code>：模式中的最后一个单词可以仅前缀匹配。</p>
<p><code>fuzzy</code> query：<em>Returns documents that contain terms similar to the search term. Elasticsearch measures similarity, or fuzziness, using a Levenshtein edit distance.</em></p>
<h3 id="compound-queries"><a class="header" href="#compound-queries">Compound queries</a></h3>
<blockquote>
<p><em>Compound queries wrap other compound or leaf queries, either to combine their results and scores, to change their behaviour, or to switch from query to filter context.</em></p>
</blockquote>
<p><code>constant_score</code> query
<strong>A query which wraps a filter query, executing it in filter context</strong>. All matching documents are given the same “constant” <code>_score</code>.</p>
<pre><code class="language-json">&quot;query&quot;: {
  &quot;constant_score&quot;: {
    &quot;filter&quot;: {  // 仅能包含一个条件
      &quot;term&quot;: { &quot;user.id&quot;: &quot;kimchy&quot; }
}}}
</code></pre>
<p><code>filter</code>查询仅可包含一个查询条件，如果需要提供多个查询条件，则使用<code>bool</code>查询封装查询条件。</p>
<p><code>bool</code> query
The default query for combining multiple leaf or compound query clauses, as <code>must</code>, <code>should</code>, <code>must_not</code>, or <code>filter</code> clauses. T==he <code>must</code> and <code>should</code> clauses have their scores combined== — the more matching clauses, the better — while the <code>must_not</code> and <code>filter</code> clauses are executed in filter context.</p>
<pre><code class="language-json">&quot;query&quot;: {
  &quot;bool&quot; : {
    &quot;filter&quot;: { // 多个条件则为字典构成的序列
      &quot;term&quot; : { &quot;tags&quot; : &quot;production&quot; }
    },
    &quot;must_not&quot; : {
      &quot;range&quot; : { &quot;age&quot; : { &quot;gte&quot; : 10, &quot;lte&quot; : 20 } }
    },
    &quot;must&quot; : {
      &quot;term&quot; : { &quot;user.id&quot; : &quot;kimchy&quot; }
    },
    &quot;should&quot; : [
      { &quot;term&quot; : { &quot;tags&quot; : &quot;env1&quot; } },
      { &quot;term&quot; : { &quot;tags&quot; : &quot;deployed&quot; } }
    ],
    &quot;minimum_should_match&quot; : 1,
    &quot;boost&quot; : 1.0
}}
</code></pre>
<p><code>minimum_should_match</code>：指定<code>should</code>语句必须匹配的数量或百分比（而非仅依据相似性得分）。如果<code>bool</code>查询仅包含<code>should</code>，那么默认值为1，反之，默认值为0（可选条件）。</p>
<blockquote>
<p><code>should</code>为空时，<code>minimum_should_match</code>应该设置为0，否则无返回结果。</p>
</blockquote>
<p><code>boosting</code> query
Return documents which match a positive query, but reduce the score of documents which also match a negative query.
<code>dis_max</code> query
A query which accepts multiple queries, and returns any documents which match any of the query clauses. ==While the bool query combines the scores from all matching queries, the dis_max query uses the score of the single best-matching query clause==.
<code>function_score</code> query
Modify the scores returned by the main query with functions to take into account factors like popularity, recency, distance, or custom algorithms implemented with scripting.</p>
<h3 id="eql"><a class="header" href="#eql">EQL</a></h3>
<p><a href="https://eql.readthedocs.io/en/latest/query-guide/index.html">Event Query Language (EQL)</a> is a query language for event-based, time series data, such as logs.</p>
<blockquote>
<p><strong>We designed EQL for security use cases.</strong></p>
</blockquote>
<pre><code class="language-json">GET /my-index-000001/_eql/search
{
 &quot;query&quot;: &quot;&quot;&quot;
  sequence by process.pid with maxspan=1h
  [ process where process.name == &quot;regsvr32.exe&quot; ]
  [ file where stringContains(file.name, &quot;scrobj.dll&quot;) ]
  &quot;&quot;&quot; 
}
</code></pre>
<h3 id="sql"><a class="header" href="#sql">SQL</a></h3>
<p>Elasticsearch SQL allows SQL-like queries to be executed in real-time against Elasticsearch. One can think of Elasticsearch SQL as a <em>translator</em>, one that understands both SQL and Elasticsearch and makes it easy to read and process data in real-time, at scale by leveraging Elasticsearch capabilities.</p>
<pre><code class="language-json">//POST /_sql?format=txt  csv,json,yaml,...
{
  &quot;query&quot;: &quot;SELECT * FROM library WHERE release_date &lt; '2000-01-01'&quot;,
  &quot;fetch_size&quot;: 5,      // 分页查询
  &quot;columnar&quot;: false     // 按列返回数据
}
</code></pre>
<p>[Mapping concepts across SQL and Elasticsearch | Elasticsearch Guide <a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.14/_mapping_concepts_across_sql_and_elasticsearch.html">7.14] | Elastic</a></p>
<p>[Response Data Formats | Elasticsearch Guide <a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.14/sql-rest-format.html">7.14] | Elastic</a></p>
<h5 id="sql-cli"><a class="header" href="#sql-cli">SQL CLI</a></h5>
<pre><code class="language-shell">./bin/elasticsearch-sql-cli http[s]://some.server:9200
</code></pre>
<h2 id="聚合查询"><a class="header" href="#聚合查询">聚合查询</a></h2>
<p>根据文档查询结果进行聚合。聚合查询DSL基本语法：</p>
<pre><code class="language-json">{
    &quot;query&quot;: {},
    &quot;aggregations&quot; : {   // =&gt; &quot;aggs&quot;
        &quot;&lt;aggregation_name&gt;&quot; : {
            &quot;&lt;aggregation_type&gt;&quot; : {
                // &lt;aggregation_body&gt;
            },
            // [,&quot;meta&quot; : {  [&lt;meta_data_body&gt;] } ]?
            // [,&quot;aggregations&quot; : { [&lt;sub_aggregation&gt;]+ } ]?
        },
        &quot;&lt;aggregation_name_2&gt;&quot; : { }
    } 
}
</code></pre>
<p><code>aggregation_name</code>也作为返回结果的<code>key</code>。<code>aggs</code>是<code>aggregations</code>的别名。</p>
<p>聚合分为四类：<a href="%E6%95%B0%E6%8D%AE%E5%BA%93/Elasticsearch.html#%E7%BB%9F%E8%AE%A1%E8%81%9A%E5%90%88">Metric</a>、<a href="%E6%95%B0%E6%8D%AE%E5%BA%93/Elasticsearch.html#%E5%88%86%E7%BB%84%E8%81%9A%E5%90%88">Bucketing</a>、Matrix、[Pipeline](Pipeline Aggregations)。</p>
<h3 id="统计聚合"><a class="header" href="#统计聚合">统计聚合</a></h3>
<p><strong>Metric Aggregation</strong>：字段的统计特征计算。查询返回结果为字典，通常其中<code>value</code>字段为查询结果。</p>
<h5 id="averagemaxminsum-metrics"><a class="header" href="#averagemaxminsum-metrics">Average/Max/Min/Sum Metrics</a></h5>
<pre><code class="language-json">&quot;avg&quot;: {&quot;field&quot;: &quot;grade&quot; , &quot;missing&quot;: 10 } # aggregation_body
</code></pre>
<blockquote>
<p><code>missing</code>: 填充缺失值。</p>
</blockquote>
<h5 id="weighted-average"><a class="header" href="#weighted-average">Weighted Average</a></h5>
<pre><code class="language-json">&quot;weighted_avg&quot;: {
    &quot;value&quot; : {&quot;field&quot;: &quot;grade&quot;, &quot;missing&quot;: 10},
    &quot;weight&quot;: {&quot;field&quot;: &quot;weight&quot;, &quot;missing&quot;: 1}
} # aggregation_body
</code></pre>
<h5 id="percentile"><a class="header" href="#percentile">Percentile</a></h5>
<pre><code class="language-json">&quot;percentiles&quot;: { 
  &quot;field&quot;: &quot;load_time&quot;, 
	&quot;percents&quot;: [ 95, 99, 99.9 ],
  &quot;keyed&quot;: true 
}
</code></pre>
<blockquote>
<p>默认区间为<code>[ 1, 5, 25, 50, 75, 95, 99]</code>，使用<code>percent</code>指定区间。</p>
<p><code>keyed</code>：默认将百分比设置为返回值的键名，设为<code>false</code>则返回<code>key</code>和<code>value</code>分别表示百分比和对应的值。</p>
</blockquote>
<h6 id="boxplot-quantile"><a class="header" href="#boxplot-quantile">Boxplot (quantile)</a></h6>
<pre><code class="language-json">&quot;boxplot&quot;: { &quot;field&quot;: &quot;load_time&quot; }
</code></pre>
<p>返回结果包括：<code>min</code>、<code>q1</code>、<code>q2</code>、<code>q3</code>、<code>max</code>。</p>
<h6 id="median"><a class="header" href="#median">Median</a></h6>
<pre><code class="language-json">&quot;median_absolute_deviation&quot;: {&quot;field&quot;: &quot;rating&quot;} # 近似计算
</code></pre>
<h5 id="stats"><a class="header" href="#stats">Stats</a></h5>
<pre><code class="language-json">&quot;stats&quot;: { &quot;field&quot;: &quot;grade&quot; }
&quot;extended_stats&quot;: { &quot;field&quot;: &quot;grade&quot; }  # more statistic details
</code></pre>
<p><code>stats</code>返回结果包括：<code>min</code>、<code>max</code>、<code>sum</code>、<code>count</code>和<code>avg</code>等多个字段（不包括<code>value</code>字段）。</p>
<h5 id="string-stats"><a class="header" href="#string-stats">String Stats</a></h5>
<pre><code class="language-json">&quot;string_stats&quot;: { &quot;field&quot;: &quot;message.keyword&quot; }
</code></pre>
<h5 id="计数"><a class="header" href="#计数">计数</a></h5>
<pre><code class="language-json">&quot;cardinality&quot; : {&quot;field&quot;: &quot;type&quot;}     # 近似计算不重复值的数量
&quot;value_count&quot; : { &quot;field&quot; : &quot;type&quot; }  # 不去除重复
</code></pre>
<blockquote>
<p><code>value_count</code> <em>if a field has duplicates each value will be counted individually.</em></p>
</blockquote>
<h5 id="geo-boundscentroid"><a class="header" href="#geo-boundscentroid">Geo Bounds/Centroid</a></h5>
<p>计算坐标边界和中心。</p>
<h5 id="t-test"><a class="header" href="#t-test">T-Test</a></h5>
<p>检查一个字段是否符合学生<code>t</code>分布。</p>
<h5 id="top-metrics"><a class="header" href="#top-metrics">Top-Metrics</a></h5>
<pre><code class="language-json">&quot;top_metrics&quot;: {
  &quot;metrics&quot;: {&quot;field&quot;: &quot;m&quot;},
  &quot;sort&quot;: {&quot;s&quot;: &quot;desc&quot;},
  &quot;size&quot;: 3   
} # 返回按sort字段排序后位于顶部的记录的指定字段的值
</code></pre>
<p><code>metrics</code>可用数组指定返回多个字段。</p>
<h5 id="top-hits-aggregation"><a class="header" href="#top-hits-aggregation">Top Hits Aggregation</a></h5>
<p>https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-metrics-top-hits-aggregation.html</p>
<h3 id="分组聚合"><a class="header" href="#分组聚合">分组聚合</a></h3>
<p><em><strong>Buckets Aggregation</strong></em>：根据指定标准(criterion)对记录进行分组（bucket），并返回每一组包含的记录数(<code>doc_count</code>)。==Bucket聚合可以包含针对每个分组记录的子聚合==。</p>
<pre><code class="language-json">&quot;aggs&quot;:{
  &quot;bucket_agg_name&quot;:{
    &quot;bucket_agg_type&quot;:{&quot;param&quot;: &quot;value&quot;},
    &quot;aggs&quot;:{  // 子聚合查询
      &quot;sub_agg_name&quot;:{&quot;sub_agg_type&quot;:{&quot;param&quot;: &quot;value&quot;} },
}}}
</code></pre>
<p>==嵌套的聚合<code>sub_agg_type</code>可以是针对每个bucket的<a href="%E6%95%B0%E6%8D%AE%E5%BA%93/Elasticsearch.html#%E7%BB%9F%E8%AE%A1%E8%81%9A%E5%90%88">统计聚合</a>、<a href="%E6%95%B0%E6%8D%AE%E5%BA%93/Elasticsearch.html#%E5%88%86%E7%BB%84%E8%81%9A%E5%90%88">分组聚合</a>、或者针对整个聚合结果的[Parent管道聚合](#Parent Aggregation)==。</p>
<h5 id="range-1"><a class="header" href="#range-1">Range</a></h5>
<p>按给定区间分组；</p>
<h5 id="date-range"><a class="header" href="#date-range">Date Range</a></h5>
<p>按给定的日期区间分组（<code>from/to</code>）；</p>
<h5 id="terms"><a class="header" href="#terms">Terms</a></h5>
<pre><code class="language-json">&quot;terms&quot;: { 
  &quot;field&quot;: &quot;genre[.keyword]&quot;,   
  &quot;size&quot;: 1000,
  &quot;show_term_doc_count_error&quot;: true,
  &quot;order&quot;: { &quot;_count&quot;: &quot;asc&quot; }, 
  &quot;order&quot;: { &quot;playback_stats.max&quot;: &quot;desc&quot; }, 
  &quot;include&quot;: &quot;.*sport.*&quot;, 
  &quot;include&quot;: [ &quot;mazda&quot;, &quot;honda&quot; ],
  &quot;exclude&quot;: &quot;water_.*&quot;,
  &quot;exclude&quot;: [ &quot;rover&quot;, &quot;jensen&quot; ],
}
</code></pre>
<p><code>size</code>指定返回分组的数量（默认为10）。</p>
<p><code>order='_count'|'_key'|...</code>，可以==使用子<a href="%E6%95%B0%E6%8D%AE%E5%BA%93/Elasticsearch.html#%E7%BB%9F%E8%AE%A1%E8%81%9A%E5%90%88">统计聚合</a>返回的结果==进行排序。</p>
<p>首先计算<code>include</code>，再计算<code>exclude</code>，表达式可以是精确匹配或正则表达式。</p>
<blockquote>
<p><code>terms</code>仅支持根据单个字段进行分组，[Composite Aggregation](#Composite Aggregation)可使用多个字段进行分组，并支持分页返回结果。</p>
</blockquote>
<p><em>返回结果中的计数是近似值。</em></p>
<p>https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-bucket-terms-aggregation.html</p>
<blockquote>
<p>响应内容：</p>
<p><code>doc_count_error_upper_bound</code>：计数误差上界；</p>
<p><code>sum_other_doc_count</code>：响应结果中未包含的匹配内容计数；</p>
</blockquote>
<h5 id="直方图histogram"><a class="header" href="#直方图histogram">直方图（Histogram）</a></h5>
<p>按给定字段的值所在区间$[nT,(n+1)T)$对记录进行分组，聚合后的<code>bucket_key</code>的计算方式为<code>bucket_key = Math.floor((value-offset)/interval)*interval+offset</code>（<code>offset</code>为区间边界偏移量）。</p>
<pre><code class="language-json">&quot;histogram&quot;: { &quot;field&quot;: &quot;price&quot;,  &quot;interval&quot;: 50 }
</code></pre>
<blockquote>
<p>For range values，其覆盖区间上的所有分组都计算在内。</p>
</blockquote>
<p>对分组结果再进行[求和](#Average/Max/Min/Sum Metrics)等聚合运算，可以得到统计直方图。</p>
<h6 id="date-histogram"><a class="header" href="#date-histogram">Date Histogram</a></h6>
<pre><code class="language-json">&quot;date_histogram&quot;: {
  &quot;field&quot;: &quot;date&quot;,
  &quot;calendar_interval&quot;: &quot;month&quot;, 
  &quot;format&quot;: &quot;yyyy-MM-dd&quot;,
  &quot;time_zone&quot;: &quot;+08:00&quot;
}
</code></pre>
<p>支持的日历周期（<code>calendar_interval</code>）包括：<code>minute,1m</code>、<code>hour,1h</code>、<code>day,1d</code>、<code>week,1w</code>、<code>month,1M</code>、<code>quarter,1q</code>和<code>year,1y</code>。不支持支持区间取值为多个单位周期。</p>
<p>支持的固定周期（<code>fixed_interval</code>）包括：<code>ms</code>、<code>s</code>、<code>m</code>、<code>h</code>、<code>d</code>，最为单位与数字组合使用。</p>
<blockquote>
</blockquote>
<h5 id="filters-aggregation"><a class="header" href="#filters-aggregation">Filters Aggregation</a></h5>
<p>过滤聚合内容（也可在查询语句使用<code>filter</code>设定，此处可作为聚合的补充过滤条件，可用于<code>match</code>等方法过滤内容），返回一个分组：</p>
<pre><code class="language-json">&quot;filter&quot;: { &quot;term&quot;: { &quot;type&quot;: &quot;t-shirt&quot; } },
</code></pre>
<p>添加多个过滤条件，每个条件对应一个分组；如果<code>other_bucket=true</code>，则未被任何过滤条件匹配的记录将被分到一个额外分组中：</p>
<pre><code class="language-json">&quot;filters&quot;:{
  &quot;filters&quot;: { 
    &quot;error&quot;: {&quot;term&quot;: { &quot;body&quot;: &quot;error&quot; }},
    &quot;warning&quot;: {&quot;term&quot;: {&quot;body&quot;: &quot;warning&quot;}}
  },  
  &quot;other_bucket&quot;: true,
  &quot;other_bucket_key&quot;: &quot;other_messages&quot;
}
</code></pre>
<h4 id="复合分组聚合"><a class="header" href="#复合分组聚合">复合分组聚合</a></h4>
<p>多个层级的聚合。聚合语句内容：</p>
<pre><code class="language-json">&quot;genre_group&quot;:{ // genre + state
   &quot;terms&quot;: { 
      &quot;field&quot;: &quot;genre[.keyword]&quot; // ,...
   },
   &quot;aggs&quot;: {  // 针对genre_group得到的分组分别根据state进行再一次分组
      &quot;state_group&quot;:{
         &quot;terms&quot;: {
            &quot;field&quot;: &quot;state[.keyword]&quot;,
} } } }
</code></pre>
<blockquote>
<p><em>The composite aggregation is expensive.</em> </p>
</blockquote>
<p><code>composite</code>使用多个字段组合进行分组；支持分页返回分组结果（类似查询记录时的<code>scroll</code>）</p>
<pre><code class="language-json">&quot;composite_group&quot;:{ // genre + state
   &quot;composite&quot;: {   // R6.1
      &quot;sources&quot;: [
         { &quot;state&quot;: { 
            &quot;terms&quot;: { &quot;field&quot;: &quot;state.keyword&quot;, &quot;order&quot;: 'asc' }
         }},
         { &quot;gender&quot;: { &quot;terms&quot;: { &quot;field&quot;: &quot;gender.keyword&quot; } } }
      ],
      &quot;after&quot;: {},
      &quot;size&quot;: 10
}}
</code></pre>
<p>返回结果中包含<code>after_key</code>字段，并在后续查询中指定为<code>after</code>的值，可从上次返回结果后查询剩余内容（如果记录数多于<code>size</code>给定的值，则后续返回内容非空）。</p>
<blockquote>
<p><code>composite</code>仅支持根据分组字段进行排序，如果需要根据分组的计算结果（例如记录计数），则需要使用管道聚合（[<code>bucket_sort</code>](#Bucket Sort)）。</p>
<p>如果指定的字段值为序列，则<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-bucket-composite-aggregation.html#search-aggregations-bucket-composite-aggregation">序列每个元素会和其他分组字段进行组合</a>，形成多个分组。</p>
</blockquote>
<p><code>multi_terms</code>类似于<code>composite</code>，但不支持分页，可使用<code>order</code>定义<a href="%E6%95%B0%E6%8D%AE%E5%BA%93/Elasticsearch.html#%E5%88%86%E7%BB%84%E8%81%9A%E5%90%88">排序</a>。</p>
<pre><code class="language-json">&quot;multi_group&quot;:{     // genre + state
   &quot;multi_terms&quot;: { // R7.12
      &quot;terms&quot;: [
         { &quot;field&quot;: &quot;state&quot; },
         { &quot;field&quot;: &quot;gender&quot;}
      ],
      &quot;size&quot;: 10 // 返回分组数量
}}
</code></pre>
<h3 id="pipeline-aggregations"><a class="header" href="#pipeline-aggregations">Pipeline Aggregations</a></h3>
<p>管道聚合对其他聚合的输出进行统计运算。</p>
<p><code>bucket_path</code>语法：指定输入分组。</p>
<pre><code>PATH = [AGG_NAME&gt;]SUB_AGG_NAME[.METRIC];
</code></pre>
<blockquote>
<p><code>&quot;_count&quot; </code>是一个特殊的路径，用于表示记录计数。</p>
</blockquote>
<h4 id="sibling"><a class="header" href="#sibling">Sibling</a></h4>
<p><strong>Sibling</strong>：使用一个聚合的输出计算，并在生成一个新的聚合结果。==与分组聚合子聚合的区别==：与相关聚合在同一层级，而非在其内部。</p>
<p>使用相对路径：</p>
<pre><code class="language-json">&quot;aggs&quot;: {
  &quot;agg_name&quot;: { &quot;agg_type&quot;:{&quot;param&quot;: &quot;value&quot;} },
  &quot;sibling_agg_name&quot;: {
    &quot;sibling_pipe_agg_type&quot;: {
      &quot;buckets_path&quot;: &quot;AGG_NAME[&gt;SUB_AGG_NAME]&quot;
}}}
</code></pre>
<h5 id="avgmaxminsum"><a class="header" href="#avgmaxminsum">Avg/Max/Min/Sum</a></h5>
<pre><code class="language-json">&quot;max_bucket&quot;: {&quot;buckets_path&quot;: &quot;aggs_name&gt;sub_agg_name&quot;}
</code></pre>
<blockquote>
<p>与<a href="%E6%95%B0%E6%8D%AE%E5%BA%93/Elasticsearch.html#%E7%BB%9F%E8%AE%A1%E8%81%9A%E5%90%88">统计聚合</a>的对应类型区别，Pipeline聚合的类型名称带后缀<code>_bucket</code>。</p>
</blockquote>
<h5 id="percentile-bucket"><a class="header" href="#percentile-bucket">Percentile Bucket</a></h5>
<pre><code class="language-json">&quot;percentiles_bucket&quot;: { 
  &quot;buckets_path&quot;: path, &quot;percents&quot;: [], &quot;keyed&quot;: true
}
</code></pre>
<blockquote>
<p>查看<a href="%E6%95%B0%E6%8D%AE%E5%BA%93/Elasticsearch.html#Percentile">Percentile</a>。</p>
</blockquote>
<h4 id="parent-aggregation"><a class="header" href="#parent-aggregation">Parent Aggregation</a></h4>
<p><strong>Parent</strong>：位于父聚合（例如Buckets聚合）内部，根据父聚合的输出字段进行计算，并将结果添加到父聚合生成的buckets中或影响父聚合的返回结果（如<code>bucket_sort</code>）。</p>
<pre><code class="language-json">&quot;aggs&quot;: {
  &quot;agg_name&quot;: {
    &quot;agg_type&quot;: { &quot;param&quot;: &quot;value&quot; },
	  &quot;sub_agg_name&quot;: {
	    &quot;parent_pipe_agg_type&quot;: {
        &quot;buckets_path&quot;: &quot;the_sum&quot; ,
        &quot;param&quot;: &quot;value&quot;
}}}
</code></pre>
<p><strong>Sibling和Parent聚合类型的用法和使用位置</strong>：Sibling聚合类型应用于所有Buckets中的某个统计量，需要在一个聚合计算完成后才能使用其结果进行计算，因此需要置于Buckets聚合的同层级。==Parent管道聚合的计算结果是作用于父聚合的，因此位于父聚合内部，由父聚合调用执行==。</p>
<blockquote>
<p>Sibling置于Buckets聚合内部出错：<em>The first aggregation in buckets_path must be a multi-bucket aggregation for aggregation.</em></p>
<p>Parent置于Buckets聚合的同级出错：<em>XXX aggregation [xxx] must have a histogram, date_histogram or auto_date_histogram as parent but doesn't have a parent</em>。</p>
</blockquote>
<h5 id="moving-avg"><a class="header" href="#moving-avg">Moving Avg</a></h5>
<pre><code class="language-json">&quot;moving_avg&quot;: {
  &quot;buckets_path&quot;: &quot;the_sum&quot;,
  &quot;model&quot;: &quot;holt&quot;,
  &quot;window&quot;: 5,
  &quot;gap_policy&quot;: &quot;insert_zeros&quot;,
  &quot;settings&quot;: {&quot;alpha&quot;: 0.8}
}
</code></pre>
<h5 id="差分derivative"><a class="header" href="#差分derivative">差分（Derivative）</a></h5>
<pre><code class="language-json">&quot;derivative&quot;: { &quot;buckets_path&quot;: &quot;the_sum&quot; }
</code></pre>
<h5 id="cumsumcumcardinality"><a class="header" href="#cumsumcumcardinality">CumSum/CumCardinality</a></h5>
<pre><code class="language-json">&quot;cumulative_sum&quot;: {&quot;buckets_path&quot;: &quot;the_sum&quot;}
&quot;cumulative_cardinality&quot;: {&quot;buckets_path&quot;: &quot;my_cardinality_agg&quot;}
</code></pre>
<h5 id="bucket-sort"><a class="header" href="#bucket-sort">Bucket Sort</a></h5>
<p>使用父聚合的结果中的字段进行排序：</p>
<pre><code class="language-json">&quot;bucket_sort_name&quot;:{
  &quot;bucket_sort&quot;: {
    &quot;sort&quot;: [
      { &quot;sort_field_1&quot;: { &quot;order&quot;: &quot;asc&quot; } },   
      { &quot;sort_field_2&quot;: { &quot;order&quot;: &quot;desc&quot; } },
      &quot;sort_field_3&quot;
    ],
    &quot;from&quot;: 1,
    &quot;size&quot;: 3
}}
</code></pre>
<blockquote>
<p><code>bucket_sort</code>仅对当前返回页排序，如果bucket结果分页，则每一页单独排序。</p>
</blockquote>
<h2 id="备份和恢复-2"><a class="header" href="#备份和恢复-2">备份和恢复</a></h2>
<h3 id="快照"><a class="header" href="#快照">快照</a></h3>
<h4 id="创建快照仓库"><a class="header" href="#创建快照仓库">创建快照仓库</a></h4>
<pre><code class="language-shell">curl -XPOST http://hostname:9200/_snapshot/hdfs_backup -d \
{
  &quot;type&quot;: &quot;hdfs&quot;,
  &quot;settings&quot;: {
    &quot;uri&quot;: &quot;hdfs://namenode:9000/&quot;,
    &quot;path&quot;: &quot;backup/path&quot;   // 使用相对目录，在ES用户主目录下
  }
}
curl http://hostname:9200/_snapshot/hdfs_backup  # get repo info
curl -XDELETE /_snapshot/hdfs_backup # 删除快照仓库
</code></pre>
<blockquote>
<p>快照仓库名支持通配符<code>*</code>；如果仓库名未<code>_all</code>或未提供，则会返回所有快照仓库的信息。</p>
</blockquote>
<h5 id="使用hdfs作为快照仓库"><a class="header" href="#使用hdfs作为快照仓库">使用HDFS作为快照仓库</a></h5>
<p>安装插件<code>repository-hdfs</code>。</p>
<h5 id="验证仓库配置"><a class="header" href="#验证仓库配置">验证仓库配置</a></h5>
<p>如果创建备份仓库时未指定<code>?verify=false</code>参数，可以单独执行验证：</p>
<pre><code class="language-shell">curl http://hostname:9200/_snapshot/hdfs_backup/_verify # verifying
</code></pre>
<h4 id="创建快照"><a class="header" href="#创建快照">创建快照</a></h4>
<pre><code class="language-shell">curl -XPUT /_snapshot/hdfs_backup/snapshot_1?wait_for_completion=true -d 
{
  &quot;indices&quot;: &quot;index_1,index_2&quot;
}  # 指定索引名称过滤快照内容，支持通配符
</code></pre>
<p>快照是增量创建的，对比仓库中已有的索引文件，仅加入新建或修改过的文件到快照中。</p>
<p>集群同一时间只能运行一个快照进程。</p>
<h5 id="获取快照信息"><a class="header" href="#获取快照信息">获取快照信息</a></h5>
<pre><code class="language-shell">curl /_snapshot/hdfs_backup/snapshot_1
curl /_snapshot/hdfs_backup/snapshot_*,some_other_snapshot
curl /_snapshot/hdfs_backup/_all
curl /_snapshot/hdfs_backup/_current  # 正在执行的快照
curl /_snapshot/_status
curl /_snapshot/hdfs_backup/_status
curl /_snapshot/hdfs_backup/snapshot_1/_status
</code></pre>
<h5 id="删除快照"><a class="header" href="#删除快照">删除快照</a></h5>
<pre><code class="language-shell">curl -XDELETE /_snapshot/hdfs_backup/snapshot_1
</code></pre>
<p>删除快照将删除快照中未被其他快照引用的文件。删除正在执行的快照终止快照过程。</p>
<h4 id="恢复"><a class="header" href="#恢复">恢复</a></h4>
<pre><code class="language-shell">curl -XPOST /_snapshot/hdfs_backup/snapshot_1/_restore -d \
{
  &quot;indices&quot;: &quot;index_1,index_2&quot;,
  &quot;ignore_unavailable&quot;: true,
  &quot;include_global_state&quot;: true,
}
</code></pre>
<p>恢复时可指定索引设置覆盖快照中的设置。</p>
<h5 id="恢复到其他集群"><a class="header" href="#恢复到其他集群">恢复到其他集群</a></h5>
<p>快照数据未绑定到特定集群或集群名，因此可以恢复到其他集群（无须具有相同集群大小和拓扑）。</p>
<p><code>5.x=&gt;6.x</code>，<code>5.x/=&gt;7.x</code></p>
<h4 id="问题-5"><a class="header" href="#问题-5">问题</a></h4>
<p>HDFS访问权限：<code>java.security.AccessControlException: access denied (&quot;javax.security.auth.PrivateCredentialPermission&quot; &quot;org.apache.hadoop.security.Credentials&quot; &quot;read&quot;)</code>。</p>
<blockquote>
<p>修改插件的Java安全选项<code>$PLUGIN_PATH/repository-hdfs/plugin-security.policy</code>：</p>
<pre><code class="language-java">grant {
    permission javax.security.auth.PrivateCredentialPermission &quot;org.apache.hadoop.security.Credentials * \&quot;*\&quot;&quot;, &quot;read&quot;;
}
</code></pre>
</blockquote>
<p>在ES启动脚本<code>ES_HOME/bin/elasticsearch</code>中，为启动命令添加以下Java选项，并重启集群。</p>
<pre><code class="language-shell">-Djava.security.policy=ES_HOME/plugins/repository-hdfs/plugin-security.policy
</code></pre>
<h3 id="复制数据"><a class="header" href="#复制数据">复制数据</a></h3>
<pre><code class="language-shell">elasticsearch-dump \
  --input=http://source.es.com:9200/my_index \  # 源索引支持通配符
  --output=http://target.es.com:9200/my_index \
  --type=data \
  --limit 100 \     # 根据集群配置将单批读取数据量上调可加快读取速度
</code></pre>
<p><a href="https://github.com/elasticsearch-dump/elasticsearch-dump">elasticsearch-dump: Import and export tools for elasticsearch (github.com)</a></p>
<h2 id="python客户端"><a class="header" href="#python客户端">Python客户端</a></h2>
<p>底层接口<code>elasticsearch</code>：封装了Elasticsearch REST API，通过<code>Helper</code>类简化API调用<sup class="footnote-reference"><a href="#pycli">2</a></sup>。</p>
<blockquote>
<p>HTTP传输：客户端每个配置或探测到的节点建立一个持久连接（<code>ConnectionPool</code>），并追踪每个节点的状态。如果节点变为无响应，则其对应的连接将被设置一个超时区间，直到超时区间结束才重新检测该节点是否可用。默认，连接池中的节点随机排列，并通过轮询方式调用以实现负载均衡。</p>
</blockquote>
<p>高层接口<code>elasticsearch-dsl</code>：以Python风格提供搜索接口。</p>
<blockquote>
<p>使用Elasticsearch主版本号相同的Python客户端版本：<code>elasticsearch5</code>、<code>elasticsearch6</code>……<code>elasticsearch</code>总是与当前Elasticsearch最新稳定版本一致。</p>
</blockquote>
<h3 id="python-rest-api"><a class="header" href="#python-rest-api">Python REST API</a></h3>
<h4 id="创建客户端连接实例"><a class="header" href="#创建客户端连接实例">创建客户端连接实例</a></h4>
<pre><code class="language-shell">import elasticsearch5 as es
es_cli = es.Elaticsearch(
   hosts=[
      {'host': 'hostname'},
      {'host': 'ip_addr', 'port': 9200},
      '[http://user:secret@]host_addr:9200/path'
   ]
   # Transports参数[elasticsearch.transport.Transport]
   sniff_on_start=True,          # 自动探测集群节点
   sniff_on_connection_fail=True,
   sniffer_timeout=60,           # 自动探测的时间间隔*
   retry_on_timeout=False,       # 超时触发使用不同节点重试
   # Connection参数[Urllib3HttpConnection]**
   timeout=10,                   # 全局HTTP/TCP超时限制
   maxisize=10,                  # 限制客户端与每个ES节点建立连接数(多线程并发查询)
   # 
)
es_cli.info()   # 获取当前集群的基本信息
es_cli.ping()   # 探测集群是否可用
</code></pre>
<blockquote>
<p><code>*</code>：另一个参数<code>sniff_timeout</code>表示一次探测请求的超时时限（通常设置较小以尽可能快地探测集群所有节点）。</p>
<p><code>**</code>：HTTPS连接的相关参数：<code>use_ssl=False, verify_certs=True, ca_certs=None, client_cert=None, client_key=None</code>。</p>
</blockquote>
<h5 id="es客户端内置属性"><a class="header" href="#es客户端内置属性">ES客户端内置属性</a></h5>
<p>提供访问ES集群以及各类对象的代理，查看集群和数据的相关状态。</p>
<ul>
<li><code>cat</code>、<code>cluster</code>、<code>indices</code>、<code>ingest</code>、<code>nodes</code>、<code>snapshot</code>、<code>tasks</code>。</li>
</ul>
<h5 id="api全局参数8x版本弃用"><a class="header" href="#api全局参数8x版本弃用">API全局参数(8.x版本弃用)</a></h5>
<p><code>ignore=[400,404]</code>：出错时默认会抛出异常，如<code>TransportError</code>，通过该参数忽略某些错误。</p>
<p><code>request_timeout=1</code>：API请求超时限制（秒）。</p>
<blockquote>
<p>某些API包含的<code>timeout</code>参数限制其内部操作的超时时间，不能保证请求在指定时间后返回。</p>
</blockquote>
<h4 id="文档操作接口"><a class="header" href="#文档操作接口">文档操作接口</a></h4>
<h5 id="读取信息"><a class="header" href="#读取信息">读取信息</a></h5>
<pre><code class="language-python">es_cli.exists(index, doc_type, id)  # 查看文档是否存在*
es_cli.count(index,doc_type,body)
</code></pre>
<blockquote>
<p><code>*</code>：要查看索引是否存在，<a href="%E6%95%B0%E6%8D%AE%E5%BA%93/Elasticsearch.html#%E6%9F%A5%E7%9C%8B%E7%B4%A2%E5%BC%95%E6%8E%A5%E5%8F%A3">调用<code>cli.indices.exists()</code>方法</a>。</p>
</blockquote>
<h5 id="读取文档"><a class="header" href="#读取文档">读取文档</a></h5>
<pre><code class="language-python">es_cli.get(index, id, doc_type,...)        # 返回指定id的JSON文档
es_cli.mget(ids, index, doc_type,...)      # 返回指定id的多个JSON文档
es_cli.get_source(index, id, doc_type,...) # 返回指定索引文档的源文档
</code></pre>
<h5 id="搜索文档内容"><a class="header" href="#搜索文档内容">搜索文档内容</a></h5>
<pre><code class="language-python">es_cli.search(index, 
              doc_type=None, 
              body=dsl,   # JSON文本或字典对象
              _source,    # 是否返回_source字段
              _source_{include|exclude}, # 返回数据要包含/排除的文档字段
              from_=0,
              scroll='1000s', # 启用分页并指定分页存活时长
              size=10,        # 返回的数据量
              allow_no_indices=False, # 允许通配符匹配不到任何索引
              ignore_unavailable=True, # 忽略
              version=False,  # 是否返回文档的版本信息
             )
</code></pre>
<ul>
<li><code>_source</code>：<code>True/False</code>指定是否返回JSON文档的字段；也可指定字段列表返回指定的字段（等效于指定<code>_source=True,_source_include=fields</code>）；</li>
<li><code>default_operator</code>：<code>AND/OR(default)</code>，查询文本的默认连接运算符。</li>
<li><code>expand_wildcards</code>：通配符的匹配范围，默认为<code>open</code>，其他包括：<code>closed</code>、<code>none</code>、<code>all</code>。</li>
</ul>
<p>分页搜索：</p>
<pre><code class="language-python">es_cli.scroll(scroll_id, body=dsl, scroll='1000s')
es_cli.clear_scroll()
</code></pre>
<p>迭代读取：</p>
<pre><code class="language-python">from elasticsearch import helpers
helpers.scan(es_cli, query,scroll,preserve_order=False,clear_scroll=True) 
</code></pre>
<blockquote>
<p>搜索模板：</p>
<pre><code class="language-python">es_cli.search_template(...)
es_cli.get_template(id)
es_cli.put_template(id)
es_cli.delete_template(id)
es_cli.exist_template(name)
</code></pre>
<ul>
<li><code>id</code>：搜索模板ID。</li>
</ul>
</blockquote>
<h5 id="聚合搜索"><a class="header" href="#聚合搜索">聚合搜索</a></h5>
<p>在查询结构的查询语句<code>body</code>中，声明<code>aggregations/aggs</code>语句。</p>
<h5 id="创建文档接口"><a class="header" href="#创建文档接口">创建文档接口</a></h5>
<p>必须指定文档ID<code>id</code>（可以是整数或字符串形式，最终存储为文本），如果文档已存在，且未指定不同的<code>version</code>，会抛出<code>ConflictError</code>。</p>
<pre><code class="language-python">es_cli.create(index, doc_type, body, id=None, timeout,version...) # -&gt; 文档的基本信息
</code></pre>
<blockquote>
<p>创建的文档会经过一定的延迟才可被搜索。</p>
</blockquote>
<ul>
<li><code>doc_type</code>：文档类型。<code>5.x</code>必须指定文档类型，<code>7.x</code>为可选参数。</li>
<li><code>body</code>：文档数据；</li>
<li><code>id</code>：文档编号。如果未指定，则由ES自动生成。</li>
<li><code>timestamp</code>：文档显式指定时间戳；</li>
<li><code>ttl</code>：文档失效时间；</li>
<li><code>version</code>：显式指定文档版本号。</li>
</ul>
<p>更新文档：==不会覆盖原有文档，而是创建一个新的版本并更新版本号==。 </p>
<pre><code class="language-python">es_cli.update(...,_source,_source_include,_source_exclude,fields)
</code></pre>
<p>创建或更新文档：</p>
<pre><code class="language-shell">es_cli.index(index, doc_type, body, id, op_type='index',...) # -&gt; 文档的基本信息
</code></pre>
<ul>
<li><code>op_type</code>：<code>'index'</code>表示创建或更新，<code>create</code>仅在文档不存在的情况下创建文档。</li>
</ul>
<h5 id="批量写入操作"><a class="header" href="#批量写入操作">批量写入操作</a></h5>
<p>底层的<code>bulk()</code>API需要<a href="%E6%95%B0%E6%8D%AE%E5%BA%93/Elasticsearch.html#%E6%89%B9%E9%87%8F%E6%8F%90%E4%BA%A4%E6%96%87%E6%A1%A3%E7%B4%A2%E5%BC%95%E6%93%8D%E4%BD%9C">传递批量的文档文本</a>，不方便进行数据处理。<code>es.helpers</code>提供封装直接处理包含文档对象的序列。</p>
<pre><code class="language-shell">es_cli.bulk(
	body,  # action-data pair, separated by newline. 
    index, doc_type
)
helpers.bulk(es_cli,actions,stats_only=False,raise_on_error=True) #-&gt; (...)*
helpers.streaming_bulk(es_cli, actions,...) # bulk()封装streaming_bulk()
helpers.parallel_bulk(...)
</code></pre>
<blockquote>
<p><code>*</code>：<code>stats_only=True</code>：除返回写入成功的数量外，仅返回错误的统计数量；反之，返回错误的详细信息构成的列表。为了避免批量插入中途出现错误而终端批量操作，可令<code>raise_on_error=False</code>。</p>
</blockquote>
<p>批量对象序列的元素结构通常与<code>search()</code>的返回结构一致：</p>
<pre><code class="language-json">{
   '_index': 'index-name',
   '_type': 'doc',
   '_id': 42,
   '_source': {...}
}
</code></pre>
<p>如果输入数据字段中不包含<code>source</code>，则<code>helpers.bulk()</code>将从输入对象的字段中首先提取元数据字段，将剩余数据作为文档数据。可通过元数据<code>_op_type</code>指定操作类型，包括<code>index</code>(默认)、<code>create</code>、<code>delete</code>和<code>update</code>。</p>
<h5 id="删除文档"><a class="header" href="#删除文档">删除文档</a></h5>
<pre><code class="language-python">es_cli.delete(index, doc_type, id, timeout)
</code></pre>
<p>删除查询匹配的结果：</p>
<pre><code class="language-python">es_cli.delete_by_query(...)  # 接受search接口的参数
</code></pre>
<h4 id="索引管理接口"><a class="header" href="#索引管理接口">索引管理接口</a></h4>
<p>通过ES客户端实例<a href="%E6%95%B0%E6%8D%AE%E5%BA%93/Elasticsearch.html#ES%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%86%85%E7%BD%AE%E5%B1%9E%E6%80%A7">提供的索引的客户端代理</a><code>IndicesClient</code>提供的接口来管理索引。</p>
<h5 id="查看索引接口"><a class="header" href="#查看索引接口">查看索引接口</a></h5>
<p>索引汇总信息：</p>
<pre><code class="language-python">es_cli.cat.indices(index, format='json|yaml', health=None,s=None,v=False)
</code></pre>
<p><code>health</code>：<code>'green'|'yellow'|'red'</code>，按节点状态筛选；</p>
<p>索引详细信息：</p>
<pre><code class="language-python">es_cli.indices.exists(index, ignore_unavailable) # 索引是否存在
es_cli.indices.get(index)                        # 获取索引信息(alises,settings,mappings)
</code></pre>
<blockquote>
<p><code>index</code>：支持通配符。</p>
</blockquote>
<h5 id="创建索引接口"><a class="header" href="#创建索引接口">创建索引接口</a></h5>
<pre><code class="language-shell">es_cli.indices.create(index, body,...) # -&gt; 返回执行状态
</code></pre>
<p><code>body:dict</code>：索引的配置，包括<a href="%E6%95%B0%E6%8D%AE%E5%BA%93/Elasticsearch.html#%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95">设置(settings)和映射(mappings)</a>的JSON对象。</p>
<p>获取已有索引的这些配置：</p>
<pre><code class="language-python">es_cli.indices.get_mapping(fileds, index, doc_type,...)  # 获取索引的映射
es_cli.indices.get_settings(fileds, index, doc_type,...) # 获取索引的配置
es_cli.indices.get_field_mapping(fileds, index, doc_type,...)
</code></pre>
<blockquote>
<p>返回JSON对象以索引名为根节点。</p>
</blockquote>
<h5 id="开启或关闭索引接口"><a class="header" href="#开启或关闭索引接口">开启或关闭索引接口</a></h5>
<pre><code class="language-python">es_cli.indices.open(index, ingore_unavailable,...)
es_cli.indices.close(index, ingore_unavailable,...)
</code></pre>
<h5 id="删除索引接口"><a class="header" href="#删除索引接口">删除索引接口</a></h5>
<pre><code class="language-python">es_cli.indices.delete(index)
es_cli.indices.delete_alias(index, name)
</code></pre>
<h5 id="索引数据迁移"><a class="header" href="#索引数据迁移">索引数据迁移</a></h5>
<pre><code class="language-python">es_clit.reindex(body=dsl, )  # reindex all docs from one index to another
helpers.reindex(es_cli, src_index, tgt_index,...)
</code></pre>
<h4 id="模板管理接口"><a class="header" href="#模板管理接口">模板管理接口</a></h4>
<pre><code class="language-python">es_cli.cat.templates(
    name=pattern,      #*
    format='json',     # 以JSON/YAML格式输出,默认以纯文本表格输出
    h='name,template', # 要输出的列
    s='name,template', # 对输出按列排序
    v=True             # 显示表头
)  # 返回匹配的模板名称
es_cli.indices.exists_template(name='xxx') -&gt; bool
es_cli.indices.get_template(name='xxx') -&gt; Dict[str,dict]
es_cli.indices.put_template(name='xxx', body, create=False)  #**
es_cli.indices.delete_template(name='xxx')

</code></pre>
<blockquote>
<p><code>*</code>：<code>name</code>参数支持通配符。</p>
<p><code>**</code>：<code>create=False</code>支持替换已有模板。</p>
</blockquote>
<h2 id="opensearch"><a class="header" href="#opensearch">OpenSearch</a></h2>
<blockquote>
<p><strong>OpenSearch</strong> is <a href="https://aws.amazon.com/blogs/opensource/introducing-opensearch/">a community-driven, open source fork</a> of <a href="https://en.wikipedia.org/wiki/Elasticsearch">Elasticsearch</a> and <a href="https://en.wikipedia.org/wiki/Kibana">Kibana</a>.</p>
<p>OpenSearch is a community-driven, Apache 2.0-licensed open source search and analytics suite that makes it easy to ingest, search, visualize, and analyze data. Developers build with OpenSearch for use cases such as application search, log analytics, data observability, data ingestion, and more.</p>
<p>OpenSearch consists of a data store and search engine (OpenSearch), and a visualization and user interface (OpenSearch Dashboards). Users can extend the functionality of OpenSearch with a selection of plugins that enhance search, security, performance analysis, machine learning, and more.</p>
</blockquote>
<p><a href="https://opensearch.org/docs/latest/">Get started - OpenSearch documentation</a></p>
<h2 id="参考文献-14"><a class="header" href="#参考文献-14">参考文献</a></h2>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">3</sup>
<p><a href="https://elastic-stack.readthedocs.io/en/latest/index.html">Log Consolidation with ELK Stack — Log Consolidation with ELK Stack 1.2 documentation (elastic-stack.readthedocs.io)</a>
<sup class="footnote-reference"><a href="#search">1</a></sup>: <a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.2/search.html">Search APIs | Elasticsearch Guide 8.2 | Elastic</a>
<sup class="footnote-reference"><a href="#pycli">2</a></sup>:<a href="https://elasticsearch-py.readthedocs.io/en/5.5.1/index.html">Python Elasticsearch Client — Elasticsearch 5.5.1 documentation (elasticsearch-py.readthedocs.io)</a></p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="elastic-datasource"><a class="header" href="#elastic-datasource">Elastic Datasource</a></h1>
<h2 id="数据源-1"><a class="header" href="#数据源-1">数据源</a></h2>
<h3 id="beats"><a class="header" href="#beats">Beats</a></h3>
<img src="数据库/Elastic Datasource.assets/beats-platform.png" style="zoom: 67%;" />
<h4 id="filebeat-1"><a class="header" href="#filebeat-1">Filebeat<img src="数据库/Elastic Datasource.assets/icon-filebeat-32-color.svg" alt="icon" style="zoom:80%;float:right;" /></a></h4>
<h4 id="metricbeat"><a class="header" href="#metricbeat">Metricbeat<img src="数据库/Elastic Datasource.assets/icon-metricbeat-32-color.svg" alt="icon" style="zoom:80%; float:right;" /></a></h4>
<blockquote>
<p><em>Metricbeat is a lightweight way to send system and service statistics:</em></p>
<ul>
<li>system-level CPU usage, memory, file system, disk IO, and network IO statistics, as well as top-like statistics for every process running on your systems.</li>
<li>collect metrics from services like Apache, Jolokia, NGINX, MongoDB, MySQL, PostgreSQL, Prometheus, <a href="https://www.elastic.co/guide/en/beats/metricbeat/current/metricbeat-modules.html">and more</a>.</li>
</ul>
</blockquote>
<h4 id="packetbeat"><a class="header" href="#packetbeat">Packetbeat<img src="数据库/Elastic Datasource.assets/icon-packetbeat-32-color.svg" alt="icon" style="zoom:80%; float:right;" /></a></h4>
<p>![img](Elastic Datasource.assets/packetbeat-monitoring-steps3.svg)</p>
<h4 id="winlogbeat"><a class="header" href="#winlogbeat">Winlogbeat<img src="数据库/Elastic Datasource.assets/icon-winlogbeat-32-color.svg" alt="icon" style="zoom:80%;float:right" /></a></h4>
<h2 id="数据处理-1"><a class="header" href="#数据处理-1">数据处理</a></h2>
<h3 id="logstash"><a class="header" href="#logstash">Logstash</a></h3>
<img src="数据库/Elasticsearch.assets/basic_logstash_pipeline.png" alt="basic logstash pipeline" style="zoom:50%;" />
<p>Event ordering：https://www.elastic.co/guide/en/logstash/current/processing.html#event-ordering</p>
<h4 id="插件介绍"><a class="header" href="#插件介绍">插件介绍</a></h4>
<h5 id="inputs"><a class="header" href="#inputs">Inputs</a></h5>
<p><strong>file</strong>：reads from a file on the filesystem, much like the UNIX command <code>tail -0F</code></p>
<p><strong>syslog</strong>：listens on the well-known port 514 for syslog messages and parses according to the RFC3164 format；</p>
<p><a href="https://www.elastic.co/guide/en/logstash/current/input-plugins.html">……</a></p>
<h5 id="filters"><a class="header" href="#filters">Filters</a></h5>
<ul>
<li>
<p><strong>grok</strong>：parse and structure arbitrary text.</p>
</li>
<li>
<p><strong>mutate</strong>：rename, remove, replace, and modify fields in your events.</p>
</li>
<li>
<p><strong>geoip</strong></p>
</li>
<li>
<p><strong>date</strong>：==parses out a timestamp and uses it as the timestamp for the event (regardless of when you’re ingesting the log data).==</p>
</li>
<li>
<p><a href="https://www.elastic.co/guide/en/logstash/current/filter-plugins.html">……</a></p>
</li>
</ul>
<p><a href="https://www.elastic.co/guide/en/logstash/current/event-dependent-configuration.html">Accessing event data and fields in the configuration | Logstash Reference [7.15] | Elastic</a></p>
<p><a href="https://www.elastic.co/guide/en/logstash/current/config-examples.html">Logstash configuration examples | Logstash Reference [7.15] | Elastic</a></p>
<h5 id="outputs"><a class="header" href="#outputs">Outputs</a></h5>
<ul>
<li><strong>elasticsearch</strong></li>
<li><strong>file</strong></li>
<li><a href="https://www.elastic.co/guide/en/logstash/current/output-plugins.html">……</a></li>
</ul>
<h2 id="采集器管理"><a class="header" href="#采集器管理">采集器管理</a></h2>
<blockquote>
<p><em>Fleet provides a web-based UI in Kibana to add and manage integrations for popular services and platforms, as well as manage a fleet of Elastic Agents.</em></p>
</blockquote>
<h3 id="install-elastic-agent-fleet"><a class="header" href="#install-elastic-agent-fleet">Install Elastic Agent (Fleet)</a></h3>
<h4 id="设置fleet"><a class="header" href="#设置fleet">设置Fleet</a></h4>
<p>修改Elasticsearch和Kibana集群的URL。</p>
<p>使用集中管理需要创建一个具有创建API keys并写入<code>logs-*</code>和<code>metrics-*</code>索引权限的用户（使用超级用户登录Kibana后可自动创建）。</p>
<p><code>Fleet</code>作为服务运行于一个或多个Elast Agent上。</p>
<h4 id="下载安装"><a class="header" href="#下载安装">下载安装</a></h4>
<h5 id="ubuntu-3"><a class="header" href="#ubuntu-3">Ubuntu</a></h5>
<pre><code class="language-shell">curl -L -O https://artifacts.elastic.co/downloads/beats/elastic-agent/elastic-agent-&lt;version&gt;-amd64.deb
sudo dpkg -i elastic-agent-&lt;version&gt;-amd64.deb
sudo elastic-agent enroll -i &lt;kibana_url&gt; &lt;enrollment_token&gt; # 1,3
sudo systemctl enable elastic-agent
sudo systemctl start elastic-agent  # 2
</code></pre>
<blockquote>
<ol>
<li>
<p>没有<code>systemd</code>的系统（如WSL），使用<code>service</code>启动服务：</p>
<pre><code class="language-shell"> service elastic-agent start
</code></pre>
<p>由于登记为服务，因此代理会在系统重启时启动启动。</p>
</li>
<li>
<p><code>kibana_url</code>和<code>enrollment_token</code>可在代理添加页面找到。</p>
</li>
<li>
<p>安装目录位于<code>/opt/Elastic/Agent</code>。</p>
</li>
</ol>
</blockquote>
<h5 id="windows-5"><a class="header" href="#windows-5">Windows</a></h5>
<p>从解压目录执行安装命令：</p>
<pre><code class="language-powershell">.\elastic-agent.exe install -i -f \
	--kibana-url=&lt;kibana_url&gt; \
	--enrollment-token=&lt;token&gt;
</code></pre>
<blockquote>
<p>Download the Elastic Agent Windows zip file from the <a href="https://www.elastic.co/downloads/beats/elastic-agent">downloads page</a>.</p>
<p>安装目录位于：<code>C:\Program Files\Elastic\Agent</code>。</p>
</blockquote>
<h4 id="代理管理"><a class="header" href="#代理管理">代理管理</a></h4>
<p>需要将集群使用的证书（Kibana）添加到代理所在系统（生成证书时要在<a href="%E6%95%B0%E6%8D%AE%E5%BA%93/scripts/instances.yml">配置文件</a>中添加集群所使用的域名）。</p>
<blockquote>
<p>Windows需要将证书添加到<code>LocalMachine</code>目录下。</p>
</blockquote>
<p>从Fleet管理界面修改代理配置策略以及解除代理注册。</p>
<p>使用<code>elastic-agent enroll</code>命令重新注册到Fleet。</p>
<h3 id="install-elastic-agent-manually"><a class="header" href="#install-elastic-agent-manually">Install Elastic Agent （Manually）</a></h3>
<h4 id="配置文件-3"><a class="header" href="#配置文件-3">配置文件</a></h4>
<p>使用Fleet生成<a href="%E6%95%B0%E6%8D%AE%E5%BA%93/scripts/elastic-agent.yml">配置文件<code>elastic-agent.yml</code></a>，手动修改配置。</p>
<pre><code class="language-yaml">outputs:
  default:
    type: elasticsearch
    hosts:
      - 'http://localhost:9200'
    username: ES_USERNAME 
    password: ES_PASSWORD
</code></pre>
<h4 id="创建代理用户"><a class="header" href="#创建代理用户">创建代理用户</a></h4>
<pre><code class="language-http">POST /_security/role/standalone_agent
{
  &quot;cluster&quot;: [&quot;monitor&quot;],
  &quot;indices&quot;: [
    {
      &quot;names&quot;: [&quot;logs-*&quot;, &quot;metrics-*&quot;, &quot;events-*&quot;, &quot;.ds-logs-*&quot;, &quot;.ds-metrics-*&quot;, &quot;.ds-events-*&quot;],
      &quot;privileges&quot;: [&quot;write&quot;, &quot;create_index&quot;, &quot;indices:admin/auto_create&quot;]
    }
  ]
}
</code></pre>
<h4 id="安装-28"><a class="header" href="#安装-28">安装</a></h4>
<p>无需提供参数，安装程序将使用本地配置文件进行初始化。</p>
<h3 id="upgrade-elastic-agent"><a class="header" href="#upgrade-elastic-agent">Upgrade Elastic Agent</a></h3>
<pre><code class="language-shell">sudo elastic-agent upgrade &lt;version-number&gt;
</code></pre>
<h3 id="卸载-1"><a class="header" href="#卸载-1">卸载</a></h3>
<pre><code class="language-powershell">cd C:\Program Files\Elastic\Agent
.\elastic-agent.exe uninstall
</code></pre>
<h2 id="数据源-2"><a class="header" href="#数据源-2">数据源</a></h2>
<h3 id="elastic-endpoint-security"><a class="header" href="#elastic-endpoint-security">Elastic Endpoint Security</a></h3>
<h5 id="卸载-2"><a class="header" href="#卸载-2">卸载</a></h5>
<p>以管理员运行：</p>
<pre><code class="language-powershell">cd C:\Program Files\Elastic\Endpoint
.\elastic-endpoint.exe uninstall
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mongodb"><a class="header" href="#mongodb">Mongodb</a></h1>
<h2 id="安装-29"><a class="header" href="#安装-29">安装</a></h2>
<h3 id="单机配置"><a class="header" href="#单机配置">单机配置</a></h3>
<pre><code class="language-yml">storage:
  dbPath: /var/lib/mongo
net:
  port: 27017
  bindIp: 0.0.0.0
replication:
   replSetName: rs # 定义副本集的名称
</code></pre>
<p>启动服务：</p>
<pre><code class="language-shell">systemctl enable --now mongod
</code></pre>
<p>默认服务端口为：<code>TCP/27017</code>和<code>UNIX/tmp/mongodb-27017.sock</code>。默认监听地址为<code>127.0..0.1</code>，可改为<code>0.0.0.0</code>以监听所有地址。</p>
<h3 id="mongodb-shell"><a class="header" href="#mongodb-shell">MongoDB Shell</a></h3>
<blockquote>
<p><code>mongosh</code>：<em>a fully functional JavaScript and Node.js 14.x REPL environment.</em></p>
</blockquote>
<p>关键字为小写（大小写敏感）。</p>
<p><a href="https://docs.mongodb.com/manual/reference/sql-comparison/">SQL to MongoDB Mapping Chart — MongoDB Manual</a></p>
<h5 id="用户管理-6"><a class="header" href="#用户管理-6">用户管理</a></h5>
<pre><code class="language-typescript">use admin
db.createUser({   // =&gt; 创建用户
  user: 'root',
  pwd: '123456',
  roles:[{ role: 'root', db: 'admin' }]
})
db.getUser(&quot;root&quot;)
</code></pre>
<blockquote>
<p><code>db</code>是关键字，表示当前数据库；</p>
</blockquote>
<h5 id="常用命令-3"><a class="header" href="#常用命令-3">常用命令</a></h5>
<pre><code class="language-typescript">db.auth(&quot;root&quot;,&quot;123456&quot;)  // 如果启用授权验证，则在进入shell后需要提供用户凭据
db.stats()
db.adminCommand({getParameter:&quot;*&quot;})
db._adminCommand({getCmdLineOpts: 1})
</code></pre>
<h3 id="集群配置"><a class="header" href="#集群配置">集群配置</a></h3>
<p>在集群每个节点安装Mongodb服务。</p>
<h4 id="replica-set"><a class="header" href="#replica-set"><a href="https://docs.mongodb.com/manual/replication/">replica set</a></a></h4>
<p><em><strong>replica set</strong></em>包含一组维护相同数据集的<code>mongod</code>实例，提供冗余和高可靠性，提高读取速率。</p>
<img src="https://docs.mongodb.com/manual/images/replica-set-read-write-operations-primary.bakedsvg.svg" style="zoom: 67%;" />
<p>一个集群仅包含一个主节点。数据需要从主节点写入，次级节点根据主节点的操作记录修改本地数据以与主节点保持一致。节点之间通过发送心跳信息检测可用性。当主节点失效，次级节点将发起竞选以产生新的主节点。</p>
<h5 id="副本集配置"><a class="header" href="#副本集配置">副本集配置</a></h5>
<p>启动Mongo Shell，执行以下命令==将当前节点设置为主节点==。如果返回结果显示<code>ok=1</code>，则集群配置成功。</p>
<pre><code class="language-typescript">rs.initiate({
    &quot;_id&quot;: &quot;rs&quot;,
    &quot;members&quot;: [
        { &quot;_id&quot;: 1, &quot;host&quot;: &quot;172.17.218.11:27017&quot; },
        { &quot;_id&quot;: 2, &quot;host&quot;: &quot;172.17.218.12:27017&quot; },
        { &quot;_id&quot;: 3, &quot;host&quot;: &quot;172.17.218.13:27017&quot; }
    ]
})
</code></pre>
<blockquote>
<p>当节点配置使用replica set后，启动shell时会自动创建replica set管理对象<code>rs</code>，用于执行replica set得初始化和管理。</p>
</blockquote>
<p><a href="https://juejin.cn/post/6859163488200982542">MongoDB Replica Set副本集配置 - 掘金 (juejin.cn)</a></p>
<h5 id="验证集群"><a class="header" href="#验证集群">验证集群</a></h5>
<pre><code class="language-javascript">rs.status()  // 查看当前复制集的状态
// {  &quot;set&quot;: &quot;rs&quot;,  &quot;members&quot;: [...], &quot;ok&quot;: 1 }
rs.isMaster() // 返回当前节点是否为集群主节点得相关信息
</code></pre>
<h5 id="在线集群配置"><a class="header" href="#在线集群配置">在线集群配置</a></h5>
<pre><code class="language-javascript">conf = rs.conf() 
// 修改conf的属性
rs.reconfig(conf)
</code></pre>
<h4 id="sharded-cluster"><a class="header" href="#sharded-cluster">Sharded Cluster</a></h4>
<p><a href="https://docs.mongodb.com/manual/sharding/">Sharding — MongoDB Manual</a></p>
<h3 id="docker配置"><a class="header" href="#docker配置">docker配置</a></h3>
<h5 id="replica-set-1"><a class="header" href="#replica-set-1">replica set</a></h5>
<p><a href="https://gist.github.com/harveyconnor/518e088bad23a273cae6ba7fc4643549">MongoDB Replica Set / docker-compose / mongoose transaction with persistent volume (github.com)</a></p>
<h3 id="存储引擎"><a class="header" href="#存储引擎">存储引擎</a></h3>
<p><a href="https://docs.mongodb.com/manual/core/storage-engines/">Storage Engines — MongoDB Manual</a></p>
<h2 id="写入数据-1"><a class="header" href="#写入数据-1">写入数据</a></h2>
<h3 id="数据模型"><a class="header" href="#数据模型">数据模型</a></h3>
<p>同一个集合中的文档不需要具有相同的字段和数据类型；可以灵活更新文档的字段以及数据类型；</p>
<p>可以在创建文档集合时声明JSON Schema以限制数据操作。</p>
<pre><code class="language-typescript">db.createCollection(&quot;students&quot;, {
   validator: {
      $jsonSchema: {
         bsonType: &quot;object&quot;,
         required: [ &quot;name&quot;, &quot;year&quot;, &quot;major&quot;, &quot;address&quot; ],
         properties: {
            name: {
               bsonType: &quot;string&quot;,
               description: &quot;must be a string and is required&quot;
            },
            year: {
               bsonType: &quot;int&quot;,
               minimum: 2017,
               maximum: 3017,
               description: &quot;must be an integer in [ 2017, 3017 ] and is required&quot;
            },
            major: {
               enum: [ &quot;Math&quot;, &quot;English&quot;, &quot;Computer Science&quot;, &quot;History&quot;, null ],
               description: &quot;can only be one of the enum values and is required&quot;
            },
            //...
         }
      }
   }
}
</code></pre>
<p><a href="https://docs.mongodb.com/manual/reference/bson-types/">字段类型说明</a>。</p>
<h4 id="文档结构-1"><a class="header" href="#文档结构-1">文档结构</a></h4>
<p><img src="%E6%95%B0%E6%8D%AE%E5%BA%93/Mongodb.assets/image-20211230085728177.png" alt="image-20211230085728177" /></p>
<p><a href="https://docs.mongodb.com/manual/core/data-modeling-introduction/">Data Modeling Introduction — MongoDB Manual</a></p>
<h3 id="写入操作"><a class="header" href="#写入操作">写入操作</a></h3>
<h5 id="插入单个文档"><a class="header" href="#插入单个文档">插入单个文档</a></h5>
<pre><code class="language-typescript">db.collection.insertOne(
   { item: &quot;canvas&quot;, qty: 100, tags: [&quot;cotton&quot;], size: { h: 28, w: 35.5, uom: &quot;cm&quot; } }
)
</code></pre>
<h5 id="插入多个文档"><a class="header" href="#插入多个文档">插入多个文档</a></h5>
<pre><code class="language-typescript">db.collection.insertMany([
   { item: &quot;journal&quot;, qty: 25, tags: [&quot;blank&quot;, &quot;red&quot;], size: { h:14, w:21, uom:&quot;cm&quot; } },
   { item: &quot;mat&quot;, qty: 85, tags: [&quot;gray&quot;], size: { h:27.9, w:35.5, uom:&quot;cm&quot; } },
   { item: &quot;mousepad&quot;, qty: 25, tags: [&quot;gel&quot;, &quot;blue&quot;], size: { h:19, w:22.85, uom:&quot;cm&quot; } }
])
</code></pre>
<p>如果文档不包含<code>_id</code>字段（主键），则自动为文档添加<code>_id</code>字段：<code>{&quot;_id&quot;: ObjectId(&quot;value&quot;)}</code>。如果指定了<code>_id</code>，则需要保证<code>_id</code>唯一，否则会产生异常。</p>
<p>如果文档集合<code>collection</code>不存在，则自动创建集合；</p>
<p><a href="https://docs.mongodb.com/manual/reference/insert-methods/">Insert Methods — MongoDB Manual</a></p>
<h5 id="更新文档"><a class="header" href="#更新文档">更新文档</a></h5>
<pre><code class="language-typescript">db.inventory.updateOne(  // updateMany(), replaceOne()
   { item: &quot;paper&quot; },
   {
     $set: { &quot;size.uom&quot;: &quot;cm&quot;, status: &quot;P&quot; },
     $currentDate: { lastModified: true }
   }
)
</code></pre>
<h5 id="删除文档-1"><a class="header" href="#删除文档-1">删除文档</a></h5>
<pre><code class="language-typescript">db.collection.deleteMany(conditions)
db.collection.deleteOne( conditions )
</code></pre>
<p><code>conditions</code>为空字典，则删除集合的所有文档。</p>
<h5 id="批量写操作"><a class="header" href="#批量写操作">批量写操作</a></h5>
<p>一次执行多个写操作。</p>
<p><a href="https://docs.mongodb.com/manual/core/bulk-write-operations/">Bulk Write Operations — MongoDB Manual</a></p>
<h2 id="查询-1"><a class="header" href="#查询-1">查询</a></h2>
<pre><code class="language-javascript">show dbs
use &lt;db_name&gt;
show collections
show users  // users of current database
</code></pre>
<h5 id="等式查询"><a class="header" href="#等式查询">等式查询</a></h5>
<pre><code class="language-shell">db.inventory.find( {item:&quot;canvas&quot;} ) # =&gt; SELECT * FROM db.inventory WHERE item='canvas'
</code></pre>
<p><code>find()</code>的参数为查询条件构成的文档；如果字段为空，则返回所有文档。</p>
<p>字段值可以是嵌套的子文档值；或者指定子文档字段：<code>field.nestfield</code>。</p>
<p>数组字段查询：指定数组所有元素；<code>$all</code>运算符不限定数组元素顺序，指定单个元素查询数组字段是否包含该元素。</p>
<h5 id="指定查询条件"><a class="header" href="#指定查询条件">指定查询条件</a></h5>
<pre><code>{ &lt;field1&gt;: { &lt;operator1&gt;: &lt;value1&gt; }, ... }
</code></pre>
<p>比较运算符：<code>$in,$nin,$lt,$gt,$gte,$lte,$eq,$ne</code>；</p>
<p>逻辑运算符：默认情况下，查询条件文档字段之间为<code>AND</code>连接；使用<code>$or</code>构造<code>OR</code>连接</p>
<pre><code class="language-typescript">db.inventory.find( {
     status: &quot;A&quot;,
     $or: [ { qty: { $lt: 30 } }, { item: /^p/ } ]
})
</code></pre>
<p>逻辑运算符可以嵌套使用，构造复杂查询条件。</p>
<p><a href="https://docs.mongodb.com/manual/reference/operator/query/regex/#mongodb-query-op.-regex">正则表达式运算符</a>：<code>$regex</code>（MongDB使用PCRE）</p>
<pre><code class="language-typescript">{ &lt;field&gt;: { $regex: 'pattern', $options: '&lt;options&gt;' } }
{ &lt;field&gt;: /pattern/&lt;options&gt; }
</code></pre>
<h5 id="限定返回字段"><a class="header" href="#限定返回字段">限定返回字段</a></h5>
<pre><code class="language-typescript">db.collection.find(condition, projection)
</code></pre>
<p><code>projection</code>指定返回的字段（为指定该参数返回所有字段），要返回字段名对应的值为1；默认返回<code>_id</code>字段。如果仅包含值为<code>0</code>的字段声明，则返回除声明字段外的字段。</p>
<pre><code class="language-json">{ &quot;field1&quot;: 1, &quot;field2&quot;: 1, ..., &quot;_id&quot;: 0}
</code></pre>
<h2 id="python-api"><a class="header" href="#python-api">Python API</a></h2>
<p>Python API语法<code>pymongo</code>基本和Mongo Shell一致。</p>
<h5 id="连接-3"><a class="header" href="#连接-3">连接</a></h5>
<pre><code class="language-python">from pymongo import MongoClient
client = MongoClient(&quot;mongodb://root:passwd@server_name/db&quot;, authSource=&quot;admin&quot;)
</code></pre>
<h5 id="数据库信息"><a class="header" href="#数据库信息">数据库信息</a></h5>
<pre><code class="language-python">db = client.get_database(name=None) # =&gt; client['db_name'] =&gt; client.db_name
db.list_collections()               # -&gt; Iterator[collection]
db.list_collection_names()          # -&gt; List[str]
c = db.get_collection('collection') # =&gt; db['collection'] =&gt; db.collection
</code></pre>
<h5 id="写入"><a class="header" href="#写入">写入</a></h5>
<pre><code class="language-python">db.collection.insert(dict_item)
db.collection.insert_many([dict_item,...])
</code></pre>
<h5 id="查询-2"><a class="header" href="#查询-2">查询</a></h5>
<pre><code class="language-python">db.collection.find({...})       # -&gt; Iterator(dict)
db.collection.find_one({...})   # -&gt; dict
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="图数据分析"><a class="header" href="#图数据分析">图数据分析</a></h1>
<ul>
<li>
<p>图计算引擎：Apache Spark是一个横向扩展和以节点为中心的图计算引擎。</p>
<p>GraphFrames是 Spark 的一个图处理库，于 2016 年替代 GraphX，但是它与核心Spark是分离的。</p>
<p>Spark Graph项目是在Spark 3.0 版本中增加对DataFrame、Cypher 和基于DataFrame的算法的支持。</p>
</li>
<li>
<p>图数据库：Neo4j图平台是图数据库和算法中心式处理紧密集成的典范，针对图进行了优化。</p>
</li>
<li>
<p>兼用Spark和Neo4j进行图处理：将Spark用于大规模数据集的高层筛选与预处理以及数据集成，将Neo4j用于特定处理并且与基于图的应用集成。</p>
</li>
</ul>
<h2 id="spark-graph"><a class="header" href="#spark-graph">Spark Graph</a></h2>
<h2 id="dgraph"><a class="header" href="#dgraph">dgraph</a></h2>
<h3 id="安装-30"><a class="header" href="#安装-30">安装</a></h3>
<p>当前<a href="https://github.com/dgraph-io/dgraph/releases/tag/v21.03.2">稳定版本</a>为<code>21.03</code>。</p>
<pre><code class="language-shell">export DGRAPH_HOME=/opt/dgraph-21.03
export DGRAPH_DATA=$DGRAPH_HOME/data
export PATH=$DGRAPH_HOME/bin:$PATH
</code></pre>
<pre><code class="language-shell">.
├── bin
│   ├── badger
│   └── dgraph
└── data
</code></pre>
<h4 id="系统架构-1"><a class="header" href="#系统架构-1">系统架构</a></h4>
<p>运行Dgraph需至少包含以下类型节点：</p>
<ul>
<li>
<p><em><strong>Alpha</strong></em>：数据库节点，包括数据存储、访问、管理和节点管理功能。</p>
<p><a href="https://dgraph.io/docs/deploy/dgraph-alpha/">More about Dgraph Alpha - Deploy</a></p>
</li>
<li>
<p><em><strong>Zero</strong></em>：管理节点，管理集群中的节点，自动在数据库节点间进行数据移动。</p>
<p><a href="https://dgraph.io/docs/deploy/dgraph-zero/">More about Dgraph Zero - Deploy</a></p>
</li>
<li>
<p><em><strong>Ratel</strong></em>：UI服务，支持DQL。<a href="https://github.com/dgraph-io/ratel/releases/">Releases · dgraph-io/ratel (github.com)</a>。</p>
</li>
</ul>
<p>对于高可用集群，每类节点至少运行三个实例。</p>
<h4 id="配置-13"><a class="header" href="#配置-13">配置</a></h4>
<p><a href="https://dgraph.io/docs/deploy/config/">Configuration - Deploy (dgraph.io)</a></p>
<h4 id="运行-4"><a class="header" href="#运行-4">运行</a></h4>
<pre><code class="language-shell">dgraph zero --my=IPADDR:5080
# Setting up grpc listener at: 0.0.0.0:5080
# Setting up http listener at: 0.0.0.0:6080
for ((i=0; i&lt;N; ++i)); do
  dgraph alpha --my=IPADDR:7080 --zero=ZERO_IPADDR:5080 -o $i
done
# Sending member request to Zero: addr:&quot;192.168.0.200:7080&quot;
# Worker listening at address: [::]:7080
# Bringing up GraphQL HTTP admin API at 0.0.0.0:8080/admin
# gRPC server started.  Listening on port 9080
# CONN: Connecting to 192.168.0.200:5080
# Connected to group zero. Assigned group: 1
# Raft Id after connection to Zero: 0x1
# Node ID: 0x1 with GroupID: 1
# RaftContext: id:1 group:1 addr:&quot;192.168.0.200:7080&quot;
ratel -addr &quot;http://192.168.0.200:8080&quot;
# Listening on :8000...
</code></pre>
<h3 id="graphql"><a class="header" href="#graphql">GraphQL</a></h3>
<h5 id="graphql-api接口"><a class="header" href="#graphql-api接口">GraphQL API接口</a></h5>
<ul>
<li>
<p>查询接口：<code>http://alpha-server:8080/graphql</code>（启动服务时日志输出该地址）；</p>
<pre><code class="language-shell">curl -XPOST alpha-server:8080/graphql \
     --header='Content-Type: application/graphql'
     --data '...' --data-binary '@file-path.graphql'
curl -XGET alpha-server:8080/graphql?query={...}&amp;variables={...}&amp;operation=...
</code></pre>
<p><code>POST</code>请求的数据格式支持<code>graphql</code>或<code>json</code>，JSON格式的请求数据支持添加变量等（也可通过客户端分别添加查询语句和变量）。</p>
<pre><code class="language-shell">curl -XPOST alpha-server:8080/graphql \
     --header='Content-Type: application/json'
     --data-binary '@file-path.json'
</code></pre>
<pre><code class="language-json">{
   &quot;oeprationName&quot;: &quot;query_name&quot;,
   &quot;query&quot;: &quot;query query_name(......&quot;,
   &quot;variable&quot;: {
      &quot;filter&quot;: { ... }
   }
}
</code></pre>
</li>
<li>
<p>管理接口：<code>http://alpha-server:8080/admin</code>（启动服务时日志输出该地址）；</p>
<pre><code class="language-shell">curl -XPOST alpha-server:8080/admin/schema \
     --header='Content-Type: application/graphql'
     --data '...' --data-binary '@schema.graphql'
</code></pre>
</li>
</ul>
<blockquote>
<p>返回信息：</p>
<pre><code class="language-json">{&quot;data&quot;:{&quot;code&quot;:&quot;Success&quot;,&quot;message&quot;:&quot;Done&quot;}}
</code></pre>
<p>管理接口授权：</p>
<p><code>&quot;resolving updateGQLSchema failed because unauthorized ip address</code>。</p>
</blockquote>
<p><strong>响应数据</strong>：总是以<code>JSON</code>格式返回，成功返回<code>data</code>和<code>extensions</code>字段，错误返回<code>errors</code>字段。</p>
<h5 id="客户端"><a class="header" href="#客户端">客户端</a></h5>
<ul>
<li><a href="https://github.com/graphql/graphql-playground">graphql/graphql-playground: 🎮 GraphQL IDE for better development workflows (GraphQL Subscriptions, interactive docs &amp; collaboration) (github.com)</a></li>
<li></li>
</ul>
<h4 id="schema"><a class="header" href="#schema">schema</a></h4>
<p>schema定义了实体类型及其包含的属性。</p>
<pre><code class="language-go">type Product {
    productID: ID!
    name: String @search(by: [term])
    reviews: [Review] @hasInverse(field: about)
}

type Customer {
    username: String! @id @search(by: [hash, regexp])
    reviews: [Review] @hasInverse(field: by)
}

type Review@withSubscription { //*
    id: ID!
    about: Product!
    by: Customer!
    comment: String @search(by: [fulltext]) 
    rating: Int @search
}

</code></pre>
<blockquote>
<p><code>*</code>：<code>@withSubscription</code>：启用<a href="%E6%95%B0%E6%8D%AE%E5%BA%93/GraphDatabase.html#GraphQL%E8%AE%A2%E9%98%85">订阅</a>，当数据更新时，自动向订阅者发送查询结果。</p>
</blockquote>
<p><code>String! @id</code>：使用该字段作为ID；<code>ID!</code>自动生成ID。</p>
<p>Dgraph将根据定义的schema自动生成访问数据的API，包括：</p>
<pre><code class="language-go">getType(postID: ID!): Type
queryType(filter: TypeFilter, order: TypeOrder, first: Int, offset: Int): [Type]
aggregateType(filter: PostFilter): TypeAggregateResult
</code></pre>
<p>注释：</p>
<ul>
<li><code>&quot;&quot;&quot;xxx&quot;&quot;&quot;</code>内容在生成API时会被自动处理为文档。</li>
<li><code>#...</code>会被自动忽略。</li>
</ul>
<h5 id="修改schema"><a class="header" href="#修改schema">修改Schema</a></h5>
<p>通过API提交schema数据可更新schema。</p>
<h5 id="数据类型-8"><a class="header" href="#数据类型-8">数据类型</a></h5>
<ul>
<li>
<p><code>Int</code>、<code>Float</code>、<code>String</code>、<code>Boolean</code>、<code>Int64</code>、<code>DateTime</code>(RFC3389)。</p>
</li>
<li>
<p>序列类似于无序集合不会存储重复值：<code>[Type]</code>。</p>
</li>
<li>
<p><code>ID</code>：不能声明<code>ID</code>类型的序列，每个模式只能有一个<code>ID</code>类型字段。</p>
</li>
<li>
<p>枚举</p>
<pre><code class="language-go">enum Tag {
   GraphQL
   Database
   Question
}
type Post {
   tags: [Tag!]!
}
</code></pre>
</li>
<li>
<p>自定义模式也可作为其他模式的类型声明。</p>
</li>
</ul>
<h5 id="接口-5"><a class="header" href="#接口-5">接口</a></h5>
<pre><code class="language-python">interface Post {
    id: ID!
    text: String
    datePublished: DateTime
}

type Question implements Post {
    title: String!
}
type Comment implements Post {
    commentsOn: Post!
}
</code></pre>
<p>在类型中重复声明接口中已有字段不会产生重复字段，必须具有相同类型及是否为空的条件，其他属性则继承接口声明。</p>
<h5 id="联合"><a class="header" href="#联合">联合</a></h5>
<pre><code>union HomeMember = Dog | Parrot | Human
</code></pre>
<h4 id="搜索和过滤"><a class="header" href="#搜索和过滤">搜索和过滤</a></h4>
<p><code>@search</code>命令控制如何构建索引以及搜索类型，基于字段的搜索类型决定在查询时如何设置过滤表达式。</p>
<h5 id="数值类型搜索"><a class="header" href="#数值类型搜索">数值类型搜索</a></h5>
<p><code>Int</code>、<code>Float</code>和<code>DateTime</code>类型，<code>DateTime</code>类型支持设置时间查询单位（包括<code>year</code>、<code>month</code>、<code>data</code>、<code>hour</code>）。过滤条件支持的运算符包括<code>lt</code>、<code>le</code>、<code>eq</code>、<code>in</code>、<code>between</code>、<code>ge</code>、<code>gt</code>。</p>
<pre><code class="language-shell">numLikes: Int @search
querySomeType(filter: { numLikes: { gt: 50 }})
datePublished: DateTime @search(by: [day])
</code></pre>
<h5 id="boolean类型搜索"><a class="header" href="#boolean类型搜索">Boolean类型搜索</a></h5>
<pre><code class="language-go">isPublished: Boolean @search  // schema
filter: { isPublished: true } // filter
</code></pre>
<h5 id="字符串类型搜索"><a class="header" href="#字符串类型搜索">字符串类型搜索</a></h5>
<p>搜索类型及其对应的过滤运算符：</p>
<ul>
<li>
<p><code>hash</code>：<code>eq</code>、<code>in</code>。</p>
</li>
<li>
<p><code>exact</code>：过滤运算符与数值类型相同。</p>
</li>
<li>
<p><code>regexp</code>：<code>regexp</code>。正则表达式必须置于<code>/.../</code>之间（类似于<code>sed</code>语法）。</p>
<pre><code class="language-go">filter: { name: { regexp: &quot;/.*iggy.*/&quot; } }
</code></pre>
</li>
<li>
<p><code>term</code>：<code>allofterms</code>、<code>anyofterms</code>。</p>
</li>
<li>
<p><code>fulltext</code>：<code>alloftext</code>、<code>anyoftext</code>。</p>
</li>
</ul>
<p>支持为字符串类型字段设置多个搜索类型。</p>
<h5 id="枚举类型搜索"><a class="header" href="#枚举类型搜索">枚举类型搜索</a></h5>
<p>搜索类型及其对应的过滤运算符：</p>
<ul>
<li>未指定/<code>hash</code>：<code>eq</code>、<code>in</code>。</li>
<li><code>exact</code>：过滤运算符与数值类型相同。</li>
<li><code>regexp</code>：<code>regexp</code>。</li>
</ul>
<h5 id="地理位置"><a class="header" href="#地理位置"><a href="https://dgraph.io/docs/v21.03/graphql/schema/search/#geolocation">地理位置</a></a></h5>
<h4 id="mutation"><a class="header" href="#mutation">mutation</a></h4>
<pre><code class="language-go">mutation {
  addProduct(input: [ // add an object of Product* 
    { name: &quot;GraphQL on Dgraph&quot;},
    { name: &quot;Dgraph: The GraphQL Database&quot;}
  ]) {
    product {
      productID
      name
    }
  }
  addCustomer(input: [{ username: &quot;Michael&quot;}]) {
    customer {
      username
    }
  }
}
</code></pre>
<blockquote>
<p><code>*</code>操作名称基于对象类型和操作类型自动识别。</p>
</blockquote>
<pre><code class="language-shell">curl -XPOST localhost:8080/graphql \
     --header &quot;Content-Type: application/graphql&quot;  \
     --data-binary '@add-data.graphql'
</code></pre>
<h4 id="query"><a class="header" href="#query">query</a></h4>
<pre><code class="language-go">query [query_name($variable: Type)]{ 
  queryType(filter: { comment: {alloftext: &quot;easy to install&quot;}}) {
    // 指定查询字段及其引用对象的字段
    comment
    by {
      username
    }
    about {
      name
    }
    posts(filter: {title: {allofterms: &quot;GraphQL&quot;}}) {
      title
      text
      datePublished
    }
  }
}
</code></pre>
<blockquote>
<p>序列字段也可指定过滤表达式。</p>
</blockquote>
<p>查询操作可选择设置名称和传入的变量，如果仅包含一个查询操作，也可省略外侧<code>query</code>关键字。</p>
<p>一个查询语句块中，可包含多个查询命令，返回结果将包含每个查询命令的返回数据。</p>
<p>可以在查询请求中声明多个查询操作，但一次请求只能指定一个操作（通过<code>operationName</code>指定）。</p>
<p><a href="https://dgraph.io/docs/v21.03/graphql/queries/search-filtering/">Search and Filtering - GraphQL (dgraph.io)</a></p>
<h5 id="graphql订阅"><a class="header" href="#graphql订阅">GraphQL订阅</a></h5>
<p><a href="https://dgraph.io/docs/v21.03/graphql/subscriptions/">GraphQL Subscriptions - GraphQL (dgraph.io)</a></p>
<h3 id="dql"><a class="header" href="#dql">DQL</a></h3>
<blockquote>
<p><em>GraphQL couldn’t support many of the features required from a language meant to interact with Graph data, and we felt some of the features were unnecessary and complicated. So, we’ve created a simplified and feature rich version of GraphQL.</em></p>
</blockquote>
<h4 id="修改schema-1"><a class="header" href="#修改schema-1">修改schema</a></h4>
<pre><code class="language-shell">curl -XPOST &quot;localhost:8080/alter&quot; --silent --data-binary @alter_schema.dql 
</code></pre>
<blockquote>
<p><em>RDF文件中的数据字段名称最好添加前缀，避免与数据库中已有字段发生冲突。</em></p>
</blockquote>
<p>schema的定义语法与GraphQL一致。</p>
<blockquote>
<p>可通过Ratel UI修改Schema。</p>
</blockquote>
<h4 id="mutate"><a class="header" href="#mutate">mutate</a></h4>
<pre><code class="language-shell">curl -XPOST &quot;localhost:8080/mutate?commitNow=true&quot; --silent \
     --header  &quot;Content-Type: application/rdf&quot; \
     --data-binary &quot;@starwars.rdf&quot;  
     # --data 'rdf_data'
</code></pre>
<blockquote>
<p>使用<code>--data-binary</code>将保留数据中的换行，因此数据中的注释内容能得到正确处理。</p>
</blockquote>
<h4 id="查询-3"><a class="header" href="#查询-3">查询</a></h4>
<pre><code class="language-shell">curl -XPOST &quot;localhost:8080/query&quot; --silent \
  --header &quot;Content-Type: application/dql&quot; \
  --data $'{ me(func: has(starring)){ name }}'
</code></pre>
<h5 id="查询语法"><a class="header" href="#查询语法">查询语法</a></h5>
<pre><code class="language-javascript">{
  me(func: allofterms(name, &quot;Star Wars&quot;), orderasc: release_date) 
    @filter(ge(release_date, &quot;1980&quot;)) {
    name
    release_date
    revenue
    running_time
    director {
     name
    }
    starring (orderasc: name) {
     name
    }
  }
}
</code></pre>
<p>返回数据为JSON（与GraphQL一致），<code>data</code>字段为图数据对象（与查询语句中命令对象<code>me</code>一致）。图数据包含节点（JSON对象）序列，==每个节点可嵌套JSON对象数组以表示与其他节点的关系==。</p>
<p><a href="https://dgraph.io/docs/v21.03/clients/python/">Python - Clients (dgraph.io)</a>：<em>Official Dgraph client implementation for Python (<code>Python&gt;=v2.7 and &gt;=v3.5</code>), using gRPC.</em></p>
<p><a href="https://dgraph.io/docs/v21.03/query-language/">Dgraph Query Language - Query language (dgraph.io)</a></p>
<h3 id="图数据"><a class="header" href="#图数据">图数据</a></h3>
<h4 id="链路"><a class="header" href="#链路">链路</a></h4>
<p>在类型声明中包含指向另一类型的成员（标量或向量），则在实际声明数据时即创建了链路。</p>
<pre><code class="language-shell">type Author {
	posts: [Post] @hasInverse(field: author)
}
type Post {
	author: Author
}
</code></pre>
<h5 id="双向链路"><a class="header" href="#双向链路">双向链路</a></h5>
<p>为了保证数据实例<code>A-&gt;B</code>有反向链路<code>B-&gt;A</code>，需要在<code>A</code>的外链成员声明后添加<code>hasInverse</code>属性。该属性保证在添加节点时自动更新其外链节点的属性。</p>
<h2 id="neo4j"><a class="header" href="#neo4j">Neo4j</a></h2>
<p><img src="%E6%95%B0%E6%8D%AE%E5%BA%93/GraphDatabase.assets/image-20220901174750558.png" alt="image-20220901174750558" /></p>
<p><a href="https://neo4j.com/developer/neo4j-desktop/#what-is-neo4j-desktop">Neo4j Desktop User Interface Guide - Developer Guides</a></p>
<p><a href="https://neo4j.com/labs/apoc/">Awesome Procedures On Cypher (APOC) - Neo4j Labs</a></p>
<p><a href="https://neo4j.com/developer/graph-apps/">Graph Applications Overview - Developer Guides (neo4j.com)</a></p>
<p><img src="%E6%95%B0%E6%8D%AE%E5%BA%93/Graph%20Database.assets/graph-data-science.svg" alt="graph data science" /></p>
<p><a href="https://neo4j.com/developer/graph-data-science/">Neo4j Graph Data Science - Developer Guides</a></p>
<h3 id="安装运行-1"><a class="header" href="#安装运行-1">安装运行</a></h3>
<h4 id="安装-31"><a class="header" href="#安装-31">安装</a></h4>
<h5 id="yum"><a class="header" href="#yum">yum</a></h5>
<pre><code class="language-shell">rpm --import https://debian.neo4j.com/neotechnology.gpg.key
cat &lt;&lt;EOF&gt;  /etc/yum.repos.d/neo4j.repo
[neo4j]
name=Neo4j Yum Repo
baseurl=http://yum.neo4j.com/stable
enabled=1
gpgcheck=1
EOF
sudo yum install neo4j   # 社区版
</code></pre>
<h5 id="apt-2"><a class="header" href="#apt-2">apt</a></h5>
<pre><code class="language-shell">wget -O - https://debian.neo4j.com/neotechnology.gpg.key | sudo apt-key add -
echo 'deb https://debian.neo4j.com stable 4.0' | sudo tee /etc/apt/sources.list.d/neo4j.list
sudo apt-get update
</code></pre>
<h5 id="手动安装"><a class="header" href="#手动安装">手动安装</a></h5>
<pre><code class="language-shell">tar -xf neo4j-community-4.4.11-unix.tar.gz -C /opt
ln -sf /opt/neo4j-community-4.4.11 /usr/local/neo4j
export NEO4J_HOME=/usr/local/neo4j
</code></pre>
<h5 id="neo4j图算法库"><a class="header" href="#neo4j图算法库">Neo4j图算法库</a></h5>
<p>Neo4j图算法库（<em><strong>Graph Data Science</strong></em>）以插件形式与数据库一起安装，提供了一个可通过Cypher查询语言执行的用户自定义程序集。提供了支持图分析和机器学习工作流程的并行算法。这些算法在基于任务的并行计算框架上执行，并针对 Neo4j平台进行了优化。</p>
<h5 id="apoc库"><a class="header" href="#apoc库">APOC库</a></h5>
<p>APOC（<em><strong>Awesome Procedures on Cypher</strong></em>）库用于辅助完成数据集成、数据转换和模型重构等常规任务。</p>
<h5 id="cypher-shell"><a class="header" href="#cypher-shell">Cypher Shell</a></h5>
<h4 id="配置-14"><a class="header" href="#配置-14">配置</a></h4>
<p>Java版本：</p>
<blockquote>
<p><em>Please use Oracle(R) Java(TM) 11, OpenJDK(TM) 11 to run Neo4j.</em></p>
</blockquote>
<pre><code class="language-shell"># Paths of directories in the installation.
dbms.default_database=neo4j
dbms.default_listen_addres=0.0.0.0 # 默认监听localhost
dbms.directories.data=/home/neo4j/data  #*
dbms.directories.logs=/home/neo4j/logs  
dbms.directories.run=/home/neo4j/run
dbms.directories.transaction.logs.root=/home/neo4j/data/transactions  
dbms.directories.import=/home/neo4j/import  # CSV文件加载源目录,注释取消限制
</code></pre>
<blockquote>
<p><code>*</code>：如果运行Neo4j的用户没有Neo4j安装目录的写权限，应该修改输出目录，或修改默认目录的写权限。</p>
</blockquote>
<pre><code class="language-sh">NEO4J_ULIMIT_NOFILE=60000
# edit: /etc/security/limits.conf
neo4j   soft    nofile  40000
neo4j   hard    nofile  40000
</code></pre>
<h4 id="运行-5"><a class="header" href="#运行-5">运行</a></h4>
<h5 id="docker-3"><a class="header" href="#docker-3">docker</a></h5>
<pre><code class="language-shell">docker run \
    --publish=7474:7474 --publish=7687:7687 \
    --volume=$HOME/neo4j/data:/data \
    neo4j:4.3.5-community
</code></pre>
<h5 id="命令行-1"><a class="header" href="#命令行-1">命令行</a></h5>
<p>将<code>neo4j</code>添加到<code>PATH</code>。</p>
<pre><code class="language-shell">neo4j console
neo4j start    # background
</code></pre>
<p>以<code>systemd</code>服务启动。</p>
<pre><code class="language-ini">[Unit]
After=network.target
[Service]
Environment=PATH=/usr/local/openjdk11jre/bin:/usr/local/sbin:/usr/local/bin:/usr/bin:/usr/bin
Environment=NEO4J_ULIMIT_NOFILE=60000
Type=forking
ExecStart=/usr/local/neo4j/bin/neo4j start
PIDFile=/home/neo4j/run/neo4j.pid
User=neo4j
Group=neo4j
[Install]
WantedBy=multi-user.target
</code></pre>
<h4 id="交互命令"><a class="header" href="#交互命令">交互命令</a></h4>
<p>访问数据库界面：<code>http://localhost:7474</code>，默认用户名和密码为<code>neo4j:neo4j</code>，首次登录需要修改密码。</p>
<blockquote>
<p>API端口：<code>7687</code>。</p>
</blockquote>
<p>数据库和服务器信息：</p>
<pre><code class="language-shell">:server user list/add  # 列出/添加用户
:server disconnect
:dbs      # 列出服务器中的数据库
:sysinfo  # 列出数据存储信息
</code></pre>
<h5 id="选择数据库"><a class="header" href="#选择数据库">选择数据库</a></h5>
<pre><code class="language-shell">:use graph_db_name  # &quot;:&quot;是命令的一部分
</code></pre>
<h3 id="查询语言"><a class="header" href="#查询语言">查询语言</a></h3>
<p>变量赋值表达式</p>
<pre><code class="language-cypher">WITH &quot;URL&quot; AS base 
WITH base + &quot;transport-nodes.csv&quot; AS uri
</code></pre>
<p>多条命令使用<code>;</code>分隔。</p>
<h4 id="数据库管理-1"><a class="header" href="#数据库管理-1">数据库管理</a></h4>
<pre><code class="language-cypher">SHOW DATABASES;
SHOW DATABASE name;
</code></pre>
<p>企业版支持数据库创建和修改。</p>
<pre><code class="language-cypher">CREATE DATABASE name [IF NOT EXISTS];  
ALTER DATABASE name [IF EXISTS] SET ACCESS {READ ONLY | READ WRITE};
START/STOP DATABASE name;
DROP DATABASE name [IF EXISTS] [{DUMP|DESTROY} [DATA]];
</code></pre>
<h4 id="定义数据-2"><a class="header" href="#定义数据-2">定义数据</a></h4>
<p>Neo4j的底层数据类型为<em>Directed Multi-Graph</em>，节点间可存在多条边（多种连接关系）。<strong>通过节点/边的标签或者其包含的属性，可获取其中的一个或多个子图用于分析</strong>。</p>
<h5 id="添加节点"><a class="header" href="#添加节点">添加节点</a></h5>
<p>节点类似于关系型数据库表的一条记录，但没有严格的Schema约束，即每个节点可任意添加属性。具有相同标签的节点通常具有相同的属性。</p>
<pre><code class="language-cypher">CREATE (n:NodeLabel {name:'John'}) RETURN n;
CREATE (:NodeLabel {name:'John'});
CREATE ({name:'John'});
</code></pre>
<p>创建节点的可选参数（可在后续通过查询节点并补充设置相应参数）：</p>
<ul>
<li>
<p><code>n</code>为当前创建节点的引用标识，用于当前语句后续命令引用（例如<code>RETURN n</code>）。</p>
</li>
<li>
<p><code>NodeLabel</code>：<strong>标签/类型</strong>（可选，后续可设置），如果省略了节点标识，则需要保留<code>:NodeLabel</code>；</p>
</li>
<li>
<p>属性列表：字典类型<code>{...}</code>（可选，后续可设置）。</p>
<blockquote>
<p><code>CREATE()</code>如果不接受任何属性，则会创建一个空节点。</p>
</blockquote>
</li>
</ul>
<p><strong>注意</strong>：添加节点时无法检查是否有重复节点，用户需要首先根据属性查询是否有匹配节点再决定是否创建新节点。</p>
<h5 id="添加或更新节点"><a class="header" href="#添加或更新节点">添加或更新节点</a></h5>
<pre><code class="language-cypher">MERGE (n:Person {name: $value}) // 节点属性用于匹配已有节点
ON CREATE SET n.created = timestamp() // 根据匹配结果：创建或更新节点属性
ON MATCH SET
  n.counter = coalesce(n.counter, 0) + 1,
  n.accessTime = timestamp()
</code></pre>
<h5 id="在节点间添加关系"><a class="header" href="#在节点间添加关系">在节点间添加关系</a></h5>
<p>仅在已有节点间添加关系，需要<strong>注意设置过滤条件，否则匹配的点对可能非常多</strong>。</p>
<pre><code class="language-cypher">MATCH (a:Person {name:'Liz'}), (b:Person {name:'Mike'})
MERGE (a)-[r:EdgeType {since:2001}]-&gt;(b);
MATCH (a:Person {name:'Liz'})
MERGE (a)-[r:EdgeType {since:2001}]-&gt;(b:Person {name:'Mike'}); //*
</code></pre>
<blockquote>
<p><code>*</code>：匹配一个节点，新增一个节点。</p>
</blockquote>
<p><code>(a)-[r]-&gt;(b)</code>表示点之间的关系（边）：类似于节点表示，边也可以指定标签<code>Relation</code>和属性<code>{...}</code>（如果没有标签和属性，可完全省略<code>[r]</code>）。Neo4j仅支持创建有向边，即表达式中必须使用<code>--&gt;</code>或<code>&lt;--</code>，不支持<code>--</code>或<code>&lt;--&gt;</code>。</p>
<blockquote>
<p>自动创建节点和边。由于<strong>不会检测已存在节点或边</strong>，通常不使用这种方式添加关系，无法对已有数据进行修改，应该使用<code>MATCH</code>语句首先获取已有数据。</p>
<pre><code class="language-cypher">CREATE (a:Person {name:'Todd'})-[r:Friends]-&gt;(b:Person {name:'Carlos'});
CREATE (a)-[r:Relation {name: value}]-&gt;(b); //*
</code></pre>
<p><code>*</code>：由于未指定节点属性，因此将在所有已存在节点对之间添加边（不推荐）。</p>
</blockquote>
<h4 id="查询数据-1"><a class="header" href="#查询数据-1">查询数据</a></h4>
<h5 id="查询满足条件的节点"><a class="header" href="#查询满足条件的节点">查询满足条件的节点</a></h5>
<pre><code class="language-cypher">MATCH (a:Label {prop...}) RETURN a LIMIT 10;
MATCH (a:Label) WHERE a.prop=value RETURN a.prop AS prop LIMIT 10;
</code></pre>
<p>节点/链路的标签和属性用于限定查询范围，可省略。</p>
<p><code>AS</code>用于定义返回值的别名。</p>
<h5 id="查询关系中的节点"><a class="header" href="#查询关系中的节点">查询关系中的节点</a></h5>
<p>与一类节点有关系的节点，关系描述表达式可使用<code>--&gt;</code>和<code>&lt;--</code>来表示单向边，<code>--</code>或<code>&lt;--&gt;</code>表示具有任意方向的边（这种方式会遍历<code>a-&gt;b</code>和<code>b-&gt;a</code>返回重复数据，不推荐）。</p>
<pre><code class="language-cypher">MATCH (a:LabelA{prop})-[r:LinkLabel{prop}]-&gt;(b:LabelB{prop}) RETURN b; // 
MATCH (a)--&gt;(b) RETURN b; // 所有对外有关系的节点
</code></pre>
<h5 id="查询关系"><a class="header" href="#查询关系">查询关系</a></h5>
<pre><code class="language-cypher">MATCH (a:Person)-[r:BornIn]-&gt;(b:Location {city:'Boston'}) RETURN a,b //查询满足条件的节点
</code></pre>
<p>返回数据为表格结构，每一列对应一个返回参数。节点对<code>(a,b)</code>，以及对应的关系<code>r</code>可用于可视化。</p>
<p>通过查询也可以直接获取节点或关系的属性并返回，例如：</p>
<pre><code class="language-cypher">MATCH (a)-[r]-&gt;(b) RETURN a.name, b.name, type(r)  //字段不存在返回null
</code></pre>
<h5 id="修改属性"><a class="header" href="#修改属性">修改属性</a></h5>
<pre><code class="language-cypher">MATCH (a:Person {name:'Liz'}) SET a.age=34, a.title='',...
        SET a += {...}
        SET a = {...};
MATCH (a:Person {name:'Liz'}) SET a:Student;     // 添加(不是替换)标签
MATCH (a:Person {name:'Liz'}) SET a = {};        // 清空属性
MATCH (a:Person {name:'Mike'}) REMOVE a.test;    // 移除属性
MATCH (a:Person {name:'Mike'}) REMOVE a:Student; // 移除标签
</code></pre>
<h5 id="删除数据"><a class="header" href="#删除数据">删除数据</a></h5>
<p>删除边：</p>
<pre><code class="language-cypher">MATCH ()-[r]-&gt;() WHERE r.id = 123 DELETE r;
</code></pre>
<p>删除节点及其关联边：</p>
<pre><code class="language-cypher">MATCH (n) DETACH DELETE n  // 删除所有节点
MATCH (n)-[r]-() WHERE r.id = 123 AND n.id = 'abc' DELETE n, r //*
MATCH (a:Location {city:'Portland'}) DELETE a
</code></pre>
<blockquote>
<p><code>*</code>：如果节点还关联其他边，将无法删除（抛出错误）。</p>
</blockquote>
<h4 id="导入数据-1"><a class="header" href="#导入数据-1">导入数据</a></h4>
<h5 id="导入节点数据"><a class="header" href="#导入节点数据">导入节点数据</a></h5>
<pre><code class="language-cypher">LOAD CSV WITH HEADERS FROM uri AS row  // 支持通过HTTP/HTTPS/FTP读取数据
MERGE (place:Place {id:row.id})        // 将CSV节点数据合并到图中
SET place.latitude = toFloat(row.latitude),
    place.longitude = toFloat(row.latitude),
    place.population = toInteger(row.population)
</code></pre>
<p>本地数据通过<code> file:///</code>导入，仅能导入Neo4j数据库设置的导入目录中的数据。</p>
<blockquote>
<pre><code class="language-ini">dbms.security.allow_csv_import_from_file_urls=True
dbms.directories.import=import
</code></pre>
</blockquote>
<h5 id="导入链路数据"><a class="header" href="#导入链路数据">导入链路数据</a></h5>
<pre><code class="language-cypher">LOAD CSV WITH HEADERS FROM &quot;file:///transport-relationships.csv&quot; AS row 
MATCH (origin:Place {id: row.src})
MATCH (destination:Place {id: row.dst})
MERGE (origin)-[:EROAD {distance: toInteger(row.cost)}]-&gt;(destination)
</code></pre>
<h2 id="python-api-1"><a class="header" href="#python-api-1">Python API</a></h2>
<h3 id="python-driver"><a class="header" href="#python-driver">Python Driver</a></h3>
<p>连接数据库：</p>
<pre><code class="language-python">from neo4j import GraphDatabase
uri = &quot;neo4j://example.com:7687&quot;
def write_func(tx, *args, **kwargs):
    tx.run(query, **kwargs)   # 查询语句中使用占位符`$var`代替要传入的关键字参数
def read_func(tx, *args, **kwargs):
    result = tx.run(query, **kwargs) 
    # 每条record对应查询语句返回的所有参数组成的一行记录。
    return [record for record in result]

with GraphDatabase.driver(uri, auth=(&quot;neo4j&quot;, &quot;password&quot;)) as driver:
    with driver.session() as s:
        # Auto-commit Transactions,
        # support only one statement per transaction 
        # and are not automatically retried on failure. 
        s.run()  
        # Explicit Transactions
        with session.begin_transaction() as tx:
            pass
        # Managed Transactions
        s.write_transaction(write_func, *args, *kwargs)
        result = s.read_transaction(read_func, *args, *kwargs)
        result.data()  # 将返回数据转换为字典。
    # use the driver
</code></pre>
<blockquote>
<p>使用上下文管理器代替相应的<code>close()</code>方法。</p>
</blockquote>
<h3 id="py2neo-client"><a class="header" href="#py2neo-client">Py2neo Client</a></h3>
<blockquote>
<p>使用<code>conda</code>安装<code>py2neo</code>可能缺失以下依赖项，需要指定。</p>
<pre><code class="language-shell">conda install py2neo monotonic pansi
</code></pre>
</blockquote>
<h4 id="查询节点"><a class="header" href="#查询节点">查询节点</a></h4>
<p>使用<code>NodeMatcher</code>封装获取节点的Cypher查询语句。</p>
<pre><code class="language-python">from py2neo import Graph
from py2neo.matching import *
g = Graph(uri, auth)
nodes = NodeMatcher(g)
nodes[identity]     # [raise KeyError] identity是由图数据库自动生成的*
nodes.get(identity) # return None if not exist.
</code></pre>
<p><code>nodes</code>是所有节点的集合，可进行迭代或获取节点总数(<code>len(nodes)</code>)。通常会设置条件过滤后再获取节点。</p>
<pre><code class="language-python">matches:NodeMatch = nodes.match(*labels, **properties)\
                         .where('key=value',..., key=value,...)\
                         .limit(count)\
                         .skip(count)\
                         .order_by(*fields)
# MATCH (n:labels {properties}) RETURN n;
# 返回可迭代的节点集合
matches.exists() # 判断匹配是否为空
matches.first()
matches.all()
matches.count()
for node in matches:
    print(node)
</code></pre>
<h5 id="节点对象"><a class="header" href="#节点对象">节点对象</a></h5>
<p>节点对象可在本地创建，或通过查询语句返回（与数据库绑定）。</p>
<pre><code class="language-python">a = Node('Person', name='Alice')
a.graph    # 节点绑定的远端图数据库
a.identity # 节点标识号
a.add_label('Employee')  # -&gt; a.labels, a.has_label, a.clear_label
a.update_labels(lables)
</code></pre>
<p>如果节点与远端数据库绑定，则节点相等关系取决于数据库分配的ID（与属性或标签无关）；反之，节点仅与其自身相等。</p>
<p>节点数据的访问方式类似于字典对象。节点数据也可转换为字典对象。</p>
<pre><code class="language-python">a[prop] = value
a.get(prop, default=None)
del a[prop]
a.clear() # 清除所有属性
dict[a]   # 节点的所有属性组成的字典
a.items(), a.keys(), a.values(), a.update(**kwargs)
</code></pre>
<h5 id="条件表达式-1"><a class="header" href="#条件表达式-1">条件表达式</a></h5>
<p>除字符串形式的<code>WHERE</code>表达式外，可通过API构造表达式。</p>
<pre><code class="language-python">from py2neo import AND, OR
nodes.match(&quot;Person&quot;, born=ALL(GE(1964), LE(1966)))
</code></pre>
<p>运算符类型：</p>
<ul>
<li><code>null</code>检查：<code>IS_NULL</code>、<code>IS_NOT_NULL</code>；</li>
<li>值比较：<code>EQ</code>、<code>NE</code>、<code>LT</code>、<code>LE</code>、<code>GT</code>、<code>GE</code>；</li>
<li>字符串比较：<code>STARTS_WITH</code>、<code>ENDS_WITH</code>、<code>CONTAINS</code>、<code>LIKE</code>（正则表达式）；</li>
<li>集合比较：<code>IN</code>；</li>
<li>逻辑连接：<code>AND</code>、<code>OR</code>、<code>XOR</code>。</li>
</ul>
<h4 id="查询关系-1"><a class="header" href="#查询关系-1">查询关系</a></h4>
<p>类似于节点查询接口。</p>
<pre><code class="language-python">links = RelationshipMatcher(g)
matches:RelationshipMatch = links.match(
    nodes:List[Node]=None, r_type=None, **properties)
</code></pre>
<p><code>nodes</code>指定匹配关系的节点范围（<code>None</code>不限定节点）；<code>r_type</code>为关系类型。</p>
<h5 id="关系对象"><a class="header" href="#关系对象">关系对象</a></h5>
<pre><code class="language-python">KNOWS = Relationship.type(&quot;Knows&quot;)
ab = KNOWS(a,b)
ab.nodes # -&gt; (a,b)
ab.start_node, ab.end_node
</code></pre>
<p>关系对象也可像节点对象一样设置和访问属性。</p>
<h5 id="路径对象"><a class="header" href="#路径对象">路径对象</a></h5>
<p>路径对象可通过查询或本地构造获取。<code>Path</code>构造方法的参数由节点对象和关系（关系对象或字符串）交替组成，路径遍历不固定方向，但关系对象的起点或终点必须是上一个节点参数。</p>
<pre><code class="language-python">alice, bob, carol = Node(name=&quot;Alice&quot;), Node(name=&quot;Bob&quot;), Node(name=&quot;Carol&quot;)
abc = Path(alice, &quot;KNOWS&quot;, bob, Relationship(carol, &quot;KNOWS&quot;, bob), carol)
</code></pre>
<h5 id="子图对象"><a class="header" href="#子图对象">子图对象</a></h5>
<p>子图<code>Subgraph</code>是任意节点和关系的集合，也是<code>Node</code>、<code>Relationship</code>和<code>Path</code>的基类（子图可以和这些对象运算）。使用子图，可以在本地构造图对象，并与远端的图数据进行运算（创建、合并）。</p>
<pre><code class="language-python">subgraph | other |... # 合并图(自动去重)
subgraph &amp; other &amp;... # 图交集
subgraph - other -... # 差集
subgraph ^ other ^... # 对称差集(不在其中一个子图中对象)
subgraph.keys()   # 所有对象使用过的属性名
subgraph.labels() # 所有节点使用过的标签名
subgraph.types()  # 所有关系使用过的标签名
subgraph.nodes, subgraph.relationships
</code></pre>
<h4 id="修改图数据库"><a class="header" href="#修改图数据库">修改图数据库</a></h4>
<p>修改图数据库可直接通过图数据库对象<code>Graph</code>，或通过图数据库对象创建的事务<code>Transaction</code>进行。</p>
<pre><code class="language-python">with g.begin(readonly=False) as tx:
    tx.exists(subgraph)
    tx.match(nodes=None, r_type=None, limit=None)
    tx.match_one(nodes=None, r_type=None)
    tx.create(subgraph)
    tx.merge(subgraph, label=None, *property_keys)
    tx.delete(subgraph)
    tx.delete_all()
    tx.suparate(subgraph) # 删除数据库中的关系(保留节点)
</code></pre>
<p>当修改数据库查询返回对象并需要与数据库同步时，可通过<code>pull</code>和<code>push</code>方法。</p>
<pre><code class="language-python">with g.begin(readonly=False) as tx:
    tx.push(subgraph)  # 将本地修改回写到远端
    tx.pull(subgraph)  # 从远端获取最新数据
</code></pre>
<h4 id="执行cypher原生查询"><a class="header" href="#执行cypher原生查询">执行Cypher原生查询</a></h4>
<blockquote>
<p>类似于<code>neo4j-python-driver</code>的查询接口。</p>
</blockquote>
<pre><code class="language-python">from py2neo import Cursor
g = Graph(uri, auth)
cs:Cursor = db.run('MATCH (a)-[r:Friends]-&gt;(b) RETURN a,b,r')
cs.stats  # 命令执行状态
cs.to_supgraph()
</code></pre>
<p><code>Cursor</code>是查询结果<code>Record</code>（一行记录）的迭代器，可使用<code>for</code>语句或调用<code>forward()/current()</code>或<code>next()</code>方法遍历查询记录。使用任何读取方法，都只能从迭代器获取一次数据。</p>
<h5 id="访问记录"><a class="header" href="#访问记录">访问记录</a></h5>
<p>通过编号或返回参数名访问<code>Record</code>（访问方法类似于<code>Cursor</code>，区别在于只包含一条记录）。</p>
<h4 id="原始数据批量处理"><a class="header" href="#原始数据批量处理">原始数据批量处理</a></h4>
<p><a href="https://py2neo.org/2021.1/bulk/index.html">py2neo.bulk – Bulk data operations — py2neo 2021.1</a></p>
<p>导出<a href="%E6%95%B0%E6%8D%AE%E5%BA%93/GraphDatabase.html#%E6%89%A7%E8%A1%8CCypher%E5%8E%9F%E7%94%9F%E6%9F%A5%E8%AF%A2">原生查询</a>结果。</p>
<pre><code class="language-python">graph_data= cs.data(*keys)
# 返回查询结果的字典序列，`keys`为`RETURN`语句指定的返回参数名（`cs.keys()`）。
graph_df = cs.to_data_frame(index=None, columns=None)
</code></pre>
<h4 id="图对象映射ogm"><a class="header" href="#图对象映射ogm">图对象映射OGM</a></h4>
<p><a href="https://py2neo.org/2021.1/ogm/index.html">py2neo.ogm – Object-Graph Mapping — py2neo 2021.1</a></p>
<h3 id="图分析算法"><a class="header" href="#图分析算法">图分析算法</a></h3>
<p>配置算法参数：</p>
<pre><code class="language-cypher">:param limit =&gt; (null);
:param config =&gt; ({
  relationshipWeightProperty: null
});
:param startNode =&gt; ('Amsterdam');
:param endNode =&gt; ('London');
:param graphConfig =&gt; ({
  nodeProjection: 'Place',
  relationshipProjection: {
    relType: {
      type: 'EROAD',
      orientation: 'UNDIRECTED',
      properties: {}
    }
  }
});
:param communityNodeLimit =&gt; ( 10);
:param generatedName =&gt; ('in-memory-graph-1662349638926');
</code></pre>
<p>创建和删除内存图实例：</p>
<pre><code class="language-cypher">CALL gds.graph.project($generatedName, $graphConfig.nodeProjection, $graphConfig.relationshipProjection, {})
</code></pre>
<p>运行图算法：</p>
<pre><code class="language-cypher">CALL db.propertyKeys() YIELD propertyKey MATCH (start) WHERE start[propertyKey] contains $startNode
WITH start
LIMIT 1
CALL db.propertyKeys() YIELD propertyKey MATCH (end) WHERE end[propertyKey] contains $endNode
WITH start, end
LIMIT 1
WITH $config AS config, start, end
WITH config { .*, sourceNode: id(start), targetNode: id(end)} as config
CALL gds.shortestPath.dijkstra.stream($generatedName, config)
YIELD nodeIds, costs
UNWIND range(0, size(nodeIds)-1) AS index
RETURN gds.util.asNode(nodeIds[index]) AS node, costs[index] AS cost
</code></pre>
<p>删除内存图实例：</p>
<pre><code class="language-cypher">CALL gds.graph.drop($generatedName)
</code></pre>
<h2 id="nebulagraph"><a class="header" href="#nebulagraph">NebulaGraph</a></h2>
<p><a href="https://docs.nebula-graph.com.cn/3.2.1/">NebulaGraph Database 手册 (nebula-graph.com.cn)</a></p>
<h2 id="apache-tinkerpop"><a class="header" href="#apache-tinkerpop">Apache TinkerPop</a></h2>
<blockquote>
<p><em>Apache TinkerPop™ is a graph computing framework for both graph databases (OLTP) and graph analytic systems (OLAP).</em></p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="分布式大数据处理"><a class="header" href="#分布式大数据处理">分布式大数据处理</a></h1>
<h2 id="mapreduce"><a class="header" href="#mapreduce">MapReduce</a></h2>
<p>Map操作将运算依次作用到序列的每个元素，并把运算结果作为新的序列返回。</p>
<p>Reduce操作把运算依次作用在序列元素上进行聚合运算。</p>
<img src="服务器/分布式大数据处理.assets/map.png" alt="map" style="zoom:80%;" />
<p>Python内建了<code>map()</code>、<code>filter()</code>和<code>reduce()</code>函数。</p>
<pre><code class="language-python">maped_set = map(fcn, dataset)  # 等价于 list=[fcn(x) for x in dataset]
</code></pre>
<pre><code class="language-python">tf = filter(lambda x: cond(x), list) # tf=[cond(x) for x in list]
list = list(tf)		# list=[x for x in list if cond(x)]
</code></pre>
<pre><code class="language-python">from functools import reduce
result = reduce(lambda x,y: x+y, dataset)
</code></pre>
<h2 id="hadoop-framework"><a class="header" href="#hadoop-framework">Hadoop Framework</a></h2>
<blockquote>
<p>The Apache Hadoop software library is a framework that allows for the distributed processing of large data sets across clusters of computers using simple programming models.</p>
</blockquote>
<p>Hadoop包括分布式文件系统HDFS和计算框架Hadoop Yarn。</p>
<img src="服务器/分布式大数据处理.assets/hdfsarchitecture.png" alt="HDFS Architecture" style="zoom: 50%;" />
<p>Hadoop的部署模式为主从模式，包括：</p>
<ul>
<li>
<p>Master Node of HDFS：</p>
<ul>
<li><strong>NameNode</strong> manages the distributed file system and knows where are stored data blocks.</li>
</ul>
</li>
<li>
<p>Master Node of Yarn:</p>
<ul>
<li>资源管理器（<strong>ResourceManager</strong>） manages the YARN jobs and takes care of scheduling and executing processes on worker nodes.  调度器（<strong>Scheduler</strong>）是资源管理器的组成部分，allocating resources to applications based on the <strong>resource requirements</strong> of applications, subject to <strong>constraints of capacities, queues</strong> etc.</li>
</ul>
</li>
<li>
<p>Worker Nodes: store the actual data and provide processing power to run the jobs. </p>
<ul>
<li><strong>DataNode</strong>  manages the physical data stored on the node;</li>
<li><strong>NodeManager</strong>：负责工作节点上运行任务（Container）的资源管理，并与<strong>ResourceManager</strong>交互。</li>
<li><strong>Container</strong>: the abstract notion of resources, including memory, CPU, disk, network etc. </li>
</ul>
</li>
</ul>
<p><img src="%E6%9C%8D%E5%8A%A1%E5%99%A8/%E5%88%86%E5%B8%83%E5%BC%8F%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86.assets/hadoop-cluster-overview.png" alt="img" /></p>
<img src="服务器/分布式大数据处理.assets/hddg_0402.png" alt="How YARN runs an application" style="zoom:50%;" />
<blockquote>
<p><code>App Mstr</code>：<strong>ApplicationMaster</strong>，即应用主节点，是应用运行的主要容器，负责管理同一应用的其他容器并与调度器交互。</p>
<p>Yarn的部署方式也是主从方式，但无需与HDFS的主从节点重合。</p>
<p><em>HDFS daemons are <strong>NameNode</strong>, <strong>SecondaryNameNode</strong>, and <strong>DataNode</strong>.</em>
<em>YARN daemons are <strong>ResourceManager</strong>, <strong>NodeManager</strong>, and <strong>WebAppProxy</strong>.</em></p>
</blockquote>
<h3 id="部署"><a class="header" href="#部署">部署</a></h3>
<h4 id="下载安装-1"><a class="header" href="#下载安装-1">下载安装</a></h4>
<p>从镜像站点<a href="https://hadoop.apache.org/releases.html">下载</a><code>hadoop-x.y.z.tar.gz</code>并解压缩到目标文件夹。</p>
<p>版本：<a href="https://docs.cloudera.com/documentation/enterprise/6/release-notes/topics/rg_cdh_6_version_packaging_download.html">CDH 6 Version, Packaging, and Download Information | 6.x | Cloudera Documentation</a>。</p>
<h5 id="设置运行环境"><a class="header" href="#设置运行环境">设置运行环境</a></h5>
<p>如果同时使用Hive则需要使用Java 8。</p>
<blockquote>
<p>Apache Hadoop 3.3 and upper supports Java 8 and Java 11 (runtime only). 
Apache Hadoop from 3.0.x to 3.2.x now supports only Java 8.
Apache Hadoop from 2.7.x to 2.10.x support both Java 7 and 8.</p>
</blockquote>
<p>用户环境变量</p>
<pre><code class="language-sh"># edit /home/&lt;user&gt;/.bashrc
# JAVA_HOME set to the root of your Java installation: 
# update-alternatives --display java
export JAVA_HOME=/usr/lib/jvm/java-11-openjdk-amd64
export HADOOP_HOME=/usr/local/hadoop
export PATH=${PATH}:${HADOOP_HOME}/bin:${HADOOP_HOME}/sbin
</code></pre>
<p>通过Hadoop环境配置文件<code>etc/hadoop/hadoop-env.sh</code>设置<code>JAVA_HOME</code>，不影响全局Java环境配置。</p>
<h4 id="single-node"><a class="header" href="#single-node">Single Node</a></h4>
<h5 id="pseudo-distributed-operation"><a class="header" href="#pseudo-distributed-operation">Pseudo-Distributed Operation</a></h5>
<ol>
<li>
<p>配置<code>etc/hadoop/core-site.xml</code>和<code>etc/hadoop/hdfs-site.xml</code>（参考集群配置）。</p>
</li>
<li>
<p>设置本地SSH免密登录</p>
<pre><code class="language-sh">ssh-copy-id -i ~/.ssh/id_rsa.pub $hostname
</code></pre>
</li>
<li>
<p>格式化HDFS文件系统，由<code>dfs.namenode.name.dir</code>指定，默认位置<code>root=/tmp/hadoop-gary/dfs/name</code>：</p>
<pre><code class="language-sh">hdfs namenode -format
</code></pre>
<blockquote>
<p>不同版本的HDFS文件系统不兼容。</p>
</blockquote>
</li>
<li>
<p>启动Name Node和Data Node守护进程：<code>start-dfs.sh</code>（关闭<code>stop-dfs.sh</code>）</p>
</li>
<li>
<p>执行MapReduce任务</p>
</li>
</ol>
<h5 id="yarn-on-a-single-node"><a class="header" href="#yarn-on-a-single-node">YARN on a Single Node</a></h5>
<ol>
<li>在上述步骤基础上，配置<code>etc/hadoop/mapred-site.xml</code>和<code>etc/hadoop/yarn-site.xml</code>（参考Cluster配置）。</li>
<li>启动守护进程：<code>start-yarn.sh</code>（停止：<code>stop-yarn.sh</code>）</li>
</ol>
<h4 id="cluster-1"><a class="header" href="#cluster-1">Cluster</a></h4>
<blockquote>
<p><em>Typically one machine in the cluster is designated as the NameNode and another machine as the ResourceManager, exclusively</em>. </p>
<p><em>The rest of the machines (workers) in the cluster act as both DataNode and NodeManager.</em> </p>
<p><em>If MapReduce is to be used, then the MapReduce Job History Server will also be running.</em> </p>
<p><em>For large installations, these are generally running on separate hosts.</em></p>
</blockquote>
<blockquote>
<p>如果使用虚拟机进行实验，可先将多数内容在单节点上创建完成，然后复制虚拟机。</p>
</blockquote>
<ol>
<li>
<p>编辑<code>/etc/hosts</code>，配置集群所有节点的域名映射。</p>
</li>
<li>
<p>配置主节点（Name Node和Resource Manager）到从节点的SSH连接，实现[免密登录](../Linux and UNIX/Linux配置和管理#通过SSH访问服务器)，从而从主节点完成所有节点的配置（设置SSH服务的<code>PermitUserEnvironment</code>从而保证远程连接能够使用环境变量）。</p>
</li>
<li>
<p>配置<a href="%E6%9C%8D%E5%8A%A1%E5%99%A8/./scripts/core-site.xml"><code>etc/hadoop/core-site.xml</code></a>，<a href="%E6%9C%8D%E5%8A%A1%E5%99%A8/./scripts/hdfs-site.xml"><code>etc/hadoop/hdfs-site.xml</code></a>，<a href="%E6%9C%8D%E5%8A%A1%E5%99%A8/./scripts/mapred-site.xml"><code>etc/hadoop/mapred-site.xml</code></a>和<a href="%E6%9C%8D%E5%8A%A1%E5%99%A8/./scripts/yarn-site.xml"><code>etc/hadoop/yarn-site.xml</code></a>（包括<a href="%E6%9C%8D%E5%8A%A1%E5%99%A8/%E5%88%86%E5%B8%83%E5%BC%8F%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86.html#Resource-Allocation-on-Yarn">Yarn的资源分配</a>）。</p>
<blockquote>
<p>如没有配置<code>hadoop.tmp.dir</code>参数，系统使用默认的临时目录：<code>/tmp/hadoo-hadoop</code>。而<a href="http://www.spring4all.com/article/18052">这个目录在每次重启后都会被删除</a>，必须重新执行format才行，否则会出错。</p>
</blockquote>
</li>
<li>
<p>创建文件读写目录。配置文件中设置的相关目录，需要运行<code>hadoop</code>的用户或其所属组具有写权限（使用<code>chmod</code>或<code>chown</code>修改相应权限）；否则应将相关目录设置到有权限的目录下。</p>
<blockquote>
<p><em>hadoop-master: ERROR: Cannot set priority of secondarynamenode process 3001</em>.</p>
</blockquote>
</li>
<li>
<p>编辑<code>etc/hadoop/workers</code>（Hadoop2.x为<code>slave</code>），配置工作节点（主机名）；</p>
</li>
<li>
<p>配置内存分配规则（小内存节点需要）；</p>
</li>
<li>
<p>将配置文件分发到各个节点：</p>
<pre><code class="language-sh">for node in nodes; do
	scp -r etc/hadoop/* $node:hadoop_home/etc/hadoop/;
done
</code></pre>
<blockquote>
<p>注意将配置文件的权限应该包括<code>scp</code>用户的可写权限。</p>
</blockquote>
</li>
<li>
<p>在NameNode节点上执行格式化HDFS文件系统</p>
<blockquote>
<p>完成格式化后显示<code>SHUTDOWN_MSG: Shutting down NameNode at hadoop-master/192.168.3.110</code>。输出日志中记载了文件系统的配置信息（包括磁盘路径）。</p>
</blockquote>
</li>
<li>
<p>在<code>NameNode</code>上启动HDFS：<code>start-dfs.sh</code>（停止：<code>stop-dfs.sh</code>）</p>
</li>
<li>
<p>在作为<code>ResourceManager</code>上启动Yarn：<code>start-yarn.sh</code>（停止：<code>stop-yarn.sh</code>）</p>
<blockquote>
<p>在非<code>ResourceManager</code>的节点上（根据配置文件声明）启动Yarn会导致<code>ResourceManager</code>启动失败并触发<code>BindException</code>。因为启动脚本会监听域名/主机名对应的IP和端口，其并非当前主机的IP地址，所以导致上述异常。</p>
</blockquote>
</li>
<li>
<p>执行MapReduce任务。</p>
</li>
</ol>
<blockquote>
<p>https://hadoop.apache.org/docs/r3.3.0/hadoop-project-dist/hadoop-common/RackAwareness.html</p>
</blockquote>
<h5 id="网络拓扑"><a class="header" href="#网络拓扑">网络拓扑</a></h5>
<p>Hadoop可根据集群的<a href="https://hadoop.apache.org/docs/stable/hadoop-project-dist/hadoop-common/RackAwareness.html">网络拓扑</a>优化数据读写。</p>
<p>在<code>core-site.xml</code>中指定<a href="https://blog.csdn.net/amingo_ss/article/details/106014087">拓扑声明文件</a>：</p>
<pre><code class="language-ini">net.topology.node.switch.mapping.impl=org.apache.hadoop.net.TableMapping
net.topology.table.file.name=$FILEPATH/network.mapping
</code></pre>
<p>拓扑声明文件可手动编写或通过脚本生成：</p>
<pre><code>172.28.76.111  /rack-001
172.28.76.112  /rack-002
172.28.76.113  /rack-003
</code></pre>
<h5 id="可能的问题"><a class="header" href="#可能的问题">可能的问题</a></h5>
<ol>
<li><code>pdsh</code>导致无法远程配置节点，卸载<code>pdsh</code>。</li>
<li>DataNode的路径配置不正确，导致节点不能启动，检查<code>hdfs-site.xml</code>配置文件。</li>
</ol>
<h3 id="hadoop命令行"><a class="header" href="#hadoop命令行">Hadoop命令行</a></h3>
<pre><code class="language-shell">shellcommand [SHELL_OPTIONS] [COMMAND] [GENERIC_OPTIONS] [COMMAND_OPTIONS]
</code></pre>
<p><code>shellcommand</code>：例如<code>hadoop, hdfs, yarn,...</code>，</p>
<p><code>COMMAND</code>是子命令，</p>
<p><code>GENERIC_OPTIONS</code>是多类命令通用的选项，</p>
<ul>
<li><code>-libjars xxx.jar,yyy.jar,...</code>：提交任务时在<code>CLASSPATH</code>中添加额外<code>jar</code>包。</li>
</ul>
<p><a href="https://hadoop.apache.org/docs/stable/hadoop-project-dist/hadoop-common/CommandsManual.html">Apache Hadoop 3.3.1 – Hadoop Commands Guide</a></p>
<h4 id="hadoop命令"><a class="header" href="#hadoop命令">Hadoop命令</a></h4>
<pre><code class="language-shell"> hadoop classpath [--glob | --jar &lt;path&gt; ]
 hadoop jar &lt;jar&gt; [mainClass] args...  # 使用yarn jar启动YARN applications.
</code></pre>
<h4 id="hdfs命令"><a class="header" href="#hdfs命令">HDFS命令</a></h4>
<p>HDFS命令用于管理HDFS数据。HDFS默认目录为<code>/user</code>。</p>
<pre><code class="language-sh">hdfs dfs -cmd [options] args    # 等效命令：hadoop fs
hdfs dfs -help/-usage [cmd ...] # 查看命令的帮助信息/使用语法
</code></pre>
<p>多数命令<code>cmd</code>与Linux命令相同，包括<code>ls</code>、<code>mkdir</code>、<code>rm</code>等。</p>
<h5 id="文件系统信息-2"><a class="header" href="#文件系统信息-2">文件系统信息</a></h5>
<pre><code class="language-shell">hdfs fsck PATH		          # 检查文件系统状态
hdfs dfs -df -h [PATH ...]  # 查看指定路径所在文件系统的名称、容量、使用量、可用量、使用比例
         -du -s -h PATH ... # 查看指定类路径下个目录的使用容量
hdfs dfs -count -h PATH     # 统计指定路径下目录、文件数量和数据量
</code></pre>
<p>格式化输出文件/目录的统计信息，格式化字符串中可包含普通字符和<code>%</code>替换指令：</p>
<pre><code class="language-shell">hdfs dfs -stat FORMAT PATH  # %n(name) %F(type) %u(user) %g(group) %b(filesize) %o(blocksize)   
                            # %y(datetime) %Y(timestamp-ms) %r(replication)
</code></pre>
<p>设置文件的副本数量：</p>
<pre><code class="language-shell">hadoop fs -setrep [-w] [-R] &lt;numReplicas&gt; &lt;path&gt;   # =&gt; hdfs dfs
hadoop fs –setrep -w 3 hdfs:///some/path/spark-libs.jar
</code></pre>
<blockquote>
<p><code>-w</code>：等待操作完成。<code>-R</code>选项用于向后兼容，如果找不到命令可添加该选项。</p>
</blockquote>
<h5 id="文件管理-5"><a class="header" href="#文件管理-5">文件管理</a></h5>
<p>使用<code>get</code>命令导出数据到本地磁盘，使用<code>put</code>命令将本地磁盘的数据存入HDFS文件系统。</p>
<pre><code class="language-shell">hdfs dfs -copyFromLocal|copyToLocal SRC DEST  # 本地系统与DHFS间文件复制 =&gt; -get/-put
         -moveFromLocal/moveToLocal SRC DEST 
         -appendToFile SRC ... DEST
hdfs dfs -cp/-mv -f SRC DEST  # HDFS文件复制/移动
hdfs dfs -ls -h -R PATH
hdfs dfs -find PATH ... EXPRESSION ...  # =&gt; linux find
hdfs dfs -rm -skipTrash FILE
hdfs dfs -mkdir/-rmdir /user/gary/packages    # 创建/移除目录
hdfs dfs -test -[defsrwz] PATH_URL  # 测试文件/目录信息(d:目录,e:存在,f:文件,s:非空,z:空文件) 
hdfs dfs -touchz PATH               # 创建空文件
</code></pre>
<h5 id="权限管理-3"><a class="header" href="#权限管理-3">权限管理</a></h5>
<pre><code class="language-shell">hdfs dfs -chgrp|chown|chmod -R ... PATH
</code></pre>
<h5 id="文件输入输出-1"><a class="header" href="#文件输入输出-1">文件输入输出</a></h5>
<pre><code class="language-shell">hdfs dfs -cat SRC ..
hdfs dfs -tail -f FILE  # Show the last 1KB of the file.
hdfs dfs -truncate [-w] LENGTH PATH
</code></pre>
<h5 id="hdfs-url"><a class="header" href="#hdfs-url">HDFS URL</a></h5>
<pre><code class="language-shell">hdfs:/hostname[:port]/path/file  # 使用域名或IP，端口可省略
hdfs:///path/file    # 省略主机采用Hadoop集群配置
/path/file           # 省略协议
</code></pre>
<blockquote>
<p><strong>错误</strong>:<em>Operation category READ is not supported in state Standby</em>：集群使用了高可用配置，而HDFS地址指向了备份节点。<strong>解决方法</strong>：使用集群名称<code>HACluster</code>或省略主机名。</p>
</blockquote>
<blockquote>
</blockquote>
<p><a href="http://hadoop.apache.org/docs/current/hadoop-project-dist/hadoop-hdfs/HDFSCommands.html">Apache Hadoop 3.3.0 – HDFS Commands Guide</a></p>
<ul>
<li><a href="http://hadoop.apache.org/docs/current/hadoop-project-dist/hadoop-common/FileSystemShell.html">Apache Hadoop 3.3.0 – File System Shell</a></li>
</ul>
<h4 id="提交mapreduce任务"><a class="header" href="#提交mapreduce任务">提交MapReduce任务</a></h4>
<h4 id="yarn命令"><a class="header" href="#yarn命令">Yarn命令</a></h4>
<p><a href="https://hadoop.apache.org/docs/stable/hadoop-yarn/hadoop-yarn-site/YarnCommands.html#jar">Apache Hadoop 3.3.1 – YARN Commands</a></p>
<h3 id="权限-3"><a class="header" href="#权限-3">权限</a></h3>
<p>如果HDFS开启权限管控，则<a href="https://community.cloudera.com/t5/Support-Questions/Permission-denied-user-root-access-WRITE-inode-quot-user/td-p/4943">只有文件或目录授权的用户才能对相应目录进行操作</a>（主机的<code>root</code>用户如果不在<code>superuser</code>组中也也无法操作）。</p>
<pre><code class="language-shell">sudo -u hdfs hadoop fs -mkdir /user/root  # /user目录的所有者为hdfs:superuser
sudo -u hdfs hadoop fs -chown root /user/root
</code></pre>
<p>如果没有操作权限，则可能会出现以下错误：<em><code>Permission denied: user=root, access=WRITE, inode=&quot;/user&quot;:hdfs:supergroup:drwxr-xr-x</code></em>。</p>
<h3 id="resource-allocation-on-yarn"><a class="header" href="#resource-allocation-on-yarn">Resource Allocation on Yarn</a></h3>
<img src="服务器/分布式大数据处理.assets/hadoop-2-memory-allocation.jpg" alt="Schema of memory allocation properties" style="zoom:80%;" />
<blockquote>
<p><a href="https://www.linode.com/docs/databases/hadoop/how-to-install-and-set-up-hadoop-cluster/">How to Install and Set Up a 3-Node Hadoop Cluster</a></p>
</blockquote>
<h5 id="内存分配"><a class="header" href="#内存分配">内存分配</a></h5>
<pre><code class="language-shell">yarn.scheduler.minimum-allocation-mb 256
yarn.scheduler.maximum-allocation-mb 1024
yarn.nodemanager.resource.memory-mb  2048
</code></pre>
<p>虚拟内存分配配置：</p>
<pre><code class="language-xml">&lt;property&gt;
   &lt;name&gt;yarn.nodemanager.vmem-pmem-ratio&lt;/name&gt;
   &lt;value&gt;2.1&lt;/value&gt;   &lt;!--如果因为VMEM不足导致容器被终止，可适当将该值调大--&gt;
&lt;/property&gt;
&lt;property&gt;
   &lt;name&gt;yarn.nodemanager.pmem-check-enabled&lt;/name&gt;
   &lt;value&gt;false&lt;/value&gt;
&lt;/property&gt;
&lt;property&gt;
   &lt;name&gt;yarn.nodemanager.vmem-check-enabled&lt;/name&gt;
   &lt;value&gt;false&lt;/value&gt;
&lt;/property&gt;
</code></pre>
<h5 id="fair-scheduler"><a class="header" href="#fair-scheduler">Fair Scheduler</a></h5>
<p>为应用程序设置优先级（权重）；建立多个队列，并未每个队列设置优先级；系统<a href="%E6%9C%8D%E5%8A%A1%E5%99%A8/./scripts/hadoop_fairshare.py">根据队列优先级按比例为各队列分配资源（同时考虑最小和最大资源约束）</a>。</p>
<blockquote>
<p>It can be configured to schedule with both memory and CPU, using the notion of Dominant Resource Fairness.</p>
<p>队列中应用程序根据优先级按比例分配队列可用资源（只有1个应用时，该应用可占用所有资源）。</p>
<p>每个队列可设置最大可运行的App数量。由于App按比例分配队列中的资源，当运行的App过多时，每个App可用的资源减少，新提交的App可能由于资源不足而挂起；已有App也可能因为抢占而被提前终止。</p>
<p><a href="https://cloud.tencent.com/developer/article/1239472">yarn公平调度详细分析（一）</a>。</p>
</blockquote>
<h5 id="capacity-scheduler"><a class="header" href="#capacity-scheduler">Capacity Scheduler</a></h5>
<p>The <a href="https://hadoop.apache.org/docs/current/hadoop-yarn/hadoop-yarn-site/CapacityScheduler.html"><code>CapacityScheduler</code></a> is designed to allow sharing a large cluster while giving each organization capacity guarantees.</p>
<ul>
<li><strong>Hierarchical Queues</strong></li>
<li><strong>Capacity Guarantees</strong></li>
<li><strong>Elasticity</strong> </li>
<li><strong>Multi-tenancy</strong></li>
<li><strong>Resource-based Scheduling</strong></li>
<li><strong>Priority Scheduling</strong></li>
</ul>
<h4 id="using-gpu-on-yarn"><a class="header" href="#using-gpu-on-yarn">Using GPU on Yarn</a></h4>
<p><a href="https://hadoop.apache.org/docs/r3.1.0/hadoop-yarn/hadoop-yarn-site/UsingGpus.html">Apache Hadoop 3.1.0 – Using GPU On YARN</a></p>
<h2 id="分布式数据仓库hive"><a class="header" href="#分布式数据仓库hive">分布式数据仓库Hive</a></h2>
<blockquote>
<p>The Apache Hive ™ data warehouse software facilitates reading, writing, and managing large datasets residing in distributed storage using SQL. </p>
</blockquote>
<p>Hive提供类SQL查询语言<strong>HiveQL(Hive query Language)<strong>以读取数据，并在内部将HiveQL转换为</strong>MapReduce</strong>任务并在Hadoop集群上执行。</p>
<h3 id="安装-32"><a class="header" href="#安装-32">安装</a></h3>
<p>从镜像站点下载<code>apache-hive-3.1.2-bin.tar.gz</code>。</p>
<blockquote>
<p>Hive目前还不支持Java 11，Hive使用Hadoop指定的Java版本。</p>
</blockquote>
<h4 id="hive环境配置"><a class="header" href="#hive环境配置">Hive环境配置</a></h4>
<pre><code class="language-shell">export HIVE_HOME=/usr/local/hive
export PATH=${PATH}:${HIVE_HOME}/bin
</code></pre>
<p>Hive的数据存储于HDFS中，因此首先在HDFS中创建Hive数据存储路径（<code>hive.metastore.warehouse.dir</code>）并设置读写权限：</p>
<pre><code class="language-sh">hdfs dfs -mkdir -p /tmp /user/hive/warehouse # 这是默认的数据仓库位置
# drwxr-xr-x   - gary supergroup  0 2021-05-30 22:34 /hive/warehouse
hdfs dfs -chmod g+w /tmp /user/hive/warehouse
</code></pre>
<p>Hive配置文件：<code>conf/hive-site.xml</code>（默认值<code>hive-site.xml.template</code>）。</p>
<h4 id="初始化元数据库"><a class="header" href="#初始化元数据库">初始化元数据库</a></h4>
<p>Hive应用在访问Hive数据前需要首先获取Hive的<a href="%E6%9C%8D%E5%8A%A1%E5%99%A8/./Metastore.html">元数据库</a>（metastore）信息，因此需要配置对metastore的访问路径和方法等（具体配置参考相应的<a href="%E6%9C%8D%E5%8A%A1%E5%99%A8/%E5%88%86%E5%B8%83%E5%BC%8F%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86.html#%E5%B9%B6%E5%8F%91%E8%AE%BF%E9%97%AEHive">访问方式</a>）。</p>
<pre><code class="language-shell">javax.jdo.option.ConnectionURL=jdbc:&lt;db_scheme&gt;
javax.jdo.option.ConnectionDriverName=&lt;driver_name&gt;
javax.jdo.option.ConnectionUserName=hiveuser
javax.jdo.option.ConnectionPassword=hivepass
</code></pre>
<blockquote>
<p><a href="https://stackoverflow.com/questions/29362166/how-to-get-database-username-and-password-in-hive">用户名（<code>ConnectionUserName</code>）和密码</a>用于初始化数据库，且不能改作其他名称，否则会产生错误：<code>Schema 'UNSERNAME' does not exist</code>。</p>
</blockquote>
<p>使用数据库前执行初始化，在执行初始化的位置生成<code>metastore_db</code>。根据元数据的存储方式设置<code>dbType</code>，默认存储在磁盘上使用<code>derby</code>。如果使用数据库，则选择相应的数据库类型，如<code>mysql</code>。初始化数据库前需要设置好配置文件，需要读取其中的访问方式以及用户凭据，==并且==在存储<a href="%E6%9C%8D%E5%8A%A1%E5%99%A8/%E5%88%86%E5%B8%83%E5%BC%8F%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86.html#%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%98%E5%82%A8metastore">metastore的数据源</a>==设置hive访问权限==。</p>
<pre><code class="language-sh">schematool -dbType &lt;db_type&gt; \ # 必须指定数据库类型e.g., derby, mysql
           -initSchema         # 初始化metastore
	        -upgradeSchema
	        -validate           # 验证
</code></pre>
<p><strong>初始化错误</strong>：<em>NoSuchMethodError: .......Preconditions.checkArgument(......</em>。Hive与Hadoop中的Java包版本不兼容：<code>guava-xxx.jar</code>，使用Hadoop提供的包替换hive提供的包。</p>
<pre><code class="language-sh"> hadoop/share/hadoop/common/lib/guava-27.0-jre.jar
 hive/lib/guava-19.0.jar
</code></pre>
<blockquote>
<p><a href="https://db.apache.org/derby/faq.html#schema_exist">Why do I get the error 'schema does not exist'?</a></p>
<p><a href="https://cwiki.apache.org/confluence/display/Hive/AdminManual+Metastore+3.0+Administration">AdminManual Metastore 3.0 Administration</a></p>
</blockquote>
<h3 id="并发访问hive"><a class="header" href="#并发访问hive">并发访问Hive</a></h3>
<p>要实现并发访问Hive，必须实现对元数据<code>metastore</code>的并发访问（Derby服务和数据库服务），或提供可并发的Hive数据读写服务（Hiveserver2、metastore服务）。Hive CLI、Beeline/Hiveserver2等应用利用内置Derby驱动、Derby服务或数据库服务读写metastore数据，提供查询Hive数据的应用和服务。metastore服务基于<code>metastore</code>数据提供Thrift接口（默认端口<code>tcp/9083</code>）以支持第三方应用分布式访问Hive数据。</p>
<blockquote>
<p>使用Derby网络服务或数据库服务读取metastore，从而允许多类客户端对metastore的并发访问。</p>
</blockquote>
<h4 id="metastore"><a class="header" href="#metastore">metastore</a></h4>
<h5 id="本地metastore存储"><a class="header" href="#本地metastore存储">本地metastore存储</a></h5>
<p>在未配置<code>ConnectionURL</code>的情况下，应用将尝试寻找是否存在<code>metastore</code>数据（默认当前工作目录下），并使用内置的derby driver访问本地<code>metastore</code>数据文件。其<code>metastore</code>的配置如下：</p>
<pre><code class="language-shell">driver_name=org.apache.derby.jdbc.EmbeddedDriver
db_scheme=derby:/local/path/metastore_db;create=true
</code></pre>
<blockquote>
<p>嵌入模式下不支持使用URL作为数据库的源，<em>derby.jdbc.EmbeddedDriver claims to not accept jdbcUrl</em>。</p>
<p><code>db_scheme</code>可额外指定一个参数<code>databaseName=metastore_db</code>，该参数将添加到路径后面。路径可为绝对或相对路径，如果留空，则表示读取该配置文件的程序的当前工作目录。</p>
</blockquote>
<p>该驱动方法将占用本地磁盘上的<code>metastore</code>文件，导致其他应用无法访问元数据（数据库文件目录下由<code>db.lck</code>和<code>dbex.lck</code>两个文件，防止其他客户端并发访问），从而无法并发访Hive数据。</p>
<h5 id="通过derby服务访问metastore"><a class="header" href="#通过derby服务访问metastore">通过Derby服务访问metastore</a></h5>
<p>为了支持并发访问数据库，可使用独立的Derby Network Server（<code>tcp/1527</code>，需要单独<a href="http://db.apache.org/derby/releases/release-10.14.2.0.cgi">下载</a>并首先<a href="https://cwiki.apache.org/confluence/display/Hive/HiveDerbyServerMode">启用该服务</a>）。在该模式下，Derby服务也将占用<code>metastore_db</code>，但Derby网络服务可支持并发连接。通过配置URL使用该服务，访问Hive的程序与Derby服务可以位于不同主机上。</p>
<pre><code class="language-shell">driver_name=org.apache.derby.jdbc.ClientDriver
db_scheme=derby://hadoop-master:1527//.../metastore_db;create=true
</code></pre>
<blockquote>
<p>路径中在“<code>protocol://domain:port</code>”后使用<code>//</code>表示绝对路径。</p>
</blockquote>
<h5 id="数据库存储metastore"><a class="header" href="#数据库存储metastore">数据库存储metastore</a></h5>
<p>由于数据库提供服务支持并发访问，因此也可以使用数据库（如<code>mysql-server 8.0</code>、<code>postgresql 12.6</code>等）来存储metastore数据。</p>
<pre><code class="language-shell">driver_name=com.mysql.cj.jdbc.Driver
db_scheme=jdbc:mysql://hadoop-namenode:3306/hive?createDatabaseIfNotExist=true
</code></pre>
<blockquote>
<p>如果使用数据库，则需要相应的数据库驱动包（例如MySQL需要在官网下载<code>MySQL Connector/J</code> 安装包，驱动包安装在<code>/usr/share/java/mysql-connector-java-8.0.25.jar</code>）。</p>
</blockquote>
<p>需要在数据库中首先创建账户并配置访问权限。</p>
<pre><code class="language-mysql">CREATE USER hiveuser@'%' IDENTIFIED BY 'PassWord';
GRANT ALL ON hive_metastore.* TO hiveuser@'%';
</code></pre>
<h5 id="metastore-thrift服务"><a class="header" href="#metastore-thrift服务">Metastore Thrift服务</a></h5>
<pre><code class="language-shell">hive --service metastore  &gt; /tmp/metastore.log 2&gt;&amp;1 &amp;
</code></pre>
<p>此时需要访问Hive的应用（应用所在目录的hive配置）无需配置<code>ConnectionURL</code>和<code>ConnectionDriverName</code>，而是配置<code>hive.metastore.uris</code>。</p>
<pre><code class="language-shell">hive.metastore.uris=thrift://hadoop-namenode:9083
</code></pre>
<blockquote>
<p>运行metastore服务的节点上<code>hive-site.xml</code>需配置<code>jdbc</code>的方式以使该服务访问<code>metastore</code>数据。需要访问Thrift服务的其他应用程序（同一节点或远程节点）应在自身的<code>hive-site.xml</code>文件（设置<code>HIVE_CONF_DIR</code>指定配置文件所在目录）中设置<code>hive.metastore.uris</code>。</p>
</blockquote>
<h4 id="数据访问"><a class="header" href="#数据访问">数据访问</a></h4>
<h5 id="从命令行访问hive"><a class="header" href="#从命令行访问hive">从命令行访问Hive</a></h5>
<p>Hive提供Hive CLI（已弃用）和Beeline/Hiveserver2访问Hive数据，提供HQL数据查询功能。</p>
<pre><code class="language-sh">hive --silent		# --verbose for information
</code></pre>
<h6 id="beeline-hiveserver2-cli-"><a class="header" href="#beeline-hiveserver2-cli-">Beeline (Hiveserver2 CLI )</a></h6>
<p>Beeline/Hiveserver2将数据查询的前后端分离，Hiveserver2作为服务在后台运行，提供访问Hive数据的<code>jdbc</code>接口（<code>jdbc:hive2://hadoop-master:10000</code>），因此支持多个Beeline客户端（或其他应用）接入服务，并由Hiveserver2统一调度Hive数据查询。除直接访问metastore数据的方式外，Hiveserver2也支持[读取Thrift接口访问metastore](#metastore service)。</p>
<blockquote>
<p>使用<code>org.apache.hive.jdbc.HiveDriver</code>访问Hiveserver2的接口。</p>
<h6 id="启动hiveserver2服务"><a class="header" href="#启动hiveserver2服务">启动Hiveserver2服务</a></h6>
<pre><code class="language-sh">hiveserver2 &gt; /tmp/hive/hiveserver2.log 2&gt;&amp;1 &amp;
</code></pre>
<p>Hiveserver2的接口包括<code>binary</code>（默认，使用10000端口）和<code>http</code>（使用10001端口）两种模式。如果使用<code>http</code>模式，则<a href="https://cwiki.apache.org/confluence/display/Hive/HiveServer2+Clients#HiveServer2Clients-ConnectionURLWhenHiveServer2IsRunninginHTTPMode">接口格式</a>为：</p>
<pre><code class="language-shell">jdbc:hive2://hadoop-master:10001/;transportMode=http;httpPath=cliservice
</code></pre>
<p>URL需要以<code>/;</code>结尾以与后面的参数分隔。<code>http</code>模式的配置项：</p>
<pre><code class="language-xml">hive.server2.transport.mode=http
hive.server2.thrift.http.port=10001
</code></pre>
</blockquote>
<p>默认不需要提供用户名和密码，<a href="https://stackoverflow.com/questions/43180305/cannot-connect-to-hive-using-beeline-user-root-cannot-impersonate-anonymous">以匿名用户登录</a>（<code>user=anonymous</code>），不具有对HDFS的写入权限。指定用户名<a href="%E6%9C%8D%E5%8A%A1%E5%99%A8/%E5%88%86%E5%B8%83%E5%BC%8F%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86.html#Hive%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%E9%97%AE%E9%A2%98">登录</a>：注意此处的用户名应该是能够写HDFS中<a href="%E6%9C%8D%E5%8A%A1%E5%99%A8/%E5%88%86%E5%B8%83%E5%BC%8F%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86.html#Hive%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE">Hive数据仓库</a>的<a href="%E6%9C%8D%E5%8A%A1%E5%99%A8/%E5%88%86%E5%B8%83%E5%BC%8F%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86.html#Hive%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%E9%97%AE%E9%A2%98">用户</a>，而非Hive配置文件中的用户。</p>
<pre><code class="language-sh">beeline -u jdbc:hive2://localhost:10000/default -n gary
#&gt; beeline
#beeline&gt; !connect jdbc:hive2://localhost:10000/default
</code></pre>
<blockquote>
<p><em>AccessControlException Permission denied: user=hiveuser, access=WRITE, inode=&quot;/user/hive/warehouse&quot;:gary:supergroup:drwxrwxr-x</em>。</p>
</blockquote>
<p>退出Beeline：</p>
<pre><code class="language-sh">#0: jdbc:hive2://hadoop-master:10000&gt;!q  # exit CLI =&gt; !quit
</code></pre>
<h3 id="读写数据"><a class="header" href="#读写数据">读写数据</a></h3>
<p>在命令行中，可通过<a href="%E6%9C%8D%E5%8A%A1%E5%99%A8/../%E6%95%B0%E6%8D%AE%E5%BA%93/HiveSQL.html#Hive-SQL">SQL语句</a>执行数据库/表格的创建以及数据读写；</p>
<h3 id="问题诊断"><a class="header" href="#问题诊断">问题诊断</a></h3>
<p>查看<code>/tmp/&lt;user&gt;/hive.log</code>查看完整日志，启动服务时设置以下选项输出更多调试信息。</p>
<pre><code class="language-shell">--hiveconf hive.root.logger=DEBUG,console
</code></pre>
<h6 id="hive-cli无法初始化会话"><a class="header" href="#hive-cli无法初始化会话">Hive CLI无法初始化会话</a></h6>
<pre><code class="language-sh">FAILED: HiveException java.lang.RuntimeException: Unable to instantiate org.apache.hadoop.hive.ql.metadata.SessionHiveMetaStoreClient
</code></pre>
<h6 id="hiveserver2未监听10000端口但未产生错误提示"><a class="header" href="#hiveserver2未监听10000端口但未产生错误提示">Hiveserver2未监听10000端口，但未产生错误提示</a></h6>
<p><a href="https://stackoverflow.com/questions/54196915/hiveserver2-not-listening-on-port-10000-and-10001/60670556#60670556">metastore版本</a>问题：上述两个问题可能是由于<code>metastore</code>的版本检查出错。可以通过配置<code>hive-site.xml</code>禁用版本检查（<code>hive.metastore.schema.verification=false</code>），或修改<code>metastore_db</code><a href="https://blog.csdn.net/qq_27882063/article/details/79886935">数据库中的版本信息</a>。不推荐上述修改方式，忽略版本兼容性或修改版本信息可能导致无法正确读取数据，<a href="%E6%9C%8D%E5%8A%A1%E5%99%A8/%E5%88%86%E5%B8%83%E5%BC%8F%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86.html#%E8%AE%BF%E9%97%AE%E9%9D%9E%E9%BB%98%E8%AE%A4%E7%89%88%E6%9C%ACHive">应该使对应版本的库读取数据</a>。</p>
<p>上述问题也有可能是由于接管<code>metastore</code>的服务异常退出，导致<a href="https://stackoverflow.com/questions/22711364/java-lang-runtimeexceptionunable-to-instantiate-org-apache-hadoop-hive-metastor"><code>metastore_db/*.lck</code>未被删除</a>（直接访问metastore数据的配置下），从而无法再次启用相应的服务。Hiveserver2会不断尝试连接服务，并不会给出错误提示，需要==查看日志==。</p>
<h6 id="hive用户登录问题"><a class="header" href="#hive用户登录问题">Hive用户登录问题</a></h6>
<p><a href="https://stackoverflow.com/questions/36909002/authorizationexception-user-not-allowed-to-impersonate-user">User not allowed to impersonate User</a>：设置hive查询用户</p>
<pre><code class="language-xml">&lt;property&gt; &lt;!--hive-site.xml--&gt;
  &lt;!--true: 使用提交查询的用户(beeline登录用户)；
  ----false: 使用hiveserver2进程所属用户  --&gt;
  &lt;name&gt;hive.server2.enable.doAs&lt;/name&gt;
  &lt;value&gt;true&lt;/value&gt;
&lt;/property&gt;
</code></pre>
<p>Hive以上述两种用户身份登录，还需要设置Hadoop的<a href="%E6%9C%8D%E5%8A%A1%E5%99%A8/./scripts/core-site.xml">代理用户</a>（<a href="http://hadoop.apache.org/docs/current/hadoop-project-dist/hadoop-common/Superusers.html"><em>Proxy user - Superusers Acting On Behalf Of Other Users</em></a>）。</p>
<h6 id="没有读写权限"><a class="header" href="#没有读写权限">没有读写权限</a></h6>
<blockquote>
<p><em>Permission denied: user=anonymous, access=WRITE, inode=&quot;/user/hive/warehouse&quot;:gary:supergroup:drwxrwxr-x</em></p>
</blockquote>
<p>连接hive时需要<a href="%E6%9C%8D%E5%8A%A1%E5%99%A8/%E5%88%86%E5%B8%83%E5%BC%8F%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86.html#%E4%BB%8E%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%AE%BF%E9%97%AEHive">指定用户名</a>，否则以匿名用户登录，没有写入权限。</p>
<h5 id="参考文献-15"><a class="header" href="#参考文献-15">参考文献</a></h5>
<ol>
<li><a href="https://cwiki.apache.org/confluence/display/Hive/GettingStarted">Hive Getting Started Guide</a></li>
<li><a href="https://cwiki.apache.org/confluence/display/Hive/Setting+Up+HiveServer2">AdminManual SettingUpHiveServer</a></li>
<li><a href="https://cwiki.apache.org/confluence/display/Hive/HiveServer2+Clients">HiveServer2 Clients</a></li>
</ol>
<h2 id="hbase"><a class="header" href="#hbase">HBase</a></h2>
<blockquote>
<p>Java版本：JDK8。</p>
</blockquote>
<pre><code class="language-shell">vi hbase-env.sh
export JAVA_HOME=/usr/jdk64/jdk1.8.0_112
</code></pre>
<h3 id="安装部署"><a class="header" href="#安装部署">安装部署</a></h3>
<h4 id="测试-3"><a class="header" href="#测试-3">测试</a></h4>
<h5 id="单机运行"><a class="header" href="#单机运行">单机运行</a></h5>
<h5 id="伪分布式运行"><a class="header" href="#伪分布式运行">伪分布式运行</a></h5>
<h4 id="分布式部署"><a class="header" href="#分布式部署">分布式部署</a></h4>
<p><a href="https://hbase.apache.org/book.html#quickstart">Apache HBase ™ Reference Guide</a></p>
<p><a href="https://hbase.apache.org/book.html#zookeeper">Apache HBase ™ Reference Guide -- ZooKeeper</a></p>
<h2 id="spark"><a class="header" href="#spark">Spark</a></h2>
<blockquote>
<p><strong>Apache Spark™</strong> is a unified analytics engine for large-scale data processing.</p>
</blockquote>
<img src="服务器/分布式大数据处理.assets/spark-stack.png" alt="img" style="zoom:45%;" />
<h3 id="框架概览"><a class="header" href="#框架概览">框架概览</a></h3>
<p>Spark程序是运行在一个集群上的<strong>相互独立的程序集</strong>（<em>independent sets of processes</em>），由用户主程序（<em>driver program</em>）中的<code>SparkContext</code> 对象进行协调。<code>SparkContext</code>可以连接至多种集群管理器（<em>cluster managers</em>），例如Spark的独立集群管理器、Apache Mesos、<a href="https://zhuanlan.zhihu.com/p/54192454">Hadoop YARN</a>以及Kubernetes。建立连接后，Spark与集群节点上的执行器（<em>executors</em>）进行通信。</p>
<img src="服务器/分布式大数据处理.assets/spark-cluster-overview.png" alt="Spark cluster components" style="zoom:80%;" />
<blockquote>
<p>集群管理器负责应用程序间的资源分配。</p>
<p>执行器（Executor）是运行执行运算并储存结果的进程，每个应用程序有独立的执行器进程，并以多线程的方式运行计算任务（<em>Tasks</em>）。</p>
</blockquote>
<p>然后集群管理器将应用程序代码（传递给<code>SparkContext</code>的JAR或Python文件）发送给执行器。最后<code>SparkContext </code>将计算任务发送给执行器从而运行计算。</p>
<h5 id="应用部署模式"><a class="header" href="#应用部署模式">应用部署模式</a></h5>
<p><code>cluster</code>模式：driver程序在集群分配的主节点（如Hadoop集群的[ApplicationMaster](#Hadoop Framework)）中运行，客户端完应用提交后即退出。适用于提交位置与工作节点距离较远（当前独立模式不支持cluster模式下的Python应用提交）。</p>
<p><code>client</code>模式：提交的应用（driver程序）在客户端上运行，集群上的主节点仅用于向集群请求资源。适用于提交应用位置与工作节点接近（例如在同一网络中，<code>shell</code>属于client模式）。</p>
<h4 id="模块-2"><a class="header" href="#模块-2">模块</a></h4>
<h3 id="安装-33"><a class="header" href="#安装-33">安装</a></h3>
<p>选择稳定版的<a href="https://mirrors.tuna.tsinghua.edu.cn/apache/spark/spark-3.1.1/spark-3.1.1-bin-hadoop3.2.tgz">下载链接</a>，下载至本地并解压。Spark需要Java语言运行时。</p>
<blockquote>
<p><a href="https://spark.apache.org/releases/spark-release-3-0-0.html">Spark 3.0</a>已支持Java 11。</p>
<p>在Windows上运行Spark需要添加<a href="https://github.com/cdarlint/winutils">Hadoop工具包</a>模拟Hadoop集群，并配置环境变量。</p>
<pre><code class="language-powershell">$env:HADOOP_HOME=$WIN_UTILS_HOME/hadoop-VER
</code></pre>
<p>在Windows上运行Spark任务时，在任务结束后会出现异常<code>Exception while deleting Spark temp dir...</code>。这是由于Windows不允许删除正在被使用的文件。因此，只能在Spark程序推出后再进行清理。</p>
</blockquote>
<h4 id="pyspark安装配置"><a class="header" href="#pyspark安装配置">==PySpark安装配置==</a></h4>
<p>如果需要通过Python运行Spark程序，需要使用PySpark库。Spark发行版本自带Python库（模块位于<code>$SPARK_HOME/python</code>、命令行工具<code>pyspark</code>位于<code>$SPARK_HOME/bin</code>）。如果仅需要Python环境，可不安装Spark发行包，而是从Python源安装PySpark库（同样包括上述内容，并安装Java模块运行所需的<code>jar</code>包），并单独<a href="%E6%9C%8D%E5%8A%A1%E5%99%A8/%E5%88%86%E5%B8%83%E5%BC%8F%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86.html#%E9%85%8D%E7%BD%AESpark%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83">指定Spark配置目录</a>等相关环境变量。</p>
<blockquote>
<p>如果是通过Python环境启动Spark，需要提前配置<code>SPARK_HOME</code>环境变量，否则启动脚本以其所在位置（Python环境的<code>Scripts</code>或<code>bin</code>目录）为<code>SPARK_HOME</code>，从而找不到Spark的库。</p>
<pre><code class="language-shell">export SPARK_HOME=$PYTHON_HOME/lib/python3.10/site-packages/pyspark
</code></pre>
<pre><code class="language-powershell">$env:SPARK_HOME=$PYTHON_HOME/lib/python3.10/site-packages/pyspark
</code></pre>
</blockquote>
<p>运行Spark集群的所有节点都需要安装Python环境（<a href="%E6%9C%8D%E5%8A%A1%E5%99%A8/%E5%88%86%E5%B8%83%E5%BC%8F%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86.html#%E9%85%8D%E7%BD%AESpark%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83">客户端通过配置</a><code>spark.pyspark.python</code>或<code>PYSPARK_PYTHON</code>指定使用的Python环境路径），根据节点是否安装Spark发行包决定是采用Spark内置Pyspark发行包或在Python环境中安装PySpark。</p>
<pre><code class="language-shell">export PYSPARK_PYTHON=/usr/local/miniconda3/envs/dataproc/python
export PYSPARK_DRIVER_PYTHON=/opt/apps/miniconda3/envs/process/bin/python
</code></pre>
<blockquote>
<p>问题：<em><code>Exception: Python in worker has different version 2.7 than that in driver 3.7, PySpark cannot run with different minor versions.Please check environment variables PYSPARK_PYTHON and PYSPARK_DRIVER_PYTHON are correctly set.</code></em>。客户端程序和集群需要使用相同的Python版本。</p>
</blockquote>
<p>如果要使用Spark发行包自带的PySpark库，则在Python搜索路径中添加库文件所在路径：</p>
<pre><code class="language-shell">export PYTHONPATH=&quot;${SPARK_HOME}/python/:$PYTHONPATH&quot;
export PYTHONPATH=&quot;${SPARK_HOME}/python/lib/py4j-0.10.6-src.zip:$PYTHONPATH&quot;
</code></pre>
<blockquote>
<p>问题：<em><code>java.util.NoSuchElementException: key not found: _PYSPARK_DRIVER_CALLBACK_HOST</code></em>，<a href="https://stackoverflow.com/a/50988318/6571140">安装的<code>py4j</code>版本和Spark支持的版本不一致</a>。创建Python环境时，需要使用与Spark分发版内置Python库相同的版本，通过设置<code>PYTHONPATH</code>指定（参考<code>bin/pyspark</code>脚本）。</p>
<pre><code class="language-shell"># Name         Version        Build           Channel
py4j           0.10.9         pyh9f0ad1d_0    conda-forge
pyspark        3.1.2          pyh6c4a22f_0    conda-forge
</code></pre>
</blockquote>
<h4 id="单机测试"><a class="header" href="#单机测试">单机测试</a></h4>
<p><strong>测试Java/Scala环境</strong>：</p>
<pre><code class="language-sh">./bin/run-example SparkPi 10
</code></pre>
<blockquote>
<p><a href="%E6%9C%8D%E5%8A%A1%E5%99%A8/%E5%88%86%E5%B8%83%E5%BC%8F%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86.html#Spark-on-Yarn">未识别Hadoop的安装目录</a>，因此上述计算直接采用内置的java模块执行计算：<em>NativeCodeLoader: Unable to load native-hadoop library for your platform... using builtin-java classes where applicable</em>。</p>
</blockquote>
<p><strong>测试PySpark环境</strong>：</p>
<pre><code class="language-sh">./bin/spark-submit examples/src/main/python/pi.py 10
</code></pre>
<h4 id="配置spark运行环境"><a class="header" href="#配置spark运行环境">配置Spark运行环境</a></h4>
<p>配置系统环境变量，以方便调用Spark命令。</p>
<pre><code class="language-shell">export SPARK_HOME=/home/gary/apps/spark
export PATH=$PATH:${SPARK_HOME}/bin
export SPARK_CONF_DIR=${SPARK_HOME}/conf  # conf/spark-env.sh中的默认值
</code></pre>
<p>Spark的运行参数配置主要包括三个部分：</p>
<ul>
<li>
<p>Spark属性：用于运行Spark应用程序的参数（<code>conf/spark-default.conf</code>）；</p>
</li>
<li>
<p>Spark环境变量：继承系统环境变量，主要设置Spark集群相关环境变量（<code>conf/spark-env.sh</code>），在提交任务前加载；</p>
<blockquote>
<p>Spark on YARN in <code>cluster</code> mode: environment variables need to be set using the <code>spark.yarn.appMasterEnv.[EnvironmentVariableName]</code> property. Environment variables that are set in <code>spark-env.sh</code> will not be reflected in the YARN Application Master process in <code>cluster</code> mode. </p>
</blockquote>
</li>
<li>
<p><code>conf/log4j.properties</code>：控制日志。</p>
<pre><code class="language-shell">log4j.rootCategory=WARN, console               # 后台日志 WARN ==&gt; INFO
log4j.logger.org.apache.spark.repl.Main=WARN   # spark shell 日志级别
</code></pre>
<p>还可指定其他文件作为任务运行时的日志配置文件：</p>
<pre><code class="language-shell">spark-submit --conf &quot;spark.driver.extraJavaOptions=-Dlog4j.configuration=file:log4j.properties&quot;
</code></pre>
</li>
</ul>
<p><strong>Spark属性</strong>：可通过配置文件、<a href="%E6%9C%8D%E5%8A%A1%E5%99%A8/%E5%88%86%E5%B8%83%E5%BC%8F%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86.html#%E6%8F%90%E4%BA%A4%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F">命令行参数</a>、<a href="%E6%9C%8D%E5%8A%A1%E5%99%A8/%E5%88%86%E5%B8%83%E5%BC%8F%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86.html#%E7%BC%96%E5%86%99%E5%BC%95%E7%94%A8%E7%A8%8B%E5%BA%8F">程序</a>中通过<code>SparkConf</code>设置。在提交应用程序时，后者具有更高优先级。</p>
<blockquote>
<p>在Client模式下，关于Client资源分配的属性无法通过程序设置，例如“<code>spark.driver.memory</code>”。这些属性在Client启动时已经确定，无法动态更改，因此需要由配置文件或命令行参数提供。</p>
<p><code>--conf spark.prop=value</code>：从命令行参数设置配置文件中的配置项；
<code>--properties-file</code>：指定配置文件（默认为<code>conf/spark-default.conf</code>）；</p>
</blockquote>
<h5 id="任务执行模式"><a class="header" href="#任务执行模式">任务执行模式</a></h5>
<p><code>spark.master</code>(<code>--master</code>)：集群地址；</p>
<p><code>spark.submit.deployMode</code>（<code>--deploy-mode</code>）：<a href="%E6%9C%8D%E5%8A%A1%E5%99%A8/%E5%88%86%E5%B8%83%E5%BC%8F%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86.html#%E8%BF%90%E8%A1%8CSpark%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F">任务提交</a>模式<code>cluster</code>或<code>client</code>；</p>
<h5 id="执行器环境变量"><a class="header" href="#执行器环境变量">执行器环境变量</a></h5>
<p><code>spark.executorEnv.[EnvironmentVariableName]</code>：当系统自动设置的环境变量不正确时，可设置此类环境变量。</p>
<blockquote>
<p><code>spark.executorEnv.PYTHONPATH</code>：执行节点的Python<a href="%E6%9C%8D%E5%8A%A1%E5%99%A8/../Python/Python%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80.html#%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83">附加库搜索路径</a>。</p>
</blockquote>
<h5 id="spark任务路径和文件"><a class="header" href="#spark任务路径和文件">Spark任务路径和文件</a></h5>
<p><code>spark.{driver|executor}.extraClassPath</code> (<code>--driver-class-path</code>，执行器无对应选项)：<em>Extra <a href="%E6%9C%8D%E5%8A%A1%E5%99%A8/../Java/JAVA%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80.html#%E6%90%9C%E7%B4%A2%E5%A4%96%E9%83%A8%E7%B1%BB%EF%BC%88CLASSPATH%EF%BC%89">classpath</a> entries to ==prepend== to the classpath of the driver.</em>
<code>spark.jars</code>（<code>--jars</code>）：从给定源读取并复制到每个<code>SparkContext</code>的工作目录下（Yarn模式支持自动清理，独立模式可配置<code>spark.worker.cleanup.appDataTtl</code>清理），文件的URL格式（==使用逗号分隔多个文件==，不支持路径展开，<strong>重复提供该选项不会叠加而是覆盖</strong>）：</p>
<ul>
<li>
<p><code>file:/path/to/file</code>：集群节点从主程序（driver）内置的<strong>HTTP</strong>文件服务拉去拉取文件（即Driver所在节点的文件，==绝对路径标识==）；</p>
<blockquote>
<p><code>file://path/to/file</code>不是合法的路径标识，应该为<code>file:/</code>或<code>file:///</code>。</p>
</blockquote>
</li>
<li>
<p><code>{hdfs|http|https|ftp}://server:port/path</code>：集群节点从相应的URI获取文件（如果在<em>Spark-on-Yarn</em>模式下，HDFS可省略<code>server:port</code>，使用部署配置中的HDFS集群）；</p>
</li>
<li>
<p><code>local:/path</code>：集群工作节点上的文件（存在于每个集群节点）。</p>
<blockquote>
<p><a href="https://spark.apache.org/docs/latest/submitting-applications.html#advanced-dependency-management">Advanced Dependency Management - Spark uses the following URL scheme to allow different strategies for disseminating jars</a>.</p>
</blockquote>
</li>
</ul>
<p><code>spark.jars.packages</code>（<code>--packages</code>）：driver和executor需要使用的位于Maven仓库的<code>jar</code>包（逗号分隔列表），包名的格式为<code>groupId:artifactId:version</code>（可从中央仓库查找）。</p>
<p><code>spark.pyspark.python</code>：driver和executor使用的Python解释器（<code>PYSPARK_PYTHON</code>）。
<code>spark.pyspark.driver.python</code>：Driver单独使用的Python解释器（<code>PYSPARK_DRIVER_PYTHON</code>）。
<code>spark.submit.pyFiles</code> (<code>--py-files</code>)：上传<code>.zip</code>, <code>.egg</code>, or <code>.py</code> 并添加到<code>PYTHONPATH</code>。</p>
<p><code>spark.files</code> (<code>--files</code>)：<em>list of files to be placed in the working directory of each executor.</em>
<code>spark.archives</code> (<code>--archives</code>)：将指定文件解压到每个执行器<code>SparkContext</code>工作目录下，支持格式包括<code>.jar</code>, <code>.tar.gz</code>, <code>.tgz</code> 和 <code>.zip</code>（使用<code>file.zip#directory</code> [<code>3.1.0</code>]指定档释放后存放的目录）。</p>
<p><code>spark.{driver|executor|yarn.am}.extraLibraryPath</code>：JVM加载的附加库目录，指定为执行节点上的本地路径（如<code>hadoop/lib/native</code>），<code>--driver-library-path</code>为驱动程序等效的命令行选项（执行器无对应选项）；</p>
<h5 id="网络配置-2"><a class="header" href="#网络配置-2">网络配置</a></h5>
<p><code>spark.driver.bindAddress</code>：<em>Hostname or IP address where to bind listening sockets.</em> (<code>SPARK_LOCAL_IP</code>)
<code>spark.driver.host</code>：<em>Hostname or IP address for the driver. This is used for communicating with the executors and ==the standalone Master==.</em></p>
<h5 id="应用配置-1"><a class="header" href="#应用配置-1">应用配置</a></h5>
<p><code>spark.app.name=none</code> (<code>--name</code>)
<code>spark.driver.maxResultSize=1g</code>：序列化结果的大小限制（0为无限制），受限于<code>spark.driver.memory</code>，同时需要考虑对象的内存占用量。
<code>spark.driver.supervise</code>：<em>If true, restarts the driver automatically if it fails with a non-zero exit status on Spark standalone mode or Mesos cluster deploy mode.</em>
<code>spark.python.worker.reuse</code>：<em>use a fixed number of Python workers, does not need to fork() a Python process for every task.</em> 
<code>spark.local.dir</code>：<em>including map output files and RDDs that get stored on disk. on a fast, local disk in your system.</em> 
<code>spark.driver.resource.{resourceName}.xxx</code>
<code>spark.executor.resource.{resourceName}.xxx</code></p>
<p>https://mapr.com/blog/resource-allocation-configuration-spark-yarn/</p>
<p>Spark SQL：</p>
<p>Spark Streaming：</p>
<p><a href="https://spark.apache.org/docs/latest/configuration.html">Configuration - Spark 3.1.2 Documentation (apache.org)</a></p>
<ul>
<li><a href="https://spark.apache.org/docs/2.3.0/configuration.html#environment-variables">Environment Variables - Configuration - Spark 2.3.0 Documentation (apache.org)</a></li>
</ul>
<h3 id="集群部署"><a class="header" href="#集群部署">集群部署</a></h3>
<p>Spark支持的部署模式及其主节点地址。</p>
<div class="table-wrapper"><table><thead><tr><th>Master URL</th><th>说明</th></tr></thead><tbody>
<tr><td><code>local[K]</code></td><td>本地使用<em>k</em>个工作线程运行spark，<code>local</code>等效于<code>local[1]</code>；<br/><code>local[*]</code>使用与机器逻辑处理相同数量的工作线程。</td></tr>
<tr><td><code>spark://HOST:PORT</code></td><td>连接至<a href="https://spark.apache.org/docs/latest/spark-standalone.html">spark独立集群</a>主节点（默认端口为7077）。</td></tr>
<tr><td><code>mesos://HOST:PORT</code></td><td></td></tr>
<tr><td><code>yarn</code></td><td>主节点（Resource Manger）地址在<code>yarn-site.xml</code>中给出。</td></tr>
<tr><td><code>k8s://HOST:PORT</code></td><td>连接至Kubernetes集群。</td></tr>
</tbody></table>
</div>
<p>默认主节点在<code>spark-default.conf</code><a href="%E6%9C%8D%E5%8A%A1%E5%99%A8/%E5%88%86%E5%B8%83%E5%BC%8F%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86.html#Spark%E5%B1%9E%E6%80%A7">文件</a>中给出。</p>
<pre><code class="language-sh">spark.master yarn
</code></pre>
<h4 id="spark-on-yarn"><a class="header" href="#spark-on-yarn">Spark on Yarn</a></h4>
<h5 id="配置运行环境"><a class="header" href="#配置运行环境">配置运行环境</a></h5>
<p>在hadoop yarn集群上运行Spark需要读取集群的配置文件，包括<code>core-site.xml</code>，<code>hdfs-site.xml</code>，<code>yarn-site.xml</code>和<code>hive-site.xml</code>等，因此需要在<code>conf/spark-env.sh</code>中配置这些配置文件的所在目录。</p>
<pre><code class="language-shell">export HADOOP_CONF_DIR=${HADOOP_HOME}/etc/hadoop
export YARN_CONF_DIR=${HADOOP_HOME}/etc/hadoop
</code></pre>
<p>通过<code>conf/spark-env.sh</code>配置运行应用实例的默认参数，这些参数也可以通过<code>conf/spark-default.conf</code>来设定。</p>
<blockquote>
<p><em>Spark context stopped while waiting for backend</em>：<em>可能是<a href="%E6%9C%8D%E5%8A%A1%E5%99%A8/%E5%88%86%E5%B8%83%E5%BC%8F%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86.html#Resource-Allocation-on-Yarn">虚拟内存分配</a>问题</em>。</p>
</blockquote>
<p>在没有设置<code>spark.yarn.jars</code>和<code>spark.yarn.archive</code>时，提交Spark应用时将给出提示并将从本地<code>spark/jars</code>目录搜索应用依赖的jar包并打包上传至yarn集群上的应用工作目录。为了避免应用多次运行造成重复上传，可以将上述目录中的所有文件<a href="%E6%9C%8D%E5%8A%A1%E5%99%A8/%E5%88%86%E5%B8%83%E5%BC%8F%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86.html#HDFS%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C">上传至HDFS</a>上，并通过<code>spark.yarn.jars</code>引用。此外，<code>spark.yarn.archive</code>设置时将覆盖<code>spark.yarn.jars</code>的设置，所有<code>jar</code>包应该在档案文件的根目录。</p>
<pre><code class="language-shell"># spark-default.conf
spark.yarn.jars    hdfs:///share/jars/spark/*.jar
spark.yarn.archive hdfs:///share/jars/spark-libs.jar
</code></pre>
<p><code>spark.yarn.jars</code>接受的参数格式与<a href="%E6%9C%8D%E5%8A%A1%E5%99%A8/%E5%88%86%E5%B8%83%E5%BC%8F%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86.html#Spark%E4%BB%BB%E5%8A%A1%E8%B7%AF%E5%BE%84%E5%92%8C%E6%96%87%E4%BB%B6"><code>spark.jars</code>要求格式</a>相同，并支持路径展开（参考CDH配置）。</p>
<blockquote>
<p>HDFS：可手动设置依赖包<a href="%E6%9C%8D%E5%8A%A1%E5%99%A8/%E5%88%86%E5%B8%83%E5%BC%8F%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86.html#%E8%AE%BE%E7%BD%AE%E6%96%87%E4%BB%B6%E7%9A%84%E5%89%AF%E6%9C%AC%E6%95%B0%E9%87%8F">副本数量设置</a>为与HDFS数据节点数相同，保证Spark任务无需从其他节点读取依赖包数据。设置该选项后，必须保证HDFS的相应路径下有运行Spark程序所需的包，否则程序无法启动。</p>
<p><code>spark.yarn.jars</code>不会应用到client部署模式下的客户端。因此，如果客户端有特殊需求的包（如数据库驱动<code>mysql-connector.jar</code>）可以放在客户端侧，或者通过<code>spark.jars</code>选项分发给客户端。</p>
<p><em>设置<code>spark.yarn.jars</code>后，该选项的值在配置中可能显示为空字符串，但实际已传递给集群（可查看Yarn应用的日志看到应用的依赖库已经链接到HDFS上的文件。</em></p>
</blockquote>
<h4 id="问题-6"><a class="header" href="#问题-6">问题</a></h4>
<p><strong>1. 远程启动Spark-Shell后出现超时或以客户端模式提交任务后无法执行。</strong></p>
<p>可能出现的错误信息：</p>
<pre><code>YarnScheduler: Initial job has not accepted any resources
RpcTimeoutException: Cannot receive any reply from HOSTNAME:PORT in 120 seconds.
RpcTimeoutException: Futures timed out after [120 seconds]
</code></pre>
<p>出现此错误是由于集群向客户端请求建立连接未完成。集群端正常情况下应该有以下日志：</p>
<pre><code class="language-sh">:Registering the ApplicationMaster
:Successfully created connection to CLIENTHOST/IP_ADDRESS:PORT after xx ms
</code></pre>
<p>在提交计算任务后，客户端会选择空闲端口（可配置）启动名为<code>NettyBlockTransferService</code>的服务（可通过客户端日志查看并通过<code>telnet</code>或<code>netstat</code>查看相应的IP地址和端口是否启动监听），当Spark集群为计算任务分配好资源后（<code>AM Container</code>和<code>Executor</code>），会向客户端的该服务发送确认信息。造成服务器与客户端连接不成功的原因可能是：</p>
<ol>
<li>
<p>客户端有多个网络接口（IP地址），而上述服务仅监听了其中一个地址。Spark使用的域名映射地址与监听地址不一致，故无法建立通信。因此修改Spark配置文件：</p>
<pre><code class="language-sh">spark.driver.bindAddress   192.168.137.1 	# 防止绑定到loopback地址
spark.driver.host          ws-gary        # 指定域名或主机名
spark.driver.port          (random)
</code></pre>
</li>
<li>
<p>如果将<code>spark.driver.host</code>设置为域名/主机名，则Hadoop集群在响应该客户端时必须能够解析该域名/主机名（修改集群每个节点的<code>hosts</code>文件，否则报<strong>未知主机异常</strong>，<em><code>UnknownHostException: hostname</code></em>）；也可将该配置项设置成客户端的IP地址，无需再设置<code>bindAddress</code>。</p>
</li>
<li>
<p>如果在WSL2中启动Spark客户端访问物理机局域网中的Yarn集群时，客户端默认绑定WSL的虚拟网卡IP地址；该地址与集群不在同一网络，因此Yarn调度器无法与客户端直接通信。因此需要在配置文件中指定客户端使用物理机的==域名/主机名==并配置物理机的端口转发规则（<a href="%E6%9C%8D%E5%8A%A1%E5%99%A8/../Windows/Windows%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86.html#WSL%E8%99%9A%E6%8B%9F%E7%BD%91%E7%BB%9C">WSL2需要配置端口转发</a>）。如果客户端配置域名/主机名与集群通信，则集群所有节点应配置该域名/主机名的解析地址。</p>
<pre><code class="language-ini">spark.driver.bindAddress   0.0.0.0
spark.driver.host          ws-gary
</code></pre>
</li>
<li>
<p>防火墙策略阻止了连接，修改防火墙策略以允许外部连接访问应用（<code>java</code>）或端口。在<code>Windows</code>上根据网络接口的网络类型（公用或专用）设置策略。</p>
</li>
</ol>
<p><strong>2. 未配置hadoop共享库的位置</strong>，<em><code>Unable to load native-hadoop library for your platform</code></em></p>
<p>在<code>conf/spark-env.sh</code>中配置：</p>
<pre><code class="language-shell">export LD_LIBRARY_PATH=${LD_LIBRARY_PATH}:${HADOOP_HOME}/lib/native
</code></pre>
<p><strong>3. 从HDFS读文件时找不到Hadoop依赖库</strong></p>
<p>出现*<code>Compression codec com.hadoop.compression.lzo.LzoCodec not found.</code>*：Hadoop使用的压缩库不在搜索路径中。需要将相应的库<code>hadoop-lzo-xxx.jar</code>从<code>HADOOP/share/hadoop/common/lib</code>==复制到spark的<code>jar</code>目录（和HDFS集群<code>spark.yarn.jars</code>目录==）。</p>
<h5 id="参考文献-16"><a class="header" href="#参考文献-16"><strong>参考文献</strong></a></h5>
<p><a href="https://www.linode.com/docs/databases/hadoop/install-configure-run-spark-on-top-of-hadoop-yarn-cluster/">Install, Configure, and Run Spark on Top of a Hadoop YARN Cluster</a></p>
<h4 id="独立spark集群"><a class="header" href="#独立spark集群">独立Spark集群</a></h4>
<h5 id="建立主节点"><a class="header" href="#建立主节点">建立主节点</a></h5>
<pre><code class="language-sh">./sbin/start-master.sh [-h,--host host] [-p port] [--webui-port PORT]
</code></pre>
<p>Spark默认使用主节点的主机名作为Spark服务的URL。这导致其他工作节点主机无法通过主机名或IP地址访问主节点。</p>
<blockquote>
<p>WARN Utils: Your hostname, ubuntu-vm resolves to a loopback address: 127.0.1.1; using 192.168.192.128 instead (on interface ens33)</p>
<pre><code class="language-sh">Active Internet connections (servers and established)
Proto Recv-Q Send-Q Local Address           Foreign Address         State
tcp6       0      0 ubuntu-vm:7077          [::]:*                  LISTEN
</code></pre>
<p>解决办法：</p>
<ol>
<li>
<p>执行命令时，指定主节点所使用的IP地址</p>
<pre><code class="language-sh">./sbin/start-master.sh --host IP_ADDR
</code></pre>
</li>
<li>
<p>删除<code>/etc/hosts</code>文件中的主机名映射，再启动服务</p>
</li>
<li>
<p>修改Spark配置文件<code>conf/spark-env.sh</code>关于节点IP的设置（<em>以上两种方式似乎会导致工作节点仍然访问hostname</em>）</p>
<pre><code class="language-sh">export SPARK_MASTER_HOST=IP_ADDR
export SPARK_LOCAL_IP=192.168.137.99
</code></pre>
<p>注意：当主机IP发生变化时要及时更新此处设置的IP地址，否则服务无法正常开启。</p>
<p>“<code>Service 'sparkDriver' could not bind on a random free port.</code>”</p>
</li>
</ol>
</blockquote>
<h5 id="建立工作节点"><a class="header" href="#建立工作节点">建立工作节点</a></h5>
<pre><code class="language-sh">./sbin/start-slave.sh &lt;master-spark-URL&gt;
</code></pre>
<p><a href="https://spark.apache.org/docs/latest/spark-standalone.html">Spark Standalone Mode - Spark 3.3.0 Documentation (apache.org)</a></p>
<h3 id="资源分配"><a class="header" href="#资源分配">资源分配</a></h3>
<p>在<a href="%E6%9C%8D%E5%8A%A1%E5%99%A8/./scripts/spark-default.conf"><code>spark-default.conf</code></a>中配置资源分配。</p>
<blockquote>
<p>在<code>conf/spark-defaul.conf</code>中配置的选项也可在<code>spark-env.sh</code>中配置：</p>
<pre><code class="language-shell">export SPARK_WORKER_OPTS=\
	&quot;-Dspark.executor.cores=2 \
	 -Dspark.executor.memory=512m&quot;
#内存分配可直接配置为环境变量
export SPARK_EXECUTOR_MEMORY=512M
export SPARK_DRIVER_MEMORY=512M
</code></pre>
</blockquote>
<h5 id="节点资源"><a class="header" href="#节点资源">节点资源</a></h5>
<p><strong>Yarn资源分配和调度</strong>：Spark任务包括执行计算的执行器和执行调度的Application Master。在cluster模式下，Application Master也是Client程序的容器。由于计算任务由Executor执行，而Executor映射到Yarn的容器，因此Executor的内存分配受到Yarn的容器内存分配规则（<a href="%E6%9C%8D%E5%8A%A1%E5%99%A8/./scripts/yarn-site.xml">最大/最小分配量</a>）<a href="%E6%9C%8D%E5%8A%A1%E5%99%A8/%E5%88%86%E5%B8%83%E5%BC%8F%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86.html#Spark%E8%B5%84%E6%BA%90%E8%B0%83%E5%BA%A6">限制</a>。</p>
<blockquote>
<p>Executor的内存分配与MapReduce任务内存分配无关。</p>
<p>https://mapr.com/blog/resource-allocation-configuration-spark-yarn/</p>
</blockquote>
<p><code>spark.python.worker.memory</code>：<em>memory to use per python worker process during aggregation. above this amount, spill the data into disks.</em></p>
<h5 id="任务资源"><a class="header" href="#任务资源">任务资源</a></h5>
<h6 id="任务资源需求"><a class="header" href="#任务资源需求">任务资源需求</a></h6>
<p><code>spark.executor.instances</code>（<code>--num-executors</code>，启动的执行器数量）：根据对执行器核心数的配置以及工作节点的计算资源总量，可创建多个执行器；</p>
<p><code>spark.cores.max </code>：设置任务在集群中可使用的计算单元数上限；未设置时，独立集群将其设置为<code>defaultCores</code>；而Mesos集群则默认是无穷（集群所有计算单元）。</p>
<ul>
<li><code>spark.deploy.defaultCores=10</code></li>
</ul>
<h6 id="cpu-5"><a class="header" href="#cpu-5">CPU</a></h6>
<p><code>spark.executor.cores</code> ：每个执行器所需计算核心数。默认情况：在独立模式或Mesos粗粒度模式下，执行器将占用工作节点的的所有核心；==在Yarn模式下占用1个核心==。</p>
<p><code>spark.yarn.am.cores</code> ：Yarn-Client模式下主程序CPU资源；
<code>spark.driver.cores</code> ：<strong>Cluster模式</strong>下Client程序的CPU资源（<code>--driver-cores</code>）；</p>
<h6 id="内存-5"><a class="header" href="#内存-5">内存</a></h6>
<p><code>driver</code>内存总量计算方式：<code>driver.memory</code>+<code>driver.memoryOverhead</code>，上限不超过底层容器的<a href="%E6%9C%8D%E5%8A%A1%E5%99%A8/%E5%88%86%E5%B8%83%E5%BC%8F%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86.html#Yarn%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D%E5%92%8C%E8%B0%83%E5%BA%A6">最大内存容量</a>。<code>memoryOverhead</code>为虚拟机开销等其他本地开销（<code>driverMemory*0.1</code>, ==最小384MB==，在YARN, Mesos and Kubernetes上支持该选项）。</p>
<blockquote>
<p>驱动程序内存开销和JVM的额外开销（<em>VM overheads, interned strings, other native overheads......This option is currently supported on YARN, Mesos and Kubernetes.</em>）；</p>
</blockquote>
<ul>
<li><code>spark.yarn.am.{memory|memoryOverhead}</code> ：Yarn-Client模式下主程序内存资源开销；</li>
<li><code>spark.driver.{memory|memoryOverhead}</code> ：Cluster模式下Client程序（包括Application Master）的内存资源开销（<code>--driver-memory</code>）；</li>
</ul>
<p><code>executor</code>的内存总量为（YARN and Kubernetes上支持<code>memoryOverhead</code>）：<code>memoryOverhead</code>+<code>memory</code>+<code>offHeap.size</code>+<code>pyspark.memory</code>。</p>
<ul>
<li><code>spark.executor.{memory|memoryOverhead}</code> ：（<code>--executor-memory</code>）</li>
<li><code>spark.executor.pyspark.memory*</code>（<code>2.4.0</code>）：</li>
</ul>
<blockquote>
<p>内存分配不足：<em>System memory XXX must be at least 471859200. Please increase heap size using the <code>--driver-memory</code> option or <code>spark.driver.memory</code> in Spark configuration.</em> 根据提示至少应该提供需要450MB内存，但实际设置这么多仍然不够，可根据提示的可用数量反推比例并给出满足需求的最小内存。</p>
</blockquote>
<h3 id="任务调度"><a class="header" href="#任务调度">任务调度</a></h3>
<p><code>spark.scheduler.mode=FIFO|FAIR </code>
<code>spark.task.cpus</code>
<code>spark.cores.max</code>：
<code>spark.yarn.queue</code> (<code>--queue</code>)</p>
<p>设置任务提交到<a href="%E6%9C%8D%E5%8A%A1%E5%99%A8/%E9%85%8D%E7%BD%AE%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%BF%90%E8%A1%8C%E6%A8%A1%E5%BC%8F">Yarn的队列</a>中：（<code>spark.yarn.queue</code>或<code>--queue QUEUE_NAME</code>，默认为<code>default</code>）。</p>
<h5 id="应用程序内部任务调度"><a class="header" href="#应用程序内部任务调度">应用程序内部任务调度</a></h5>
<p>每个应用可包含多个任务。https://spark.apache.org/docs/latest/job-scheduling.html</p>
<p>FIFO</p>
<pre><code class="language-sh">spark.scheduler.mode FIFO   # FAIR
spark.task.cpus 1
</code></pre>
<p>fair sharing: Spark assigns tasks between jobs in a “round robin” fashion.</p>
<p>Fair Scheduler Pools: grouping jobs into <em>pools</em> with different weights</p>
<h5 id="调度策略"><a class="header" href="#调度策略">调度策略</a></h5>
<p>https://spark.apache.org/docs/latest/job-scheduling.html</p>
<p>http://hadoop.apache.org/docs/current/hadoop-yarn/hadoop-yarn-site/FairScheduler.html</p>
<p>http://hadoop.apache.org/docs/current/hadoop-yarn/hadoop-yarn-site/CapacityScheduler.html</p>
<h5 id="动态资源分配"><a class="header" href="#动态资源分配">动态资源分配</a></h5>
<p><a href="https://spark.apache.org/docs/latest/job-scheduling.html#dynamic-resource-allocation">多个应用可共享集群资源</a>，按需申请资源。在粗粒度集群管理器中可用，包括standalone、Mesos，yarn。</p>
<pre><code class="language-sh">spark.dynamicAllocation.enabled  false
</code></pre>
<h3 id="运行spark应用程序"><a class="header" href="#运行spark应用程序">运行Spark应用程序</a></h3>
<h4 id="提交应用程序"><a class="header" href="#提交应用程序">提交应用程序</a></h4>
<p>提交程序：<code>./bin/spark-submit</code>脚本用于向集群提交并<a href="https://spark.apache.org/docs/latest/submitting-applications.html">启动应用程序</a>，并动态配置应用程序参数。默认的<a href="%E6%9C%8D%E5%8A%A1%E5%99%A8/%E5%88%86%E5%B8%83%E5%BC%8F%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86.html#%E5%BA%94%E7%94%A8%E9%83%A8%E7%BD%B2%E6%A8%A1%E5%BC%8F">应用部署模式</a>可在<a href="%E6%9C%8D%E5%8A%A1%E5%99%A8/%E5%88%86%E5%B8%83%E5%BC%8F%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86.html#Spark%E5%B1%9E%E6%80%A7"><code>spark-default.conf</code></a>中给出。</p>
<pre><code class="language-bash">./bin/spark-submit \				  # from spark root folder
  --master &lt;master-url&gt; \		
  --deploy-mode &lt;deploy-mode&gt; \ # client | cluster
  --name AppName                # 应用程序名称
  --class &lt;main-class&gt; \        # entry point: full java class name
  --conf &quot;&lt;key&gt;=&lt;value&gt;&quot; \      # spark.yarn.queue=root.share
  #...other options
  &lt;application-jar&gt;|app.py \    # application and dependencies
  [application-arguments]
</code></pre>
<p>该脚本程序实际上是封装了Spark的<a href="https://github.com/apache/spark/blob/master/launcher/src/main/java/org/apache/spark/launcher/Main.java">启动器</a><code>org.apache.spark.launcher.Main</code>，用于处理输入参数（利用<code>SparkSubmitCommandBuilder</code>生成）和设置运行环境：</p>
<pre><code class="language-shell">java -Xmx128m -cp &quot;jars/*&quot; org.apache.spark.launcher.Main &quot;$@&quot;
</code></pre>
<h5 id="命令行配置"><a class="header" href="#命令行配置">命令行配置</a></h5>
<p><code>spark-shell</code>和<code>spark-submit</code>支持命令行参数作为选项，或通过<code>--conf</code>选项按配置文件中的格式设置。可以通过<code>spark-submit --help</code>获取可配置选项。</p>
<ul>
<li><code>--class</code>：仅在程序包含多个默认入口主函数，且在项目文件未指明入口函数时使用；</li>
</ul>
<h6 id="打包依赖项"><a class="header" href="#打包依赖项">打包依赖项</a></h6>
<p>Java：将依赖项打包在应用程序的jar文件中，或者使用<code>--jars JARS</code>选项（以逗号分隔）将已封装好的jar包传输至集群（自动添加到应用程序环境的<code>CLASSPATH</code>中）。</p>
<p>Python：使用<code>--py-files PY_FILES</code>参数添加<code>.py</code>，<code>.zip</code>，<code>.egg</code>类型的文件。集群模式下主程序运行于集群节点上，其依赖的Python文件上传需要上传至集群节点。</p>
<blockquote>
<p>Standalone集群不支持Python应用以cluster部署模式提交。</p>
<p><code>sc.addPyFiles(path_url)</code>：在会话中添加Python依赖文件，之后执行的所有任务均可使用。</p>
</blockquote>
<p><a href="%E6%9C%8D%E5%8A%A1%E5%99%A8/%E5%88%86%E5%B8%83%E5%BC%8F%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86.html#Spark%E4%BB%BB%E5%8A%A1%E8%B7%AF%E5%BE%84%E5%92%8C%E6%96%87%E4%BB%B6">本地文件将上传到集群</a>各节点的工作目录。</p>
<h5 id="使用交互环境"><a class="header" href="#使用交互环境">使用交互环境</a></h5>
<p>交互环境本身即是一个Spark应用程序，包括Java/Scala交互环境、Python交互环境等。交互环境的启动命令支持与<code>spark-submit</code>相同的选项。</p>
<ul>
<li>
<p>Java/Scala交互环境</p>
<pre><code class="language-shell">./bin/spark-shell [--master MASTER_URL]
#&gt;:q   # execute CLI
</code></pre>
<blockquote>
<p>将<code>spark/bin</code>加入<code>$PATH</code>后，可以从任意位置执行命令。</p>
</blockquote>
</li>
<li>
<p>Python交互环境</p>
<pre><code class="language-shell">./bin/pyspark --master spark://IP:PORT
# =&gt; bin/spark-submit pyspark-shell-main --name PySparkShell &quot;$@&quot;
</code></pre>
<blockquote>
<p><code>pyspark</code>交互环境会将Spark分发的Python包加入搜索路径（优先搜索）；</p>
</blockquote>
</li>
</ul>
<h4 id="编写应用程序"><a class="header" href="#编写应用程序">编写应用程序</a></h4>
<p>可以使用Maven编译Java应用（<code>jar</code>）。将Master URL传递给<code>SparkContext</code>构造对象。</p>
<h5 id="java代码"><a class="header" href="#java代码">Java代码</a></h5>
<pre><code class="language-java">SparkConf conf = new SparkConf()
    .setMaster(&quot;local[2]&quot;)
    .setAppName(&quot;SparkExample&quot;);
SparkContext = new SparkContext(conf);
</code></pre>
<p>或者</p>
<pre><code class="language-java">import org.apache.spark.sql.SparkSession;
import org.apache.spark.sql.Dataset;
public class SimpleApp {
  public static void main(String[] args) {
    SparkSession spark = SparkSession.builder().appName(&quot;App&quot;).getOrCreate();
    // do your querying
    spark.stop();   //spark.close()
  }
}
</code></pre>
<p>使用Maven为项目添加<code>spark-sql</code>依赖：</p>
<pre><code class="language-xml">&lt;dependency&gt; &lt;!-- Spark dependency --&gt;
  &lt;groupId&gt;org.apache.spark&lt;/groupId&gt;
  &lt;artifactId&gt;spark-sql_2.12&lt;/artifactId&gt;
  &lt;version&gt;2.4.5&lt;/version&gt;
  &lt;scope&gt;provided&lt;/scope&gt;
&lt;/dependency&gt;
</code></pre>
<h5 id="python代码"><a class="header" href="#python代码">Python代码</a></h5>
<p>通过构建[<code>SparkContext</code>](Spark Python API.md#底层API)或[<code>SparkSession</code>](Spark Python API.md#Spark会话)开始编写Spark程序。Python代码提交：</p>
<pre><code class="language-shell">spark-submit --deploy-mode cluster \
  --conf spark.pyspark.python=.../envs/data/bin/python \  
  pyspark_sql.py
</code></pre>
<p>除了<a href="%E6%9C%8D%E5%8A%A1%E5%99%A8/%E5%88%86%E5%B8%83%E5%BC%8F%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86.html#%E6%8F%90%E4%BA%A4%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F">标准的提交方式</a>（<code>spark-submit</code>），可直接用Python解释器执行程序（默认Client模式）。</p>
<h3 id="与zookeeper集成"><a class="header" href="#与zookeeper集成">与ZooKeeper集成</a></h3>
<h4 id="高可用性"><a class="header" href="#高可用性">高可用性</a></h4>
<p>Standby Masters with ZooKeeper</p>
<p>Single-Node Recovery with Local File System</p>
<h2 id="管理控制"><a class="header" href="#管理控制">管理控制</a></h2>
<h3 id="监控程序"><a class="header" href="#监控程序">监控程序</a></h3>
<pre><code class="language-sh">hdfs dfsadmin -report   
yarn node -list
yarn application -list
yarn application -status app_id
jps | grep -v JPS		# 查看节点上运行的相关进程 JDK required
</code></pre>
<h4 id="hadoop端口信息"><a class="header" href="#hadoop端口信息">Hadoop端口信息</a></h4>
<div class="table-wrapper"><table><thead><tr><th>服务</th><th>默认端口</th><th>说明</th></tr></thead><tbody>
<tr><td>HDFS NameNode</td><td>9000</td><td><code>fs.defaultFS</code></td></tr>
<tr><td></td><td>9870</td><td>HDFSWeb服务端口<code>*</code></td></tr>
<tr><td></td><td>50090</td><td>SecondaryNameNode</td></tr>
<tr><td>Yarn</td><td>8030</td><td>资源调度器</td></tr>
<tr><td></td><td>8031</td><td>资源追踪器<code>resource-tracker</code></td></tr>
<tr><td></td><td>8032</td><td>资源管理</td></tr>
<tr><td></td><td>8033</td><td></td></tr>
<tr><td></td><td>8088</td><td>Web服务端口</td></tr>
<tr><td></td><td>19888</td><td>任务历史Web应用<br /><code>mapreduce.jobhistory.webapp.address</code></td></tr>
<tr><td></td><td>10020</td><td>任务历史<br /><code>mapreduce.jobhistory.address</code></td></tr>
<tr><td>Hive</td><td>9083</td><td>Metastore</td></tr>
<tr><td></td><td>10000</td><td><code>jdbc</code>接口</td></tr>
<tr><td></td><td>10002</td><td>Web管理服务端口</td></tr>
</tbody></table>
</div>
<blockquote>
<p><code>*</code>：2.x版本为50070。</p>
</blockquote>
<h5 id="集群的网页"><a class="header" href="#集群的网页">集群的网页</a></h5>
<p>可查看Hadoop集群应用的配置信息。</p>
<pre><code class="language-sh">http://hadoop-namenode:9870   # dfs.namenode.http-address [50070-2.x]
http://resource-manager:8088  # yarn cluster
http://hadoop-namenode:10002  # hive web
</code></pre>
<h4 id="spark状态监控"><a class="header" href="#spark状态监控">Spark状态监控</a></h4>
<p>http://driver-node:4040：通过web访问运行任务的信息。通过<code>Environment</code>选项卡可查看应用的配置信息（仅展示通过上述方式设置过的参数）。</p>
<p>http://master-node:8080：访问主节点的运行信息。</p>
<p>http://worker-node:8081：访问工作节点的运行信息。</p>
<p>http://history-server:18080 ： </p>
<h3 id="任务管理"><a class="header" href="#任务管理">任务管理</a></h3>
<p>结束正在运行的任务：</p>
<pre><code class="language-shell">yarn application -kill application_1450259063324_0001
</code></pre>
<h2 id="数据处理-2"><a class="header" href="#数据处理-2">数据处理</a></h2>
<h3 id="hive数据"><a class="header" href="#hive数据">Hive数据</a></h3>
<p>Hive数据查询模式：</p>
<ul>
<li>Hive（<code>Hiveserver2</code>）：使用自身的SQL引擎，MapReduce作为计算引擎；</li>
<li>SparkSQL with Hive：SparkSQL使用Spark提供的SQL引擎，并使用Spark作为计算引擎。由于Spark的计算在内存中进行，因此相比MapReduce，可以显著提升计算效率。Spark读取的数据在内存中以RDD/DataSet的形式加载；
<ul>
<li>Spark JDBC server：基于SparkSQL with Hive运行的服务；客户端通过<code>jdbc:hive2</code>接口提交查询和计算并获取输出数据；</li>
</ul>
</li>
<li>Hive on Spark：使用Hive SQL引擎，Spark作为计算引擎。</li>
</ul>
<p><a href="https://www.cnblogs.com/lixiaochun/p/9446350.html">Hive，Hive on Spark和SparkSQL区别 - 李晓春 - 博客园 (cnblogs.com)</a></p>
<h4 id="sparksql-with-hive"><a class="header" href="#sparksql-with-hive">SparkSQL with Hive</a></h4>
<p>Spark要访问Hive的数据，需要获取<code>metastore</code>数据库的访问方式。<strong>Spark不需要与Hive部署在同一主机上</strong>，仅需要配置Hive信息以及数据库驱动程序。Spark-shell使用上述配置方式中暴露的网络接口<a href="%E6%9C%8D%E5%8A%A1%E5%99%A8/%E5%88%86%E5%B8%83%E5%BC%8F%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86.html#%E8%AE%BF%E9%97%AEHive">访问Hive</a>。当Spark未与任何数据仓库连接，会在本地当前工作目录创建一个数据仓库。</p>
<p>通过<code>conf/spark-default.conf</code>配置连接属性。以<code>metastore</code>使用MySQL为例：</p>
<ol>
<li>
<p>将<code>$HIVE_HOME/conf/hive-site.xml</code>、<code>core-site.xml</code> (安全配置)和<code>hdfs-site.xml</code>(HDFS配置)<strong>复制或链接</strong>到<code>$SPARK_HOME/conf</code>下；编写程序时，也可以通过以下方法在代码中设定访问Hive的方式。</p>
<pre><code class="language-scala">var spark = SparkSession
	.builder()
	.config(&quot;hive.metastore.uris&quot;, &quot;thrift://hadoop-master:9083&quot;)
	.enableHiveSupport()
	.getOrCreate()
</code></pre>
<blockquote>
<p>Hive配置名可以为：<code>[spark.[hadoop.]]hive.metastore.uris</code>。缺少<code>spark</code>开头的配置项会生成警告<em>Ignoring non-Spark config property</em>（仍有效）。</p>
</blockquote>
</li>
<li>
<p>配置访问Hive元数据的JDBC驱动（Spark的库中不包含）。需要将驱动包部署到<code>jar</code>目录下（可使用符号链接），或在<code>spark-default.conf</code>配置以下两个参数添加<code>jar</code>包到搜索路径（==不能使用HDFS路径==）。</p>
<pre><code class="language-sh">spark.executor.extraClassPath /path/mysql-connector-xxx.jar
spark.driver.extraClassPath /path/mysql-connector-xxx.jar
</code></pre>
<p>或者直接引用相应版本的Hive依赖库目录（在其中添加JDBC驱动包）并配置。</p>
<pre><code class="language-shell">spark.sql.hive.metastore.jars  /path/hive-VERSION/*
</code></pre>
<blockquote>
<p>Spark已经内置derby驱动包，如果使用derby作为metastore服务，如果驱动不兼容则添加：</p>
<pre><code class="language-sh">spark.executor.extraClassPath /.../derby/lib/derbyclient.jar
spark.driver.extraClassPath   /.../derby/lib/derbyclient.jar
</code></pre>
</blockquote>
<blockquote>
<p>注意不要将整个<code>hive/lib</code>加入Spark的额外搜索路径，其中某些包与Spark不兼容。</p>
</blockquote>
</li>
<li>
<p>在完成相关设置后，<code>spark-shell</code>等内置应用能自动启用Hive读写。在<code>bin/beeline</code>可用于在<a href="%E6%9C%8D%E5%8A%A1%E5%99%A8/%E5%88%86%E5%B8%83%E5%BC%8F%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86.html#Beeline" title="Hiveserver2-CLI ">命令行访问Hive数据</a>（使用Hive配置）。</p>
</li>
</ol>
<p><strong><a href="https://stackoverflow.com/questions/47523575/messagehive-schema-version-1-2-0-does-not-match-metastores-schema-version-2-1/47624770">访问非默认版本Hive</a></strong>：Spark发行版自带的hive库仅可访问指定版本的hive（Hive Schema可能不兼容，例如Spark 3.2使用的Hive Schema为2.3），需要将目标系统上对应的Hive依赖库复制到Spark客户端，并在<code>spark-default.conf</code>中指定：</p>
<pre><code class="language-shell">spark.sql.hive.metastore.version        1.2.0
spark.sql.hive.metastore.jars           /usr/local/spark3/jars/hive-1.2.0/*
</code></pre>
<h4 id="thrift-jdbcodbc-server"><a class="header" href="#thrift-jdbcodbc-server">Thrift JDBC/ODBC server</a></h4>
<p>Spark-Shell默认支持访问metastore数据库服务（JDBC）的方式访问hive数据，或通过<code>thrift</code>服务访问hive数据库。要使用<code>jdbc:hive2:</code>的访问方式，需要配置连接JDBC服务。</p>
<pre><code class="language-java">import java.sql.*;
Connection con = DriverManager.getConnection(
   &quot;jdbc:hive2://localhost:10000/default&quot;, &quot;hiveuser&quot;, &quot;&quot;); // 连接HiveServer（on Spark）
Statement stmt = con.createStatement();
String tableName = &quot;testHiveDriverTable&quot;;
String sql = &quot;SHOW TABLES 'testHiveDriverTable'&quot;;
ResultSet res = stmt.executeQuery(sql);
</code></pre>
<p><strong>HiveServer on Spark</strong>：对应Hive内置的Hiveserver2服务（Thrift JDBC/ODBC server） ，但运行在Spark集群上，使用Spark任务代替MapReduce任务。</p>
<p><strong>Hive目录的权限问题</strong>：<em><code>root scratch dir on HDFS should be writable. Current permissions are: rwx------</code></em>。在HDFS上为Hive创建的临时目录的权限不正确，<a href="%E6%9C%8D%E5%8A%A1%E5%99%A8/%E5%88%86%E5%B8%83%E5%BC%8F%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86.html#Hive%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE">手动删除该目录</a>再尝试提交任务。</p>
<p><a href="https://blog.csdn.net/u013332124/article/details/90339850">Spark Thrift Server 架构和原理介绍</a></p>
<p><a href="https://cloud.tencent.com/developer/article/1437759">0643-Spark SQL Thrift简介 - 云+社区 - 腾讯云 (tencent.com)</a></p>
<p><a href="https://spark.apache.org/docs/latest/sql-distributed-sql-engine.html">Distributed SQL Engine - Spark 3.1.2 Documentation (apache.org)</a></p>
<h4 id="hive-on-spark"><a class="header" href="#hive-on-spark">Hive on Spark</a></h4>
<p><a href="https://cwiki.apache.org/confluence/display/Hive/Hive+on+Spark%3A+Getting+Started">Hive on Spark: Getting Started - Apache Hive - Apache Software Foundation</a></p>
<h3 id="elasticsearch-for-spark"><a class="header" href="#elasticsearch-for-spark">Elasticsearch for Spark</a></h3>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/hadoop/current/spark.html">Apache Spark support 7.14 | Elastic</a></p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/hadoop/current/reference.html">Elasticsearch for Apache Hadoop 7.14 | Elastic</a></p>
<h4 id="配置-15"><a class="header" href="#配置-15">配置</a></h4>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/hadoop/5.1/configuration.html">Configuration | Elasticsearch for Apache Hadoop 5.1 </a></p>
<p>版本兼容性：注意选择与Spark内置Scala版本一致的<code>elasticsearch-spark</code>库。</p>
<ul>
<li>Spark 3.x内置Scala 2.12，<a href="https://mvnrepository.com/artifact/org.elasticsearch/elasticsearch-spark-30">Elasticsearch从7.12版本支持Scala 2.12</a>；</li>
<li>Spark 2.x内置Scala 2.10/2.11，<a href="https://mvnrepository.com/artifact/org.elasticsearch/elasticsearch-spark-20">选择对应版本的库</a>（可通过<code>spark-shell</code>查看内置Scala版本）；</li>
</ul>
<h4 id="读取数据-3"><a class="header" href="#读取数据-3"><a href="https://www.elastic.co/guide/en/elasticsearch/hadoop/current/configuration.html">读取数据</a></a></h4>
<pre><code class="language-python">es_options = {
   &quot;nodes&quot;: &quot;es_ndoe1,es_ndoe2,es_ndoe3&quot;,
   &quot;port&quot;: 9200,
   &quot;pushdown&quot;: true  # translate Spark SQL into Query DSL
}
df = spark.read.format(&quot;org.elasticsearch.spark.sql&quot;)\
               .options(**es_options)\
               .option(&quot;es.read.field.as.array.include&quot;,&quot;domain_id,domain_name&quot;)\
               .load(&quot;index_path&quot;)  # =&gt; es.resource
</code></pre>
<blockquote>
<p>无法表示为<code>options</code>关键字参数的选项名，可通过<code>option</code>方法单独指定。</p>
</blockquote>
<p>必要选项：</p>
<ul>
<li>
<p><code>es.resource/es.resource.read/es.resource.write</code>：数据索引，读取可指定多个索引（使用<code>,</code>分隔）或使用通配符；写入可使用基于数据字段生成的动态索引，例如：</p>
<pre><code class="language-shell">my-index/{media_type}
my-collection/{@timestamp|yyyy.MM.dd}  # 格式化时间字段
</code></pre>
</li>
<li>
<p><code>es.nodes,es.port</code>：集群地址，节点可单独指定端口；无需指定集群的所有节点，由<code>es</code>库自动发现。</p>
</li>
</ul>
<p>读取选项：</p>
<ul>
<li>
<p><code>es.read.field.include/exclude</code>：包括或排除读取的字段名列表（使用<code>,</code>分隔）；</p>
</li>
<li>
<p><code>es.read.source.filter</code>：<a href="https://www.elastic.co/guide/en/elasticsearch/hadoop/current/configuration.html#configuration-options-index">[5.4]新增</a>，选取数据字段；</p>
</li>
<li>
<p><code>es.read.field.as.array.include/exclude</code>：显式指定/排除一个或多个字段为序列类型，防止字段只有一个值而被推测为标量类型；可指定多维数<code>field_name:3</code>；<a href="https://stackoverflow.com/questions/49872218/spark-read-nested-array-from-elasticsearch">如果存在嵌套数组，应该单独声明</a>。</p>
</li>
<li>
<p><code>es.query</code>：查询语句，支持DSL语句（JSON文本，需要将Python字典转换为字符串类型）；</p>
<pre><code class="language-json">{ &quot;query&quot; : { &quot;term&quot; : { &quot;user&quot; : &quot;costinl&quot; } } }
</code></pre>
</li>
</ul>
<p>写入选项：</p>
<ul>
<li><code>es.write.operation=index|create|update|upsert</code>；<code>index</code>为默认值；</li>
<li><code>es.mapping</code></li>
</ul>
<h4 id="错误"><a class="header" href="#错误">错误</a></h4>
<ol>
<li>
<p><em>scala.MatchError: 2887535652 (of class java.lang.Long)</em>：数据中包含IP字段（该字段实际为整数<code>2887535652-&gt;172.28.76.112</code>）（==未复现==）；</p>
<p><strong>解决方法</strong>：丢弃IP字段。</p>
<pre><code class="language-scala">val df_valid = df.drop(&quot;collect_ip&quot;, &quot;dev_ip&quot;)
val df_valid = df.select(&quot;user_name&quot;, &quot;user_id&quot;, ...)
</code></pre>
</li>
<li>
<p><em><code>scala.MatchError: Buffer(default)...WARNING: Field &quot;xxx&quot; is backed by an array but the associated Spark Schema does not reflect this;</code></em>
<em><code> (use es.read.field.as.array.include/exclude)</code></em>：数据字段包含嵌套的序列对象，但未从数据自动解析为序列类型（由于数据为空或只有单个值）；</p>
<p><strong>解决方法</strong>：1）设置指定列转换序列对象；2）丢弃可能为序列的无用列。</p>
<pre><code class="language-shell">es.read.field.as.array.include author,client,project # spark-default.conf
</code></pre>
<blockquote>
<p>可在运行时配置该选项。</p>
</blockquote>
</li>
</ol>
<h3 id="kafka-streaming"><a class="header" href="#kafka-streaming">Kafka Streaming</a></h3>
<h4 id="安装kafka集成模块"><a class="header" href="#安装kafka集成模块">安装Kafka集成模块</a></h4>
<p>Kafka流处理模块作为Spark的可选插件需要单独安装：下载<code>spark-streaming-kafka-0-8-assembly.jar</code>到Spark的依赖库目录（如果使用Yarn模式，同步到HDFS）。该依赖库中已包含<code>kafka-client</code>等依赖库的字节码，因此不需要添加额外的依赖库引用。</p>
<blockquote>
<p>如果通过<code>spark-submit</code>提交任务且可连接Maven仓库，可以通过<code>--packages org.apache.spark:spark-streaming-kafka-0-8:2.4.6</code>选项从仓库下载依赖项。</p>
</blockquote>
<p><a href="https://spark.apache.org/docs/2.1.1/streaming-kafka-0-8-integration.html">Spark Streaming + Kafka Integration Guide</a></p>
<h5 id="spark和kafka版本选择"><a class="header" href="#spark和kafka版本选择"><a href="https://spark.apache.org/docs/2.4.7/streaming-kafka-integration.html">Spark和Kafka版本选择</a></a></h5>
<p><code>spark-streaming-kafka-0-8</code>从2.3版本开始被弃用，推荐使用<code>spark-streaming-kafka-0-10</code>（不提供Python API）。如果需要使用Python编写Kafka流处理程序，应该使用Spark 2.x+<code>spark-streaming-kafka-0-8</code>。此外，Spark 3.x支持<a href="%E6%9C%8D%E5%8A%A1%E5%99%A8/%E5%88%86%E5%B8%83%E5%BC%8F%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86.html#Kafka-Structured-Streaming%E6%A8%A1%E5%9D%97">结构化流处理</a>，可以切换使用<code>spark-sql-kafka</code>库以接入Kafka数据源。</p>
<blockquote>
<p>如果尝试PySpark 3.2+版本中引入Kafka库，会出现错误：<em><code>ModuleNotFoundError: No module named 'pyspark.streaming.kafka'</code></em>。</p>
</blockquote>
<h5 id="spark和kafka依赖冲突"><a class="header" href="#spark和kafka依赖冲突">Spark和Kafka依赖冲突</a></h5>
<p>问题：<em><code>java.lang.NoSuchMethodError: net.jpountz.lz4.LZ4BlockInputStream.&lt;init&gt;(Ljava/io/InputStream;Z)V</code></em>。Spark<code>spark-core</code>和Kafka<code>spark-streaming-kafka</code>同时依赖<code>net.jpountz.lz4</code>包，但两者分别打包了不同版本的依赖包，即Spark依赖库目录下的<code>lz4-java-1.4.0.jar</code>和<code>spark-streaming-kafka</code>包中的<code>net/jpountz/lz4</code>，后者版本较低且包含上述方法定义，因此导致上述错误（由于依赖库加载顺序不确定，部分时候也能够引用正确Spark下的正确版本）。</p>
<p>解决方法：删除<code>spark-streaming-kafka</code>包中的<code>net/jpountz/lz4</code>字节码目录，并修改<code>META-INF</code>目录下<code>spark-streaming-kafka-0-8_2.11/spark-streaming-kafka-0-8-assembly</code>关于<code>net.jpountz.lz4</code>的依赖声明：</p>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;net.jpountz.lz4&lt;/groupId&gt;
    &lt;artifactId&gt;lz4-java&lt;/artifactId&gt;
    &lt;version&gt;1.4.0&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<h4 id="kafka-structured-streaming模块"><a class="header" href="#kafka-structured-streaming模块">Kafka Structured Streaming模块</a></h4>
<p><a href="https://spark.apache.org/docs/latest/structured-streaming-kafka-integration.html">Structured Streaming + Kafka Integration Guide (Kafka broker version 0.10.0 or higher) - Spark 3.2.0 Documentation (apache.org)</a></p>
<p>需要安装<code>spark-sql-kafka</code>及其<a href="https://stackoverflow.com/a/61605574/6571140">附加依赖项</a>：</p>
<ul>
<li><code>spark-sql-kafka-0-10_SCALA_VERSION-SPARK_VERSION.jar</code>；</li>
<li><code>commons-pool2-2.8.0.jar</code>；</li>
<li><code>kafka-clients-2.0.1.jar</code>；</li>
<li><code>spark-token-provider-kafka-0-10_SCALA_VERSION-SPARK_VERSION[3.0+].jar</code>[optional]。</li>
</ul>
<blockquote>
<p><code>spark-sql-kafka</code>库和<code>spark-streaming-kafka</code>库存在冲突，不要放在同一搜索路径下。</p>
</blockquote>
<h2 id="kubernetes"><a class="header" href="#kubernetes">Kubernetes</a></h2>
<p>https://kubernetes.io/docs/concepts/overview/what-is-kubernetes/</p>
<h2 id="mesos"><a class="header" href="#mesos">Mesos</a></h2>
<img src="服务器/分布式大数据处理.assets/architecture3.jpg" alt="Mesos Architecture" style="zoom: 50%;" />
<h2 id="dask-1"><a class="header" href="#dask-1">Dask</a></h2>
<p><a href="https://docs.dask.org/en/latest/spark.html">Comparison to Spark — Dask documentation</a></p>
<img src="服务器/分布式大数据处理.assets/data_range_process.png" style="zoom: 60%;" />
<pre><code class="language-sh">conda install dask
pip install &quot;dask[complete]&quot;    # Install everything
</code></pre>
<p><a href="https://docs.dask.org/en/latest/scheduling.html">Scheduling — Dask documentation</a></p>
<blockquote>
<p><a href="https://docs.dask.org/en/latest/setup.html">Setup — Dask documentation</a></p>
</blockquote>
<p><a href="https://ml.dask.org/">Dask-ML — dask-ml 0.1 documentation</a></p>
<p><a href="https://docs.dask.org/en/latest/gpu.html">GPUs — Dask documentation</a></p>
<h3 id="运行环境-5"><a class="header" href="#运行环境-5">运行环境</a></h3>
<p>代码传播：修改依赖库的代码后，需要同步到所有节点（重启工作进程）；非依赖库代码在程序运行时同步到各工作进程。</p>
<h3 id="调度器设置"><a class="header" href="#调度器设置">调度器设置</a></h3>
<img src="服务器/分布式大数据处理.assets/collections-schedulers.png" alt="Dask collections and schedulers" style="zoom:80%;" />
<h4 id="单机调度器"><a class="header" href="#单机调度器">单机调度器</a></h4>
<p>无需设置，直接使用，Dask会在开始计算时启动本地进程/线程池。</p>
<pre><code class="language-python">import dask.dataframe as dd    # 本地单机执行
df = dd.read_csv(...)
df.x.sum().compute(scheduler=&quot;threads&quot;|&quot;processes&quot;|&quot;single-threaded&quot;)
</code></pre>
<ul>
<li>
<p><a href="%E6%9C%8D%E5%8A%A1%E5%99%A8/../Python/Python%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B.html#%E5%B9%B6%E8%A1%8C%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6">本地线程池</a>（<code>concurrent.futures.ThreadPoolExecutor</code>）</p>
<p><code>dask.array</code>, <code>dask.dataframe</code>, and <code>dask.delayed</code>的默认模式。由于在同一个进程中，任务间没有数据传输开销。但由于GIL的存在，只能提供non-Python代码的并行。</p>
<pre><code class="language-python">import dask
dask.config.set(scheduler='threads')  # overwrite global setting
</code></pre>
</li>
<li>
<p><a href="%E6%9C%8D%E5%8A%A1%E5%99%A8/../Python/Python%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B.html#%E8%BF%9B%E7%A8%8B%E6%B1%A0">本地进程池</a>（<code>concurrent.futures.ProcessPoolExecutor</code>）</p>
<p><code>dask.bag</code>的默认模式。任务及其依赖的数据传输到本地进程执行，再将结果返回主进程。即使纯Python代码（处理字符串、字典、列表等）也不受GIL限制。但是进程间来回传输数据代价增大，因此任务间数据交互少的情况下性能更好。</p>
<pre><code class="language-python">import dask.multiprocessing
dask.config.set(scheduler='processes')
</code></pre>
</li>
<li>
<p>单线程：用于调试（<code>scheduler='synchronous'</code>）。</p>
</li>
</ul>
<h5 id="设置调度模式"><a class="header" href="#设置调度模式">设置调度模式</a></h5>
<p>全局配置：</p>
<blockquote>
<p>必须放置在主模块<code>__main__</code>中，否则出现错误：</p>
<pre><code class="language-sh">RuntimeError: An attempt has been made to start a new process before the current process has finished its bootstrapping phase.
</code></pre>
</blockquote>
<p>使用上下文管理器：</p>
<pre><code class="language-python">with dask.config.set(scheduler='threads'):
    x.compute()
</code></pre>
<p>即时调用：</p>
<pre><code class="language-python">x.compute(scheduler='threads')
</code></pre>
<h4 id="单机分布式调度器"><a class="header" href="#单机分布式调度器">单机分布式调度器</a></h4>
<p>对于复杂工作负载，其中会产生大量中间结果，则推荐使用分布式调度器<code>dask.distributed</code>。分布式调度器可以在单机或集群运行。</p>
<p>分布式调度器包含更多特性，即使是单机运行也更偏向使用分布式模式。</p>
<ul>
<li>提供异步API，例如<code>Futures</code>；</li>
<li>提供诊断仪表板，查看性能和进度信息；</li>
<li>更加灵活有效地处理数据位置问题。</li>
</ul>
<p>分布式环境配置：https://docs.dask.org/en/latest/setup.html。</p>
<h5 id="预先配置计算资源池"><a class="header" href="#预先配置计算资源池">预先配置计算资源池</a></h5>
<pre><code class="language-shell">dask-scheduler --host $(hostname) --port 8786 \
    --dashboard-address &quot;localhost:8787&quot; --dashboard-prefix='/dask' \
    --pid-file dask-local-scheduler.pid \
    --scheduler-file dask-local-scheduler.info \
    &gt; /tmp/dask/local-scheduler.log \
    2&gt; /tmp/dask/local-scheduler.error.log &amp;
# kill -SIGKILL $(cat dask-local-scheduler.pid)  # 停止集群
dask-worker [tcp://]$(scheduler):8786 \
    --nthreads 4 --nprocs 10 --memory-limit 2GiB \
    --name dask-worker \
    --pid-file dask-worker.pid \
    --local-directory /var/local/dask \
    &gt; dask-local-worker.log &amp;
</code></pre>
<p>dask-scheduler日志量过大：<a href="%E6%9C%8D%E5%8A%A1%E5%99%A8/../Linux/Linux%E9%85%8D%E7%BD%AE%E5%92%8C%E7%AE%A1%E7%90%86.html#%E6%97%A5%E5%BF%97%E6%B8%85%E7%90%86">切分清理日志</a>。</p>
<h5 id="按需创建计算资源池"><a class="header" href="#按需创建计算资源池">按需创建计算资源池</a></h5>
<p>使用<code>Client</code>或<code>LocalCluster</code>在程序中按需创建本机集群。</p>
<pre><code class="language-python">from dask.distributed import Client,LocalCluster,Worker
if __name__ == &quot;__main__&quot;:
  client = Client(**kwrags)   # 自动创建本地集群
  cluster = LocalCluster(...) # 手动创建本地集群
  client = Client(cluster)
  df.x.sum().compute()        # 在本地集群上执行计算
</code></pre>
<p><strong>LocalCluster</strong>：在本地机器上创建调度器（<code>Scheduler</code>）和工作节点（<code>Worker</code>）。</p>
<pre><code class="language-python">LocalCluster(n_workers=None, 
             threads_per_worker=None, 
             processes=True, 
             host='localhost',   # scheduler listen address
             scheduler_port=0,   # 8786 as default, 0 for random
             dashboard_address=':8787',  # set to None to disable
             worker_dashboard_address='localhost:8787', # disabled by default
             service_kwargs=None, 
             **worker_kwargs)
</code></pre>
<ul>
<li><code>n_workers</code>：工作节点数量；</li>
<li><code>process</code>：是否使用进程构造工作节点；</li>
<li><code>threads_per_worker</code>：每个工作节点启动的线程数量；</li>
<li><code>host</code>：调取器监听地址；</li>
<li><code>dashboard_address</code>：仪表板地址；</li>
<li><code>scheduler_kwargs</code>：</li>
<li><code>worker_kwargs</code>：其余参数将传递给工作节点。</li>
</ul>
<p><strong>Worker</strong>：工作节点告知调度器其拥有的数据，并从调度器获取其他节点上的数据信息。</p>
<pre><code class="language-python">Worker(nthreads=None, memory_limit='auto', **kwargs)
</code></pre>
<ul>
<li><code>nthreads</code>：工作进程的线程数量。</li>
<li><code>memory_limit='2GB'|2e9|auto</code>：计算节点内存限定。<code>auto</code>按工作进程数分配系统内存作为可用内存上限。对于单机集群模式，当数据量很大时，工作节点占用内存将达到系统内存上限。但是由于系统中其他进程还要占据一定内存，由此导致工作节点无法分配足够内存而重启。解决方法是为工作节点设置固定内存上限，当内存达到与上限相关的门限时，会触发将不适用的数据写回磁盘，从而避免耗尽系统内存。</li>
</ul>
<h4 id="分布式调度器"><a class="header" href="#分布式调度器">分布式调度器</a></h4>
<h5 id="dask-with-ssh"><a class="header" href="#dask-with-ssh">Dask with SSH</a></h5>
<p>使用SSH自动创建集群。</p>
<pre><code class="language-shell">dask-ssh [OPTIONS] \
    --scheduler &lt;scheduler&gt; \ # Defaults to first host.
    --scheduler-port &lt;scheduler_port&gt;
    --nthreads &lt;nthreads&gt; --nprocs &lt;nprocs&gt; --memory-limit &lt;memory_limit&gt;
    --ssh-username &lt;ssh_username&gt; --ssh-port &lt;ssh_port&gt;
    --log-directory &lt;log_directory&gt;
    --local-directory &lt;local_directory&gt;
    --remote-python &lt;remote_python&gt;  # Python环境路径
    [HOSTNAMES]...
</code></pre>
<h5 id="dask-on-yarn"><a class="header" href="#dask-on-yarn">Dask on yarn</a></h5>
<p><a href="https://yarn.dask.org/en/latest/">Dask-Yarn — Dask Yarn documentation</a></p>
<h6 id="managing-python-environments"><a class="header" href="#managing-python-environments">Managing Python Environments</a></h6>
<p><a href="https://yarn.dask.org/en/latest/environments.html">Managing Python Environments — Dask Yarn documentation</a></p>
<h3 id="访问集群"><a class="header" href="#访问集群">访问集群</a></h3>
<p><strong>Client</strong>：<code>Client</code>将用户连接至Dask集群。<code>Client</code>初始化后接管程序中所有的<code>dask.compute</code> 、<code>dask.persist</code>等计算任务。</p>
<pre><code class="language-python">Client(address=None)
cli.close()      # 关闭连接
cli.shutdown()   # 关闭集群
</code></pre>
<ul>
<li><code>address</code>：调度器地址和端口，例如<code>'127.0.0.1:8786'</code>，或集群对象，例如<code>LocalCluster()</code>（本地集群环境，当不提供集群地址时，将自动创建一个<a href="%E6%9C%8D%E5%8A%A1%E5%99%A8/%E5%88%86%E5%B8%83%E5%BC%8F%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86.html#%E6%8C%89%E9%9C%80%E5%88%9B%E5%BB%BA%E8%AE%A1%E7%AE%97%E8%B5%84%E6%BA%90%E6%B1%A0"><code>LocalCluster</code></a>）。</li>
</ul>
<h4 id="集群信息"><a class="header" href="#集群信息">集群信息</a></h4>
<p><code>client.dashboard_link</code>：
<code>client.get_scheduler_logs(n=N)</code>
<code>client.has_what()</code>
<code>client.status</code>
<code>client.id</code>
<code>client.scheduler</code>
<code>client.scheduler_info()</code>
<code>client.ncores</code>
<code>client.nthreads</code></p>
<h2 id="vaex-1"><a class="header" href="#vaex-1">vaex</a></h2>
<p>https://vaex.readthedocs.io/en/latest/index.html</p>
<pre><code class="language-sh">pip install --upgrade vaex
conda install -c conda-forge vaex
</code></pre>
<h2 id="ray-1"><a class="header" href="#ray-1">ray</a></h2>
<h3 id="概念-1"><a class="header" href="#概念-1">概念</a></h3>
<h4 id="基础架构"><a class="header" href="#基础架构">基础架构</a></h4>
<blockquote>
<p><em>Ray Core provides a small number of core primitives (i.e., tasks, actors, objects) for building and scaling distributed applications.</em></p>
<p><a href="https://docs.ray.io/en/latest/ray-core/key-concepts.html">Key Concepts of Ray Core — Ray 2.0.0</a></p>
</blockquote>
<h5 id="ray-cluster"><a class="header" href="#ray-cluster">Ray Cluster</a></h5>
<blockquote>
<p><em>to run Ray applications on multiple nodes you must first deploy a Ray cluster.</em></p>
<p><img src="%E6%9C%8D%E5%8A%A1%E5%99%A8/%E5%88%86%E5%B8%83%E5%BC%8F%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86.assets/ray-cluster.svg" alt="" /></p>
<p><a href="https://docs.ray.io/en/latest/cluster/key-concepts.html">Key Concepts of Ray Clusters — Ray 2.0.0</a></p>
</blockquote>
<h5 id="数据处理模式"><a class="header" href="#数据处理模式">数据处理模式</a></h5>
<p><img src="%E6%9C%8D%E5%8A%A1%E5%99%A8/%E5%88%86%E5%B8%83%E5%BC%8F%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86.assets/dataset-loading-1.png" alt="../_images/dataset-loading-1.png" /></p>
<p><img src="%E6%9C%8D%E5%8A%A1%E5%99%A8/%E5%88%86%E5%B8%83%E5%BC%8F%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86.assets/dataset-loading-2.png" alt="../_images/dataset-loading-2.png" /></p>
<h5 id="支持的数据格式"><a class="header" href="#支持的数据格式">支持的数据格式</a></h5>
<p>CSV、JSON、Parquet、Numpy、Text、Spark/Dask/Python <code>DataFrame</code>、Python <code>object</code>、<code>ndarray</code>……；</p>
<p><a href="https://docs.ray.io/en/latest/data/getting-started.html#datasets-getting-started">Getting Started — Ray 2.0.0</a></p>
<p><a href="https://docs.ray.io/en/latest/data/key-concepts.html#data-key-concepts">Key Concepts — Ray 2.0.0</a></p>
<p><img src="%E6%9C%8D%E5%8A%A1%E5%99%A8/%E5%88%86%E5%B8%83%E5%BC%8F%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86.assets/dataset-arch.svg" alt="dataset-arch" /></p>
<p><img src="%E6%9C%8D%E5%8A%A1%E5%99%A8/%E5%88%86%E5%B8%83%E5%BC%8F%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86.assets/dataset-pipeline-2-mini.svg" alt="dataset-pipeline-2-mini.svg" /></p>
<p><a href="https://docs.ray.io/en/latest/data/user-guide.html#data-user-guide">User Guides — Ray 2.0.0</a></p>
<h3 id="安装-34"><a class="header" href="#安装-34">安装</a></h3>
<pre><code class="language-shell">conda create -n ray -c conda-forge ray-all  # 安装所有模块
pip install ray            # with minimal dependencies
pip install &quot;ray[default]&quot; # + the dashboard + cluster launcher
pip install &quot;ray[air]&quot;     # + dependencies for Ray AI Runtime
pip install &quot;ray[data]&quot;    #
pip install &quot;ray[serve]&quot;  # model-serving library    
</code></pre>
<blockquote>
<p><em><a href="https://docs.ray.io/en/latest/ray-overview/installation.html">Ray on Windows is currently in beta</a>.</em></p>
<p><em><a href="https://docs.ray.io/en/latest/ray-overview/installation.html">Python 3.10 support is currently experimental.</a></em></p>
<p><em>Ray conda packages are maintained by the community, not the Ray team. While using a conda environment, it is recommended to install Ray from PyPi using <code>pip install ray</code> in the newly created environment.</em></p>
</blockquote>
<p><a href="https://docs.ray.io/en/latest/cluster/vms/user-guides/launching-clusters/on-premises.html#on-prem">Launching an On-Premise Cluster — Ray 2.0.0</a></p>
<ul>
<li>It also assumes that Ray is installed on each machine. </li>
</ul>
<p><a href="https://docs.ray.io/en/latest/cluster/vms/user-guides/community/yarn.html">Deploying on YARN — Ray 2.0.0</a>(In progress)</p>
<h4 id="spark-on-ray"><a class="header" href="#spark-on-ray">Spark on Ray</a></h4>
<p><a href="https://docs.ray.io/en/latest/data/raydp.html#spark-on-ray">Using Spark on Ray (RayDP) — Ray 2.0.0</a></p>
<h4 id="dask-on-ray"><a class="header" href="#dask-on-ray">Dask on Ray</a></h4>
<p><a href="https://docs.ray.io/en/latest/data/dask-on-ray.html#dask-on-ray">Using Dask on Ray — Ray 2.0.0</a></p>
<h2 id="参考文献-17"><a class="header" href="#参考文献-17"><strong>参考文献</strong>：</a></h2>
<ol>
<li><a href="https://hadoop.apache.org/docs/stable/hadoop-project-dist/hadoop-common/SingleCluster.html">Hadoop: Setting up a Single Node Cluster.</a></li>
<li><a href="https://hadoop.apache.org/docs/stable/hadoop-project-dist/hadoop-common/ClusterSetup.html">Hadoop Cluster Setup</a></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cdh6大数据集群离线安装"><a class="header" href="#cdh6大数据集群离线安装">CDH6大数据集群离线安装</a></h1>
<h2 id="前言"><a class="header" href="#前言">前言</a></h2>
<p><strong>为什么要用离线的方式安装CDH6大数据集群</strong></p>
<p>CDH，全称Cloudera’s Distribution, including Apache Hadoop。是Hadoop众多分支中对应中的一种，由Cloudera维护，基于稳定版本的Apache Hadoop构建，提供了Hadoop的核心（可扩展存储、分布式计算），最为重要的是提供基于web的用户界面。</p>
<p>CDH的优点：版本划分清晰，更新速度快，支持Kerberos安全认证，支持多种安装方式（如Yum、rpm等）。</p>
<p>Cloudera公司最近在官网宣布：</p>
<pre><code>从2021年1月31日开始，所有Cloudera软件都需要有效的订阅，并且只能通过付费墙进行访问。
</code></pre>
<p><img src="%E6%9C%8D%E5%8A%A1%E5%99%A8/CDH6%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%9B%86%E7%BE%A4%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85.assets/202104151826512758.png" alt="在这里插入图片描述" /></p>
<p>也就是说CDH各版本都不能免费获取了。很多以前的文章、书籍中提到CDH大数据平台，都是会引用Cloudera官网下载地址，例如：https://archive.cloudera.com/cm6/6.2.0/redhat7/yum/RPMS/x86_64/</p>
<p>现在开始要输入账号密码认证了。用Cloudera的账号密码的话，会得到如下失败信息：</p>
<pre><code>403 Forbidden (varnish) the provided credentials were incorrect
</code></pre>
<p>说明没有权限获取CDH了。在Cloudera官网社区里有很多讨论。</p>
<p>解决办法如下：</p>
<ol>
<li>
<p>使用开源的Hadoop、Spark、Hive等分别安装；</p>
</li>
<li>
<p>使用自己或别人以前下载过的CDH安装包，共享使用，官网说的是CDH6.6以后收费，以前的还是可以使用。</p>
</li>
</ol>
<p>链接: https://pan.baidu.com/s/1ION1DoWnqpfVO_sBx0GpeA 提取码: rqyi</p>
<h2 id="下载安装包"><a class="header" href="#下载安装包">下载安装包</a></h2>
<p>CDH分为Cloudera Manager管理平台和CDH parcel（parcel包含各种组件的安装包）。</p>
<p>从共享的百度网盘链接将CDH安装包下载到本地工作机，如下所示：</p>
<pre><code>~/workspace$ 
tree CDH
CDH
├── CDH
│  ├── CDH-6.3.2-1.cdh6.3.2.p0.1605554-el7.parcel
│  ├── CDH-6.3.2-1.cdh6.3.2.p0.1605554-el7.parcel.sha1
│  ├── CDH-6.3.2-1.cdh6.3.2.p0.1605554-el7.parcel.sha256
│  └── manifest.json
├── ClouderaManager
├── cloudera-manager-agent-6.3.1-1466458.el7.x86_64.rpm
├── cloudera-manager-daemons-6.3.1-1466458.el7.x86_64.rpm
├── cloudera-manager-server-6.3.1-1466458.el7.x86_64.rpm
├── cloudera-manager-server-db-2-6.3.1-1466458.el7.x86_64.rpm
├── enterprise-debuginfo-6.3.1-1466458.el7.x86_64.rpm
└── oracle-j2sdk1.8-1.8.0+update181-1.x86_64.rpm
</code></pre>
<h2 id="编辑映射文件"><a class="header" href="#编辑映射文件">编辑映射文件</a></h2>
<pre><code>root@cdh001:~# vim /etc/hosts
</code></pre>
<p>在该文件中添加如下内容：</p>
<pre><code>172.18.48.175  cdh001.gary.com    cdh001
172.18.48.176  cdh002.gary.com    cdh002
172.18.48.177  cdh003.gary.com    cdh003
</code></pre>
<h2 id="配置ssh免密登录"><a class="header" href="#配置ssh免密登录">配置SSH免密登录</a></h2>
<p>1.执行以下命令，创建公钥和私钥。</p>
<pre><code>ssh-keygen -t rsa
</code></pre>
<p>2.将公钥拷贝到要免密登录的目标机器上</p>
<p>将公钥拷贝到本机</p>
<pre><code>for node in cdh001 cdh002 ...; do 
    ssh-copy-id -i ~/.ssh/id_rsa.pub $node
done
</code></pre>
<h2 id="编写集群分发脚本"><a class="header" href="#编写集群分发脚本">编写集群分发脚本</a></h2>
<p>1.需求：循环复制文件到所有节点的相同目录下
2.需求分析：
（a）期望脚本使用方法：</p>
<pre><code>xsync &lt;要同步的文件路径&gt;
</code></pre>
<p>3.脚本实现
（a）在/root目录下创建bin目录，并在bin目录下xsync创建文件，操作如下：在该文件中编写如下代码</p>
<pre><code class="language-shell">#!/bin/bash
#1获取输入参数个数，如果没有参数，直接退出
pcount=$#
if((pcount==0));then
    echo no args;
    exit;
fi
#2获取文件路径
p1=$1
fname=`basename $p1`
echo fname=$fname
#3获取上级目录到绝对路径
pdir=`cd -P $(dirname $p1);pwd
echo pdir=$pdir
#4获取当前用户名称
user=`whoami`
#5循环
for((num=2;num&lt;4;num++));do
    host=$(printf &quot;%03d&quot; &quot;$num&quot;)
    echo -------------------cdh$host--------------
    rsync -rvl $pdir/$fname $user@cdh$host:$pdir
done
</code></pre>
<p>（b）修改脚本xsync具有执行权限</p>
<pre><code>chmod u+x xsync
</code></pre>
<p>（c）调用脚本形式：</p>
<pre><code>xsync &lt;文件路径&gt;
</code></pre>
<p>（d）分发集群分发脚本</p>
<pre><code>xsync /usr/local/bin/xsync
</code></pre>
<p>（e）分发映射文件</p>
<pre><code>xsync /etc/hosts
</code></pre>
<h2 id="安装mysql主节点"><a class="header" href="#安装mysql主节点">安装MySQL(主节点)</a></h2>
<h3 id="下载并安装mysql"><a class="header" href="#下载并安装mysql">下载并安装mysql</a></h3>
<p>下载并安装</p>
<pre><code class="language-shell">wget -i -c http://dev.mysql.com/get/mysql57-community-release-el7-10.noarch.rpm
yum -y install mysql57-community-release-el7-10.noarch.rpm
yum -y install mysql-community-server
</code></pre>
<p>启动服务</p>
<pre><code>systemctl start mysqld
</code></pre>
<p>查看状态</p>
<pre><code>systemctl status mysqld
</code></pre>
<p>查看mysql临时密码</p>
<pre><code class="language-shell">grep &quot;password&quot; /var/log/mysqld.log
# 2021-04-15T07:31:51.264538Z 1 [Note] A temporary password is generated for root@localhost: LeuhBAe2ai,u
</code></pre>
<h3 id="登录后修改密码"><a class="header" href="#登录后修改密码">登录后修改密码</a></h3>
<p>尽量复杂一点，太简单了验证不通过，也可以查看如何关闭mysql校验规则</p>
<pre><code>[root@cdh001 ~]# mysql -u root -p
mysql&gt; set global validate_password_policy=0; 
Query OK, 0 rows affected (0.00 sec)
mysql&gt; set global validate_password_length=4;
Query OK, 0 rows affected (0.00 sec)
mysql&gt; ALTER USER 'root'@'localhost' IDENTIFIED BY 'Mysql@gang2019';
Query OK, 0 rows affected (0.01 sec)
mysql&gt; FLUSH PRIVILEGES;
Query OK, 0 rows affected (0.00 sec)
</code></pre>
<h3 id="重启服务并设置开机启动"><a class="header" href="#重启服务并设置开机启动">重启服务并设置开机启动</a></h3>
<pre><code>systemctl enable mysqld &amp;&amp; systemctl restart mysqld
</code></pre>
<h3 id="下载并安装jdbc-驱动"><a class="header" href="#下载并安装jdbc-驱动">下载并安装JDBC 驱动</a></h3>
<p>要求使用5.1.26以上版本的jdbc驱动，可点击这里直接下载mysql-connector-java-5.1.47.tar.gz</p>
<pre><code class="language-shell">wget https://dev.mysql.com/get/Downloads/Connector-J/mysql-connector-java-5.1.47.tar.gz
tar -xzf mysql-connector-java-5.1.47.tar.gz 
mkdir -p /usr/share/java
ln -s /usr/share/mysql-connector-java-5.1.47/mysql-connector-java-5.1.47-bin.jar /usr/share/java/mysql-connector-java.jar
</code></pre>
<h3 id="创建cdh所需要的数据库"><a class="header" href="#创建cdh所需要的数据库">创建CDH所需要的数据库</a></h3>
<p>根据所需要安装的服务参照下表创建对应的数据库以及数据库用户，数据库必须使用utf8编码，创建数据库时要记录好用户名及对应密码：</p>
<div class="table-wrapper"><table><thead><tr><th>服务名</th><th>数据库名</th><th>用户名</th><th>密码</th></tr></thead><tbody>
<tr><td>Cloudera Manager Server</td><td><code>scm</code></td><td><code>scm</code></td><td><code>CDH@gang2019</code></td></tr>
<tr><td>Activity Monitor</td><td><code>amon</code></td><td><code>amon</code></td><td><code>CDH@gang2019</code></td></tr>
<tr><td>Reports Manager</td><td><code>rman</code></td><td><code>rman</code></td><td><code>CDH@gang2019</code></td></tr>
<tr><td>Hue</td><td><code>hue</code></td><td><code>hue</code></td><td><code>CDH@gang2019</code></td></tr>
<tr><td>Hive Metastore Server</td><td><code>metastore</code></td><td><code>hive</code></td><td><code>CDH@gang2019</code></td></tr>
<tr><td>Sentry Server</td><td><code>sentry</code></td><td><code>sentry</code></td><td><code>CDH@gang2019</code></td></tr>
<tr><td>Cloudera Navigator Audit Server</td><td><code>nav</code></td><td><code>nav</code></td><td><code>CDH@gang2019</code></td></tr>
<tr><td>Cloudera Navigator Metadata Server</td><td><code>navms</code></td><td><code>navms</code></td><td><code>CDH@gang2019</code></td></tr>
<tr><td>Oozie</td><td><code>oozie</code></td><td><code>oozie</code></td><td><code>CDH@gang2019</code></td></tr>
</tbody></table>
</div>
<p>创建sql脚步文件</p>
<pre><code>vim cdhinit.sql
</code></pre>
<p>添加内容如下：</p>
<pre><code class="language-mysql"># scm
CREATE DATABASE scm DEFAULT CHARACTER SET utf8 DEFAULT COLLATE utf8_general_ci;
GRANT ALL ON scm.* TO 'scm'@'%' IDENTIFIED BY 'CDH@gang2019';
# amon
CREATE DATABASE amon DEFAULT CHARACTER SET utf8 DEFAULT COLLATE utf8_general_ci;
GRANT ALL ON amon.* TO 'amon'@'%' IDENTIFIED BY 'CDH@gang2019';
# rman
CREATE DATABASE rman DEFAULT CHARACTER SET utf8 DEFAULT COLLATE utf8_general_ci;
GRANT ALL ON rman.* TO 'rman'@'%' IDENTIFIED BY 'CDH@gang2019';
# hue
CREATE DATABASE hue DEFAULT CHARACTER SET utf8 DEFAULT COLLATE utf8_general_ci; 
GRANT ALL ON hue.* TO 'hue'@'%' IDENTIFIED BY 'CDH@gang2019';
# hive
CREATE DATABASE metastore DEFAULT CHARACTER SET utf8 DEFAULT COLLATE utf8_general_ci;
GRANT ALL ON metastore.* TO 'hive'@'%' IDENTIFIED BY 'CDH@gang2019';
# sentry
CREATE DATABASE sentry DEFAULT CHARACTER SET utf8 DEFAULT COLLATE utf8_general_ci;  
GRANT ALL ON sentry.* TO 'sentry'@'%' IDENTIFIED BY 'CDH@gang2019';
# nav
CREATE DATABASE nav DEFAULT CHARACTER SET utf8 DEFAULT COLLATE utf8_general_ci;   
GRANT ALL ON nav.* TO 'nav'@'%' IDENTIFIED BY 'CDH@gang2019';
# navms
CREATE DATABASE navms DEFAULT CHARACTER SET utf8 DEFAULT COLLATE utf8_general_ci;
GRANT ALL ON navms.* TO 'navms'@'%' IDENTIFIED BY 'CDH@gang2019';
# oozie
CREATE DATABASE oozie DEFAULT CHARACTER SET utf8 DEFAULT COLLATE utf8_general_ci;
GRANT ALL ON oozie.* TO 'oozie'@'%' IDENTIFIED BY 'CDH@gang2019';
# flush
FLUSH PRIVILEGES;
SHOW DATABASES;
</code></pre>
<p>修改mysql密码校验策略</p>
<pre><code>[root@cdh001 ~]# mysql -u root -p
mysql&gt; set global validate_password_policy=LOW; 
Query OK, 0 rows affected (0.00 sec)
mysql&gt; set global validate_password_length=6;
Query OK, 0 rows affected (0.00 sec)
mysql&gt; SHOW VARIABLES LIKE 'validate_password%';
+--------------------------------------+-------+
| Variable_name                        | Value |
+--------------------------------------+-------+
| validate_password_check_user_name    |  OFF  |
| validate_password_dictionary_file    |       |
| validate_password_length             |   6   |
| validate_password_mixed_case_count   |   1   |
| validate_password_number_count       |   1   |
| validate_password_policy             |  LOW  |
| validate_password_special_char_count |   1   |
+--------------------------------------+-------+
7 rows in set (0.00 sec)
</code></pre>
<p>运行脚本</p>
<pre><code>mysql&gt; source /root/cdhinit.sql
Query OK, 0 rows affected, 1 warning (0.00 sec)
Query OK, 0 rows affected (0.00 sec)
.....
13 rows in set (0.00 sec)
</code></pre>
<h2 id="配置cloudera-manager-yum库主节点"><a class="header" href="#配置cloudera-manager-yum库主节点">配置Cloudera Manager yum库（主节点）</a></h2>
<p>首先安装httpd和createrepo：</p>
<pre><code>yum -y install httpd createrepo
</code></pre>
<p>启动httpd服务并设置开机自启动：</p>
<pre><code class="language-shell">systemctl enable --now httpd
</code></pre>
<p>将上传的CDH安装包移到httpd的html目录下:</p>
<pre><code>mv CDH/ /var/www/html/
</code></pre>
<p>生成RPM元数据：</p>
<pre><code class="language-shell">cd /var/www/html/CDH/ClouderaManager/
createrepo .
</code></pre>
<p>接着再创建ClouderaManager的repo文件</p>
<pre><code>vim /etc/yum.repos.d/cloudera-manager.repo
</code></pre>
<p>添加如下内容：</p>
<pre><code class="language-ini">[cloudera-manager]
name=Cloudera Manager 6
baseurl=http://cdh001/CDH/ClouderaManager/
gpgcheck=0
enabled=1
</code></pre>
<p>分发</p>
<pre><code>xsync /etc/yum.repos.d/cloudera-manager.repo
</code></pre>
<p>修改<code>/etc/httpd/conf/httpd.conf</code>配置文件：</p>
<blockquote>
<p>把第284行的<code> AddType application/x-gzip .gz .tgz</code> 修改为 <code>AddType application/x-gzip .gz .tgz .parcel</code>。</p>
</blockquote>
<p>重启httpd服务</p>
<pre><code>systemctl restart httpd
</code></pre>
<h2 id="安装jdk所有节点"><a class="header" href="#安装jdk所有节点">安装JDK（所有节点）</a></h2>
<pre><code class="language-shell">yum install oracle-j2sdk1.8
</code></pre>
<p>设置环境变量</p>
<pre><code>vim /etc/profile.d/cdh.sh
</code></pre>
<p>添加如下内容：</p>
<pre><code class="language-sh">#java
export JAVA_HOME=/usr/java/jdk1.8.0_181-cloudera/
export PATH=$JAVA_HOME/bin:$PATH
export CLASSPATH=.:$JAVA_HOME/lib
</code></pre>
<p>环境变量生效</p>
<pre><code>source /etc/profile.d/cdh.sh
java -version
</code></pre>
<p>分发配置文件</p>
<pre><code>xsync /etc/profile
</code></pre>
<h2 id="安装cloudera-manager"><a class="header" href="#安装cloudera-manager">安装Cloudera Manager</a></h2>
<h5 id="安装cloudera-manager-server--主节点"><a class="header" href="#安装cloudera-manager-server--主节点">安装Cloudera Manager Server  (主节点)</a></h5>
<pre><code class="language-shell">yum install cloudera-manager-server
</code></pre>
<h5 id="安装cloudera-manager-agent所有节点"><a class="header" href="#安装cloudera-manager-agent所有节点">安装Cloudera Manager Agent(所有节点)</a></h5>
<pre><code class="language-shell">./sync_cluster.sh cmd &quot;yum install cloudera-manager-daemons cloudera-manager-agent -y&quot;
</code></pre>
<h5 id="修改agent配置指向server节点cdh001-所有节点"><a class="header" href="#修改agent配置指向server节点cdh001-所有节点">修改agent配置，指向Server节点cdh001 （所有节点）</a></h5>
<pre><code>sed -i &quot;s/server_host=localhost/server_host=cdh01/g&quot; /etc/cloudera-scm-agent/config.ini
xsync /etc/cloudera-scm-agent/config.ini
</code></pre>
<h5 id="启动-agent-服务所有节点"><a class="header" href="#启动-agent-服务所有节点">启动 agent 服务（所有节点）</a></h5>
<pre><code class="language-sh">systemctl start cloudera-scm-agent
</code></pre>
<h3 id="初始化scm数据库"><a class="header" href="#初始化scm数据库">初始化scm数据库</a></h3>
<pre><code class="language-sh">/opt/cloudera/cm/schema/scm_prepare_database.sh mysql scm scm 'CDH@gang2019'
</code></pre>
<h3 id="启动cloudera-manager-server主节点"><a class="header" href="#启动cloudera-manager-server主节点">启动Cloudera Manager Server(主节点)</a></h3>
<pre><code class="language-sh">systemctl start cloudera-scm-server
systemctl status cloudera-scm-server
</code></pre>
<p>查看启动日志</p>
<pre><code>tail -f /var/log/cloudera-scm-server/cloudera-scm-server.log
</code></pre>
<p>看到下面的信息，说明启动完成</p>
<pre><code>2021-04-15 16:11:08,771 INFO WebServerImpl:com.cloudera.server.cmf.WebServerImpl: Started Jetty server.
</code></pre>
<h2 id="安装cdh集群"><a class="header" href="#安装cdh集群">安装CDH集群</a></h2>
<h3 id="通过浏览器访问cloudera-manager-web界面"><a class="header" href="#通过浏览器访问cloudera-manager-web界面">通过浏览器访问Cloudera Manager WEB界面</a></h3>
<p>打开浏览器，访问地址：<code>http://&lt;server_host&gt;:7180</code>，默认账号和密码都为<code>admin</code>：
<img src="%E6%9C%8D%E5%8A%A1%E5%99%A8/CDH6%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%9B%86%E7%BE%A4%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85.assets/202104151826531523.png" alt="在这里插入图片描述" /></p>
<h3 id="欢迎页面"><a class="header" href="#欢迎页面">欢迎页面</a></h3>
<p>首先是Cloudera Manager的欢迎页面，点击页面右下角的【继续】按钮进行下一步：
<img src="%E6%9C%8D%E5%8A%A1%E5%99%A8/CDH6%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%9B%86%E7%BE%A4%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85.assets/202104151826539648.png" alt="在这里插入图片描述" /></p>
<h3 id="接受条款"><a class="header" href="#接受条款">接受条款</a></h3>
<p>勾选接受条款，点击【继续】进行下一步：</p>
<h3 id="版本选择"><a class="header" href="#版本选择">版本选择</a></h3>
<p>这里选择免费版：
<img src="%E6%9C%8D%E5%8A%A1%E5%99%A8/CDH6%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%9B%86%E7%BE%A4%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85.assets/202104151826548242.png" alt="在这里插入图片描述" /></p>
<h3 id="第二个欢迎界面"><a class="header" href="#第二个欢迎界面">第二个欢迎界面</a></h3>
<p>选择版本以后会出现第二个欢迎界面，不过这个是安装集群的欢迎页：
<img src="%E6%9C%8D%E5%8A%A1%E5%99%A8/CDH6%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%9B%86%E7%BE%A4%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85.assets/202104151826556835.png" alt="在这里插入图片描述" /></p>
<h3 id="设置群集名称"><a class="header" href="#设置群集名称">设置群集名称</a></h3>
<p><img src="%E6%9C%8D%E5%8A%A1%E5%99%A8/CDH6%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%9B%86%E7%BE%A4%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85.assets/202104151826563554.png" alt="在这里插入图片描述" /></p>
<h3 id="选择主机"><a class="header" href="#选择主机">选择主机</a></h3>
<p>这一步是要选择用于安装CDH集群的主机：
<img src="%E6%9C%8D%E5%8A%A1%E5%99%A8/CDH6%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%9B%86%E7%BE%A4%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85.assets/202104151826570273.png" alt="在这里插入图片描述" /></p>
<h3 id="选择存储库"><a class="header" href="#选择存储库">选择存储库</a></h3>
<h4 id="cdh-and-other-software"><a class="header" href="#cdh-and-other-software">CDH and other software</a></h4>
<p>点击更多选项添加远程Parcel存储库：<code>http://39.108.122.82/CDH/CDH/</code>
<img src="%E6%9C%8D%E5%8A%A1%E5%99%A8/CDH6%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%9B%86%E7%BE%A4%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85.assets/202104151826578710.png" alt="在这里插入图片描述" /></p>
<blockquote>
<p>Fix:
在阿里云服务器上url应该改为http://cdh001/CDH/CDH/，采用公网ip会限速</p>
</blockquote>
<p>返回后会加载出CDH版本，确认无误后点击【继续】：
<img src="%E6%9C%8D%E5%8A%A1%E5%99%A8/CDH6%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%9B%86%E7%BE%A4%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85.assets/202104151826587011.png" alt="在这里插入图片描述" /></p>
<h3 id="install-parcels"><a class="header" href="#install-parcels">Install Parcels</a></h3>
<p><img src="%E6%9C%8D%E5%8A%A1%E5%99%A8/CDH6%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%9B%86%E7%BE%A4%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85.assets/202104151826594199.png" alt="在这里插入图片描述" /></p>
<h3 id="主机检查"><a class="header" href="#主机检查">主机检查</a></h3>
<p>等待检查完成即可：
<img src="%E6%9C%8D%E5%8A%A1%E5%99%A8/CDH6%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%9B%86%E7%BE%A4%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85.assets/202104151827002167.png" alt="在这里插入图片描述" /></p>
<h3 id="选择服务类型"><a class="header" href="#选择服务类型">选择服务类型</a></h3>
<p>这里我选择Data Engineering
Process, develop, and serve predictive models.
服务: HDFS、YARN（含 MapReduce 2）、ZooKeeper、Oozie、Hive、Hue 和 Spark</p>
<p><img src="%E6%9C%8D%E5%8A%A1%E5%99%A8/CDH6%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%9B%86%E7%BE%A4%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85.assets/202104151827010761.png" alt="在这里插入图片描述" /></p>
<h3 id="角色分配"><a class="header" href="#角色分配">角色分配</a></h3>
<p>CDH会自动给出一个角色分配，如果觉得不合理，我们可以手动调整一下，注意角色分配均衡：</p>
<p><img src="%E6%9C%8D%E5%8A%A1%E5%99%A8/CDH6%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%9B%86%E7%BE%A4%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85.assets/202104151827018446.png" alt="在这里插入图片描述" /></p>
<p>Gateway Roles https://docs.cloudera.com/documentation/enterprise/5-9-x/topics/cm_mc_managing_roles.html#managing_roles__section_scv_ywt_cn</p>
<h3 id="数据库设置"><a class="header" href="#数据库设置">数据库设置</a></h3>
<p><img src="%E6%9C%8D%E5%8A%A1%E5%99%A8/CDH6%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%9B%86%E7%BE%A4%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85.assets/202104151827028783.png" alt="在这里插入图片描述" /></p>
<h3 id="审核更改"><a class="header" href="#审核更改">审核更改</a></h3>
<p><img src="%E6%9C%8D%E5%8A%A1%E5%99%A8/CDH6%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%9B%86%E7%BE%A4%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85.assets/202104151827035673.png" alt="在这里插入图片描述" /></p>
<h3 id="等待命令执行完成"><a class="header" href="#等待命令执行完成">等待命令执行完成</a></h3>
<p><img src="%E6%9C%8D%E5%8A%A1%E5%99%A8/CDH6%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%9B%86%E7%BE%A4%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85.assets/202104151827042548.png" alt="在这里插入图片描述" /></p>
<h3 id="安装完成"><a class="header" href="#安装完成">安装完成</a></h3>
<p><img src="%E6%9C%8D%E5%8A%A1%E5%99%A8/CDH6%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%9B%86%E7%BE%A4%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85.assets/202104151827049423.png" alt="在这里插入图片描述" /></p>
<h3 id="进入监控界面"><a class="header" href="#进入监控界面">进入监控界面</a></h3>
<p><img src="%E6%9C%8D%E5%8A%A1%E5%99%A8/CDH6%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%9B%86%E7%BE%A4%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85.assets/202104151827058173.png" alt="在这里插入图片描述" /></p>
<h2 id="组件配置"><a class="header" href="#组件配置">组件配置</a></h2>
<h3 id="spark-1"><a class="header" href="#spark-1">Spark</a></h3>
<p>安装目录：</p>
<pre><code class="language-shell">SPARK_HOME=/opt/cloudera/parcels/CDH-6.3.2-1.cdh6.3.2.p0.1605554/lib/spark
</code></pre>
<p>配置目录：</p>
<pre><code class="language-shell">/etc/spark/conf                   # CDH分发配置目录
$SPARK_HOME/../../etc/spark/conf  # 内置默认配置目录
</code></pre>
<h4 id="web配置"><a class="header" href="#web配置">Web配置</a></h4>
<p>输入<code>spark-conf</code>过滤设置项，在展示的相应设置项中配置<code>spark-env.sh</code>和<code>spark-defaults.conf</code>中的选项。客户端配置在<code>Gateway Default Group</code>中。</p>
<pre><code class="language-shell">export PYSPARK_PYTHON=/opt/miniconda3/envs/dataproc/bin/python
export PYSPARK_DRIVER_PYTHON=/opt/miniconda3/envs/dataproc/bin/python
</code></pre>
<blockquote>
<p>注意在最后一行添加换行，防止生成的配置文件格式不正确。export语句在一行，且worker上未生效。</p>
</blockquote>
<p>如果界面配置环境变量不生效，在代码中加入：</p>
<pre><code class="language-python">import os
os.environ[&quot;PYSPARK_PYTHON&quot;]='/opt/miniconda3/envs/dataproc/bin/python'
</code></pre>
<h4 id="kafka集成"><a class="header" href="#kafka集成">Kafka集成</a></h4>
<p><code>spark-streaming-kafka</code>：离线环境默认缺少<a href="%E6%9C%8D%E5%8A%A1%E5%99%A8/./%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%A1%E7%AE%97.html#Spark%E5%92%8CKafka%E7%89%88%E6%9C%AC%E9%80%89%E6%8B%A9"><code>spark-streaming-kafka-0-8-assembly</code>包</a>，手动添加到<code>SPARK_HOME</code>并在集群中同步。</p>
<p><code>spark-sql-kafka</code>：</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="spark-python-api"><a class="header" href="#spark-python-api">Spark Python API</a></h1>
<h2 id="基础类型-1"><a class="header" href="#基础类型-1">基础类型</a></h2>
<h3 id="数据类型-9"><a class="header" href="#数据类型-9">数据类型</a></h3>
<p><code>DataType</code>是具体数据类型的基类。</p>
<div class="table-wrapper"><table><thead><tr><th>类型</th><th>Python类型</th><th>说明</th></tr></thead><tbody>
<tr><td><code>BooleanType</code></td><td><code>bool</code></td><td></td></tr>
<tr><td><code>ByteType</code></td><td></td><td></td></tr>
<tr><td><code>IntegerType</code></td><td><code>int</code></td><td><code>ShortType/LongType</code></td></tr>
<tr><td><code>DoubleType/FloatType</code></td><td><code>float</code></td><td></td></tr>
<tr><td><code>DecimalType()</code></td><td></td><td><code>precision,scale</code>参数控制精度；</td></tr>
<tr><td><code>StringType</code></td><td><code>str</code></td><td></td></tr>
<tr><td><code>DateType</code></td><td><code>dt.date</code></td><td></td></tr>
<tr><td><code>TimestampType</code></td><td><code>dt.datetime</code></td><td></td></tr>
<tr><td><code>NullType</code></td><td><code>None</code></td><td></td></tr>
<tr><td><code>BinaryType</code></td><td></td><td></td></tr>
<tr><td><code>ArrayType(EType)</code></td><td><code>List[Type]</code></td><td><code>nullable=True</code></td></tr>
<tr><td><code>MapType(KType,VType)</code></td><td><code>dict</code></td><td>必须声明确定的<code>key</code>和<code>value</code>类型（命名元组）。<br /><code>nullable=True</code></td></tr>
<tr><td><code>StructType([fields])</code></td><td><code>dict</code></td><td><code>StructType</code>包含固定字段；而<code>MapType</code>可以有任意数量的key-value。</td></tr>
<tr><td><code>StructField(name,DType)</code></td><td></td><td><code>nullable=True</code></td></tr>
</tbody></table>
</div>
<p><a href="https://spark.apache.org/docs/latest/sql-ref-datatypes.html">Data Types - Spark 3.2.0 Documentation (apache.org)</a></p>
<h3 id="数据结构-2"><a class="header" href="#数据结构-2">数据结构</a></h3>
<h2 id="底层api"><a class="header" href="#底层api">底层API</a></h2>
<pre><code class="language-python">from pyspark import SparkContext, SparkConf
conf = SparkConf().setAppName(&quot;AppName&quot;).setMaster(master).set(...)
sc = SparkContext(conf=conf)
</code></pre>
<p><code>master</code>表示集群的URL，或者<code>local[k]</code>。</p>
<blockquote>
<p>交互式环境（PySparkShell）中有一个默认的<code>SparkContext</code>对象<code>sc</code>。</p>
</blockquote>
<h3 id="输入-3"><a class="header" href="#输入-3">输入</a></h3>
<h4 id="文件-1"><a class="header" href="#文件-1">文件</a></h4>
<pre><code class="language-python">lines = sc.textFile(&quot;examples/src/main/resources/people.txt&quot;)
</code></pre>
<blockquote>
<p>默认文件传输协议为<code>file://</code>；<em>使用Spark-on-Yarn</em>时，默认的文件传输协议为<code>hdfs://</code>，即文件应该存储在HDFS集群上。如果要在Client模式下使用主程序所在节点的文件，显式指定协议为<code>file://</code>。</p>
<p>省略文件传输协议，且路径非<code>/</code>开头，则表示使用相对路径。</p>
<p><code>local:/</code>不是有效的文件传输协议（<a href="%E6%9C%8D%E5%8A%A1%E5%99%A8/%E5%88%86%E5%B8%83%E5%BC%8F%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86.html#Spark%E4%BB%BB%E5%8A%A1%E8%B7%AF%E5%BE%84%E5%92%8C%E6%96%87%E4%BB%B6">仅适用于Spark集群自身分发依赖库</a>）。</p>
</blockquote>
<h3 id="变换-1"><a class="header" href="#变换-1">变换</a></h3>
<p><code>map()</code></p>
<h3 id="输出-1"><a class="header" href="#输出-1">输出</a></h3>
<p><code>first()</code></p>
<h2 id="spark-sql"><a class="header" href="#spark-sql">Spark SQL</a></h2>
<h3 id="spark会话"><a class="header" href="#spark会话">Spark会话</a></h3>
<pre><code class="language-python">from pyspark.sql import SparkSession
spark=SparkSession\
        .builder\
        .master(&quot;yarn&quot;)
        .appName(&quot;PythonApp&quot;)\
        .config(&quot;hive.metastore.uris&quot;, &quot;thrift://hadoop-master:9083&quot;)\
        .enableHiveSupport()\
        .getOrCreate()
# 如果能定位SPARK_HOME下的配置文件，则可获得相应配置，否则需要通过代码指定
spark.sparkContext.setLogLevel('WARN') # set log level to WARN after then
</code></pre>
<h3 id="数据类型-10"><a class="header" href="#数据类型-10">数据类型</a></h3>
<p>输入数据以<code>pyspark.sql.DataFrame</code>表示。<code>DataFrame</code>相当于是基于<code>Row</code>组织的<code>RDD</code>，可与<code>RDD</code>相互转换。</p>
<h4 id="spark-dataframe"><a class="header" href="#spark-dataframe">Spark DataFrame</a></h4>
<p><code>spark.createDataFrame(data[,schema][,samplingRatio],verifySchema=True)</code></p>
<p>基于<code>Row</code>序列（本地或分布式<code>RDD</code>类型）创建，</p>
<pre><code class="language-python">data = [Row(a=1, b=2., c='string1', d=date(2000, 1, 1)),
        Row(a=2, b=3., c='string2', d=date(2000, 2, 1)),
        Row(a=4, b=5., c='string3', d=date(2000, 3, 1))]
# data = spark.sparkContext.parallelize(data) -&gt; RDD
df = spark.createDataFrame(data)  # 自动推测数据类型
</code></pre>
<p>基于Python序列（本地或分布式<code>RDD</code>类型）创建，由于序列没有列名信息，需要指定<code>schema</code>。</p>
<pre><code class="language-python">data = [(1, 2., 'string1', date(2000, 1, 1)),
        (2, 3., 'string2', date(2000, 2, 1)),
        (4, 5., 'string3', date(2000, 3, 1))]
# data = spark.sparkContext.parallelize(data) -&gt; RDD
df = spark.createDataFrame(data, schema='a long, b double, c string, d date')
</code></pre>
<h5 id="spark-row类型"><a class="header" href="#spark-row类型">Spark Row类型</a></h5>
<p><code>Row</code>表示Spark DataFrame中的一行数据，可以使用字典、元组的方式访问其元素，也可以将元素名称作为成员名来访问该元素（类似于命名空间成员的访问方式）。</p>
<pre><code class="language-shell">from pyspark.sql import Row
row = Row(name=&quot;Alice&quot;, age=11)
'name' in row
row.age, row['name'], row[1]
Person = Row(&quot;name&quot;, &quot;age&quot;)
Person(&quot;Alice&quot;, 11)  # Row(name='Alice', age=11)
</code></pre>
<h5 id="数据格式声明"><a class="header" href="#数据格式声明">数据格式声明</a></h5>
<p><code>schema</code>可以以字符串形式简单描述（类型可省略，根据数值采样自动推测）或使用<code>StructType</code>完整描述。</p>
<pre><code class="language-python">schema = StructType([StructField(&quot;a&quot;, StringType(), True),
                     StructField(&quot;b&quot;, DoubleType(), False),
                     StructField(&quot;c&quot;, StringType(), True),
                     StructField(&quot;d&quot;, DateType(),   False)])
</code></pre>
<p>还可以基于<code>pandas.DataFrame</code>创建。由于<code>pandas.DataFrame</code>已知数据类型，无需指定Schema。</p>
<pre><code class="language-python">pd.DataFrame(pandas_df)
</code></pre>
<h4 id="读取文件"><a class="header" href="#读取文件">读取文件</a></h4>
<p><code>reader:DataFrameReader = spark.read</code>：获取读取接口，可通过以下方式对该接口进行配置：<code>reader.format(&lt;FORMAT&gt;) -&gt;reader.&lt;FORMAT&gt;</code>：支持的文件格式包括Text、CSV、Parquet、OCR、JSON等。</p>
<pre><code class="language-python">df = spark.read.json(FILE_PATH)
df = spark.read.format(&quot;JSON&quot;).load(FILE_PATH)
</code></pre>
<p><code>reader.option(key, value)/options(**options)</code>：设置输入选项；</p>
<h5 id="csv读取参数"><a class="header" href="#csv读取参数">csv读取参数</a></h5>
<ul>
<li>
<p><a href="%E6%9C%8D%E5%8A%A1%E5%99%A8/Spark%20Python%20API.html#%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F%E5%A3%B0%E6%98%8E">数据格式</a></p>
<ul>
<li><code>schema</code>：<code>StructType</code>或文本<code>col0 INT, col1 DOUBLE</code>；</li>
<li><code>header=False</code>；</li>
<li><code>inferSchema=False</code>：推断数据格式，需要读取两次数据；</li>
<li><code>samplingRatio=1.0</code>：推断数据格式所需读取的记录比例；</li>
<li><code>enforceSchema=True</code>：默认强制应用指定的或推断的数据格式被数据源所有文件，CSV文件中的头部被忽略；反之，仅验证CSV文件的头部字段（推荐禁用该选项以避免意外错误）。</li>
<li><code>maxColumns=20480</code>：限制读取的列数；</li>
<li><code>multiLine=False</code>：数据记录跨行；</li>
</ul>
<p><code>csv</code>不支持仅读取部分数据，可在读取后执行<code>limit()</code>方法返回部分数据</p>
</li>
<li>
<p>文本编码：<code>encoding='UTF-8'</code>；</p>
</li>
<li>
<p>特殊字符：</p>
<ul>
<li><code>sep=','</code>；</li>
<li><code>quote='&quot;'</code>：用于包含分隔符的字段；</li>
<li><code>escape='\'</code>：用于转义已经使用引号的字段中的引号，即<code>\&quot;</code>；</li>
<li><code>charToEscapeQuoteEscape='\'</code>；用于转义引号字段中的转义字符，即<code>\\</code>；</li>
<li><code>comment=None</code>（数据中的注释行开头字符）；</li>
<li><code>ignoreLeadingWhiteSpace/ignoreTrailingWhiteSpace=False</code>：忽略空白；</li>
</ul>
</li>
<li>
<p>特殊值：</p>
<ul>
<li><code>nullValue=''</code>：文件中的缺失值形式；</li>
<li><code>emptyValue='&quot;&quot;'</code>：文件中空字符串的形式；</li>
<li><code>nanValue='NaN'</code>：文件中无效数值的表示形式；</li>
<li><code>positiveInf/negativeInf='Inf'</code>：文件中无穷大的表示形式；</li>
</ul>
</li>
<li>
<p>数值格式：</p>
<ul>
<li><code>dateFormat='yyyy-MM-dd'</code>：文件中日期表示形式；</li>
<li><code>timestampFormat=&quot;yyyy-MM-dd'T'HH:mm:ss.SSSXXX&quot;</code>：文件中时间表示形式；</li>
<li><code>maxCharsPerColumn=-1</code>：限制每个字段读取字符数量（默认无限制）；</li>
</ul>
</li>
<li>
<p>错误处理：</p>
<ul>
<li><code>mode='PERMISSIVE'</code>：发现坏记录将其存储在名为<code>columnNameOfCorruptRecord</code>的列（需要用户在数据格式中设置该列，否则丢弃该列），并将其他列设置为<code>null</code>；当记录字段比数据格式的列少，则缺少的列设置为<code>null</code>；反之，丢弃多余的列。<code>DROPMALFORMED</code>忽略整条坏记录。<code>FAILFAST</code>直接抛出异常。</li>
<li><code>columnNameOfCorruptRecord=spark.sql.columnNameOfCorruptRecord</code>：</li>
</ul>
</li>
</ul>
<h4 id="hive"><a class="header" href="#hive">Hive</a></h4>
<pre><code class="language-python">df = spark.sql(&quot;select * from pokes limit 10&quot;)
</code></pre>
<h5 id="hive数据源格式"><a class="header" href="#hive数据源格式">Hive数据源格式</a></h5>
<p>CSV文件：为了保证Spark能正确推测Hive数据的数据类型，Hive数据源的文件存储中不要包含表头（Spark不识别Hive的表格选项<code>skip.header.line.count</code>），否则Spark将表头视为数据，由于表头为字符串类型，导致自动推导数据类型失败。对于具有表头的数据文件，可直接存储在HDFS上，并通过Spark提供的CSV文件读取接口读取数据。</p>
<h4 id="数据表视图"><a class="header" href="#数据表视图">数据表视图</a></h4>
<pre><code class="language-python">df.createOrReplaceTempView(&quot;people&quot;) # createTempView(name)
df = spark.sql(&quot;SELECT * FROM people&quot;)
df.createGlobalTempView(&quot;people&quot;)    # createOrReplaceGlobalTempView()
df = spark.sql(&quot;SELECT * FROM global_temp.people&quot;)
df = spark.table('global_temp.people')
</code></pre>
<h3 id="dataframe-api"><a class="header" href="#dataframe-api">DataFrame API</a></h3>
<p><code>df.cache()</code>：持久化数据（<code>MEMORY_AND_DISK</code>）；<code>df.persist([storageLevel])</code>设置持久化存储等级；</p>
<p><code>df.unpersist([blocking])</code>：释放持久化存储资源；</p>
<p><code>df.coalesce(numPartitions)</code>：重新分片；</p>
<p><code>df.withColumnRenamed(existing, new)</code>：重命名列；对于为暂未计算的抽象列<code>Column</code>调用其<a href="%E6%9C%8D%E5%8A%A1%E5%99%A8/Spark%20Python%20API.html#%E5%88%97%E5%90%8D%E8%B0%83%E7%94%A8%E5%8F%98%E6%8D%A2%E6%96%B9%E6%B3%95"><code>alias</code>方法</a>修改随后返回的数据的列名。</p>
<p><code>df.columns</code>：返回列名组成的列表。</p>
<p><code>df.dtypes-&gt;List[(name,type)]</code></p>
<p><code>df.schema-&gt;StructType</code></p>
<p><code>df.isStreaming</code>：该数据集是否是流数据；</p>
<p><code>df.rdd-&gt;RDD(List[Row])</code></p>
<p><code>df.toJSON(use_unicode=True)-&gt;RDD(List[str])</code></p>
<h3 id="变换-2"><a class="header" href="#变换-2">变换</a></h3>
<ol>
<li>
<p><code>df.select(col:Column,...)</code>：从<code>DataFrame</code>选择列并执行变换，<code>select</code>执行的操作类似于<code>map</code>。可以提供<strong>序列类型或可变长参数列表</strong>作为参数。<code>Column</code>类用于表示==基于列的变换过程的声明式对象==，包括以下声明方式：</p>
<ul>
<li>
<p><code>'col_name'|col/column(col_name)|df['col_name']|df.col_name</code>：使用列名读取该列不做其他变换；仅提供列名默认引用当前查询的数据集的列；</p>
<pre><code class="language-python">from pyspark.sql.functions import col,column  # col&lt;-&gt;column
</code></pre>
<p>可使用<code>df.columns[i:j]</code>选择数据的一个分片。</p>
<p>对于结构数据字段可通过路径对象来返回嵌套字段值：</p>
<pre><code class="language-python">df.select(&quot;name.firstname&quot;,&quot;name.lastname&quot;).show(truncate=False)
</code></pre>
</li>
<li>
<p><code>df.col_name+1</code>：基于列的数值运算、逻辑运算（<code>+,-,*,/...</code>）等；</p>
<blockquote>
<p>参与运算的数值不能是<code>numpy</code>类型的数值，否则会出错：<em><code>'numpy.int32' object has no attribute '_get_object_id'</code></em>；应该将此类型转换为兼容的Python内置类型。</p>
</blockquote>
</li>
<li>
<p><code>df.col_name.func()</code>，<code>df['col_name'].func()</code>或<code>col('col_name').func()</code>：使用<a href="%E6%9C%8D%E5%8A%A1%E5%99%A8/%E5%88%97%E5%90%8D%E8%B0%83%E7%94%A8%E5%8F%98%E6%8D%A2%E6%96%B9%E6%B3%95">列名调用内置的变换方法</a>；</p>
</li>
<li>
<p><code>sqlfunc(col('col_name'))</code>或<code>sqlfunc(df['col_name'])</code>：使用<a href="%E6%9C%8D%E5%8A%A1%E5%99%A8/Spark%20Python%20API.html#%E5%88%97%E5%8F%98%E6%8D%A2">SQL函数库</a>或或<a href="%E6%9C%8D%E5%8A%A1%E5%99%A8/Spark%20Python%20API.html#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8F%98%E6%8D%A2%E5%87%BD%E6%95%B0">自定义变换函数</a>。SQL函数可能不接受字符串列名。</p>
<pre><code class="language-python">from pyspark.sql.functions import sqlfunc; # 从内置SQL函数库导入变换方法
pysaprk.sql.functions import udf;          # 通过udf,用户可自定义变换函数
</code></pre>
</li>
<li>
<p><code>expr(&quot;EXPR&quot;)</code>：由于表达式文本在运行时构造，这种方式==可动态生成查询语句==；</p>
<pre><code class="language-python">from pyspark.sql.functions import expr
df.select(expr('a*2+1'))
</code></pre>
</li>
</ul>
</li>
<li>
<p><code>df.selectExpr(*expr)</code>：使用表达式代文本替<code>df.select()</code>的列声明（<code>df.select('col_name')</code>的扩展，等效于<code>df.select(expr(&quot;EXPR&quot;))</code>），这种方式无法通过列声明对象调用内置方法（如列重命名）。</p>
<pre><code class="language-python">df.selectExpr(&quot;age * 2&quot;, &quot;abs(age)&quot;)
</code></pre>
</li>
<li>
<p>SQL查询语句：通过构造<a href="%E6%9C%8D%E5%8A%A1%E5%99%A8/Spark%20Python%20API.html#%E6%95%B0%E6%8D%AE%E8%A1%A8%E8%A7%86%E5%9B%BE">数据表视图</a>并利用<code>spark.sql(...)</code>方法传入包含<a href="https://spark.apache.org/docs/latest/sql-ref-functions.html">SQL变换方法</a>的原生SQL查询语句进行数据变换。</p>
<pre><code class="language-python">df.createOrReplaceTempView('data')
spark.sql('SELECT a, FUNC(a) FROM data').show()
</code></pre>
</li>
<li>
<p><code>df.transform(func)</code>：<code>func</code>可包含一系列<code>select</code>变换；</p>
</li>
<li>
<p>条件变换：<code>when</code>相当于是一个条件选择函数的简化形式。</p>
<pre><code class="language-python">from pysaprk.sql.functions import when
df.select(when(df.col==1,df.col+1).otherwise(0).alias(&quot;result&quot;))
</code></pre>
</li>
</ol>
<h4 id="通过列声明调用变换方法"><a class="header" href="#通过列声明调用变换方法">通过列声明调用变换方法</a></h4>
<p><code>Column.cast/astype(TYPE)</code>：列数据类型变换，<code>TYPE</code>可以是文本类型描述或<code>DataType</code>的子类对象。</p>
<p><code>Column.alias/name</code>：修改列名，默认列名为该列的变换表达式；</p>
<p><code>Column.asc/asc_nulls_first/asc_nulls_last/desc/desc_nulls_first/desc_nulls_last(col)</code>：参考对应的SQL函数；</p>
<p><code>Column.bitwiseAND/bitwiseOR/bitwiseXOR</code></p>
<p><code>Column.between(lower,upper)</code>：判断列值是否在上下界之间；</p>
<p><code>Column.startswith/endswith(other)</code></p>
<p><code>Column.contains(other)</code></p>
<p><code>Column.isin(*cols)</code>：当前列的值是否在其他列中；</p>
<p><code>Column.dropFields(*fields)/getField(name)/withField(name,value)</code>：提取/丢弃/修改<code>StructType</code>字段；</p>
<p><code>Column.getItem(idx_or_key)</code>：从序列或字典中提取元素或字段；</p>
<p><code>Column.eqNullSafe(other)</code>：<em><code>NaN = NaN</code> returns true.</em></p>
<p><code>Column.isNull/isNotNull()</code></p>
<p><code>Column.like/rlike(other)</code>：模糊匹配/正则匹配；</p>
<p><code>Column.substr(startPos,length)</code>：获取子串（<code>functions.substring</code>）；</p>
<h4 id="sql变换函数"><a class="header" href="#sql变换函数">SQL变换函数</a></h4>
<p>Sspark定义了大量内置的变换函数以及自定变换函数的接口。</p>
<pre><code class="language-python">import pyspark.sql.functions as sqlfunc
</code></pre>
<h5 id="自定义变换函数"><a class="header" href="#自定义变换函数">自定义变换函数</a></h5>
<pre><code class="language-python">from pyspark.sql.functions import udf 
@udf(returnType=ArrayType(StringType()))
def str_2_array(x: str):
    if x is None: return []
    elif x.startswith('[') and x.endswith(']'): return eval(x)
    else: return [x]
df.select(str_2_array(df.a)).show()
</code></pre>
<h5 id="pandas变换函数"><a class="header" href="#pandas变换函数">Pandas变换函数</a></h5>
<pre><code class="language-python">from pyspark.sql.functions import pandas_udf
@pandas_udf(returnType='long', functionType=None)
def pandas_plus_one(series: pd.Series) -&gt; pd.Series:
    return series+1
df.select(pandas_plus_one(df.a)).show()
def filter_func(iterator):
    for pdf in iterator:  # iterator over pandas DataFrames
        yield pdf[pdf.id == 1] # return iterator of pandas DataFrames
df.mapInPandas(filter_func, df.schema).show()  # [3.0]
</code></pre>
<pre><code class="language-python">def plus_mean(pandas_df):
    return pandas_df.assign(v1=pandas_df.v1 - pandas_df.v1.mean())
df.applyInPandas(plus_mean, schema=df.schema).show()
</code></pre>
<h4 id="sparkml变换方法"><a class="header" href="#sparkml变换方法">SparkML变换方法</a></h4>
<p>SparkML提供了基于数值特征的变换方法<code>fit/transoform()</code>，==支持拟合变换过程中的参数；相比之下，基于<code>select()</code>和SQL变换函数，需要自己实现参数拟合的方法==。此外，SparkML提供的变换类，支持同时处理多个列；SQL变换函数的输入为一列，需要自己实现多列处理逻辑并记录对应参数。</p>
<p>SparkML的变换方法的输入要求==将每一行数据参与变换的特征列拼接为向量<code>Vector</code>==（SQL函数库中的<code>array</code>函数实现的拼接与变换方法的输入类型不一致），可以使用<code>VectorAssembler</code>实现此变换。</p>
<pre><code class="language-python">from pyspark.ml.feature import VectorAssembler
assembler = VectorAssembler(inputCols=[&quot;x&quot;, &quot;y&quot;, &quot;z&quot;], outputCol=&quot;features&quot;)
x = assembler.transform(x)
some_transformer = SomeTransformer(*,inputCol='features',outputCol='_features')
model = some_transformer.fit(x)  # -&gt; SomeTransformerModel
x = model.transform(x).drop('features').withColumnRenamed('_features', 'features')
</code></pre>
<p>变换后的数据包含原有数据列，以及变换后新增的<code>features</code>列（<code>DenseVector</code>）。为了方便后续分别处理各特征列的数据，需要将<code>features</code>[拆分为多列](# 将字典或序列转换为多列)。</p>
<pre><code class="language-shell">@udf(returnType=ArrayType(DoubleType()))  # from pyspark.sql.functions import udf
def vector_2_array(x: DenseVector):
    return [ float(i) for i in x ]
y:SparkColumn = vector_2_array(x['features']).alias('features')
y = {col: y.getItem(i).alias(col) for i, col in enumerate(_columns)}
x = x.select(*x.columns, *y.columns)  # 此处需要处理变换后的重名列(drop or rename)
</code></pre>
<blockquote>
<p>Spark 3.0 <code>pyspark.ml</code>模块自带<code>vector_to_array()</code>方法。</p>
</blockquote>
<h4 id="列变换"><a class="header" href="#列变换">列变换</a></h4>
<p>内置变换方法来自<code>pyspark.sql.functions</code>（SQL函数）和<code>pyspark.ml.feature</code>（变换类）等模块。</p>
<blockquote>
<p><code>broadcast(df)</code></p>
<p><code>bucket(numBuckets, col)</code></p>
<p><code>coalesce(*cols)</code>：返回第一个不为<code>null</code>的列；</p>
</blockquote>
<h5 id="生成列"><a class="header" href="#生成列">生成列</a></h5>
<p><code>input_file_name()</code>：获取当前任务的文件名；</p>
<p><code>current_date/current_timestamp()</code>：返回当前日期，同一个查询中的调用返回相同值。</p>
<p><code>lit(VALUE)</code>：创建常量列；</p>
<p><code>monotonically_increasing_id()</code>：</p>
<p><code>rand(seed=None)/randn([seed])</code>：生成<code>[0,1)</code>区间均匀分布/标准正态分布随机数；</p>
<p><code>sequence(col_start,col_stop[,col_step])</code>：生成等差数列数组，输入参数为列名或常量列(<code>lit</code>）；</p>
<p><code>spark_partition_id()</code>：</p>
<h5 id="无效值处理"><a class="header" href="#无效值处理">无效值处理</a></h5>
<p><code>isnan/isnull(col)</code>：判断值是否为<code>NaN</code>/<code>null</code>；</p>
<p><code>nanvl(col1, col2)</code>：如果<code>col1!=NaN</code>，返回<code>col1</code>；否则返回<code>col2</code>；</p>
<p><code>df.fillna(value[,subset])</code></p>
<h5 id="数值计算函数"><a class="header" href="#数值计算函数">数值计算函数</a></h5>
<p><code>abs/exp/expm1/sqrt/cbrt/log/log10/log1p/log2(col)/pow(x,y)</code>：<code>cbrt</code>三次方根，<code>expm1-&gt;</code>$e^x-1$；</p>
<p><code>greatest/least(*cols)</code>：返回多个列元素中的最大/小值；</p>
<p><code>factorial(col)</code>：阶乘；</p>
<p><code>ceil/floor/rint(col)</code>：近似；</p>
<p><code>round/bround(col[,scale])</code>：<em><code>HALF_UP/HALF_EVEN</code> rounding mode</em>，整数<code>scale</code>控制近似精度，负数表示整数部分精度。</p>
<p><code>degrees/radians(col)</code>：弧度和角度转换；</p>
<p><code>cos/sin/tan/acos/asin/atan(col)/atan2(y,x)</code>：三角/反三角函数；</p>
<p><code>sinh/cosh/tanh/acosh/asinh/atanh</code>：双曲/反双曲函数；</p>
<p><code>bitwise_not(col)</code>：</p>
<p><code>shiftleft/shiftright/shiftrightunsigned(col,numBits)</code></p>
<p><code>exists(col,f)</code>：返回指定判断函数的真值；</p>
<p><code>hypot(x,y)</code>：<code>sqrt(a^2+b^2)</code></p>
<p><strong>数值特征处理</strong></p>
<p><code>MinMaxScaler</code>：$(0,1)$规范化；</p>
<h5 id="字符串计算函数"><a class="header" href="#字符串计算函数">字符串计算函数</a></h5>
<p><code>length(col)</code>：字符串或字节序列的长度；</p>
<p><code>levenshtein(left, right)</code>：两个字符串的Levenshtein距离；</p>
<p><code>sentences(string,language=None,country=None)</code>：将字符串拆分为语句数组，语句拆分为单词数组。</p>
<h6 id="字符串变换"><a class="header" href="#字符串变换">字符串变换</a></h6>
<p><code>initcap/lower/upper(col)</code>：</p>
<p><code>translate(srcCol,matching,replace)</code>：对<code>srcCol</code>出现在<code>matching</code>中的字符替换为<code>replace</code>相应位置上的字符，例如<code>matching='123',replace='ZYX'</code>，则替换规则为<code>1-&gt;Z,2-&gt;Y,3-&gt;X</code>；</p>
<p><code>ascii(col)</code>：计算字符串的首字符ASCII码数值；</p>
<p><code>lpad/rpad(col,len,pad)</code></p>
<p><code>trim/ltrim/rtrim(col)</code></p>
<p><code>repeat(col, n)</code>：复制字符串<code>n</code>次构成新值；</p>
<p><code>reverse(col)</code>：反转字符串（或数组）；</p>
<p><code>split(str,pattern,limit[3.0])</code>：按指定模式（<code>Java</code>正则表达式）拆分字符串；</p>
<h6 id="查找替换"><a class="header" href="#查找替换">查找替换</a></h6>
<p><code>instr(col,substr)/locate(substr,col,pos=0)</code>：查找子串；</p>
<p><code>substring(col,pos,len)</code>：获取子串；<code>substring_index(str,delim,count)</code>查找分隔符出现<code>count</code>次之前的子串（如果<code>count</code>为负数则反向查找）。</p>
<p><code>overlay(src,replace,pos,len=-1)</code>：从<code>src</code>的指定位置<code>pos</code>（位置从1开始），用<code>replace</code>的内容替换<code>src</code>内容，最大替换长度为<code>len</code>；</p>
<p><code>regexp_extract(str, pattern, idx)</code>：抽取<code>idx</code>指定的捕获组，如果模式未匹配或指定捕获组未匹配，返回空字符串。</p>
<p><code>regexp_replace(str, pattern, replacement)</code></p>
<h6 id="编码-1"><a class="header" href="#编码-1">编码</a></h6>
<p><code>base64/unbase64(col)</code>：BASE64编码/解码；</p>
<p><code>crc32(col)</code>：计算二进制序列的CRC32校验值返回<code>bigint</code>；</p>
<p><code>hash/xxhash64(*col)</code>：计算输入列元素的HASH整数值/长整数值；</p>
<p><code>md5/sha1(col)/sha2(col,numBits)</code>：返回输入列的MD5/SHA-1/SHA-2xx十六进制编码字符串；</p>
<p><code>bin(col)</code>：二进制数据的字符串表示；</p>
<p><code>hex/unhex(col)</code>：字符串/整数的十六进制字符串表示（字符串每个字符的ASCII码值映射为十六进制）；</p>
<p><code>conv(col,fromBase,toBase)</code>：字符串表示的数值进行进制转换；</p>
<p><code>decode/encode(col,charset)</code>使用指定编码方法将字节序列解码为字符串（将字符串编码为字节序列）；</p>
<p><code>concat(*cols)/concat_ws(sep,*cols)</code>：将多个列字符串/字节序列拼接为新数据；</p>
<p><code>format_string(format, *cols)</code>：<code>printf</code>模式输出新列；</p>
<h5 id="日期计算函数"><a class="header" href="#日期计算函数">日期计算函数</a></h5>
<p><code>year/quarter/month/hour/minute/second(col)</code></p>
<p><code>add_months(start,months)/date_add/date_sub(start,days)</code></p>
<p><code>next_day(date, dayOfWeek)</code>：返回下一个是指定<code>DayOfWeek</code>的日期（“<code>Mon</code>”, “<code>Tue</code>”, “<code>Wed</code>”, “<code>Thu</code>”, “<code>Fri</code>”, “<code>Sat</code>”, “<code>Sun</code>”）</p>
<p><code>trunc(col_date,format)/date_trunc(format,col_timestamp)</code>：按给定格式舍弃末尾的时间值；<code>timestamp_seconds(col)</code>：<code>[3.1]</code>截取时间字段到秒；</p>
<p><code>datediff(end,start)</code>：返回两个日期间相差的天数；<code>months_between(date1,date2[,roundOff])</code>计算两个日期间相差的月数（如果为月中同一天或最后一天返回整数，否则返回浮点数）；</p>
<p><code>dayofmonth/dayofweek/dayofyear/weekofyear/last_day(col)</code>：<code>last_day</code>表示日期所在月的最后一天；</p>
<p><code>date_format/to_date(col,format)</code>：将<code>date/timestamp/string</code>类型的日期<a href="https://spark.apache.org/docs/latest/sql-ref-datetime-pattern.html">按给定格式</a>（形如<code>yyyy-mm-dd</code>）转换为字符串。<code>to_date-&gt;col.cast(&quot;date&quot;)</code>。</p>
<p><code>from_unixtime/to_timestamp/unix_timestamp(col,format=None)</code>：将时间戳（秒）转换为时间文本（<code>to_timestamp-&gt;col.cast(&quot;timestamp&quot;)</code>，<code>unix_timestamp</code>输入列如果为指定则返回当前时间）；</p>
<p><code>from_utc_timestamp/to_utc_timestamp(timestamp, tz)</code>：可指定时区。</p>
<h5 id="排序-4"><a class="header" href="#排序-4">排序</a></h5>
<p><code>asc/asc_nulls_first/asc_nulls_last/desc/desc_nulls_first/desc_nulls_last(col)</code>：返回排序表达式。</p>
<p><code>df.orderBy(*cols)/df.sort(*cols,ascending=True)</code>：使用上述UDF声明排序表达式。</p>
<p><code>df.sortWithinPartitions(*cols,ascending=True)</code></p>
<h5 id="集合类型处理函数"><a class="header" href="#集合类型处理函数">集合类型处理函数</a></h5>
<h6 id="数组计算"><a class="header" href="#数组计算">数组计算</a></h6>
<p><code>array(*cols)/array_repeat(col,count)</code>：将一个或多个列拼接成数组、将一列重复构成数组；</p>
<p><code>array_join(col,delimiter[,null_replacement])</code>：将数组拼接为字符串；</p>
<p><code>zip_with(left,right,f(l,r))</code>：合并两个序列，合并值基于两个序列相应元素通过<code>f</code>计算；</p>
<p><code>flatten(col)</code>：拼接嵌套数组（指拼接第一层嵌套）；</p>
<p><code>array_contains(col, value)</code></p>
<p><code>forall(col,f)</code>：判断数组元素是否都满足判断条件<code>f</code>；</p>
<p><code>transform(col,f)</code>：<code>[3.1]</code>对数组每个元素进行<code>f</code>变换，返回变换后的数组；</p>
<p><code>element_at(col,idx)</code>：从数值提取指定索引的元素；</p>
<p><code>slice(x,start,length)</code>：返回子数组；</p>
<p><code>array_max/array_min(col)/array_position(col,value)</code>：查找元素；</p>
<p><code>array_sort(col)/sort_array(col,asc=True)</code>：（升序）排序；</p>
<p><code>array_remove(col,element)/array_distinct(col)</code>：移除指定元素；去除重复元素；</p>
<p><code>array_except/array_intersect/array_union(col1,col2)</code>：集合操作（差集/交集/并集）；</p>
<p><code>arrays_overlap(a1,a2)</code>：判断两个数组是否存在公共元素（如果无公共元素且都包含<code>null</code>返回<code>null</code>）。</p>
<p><code>shuffle(col)</code>：随机置换序列元素。</p>
<h6 id="字典计算"><a class="header" href="#字典计算">字典计算</a></h6>
<p><code>create_map(*cols)</code>：使用输入列构建字典，输入列分别轮流作为字典的<code>key</code>和<code>value</code>值；</p>
<p><code>map_concat(*cols)</code>：将多个输入的字典拼接为一个字典；</p>
<p><code>map_from_arrays(col1, col2)</code>：将两列数据分别转换为字典的<code>key</code>和<code>value</code>，如果输入数据为数组，则返回的字典包含多个字段；</p>
<p><code>map_zip_with(col1,col2,f(key,v1,v2))</code>：<code>[3.1]</code>合并两列字典，使用指定函数合并相同<code>key</code>对应的<code>value</code>；</p>
<p><code>map_entries[3.0]/map_keys/map_values(col)&lt;-&gt;map_from_entries(col)</code>：将字典的<code>key</code>和<code>value</code>转换为一条记录<code>Row(key=,value=)</code>，并将所有记录拼接为数组返回（后续可通过<code>explode</code>将数组中的记录展开为数据表中的记录）。</p>
<p><code>transform_keys/transform_values(col,f)</code>：对字段的<code>key/value</code>执行<code>f</code>变换、返回变换后的字典；</p>
<p><code>map_filter(col, f(k,v))</code>：<code>[3.1]</code>过滤字典中不满足条件的字段；</p>
<h6 id="结构体计算"><a class="header" href="#结构体计算">结构体计算</a></h6>
<p><code>struct(*cols)</code>：基于列名和列类型生成<code>StructType</code>；</p>
<h5 id="结构化数据处理"><a class="header" href="#结构化数据处理">结构化数据处理</a></h5>
<h6 id="csv文本处理30"><a class="header" href="#csv文本处理30">CSV文本处理<code>[3.0]</code></a></h6>
<p><code>from_csv(col,schema[,options])</code>：将CSV字符串转换为一行记录；</p>
<p><code>to_csv(col[, options])</code>：将<code>StructType</code>转换为CSV字符串；</p>
<p><code>schema_of_csv(col,options=None)</code>：从CSV字符串推测Schema；</p>
<h6 id="json文本处理"><a class="header" href="#json文本处理">JSON文本处理</a></h6>
<p><code>from_json(col,schema,options=None)</code>：将JSON文本转换为<code>Row</code>/<code>StructType</code>对象（可再<a href="%E6%9C%8D%E5%8A%A1%E5%99%A8/Spark%20Python%20API.html#%E7%BB%93%E6%9E%84%E4%BD%93%E8%AE%A1%E7%AE%97">从结构体扩展为多列</a>）；使用<code>schema_of_json(json:str,options[3.0])</code>从==JSON文本==推测Schema并传递给<code>from_json</code>；</p>
<p><code>get_json_object(col,path)</code>：使用JSON Path从==JSON文本==提取字段，例如<code>&quot;$.field&quot;</code>；</p>
<p><code>json_tuple(col,*fields)</code>：从==JSON文本==的根节点提取一个或多个字段<code>fields</code>；==由于<code>get_json_object</code>和<code>json_tuple</code>没有指定Schema，返回数据转换为字符串（默认类型）==。</p>
<p><code>to_json(col,options=None)</code>将<code>StructType</code>、<code>ArrayType</code>或<code>MapType</code>转换为JSON文本；</p>
<h4 id="按元素变换"><a class="header" href="#按元素变换">按元素变换</a></h4>
<p><code>df.replace(to_replace[, value, subset])</code></p>
<h4 id="过滤-2"><a class="header" href="#过滤-2">过滤</a></h4>
<h5 id="行过滤"><a class="header" href="#行过滤">行过滤</a></h5>
<p><code>filter(col,f)</code>：行过滤；</p>
<p><code>df.filter/where(col_expr)</code>：数据集过滤；<code>df.toDF(*cols)</code>基于列名过滤；</p>
<p><code>df.limit(num)-&gt;DataFrame</code>：保留<code>num</code>行数据；</p>
<p><code>df.sample([withReplacement, …])</code></p>
<p><code>df.dropna(how='any',thresh=None,subset=None)</code>：<code>how=any|all</code>，<code>thresh</code>指定<code>null</code>的比例，<code>subset</code>指定检查的列；</p>
<p><code>df.distinct()/df.drop_duplicates([subset])</code>：保留唯一行。</p>
<h5 id="列过滤"><a class="header" href="#列过滤">列过滤</a></h5>
<p><code>df.select(*cols)</code>或<code>df.select(df.columns[i:j])</code>：按列名或列编号选择列；</p>
<p><code>df.drop(*cols)</code>或<code>df.drop(df.columns[i:j])</code>：按列名或列编号丢弃列；</p>
<p><code>df.colRegex(colNamePattern)-&gt;Column</code>：选择列名与模式匹配的列；</p>
<h4 id="插入和扩展"><a class="header" href="#插入和扩展">插入和扩展</a></h4>
<h5 id="插入新列"><a class="header" href="#插入新列">插入新列</a></h5>
<p><code>df.withColumn(colName, col)</code>：添加或替换一列数据；添加的数据列仅能为<strong>常量或基于当前<code>DataFrame</code>声明的列变换</strong>（从而保存分布式数据结构计算的兼容性）。</p>
<h5 id="将集合类型扩展为多列"><a class="header" href="#将集合类型扩展为多列">将集合类型扩展为多列</a></h5>
<h6 id="将字典或序列转换为多列"><a class="header" href="#将字典或序列转换为多列">将字典或序列转换为多列</a></h6>
<p>使用列的<code>getItem()</code>函数可按位置或键名获取集合类型的元素，从而实现一列到多列的变换。由于字典或序列长度可能不统一，导致无法合并并行处理结果，必须预先给定固定数量的列或列名。</p>
<pre><code class="language-python">col_names = ['a', 'b', 'c']
cols = [df['map_col'].getItem(col).alias(col) for col in col_names]
cols = [df['list_col'].getItem(i).alias(str(i)) for i,_ in enumerate(col_names)]
df_new = df.select(*cols)
</code></pre>
<p>如果实际已知<code>MapType</code>具有固定数量且相同的字段，则可以：</p>
<pre><code class="language-shell">col_names = list(df.first().asDict()[col_name].keys())
</code></pre>
<h6 id="将结构体转换为多列"><a class="header" href="#将结构体转换为多列"><a href="https://stackoverflow.com/questions/38753898/how-to-flatten-a-struct-in-a-spark-dataframe">将结构体转换为多列</a></a></h6>
<p>由于结构体具有固定字段，所以能够并行处理：</p>
<pre><code class="language-python">df.select(&quot;struct_col.*&quot;)  
df.select([df['struct_col'].getField(f) for in fields])
</code></pre>
<h5 id="将集合类型扩展为多行"><a class="header" href="#将集合类型扩展为多行">将集合类型扩展为多行</a></h5>
<p><code>explode/explode_outer/posexplode/posexplode_outer()</code>：将输入列（序列/字典）扩展为多行记录；其中字典的<code>key</code>和<code>value</code>分别映射为两列（后者保留<code>null</code>元素）。<code>pos-</code>函数为返回值增加位置编号字段（表示其在源数据中的顺序，默认为<code>pos</code>）。</p>
<h4 id="数据集运算"><a class="header" href="#数据集运算">数据集运算</a></h4>
<p><code>df.join(other[, on, how])</code></p>
<p><code>df.crossJoin(other)</code></p>
<p><code>df.exceptAll(other)</code>：数据集列差集，返回在当前数据集但不在另一个数据集的列；</p>
<p><code>df.intersect/intersectAll(other)</code>：返回两个数据集都存在的行（<code>intersectAll</code>保留重复）；</p>
<p><code>df.subtract(other)</code>：返回在此数据集但不在另一个数据集的行。</p>
<p><code>df.union/unionAll(other)</code>：==纵向拼接==（不去重，使用<code>df.distinct()</code>去重）；</p>
<p><code>df.unionByName(other, allowMissingColumns=False)</code>：根据列名对应拼接；</p>
<h4 id="聚合"><a class="header" href="#聚合">聚合</a></h4>
<p>聚合内置函数：<code>aggregate(col, initialValue, merge[, finish])</code></p>
<pre><code class="language-python">df.agg(count_distinct(df.age, df.name).alias('c'))
</code></pre>
<p>分组聚合：<code>df.groupBy(col:Column,...).agg_func()</code></p>
<pre><code class="language-python">agg(*expr)
apply(udf)
applyInPandas(func, schema)
# avg/count/max/min/mean/sum... =&gt; 存在等效的UDF
</code></pre>
<p>时间窗口聚合：</p>
<pre><code class="language-python">w = df.groupBy(window(&quot;date&quot;, &quot;5 seconds&quot;)).agg(sum(&quot;val&quot;).alias(&quot;sum&quot;))
col.over(window)
</code></pre>
<h5 id="统计量"><a class="header" href="#统计量">统计量</a></h5>
<p><code>avg/count/max/min/mean/sum(col)</code>：</p>
<p><code>stddev/stddev_samp/stddev_pop(col)</code>：样本/总体标准差（<code>stddev-&gt;stddev_samp</code>）；</p>
<p><code>variance/var_samp/var_pop(col)</code>：样本/总体方差<code>=&gt;df.cov(col1,col2)</code>；</p>
<p><code>corr/covar_pop/covar_samp(col1,col2)</code>：计算两列的相关系数/总体协方差/样本协方差；<code>=&gt;df.corr(col1,col2[,method])</code></p>
<p><code>approx_count_distinct(col[, rsd])</code>：近似统计列的不同值数量。</p>
<p><code>count_distinct/sum_distinct(*cols)</code>：统计不相同元素的数量/求和；</p>
<h5 id="累积数值运算"><a class="header" href="#累积数值运算">累积数值运算</a></h5>
<p><code>product(col)</code>：累计运算；</p>
<h5 id="合并拼接"><a class="header" href="#合并拼接">合并拼接</a></h5>
<p><code>collect_list/collect_set(col)</code>：将列数据合并为序列或集合；</p>
<h5 id="采样-1"><a class="header" href="#采样-1">采样</a></h5>
<p><code>first/last(col[,ignorenulls])</code>：获取分组的第一个元素；</p>
<h5 id="窗口操作"><a class="header" href="#窗口操作">窗口操作</a></h5>
<p><code>lag/lead(col[,offset,default])</code>：返回当前行的前/后第<code>offset</code>行的值；</p>
<p><code>nth_value(col, offset[, ignoreNulls])</code>：返回当前窗口中第<code>offset</code>行（从1开始）的值；</p>
<h3 id="输出-2"><a class="header" href="#输出-2">输出</a></h3>
<p>在Driver侧输出<code>DataFrame</code>的数据信息：</p>
<pre><code class="language-python">df.printSchema()
df.explain()     # Prints the (logical and physical) plans
df.count()
df.show(vertical=False)
</code></pre>
<p>在Driver侧收集<code>DataFrame</code>数据：</p>
<pre><code class="language-python">df.collect()         # -&gt; List[Row] 
df.take(num)         # -&gt; List[Row]
df.head/tail(n=NUM)  # -&gt; List[Row]
df.first()           # -&gt; Row &lt;=&gt; df.head()
df.toPandas()        # -&gt; pandas.DataFrame
df.to_pandas_on_spark([index_col])
</code></pre>
<blockquote>
<p>注意，上述方法与<code>df.limit()</code>不同，后者输出未Spark <code>DataFrame</code>。</p>
</blockquote>
<pre><code class="language-python">df.foreach(f(Row))
df.foreachPartition(f(List[Row]))
</code></pre>
<p><code>df.toLocalIterator(prefetchPartitions=False)</code>：将每个分区逐次取到本地进行处理；</p>
<pre><code class="language-python">for part in df.toLocalIterator(prefetchPartitions=False):
   # do processing in client
   # part is a Local DataFrame
</code></pre>
<h4 id="存储方法"><a class="header" href="#存储方法">存储方法</a></h4>
<p><code>writer=df.write-&gt;DataFrameWriter</code>：</p>
<p><code>writer.format(&lt;source&gt;)</code>：输出格式包括：<code>csv,json,jdbc,parquet,...</code>，等效调用<code>writer.&lt;source&gt;</code>；</p>
<p><code>df.writeStream</code></p>
<h5 id="csv存储参数"><a class="header" href="#csv存储参数">CSV存储参数</a></h5>
<ul>
<li>存储方法
<ul>
<li>模式<code>mode='append'|'overwrite'|'ignore'|'error'</code>；</li>
<li>压缩<code>compression=None|'bzip2'|'gzip'|'lz4'|'snappy'|'deflate'</code>：CSV读取不止解压缩方法，因此如果还要将存储数据读出来则选择不压缩输出。</li>
</ul>
</li>
<li>数据格式：
<ul>
<li><code>header=False</code>：将数据的字段名写入文件的首行；</li>
</ul>
</li>
<li>特殊字符，参考<a href="%E6%9C%8D%E5%8A%A1%E5%99%A8/Spark%20Python%20API.html#CSV%E8%AF%BB%E5%8F%96%E5%8F%82%E6%95%B0">CSV读取参数</a>；
<ul>
<li><code>escapeQuotes=True</code>：默认将包含引号的字段使用引号包围并对其中的引号转义；</li>
<li><code>quoteAll=False</code>：将所有字段使用引号包含；</li>
</ul>
</li>
<li>数值格式，参考<a href="%E6%9C%8D%E5%8A%A1%E5%99%A8/Spark%20Python%20API.html#CSV%E8%AF%BB%E5%8F%96%E5%8F%82%E6%95%B0">CSV读取参数</a>；</li>
</ul>
<h4 id="分区-1"><a class="header" href="#分区-1">分区</a></h4>
<pre><code class="language-python">df.repartition(numPartitions, *cols)
writer.partitionedBy(days(&quot;ts&quot;))
</code></pre>
<h5 id="分区方法"><a class="header" href="#分区方法">分区方法</a></h5>
<p><code>years/months/days/hours(col)</code>：按天分区；</p>
<p><a href="https://spark.apache.org/docs/latest/sql-getting-started.html">Spark SQL Guide: Getting Started - Spark 3.2.0 Documentation (apache.org)</a></p>
<p><a href="https://spark.apache.org/docs/latest/api/python/reference/pyspark.sql.html">Spark SQL API Reference — PySpark 3.2.0 documentation (apache.org)</a></p>
<p>用于从Hive读取数据生成<code>DataFrame</code>或<code>DataSet</code>。</p>
<h3 id="spark-pandas-api"><a class="header" href="#spark-pandas-api">Spark Pandas API</a></h3>
<h4 id="pandas-dataframe-32"><a class="header" href="#pandas-dataframe-32">Pandas DataFrame [3.2]</a></h4>
<p><a href="https://spark.apache.org/docs/latest/sql-programming-guide.html#datasets-and-dataframes">Spark SQL and DataFrames - Spark 3.2.0 Documentation (apache.org)</a></p>
<p><a href="https://spark.apache.org/docs/latest/api/python/getting_started/quickstart_ps.html">Quickstart: Pandas API on Spark — PySpark 3.2.0 documentation (apache.org)</a></p>
<p><a href="https://spark.apache.org/docs/latest/api/python/user_guide/pandas_on_spark/index.html">Pandas API on Spark User Guide — PySpark 3.2.0 documentation (apache.org)</a></p>
<p><a href="https://spark.apache.org/docs/latest/api/python/reference/pyspark.pandas/index.html">Pandas API on Spark Reference — PySpark 3.2.0 documentation (apache.org)</a></p>
<h2 id="spark-streaming"><a class="header" href="#spark-streaming">Spark Streaming</a></h2>
<p>可扩展、高吞吐、可容错的实时数据流处理。</p>
<img src="服务器/Spark Python API.assets/streaming-arch.png" alt="Spark Streaming" style="zoom: 33%;" />
<p>内部数据流</p>
<img src="服务器/Spark Python API.assets/streaming-flow.png" alt="Spark Streaming" style="zoom: 50%;" />
<blockquote>
<p>将数据流拆分为小批次（<em>discretized stream</em> or <em>DStream</em>，a sequence of <a href="%E6%9C%8D%E5%8A%A1%E5%99%A8/Spark%20Python%20API.html#RDD">RDDs</a>）。每一次处理程序调用时，接收到的数据在Spark上生成一个RDD对象。</p>
</blockquote>
<img src="服务器/Spark Python API.assets/image-20211221180224813.png" alt="image-20211221180224813" style="zoom: 35%;" />
<p>数据源：kafka、TCP socket、……</p>
<p>算法API：map、reduce、join、window；可将机器学习算法和图处理算法应用于数据流；</p>
<p>输出：文件、数据库、仪表板</p>
<ul>
<li>
<p><a href="https://spark.apache.org/docs/latest/streaming-programming-guide.html">Spark Streaming Programming Guide - Spark 3.2.0 Documentation (apache.org)</a></p>
</li>
<li>
<p><a href="https://spark.apache.org/docs/latest/streaming-programming-guide.html#deploying-applications">Deploying Applications</a></p>
</li>
</ul>
<h3 id="流处理程序框架"><a class="header" href="#流处理程序框架">流处理程序框架</a></h3>
<p>以Kafka作为数据源的流处理程序框架：</p>
<pre><code class="language-python">sc = SparkContext(conf=conf)   # 创建Spark连接上下文
stream_context = StreamingContext(sc, batchDuration=5)  # 创建Kafka流处理上下文
# 设置Kafka消费者订阅参数
zookeeper = 'node1:2181,node2:2181,node3:2181'
group_id = 'spark-streaming-consumer'
topics = {'noah.unix': 1}
# 创建Kafka数据流: 需要根据数据源的编码格式指定对应的解码方法
kafkaStream = KafkaUtils.createStream(
   stream_context, zookeeper, group_id, topics,valueDecoder=msgpack.loads)
# 流处理过程：KafkaDStream/TransformedDStream变换方法
results = kafkaStream.map(func1).reduce(func2)...
# 输出过程
kafkaStream.foreachRDD(proc_rdd)  # 定义每一批数据的处理函数
stream_context.start()             # 启动流处理任务
stream_context.awaitTermination()  # 等待流处理结束或中断，防止程序提前退出
</code></pre>
<blockquote>
<p>在上述框架中添加的普通Python程序（例如打印语句）仅会被执行一次，只有流处理相关代码才会在流数据处理每次触发执行时被执行。当流处理启动后，不能再修改处理过程。程序同一时间仅能有一个有效的<code>StreamingContext</code>，一个<code>StreamingContext</code>可以创建多个数据流。</p>
</blockquote>
<h5 id="数据源-3"><a class="header" href="#数据源-3">数据源</a></h5>
<pre><code class="language-python">stream_context.socketTextStream(&quot;localhost&quot;, 9999) # TCP socket数据源
stream_context.textFileStream(dataDirectory)  # python仅支持文本文件(HDFS)
</code></pre>
<h4 id="kafka连接模式"><a class="header" href="#kafka连接模式">Kafka连接模式</a></h4>
<h5 id="reciever模式"><a class="header" href="#reciever模式">Reciever模式</a></h5>
<p>上述框架采用Reciever模式。<code>Receiver</code>接收的数据储存在Spark执行器中，Spark流处理任务处理接收的数据。如果任务出错可能导致数据丢失，需要启用Write Ahead Logs将接收数据写到分布式存储以在必要时恢复。</p>
<blockquote>
<p>Receiver要占用Spark应用的一个任务线程，因此分配给执行器的<code>cores</code>总数要大于1。</p>
</blockquote>
<h5 id="直连模式"><a class="header" href="#直连模式">直连模式</a></h5>
<pre><code class="language-python">kafkaStream = KafkaUtils.createDirectStream(
    kafka_context, list(topics.keys()), 
    {&quot;metadata.broker.list&quot;: &quot;node1:9092,node2:9092,node3:9092&quot;},
    valueDecoder=msgpack.loads
)
</code></pre>
<h4 id="流处理过程"><a class="header" href="#流处理过程">流处理过程</a></h4>
<p>处理过程以<code>RDD</code>作为处理对象，针对当前批次数据<code>RDD</code>执行<code>map</code>、<code>reduce</code>等分布式变换处理操作，返回<code>TransformedDStream</code>处理结果。</p>
<blockquote>
<p>流处理过程是在执行器上分布式执行的，因此在Driver侧无法查看这些处理过程中的输出。</p>
</blockquote>
<p><code>map(func)</code>：对当前批次数据的每一条记录执行运算并返回结果；传递给<code>func</code>的数据为RDD中每一条记录（普通Python对象）。</p>
<p><code>mapPartitions(func)</code>：对当前批次数据的每个分片执行<code>map</code>操作，传递给<code>func</code>的数据是一个分片。该变换的效果和<code>map</code>相同，返回结果都是包含每条记录的<code>RDD</code>。使用该方法代替<code>map()</code>的场景为减少变换方法需要反复执行的初始化操作。</p>
<blockquote>
<p>因为无法通过数据序列化将特殊对象从Driver传递给执行器（例如数据库连接），因此需要在变换方法中反复调用初始化方法，造成较大开销。利用<code>mapPartitions</code>仅需为每个分片在对应的执行器上执行一次初始化。</p>
</blockquote>
<pre><code class="language-python">def func_partition_map(data:Iterable):
   for data in Iterable:
      yield func_map(data)
</code></pre>
<blockquote>
<p><a href="https://stackoverflow.com/questions/26741714/how-does-the-pyspark-mappartitions-function-work">变换函数返回一个处理后数据的迭代器</a>，<a href="%E6%9C%8D%E5%8A%A1%E5%99%A8/../Python/Python%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80.html#%E8%BF%AD%E4%BB%A3%E5%99%A8">可使用<code>yield</code>（减少创建对象最高效）、<code>iter()</code>或直接返回<code>Iterable</code></a>。</p>
</blockquote>
<p><code>flatMap(split_func)</code>：一对多映射，将一条记录拆分为序列，并将其转换为多条记录。</p>
<p><code>transform(trans_func)</code>：将一批数据<code>RDD</code>整体进行变换，可定义任意针对<code>RDD</code>的变换方法。可以在<code>trans_func</code>中将<code>RDD</code>转换为<code>DataFrame</code>。</p>
<p><code>filter(func)</code>：仅返回<code>func</code>值为<code>true</code>的记录。</p>
<h5 id="统计聚合-1"><a class="header" href="#统计聚合-1">统计聚合</a></h5>
<p><code>count()-&gt;TransformedDStream</code>：返回当前批次数据的数量（标量<code>RDD</code>）。</p>
<p><code>countByValue()</code>：统计不同记录的数量（<code>groupby-count</code>），返回包含<code>(record, num)</code>的数据流。</p>
<p><code>reduce(redfunc)</code>：对当前批次数据执行<code>reduce</code>运算，并返回标量<code>RDD</code>。<code>redfunc</code>应该满足结合律和交换律从而支持并行计算。</p>
<p><code>reduceByKey(func, numPartitions=None)</code>：(<code>groupby-aggregate</code>)对于数据结构为<code>(key,value)</code>的数据流，按<code>key</code>分组，并对<code>value</code>进行聚合。<code>numPartitions</code>指定分组任务的并行数量（即RDD的分片数量，集群模式默认值为<code>spark.default.parallelism</code>）。</p>
<p><code>updateStateByKey(func_update_state)</code>：数据记录内部状态维护。对于数据<code>(key,value)</code>，针对每个<code>key</code>维护一个状态变量（可定义任意数据类型）。当处理一批数据时，会将每个<code>key</code>对应的值构成序列传递给状态更新函数，基于该值序列可计算更新状态。</p>
<pre><code class="language-python">def func_update_state(values, state):
   if state is None:
      # init_state
   # state_update &lt;- values
   # state &lt;- state + state_update
   return state
</code></pre>
<h5 id="时间窗操作"><a class="header" href="#时间窗操作">时间窗操作</a></h5>
<img src="服务器/Spark Python API.assets/streaming-dstream-window.png" alt="Spark Streaming" style="zoom: 50%;" />
<p>窗口操作时间参数：1）<code>windowDuration</code>：时间窗长度；2）<code>slideDuration</code>：滑动时长；均为处理周期的整数倍。</p>
<p><code>window(...) </code>：获取时间窗口中的所有数据。</p>
<p><code>countByWindow(...)</code>：获取时间窗口中的所有数据的计数。</p>
<p><code>reduceByKeyAndWindow(func,[invFunc],...,numPartitions=None,filterFunc=None)</code>：记录滑动窗口中每个批次数据的聚合结果<code>reduceByKey</code>，通过<code>func</code>将新加入窗口的批量数据的聚合结果合并到窗口聚合结果中，利用<code>invFunc</code>从窗口聚合结果中移除离开活动窗口的批量数据的聚合结果。如果未提供<code>invFunc</code>（某些合并结果可能也不支持反向移除），那么每次要对聚合窗口中的每个批次的聚合结果做合并，因此效率较低。<code>filterFunc</code>基于数据<code>(key,value)</code>进行过滤，仅对满足条件的数据聚合。</p>
<blockquote>
<p><code>countByValueAndWindow()</code>基于<code>countByValue</code>结果；<code>reduceByWindow()</code>基于<code>reduce</code>结果。</p>
</blockquote>
<h5 id="内部变换"><a class="header" href="#内部变换">内部变换</a></h5>
<p><code>repartition(numPartitions)</code>：将<code>RDD</code>重新分片。</p>
<h5 id="多数据流处理"><a class="header" href="#多数据流处理">多数据流处理</a></h5>
<p><code>union(otherStream)</code>：和其他数据流合并。</p>
<p><code>join(otherStream,numPartitions=None)</code>：合并数据流，<code>(K,V)+(K,W)-&gt;(K,(V,W))</code>；还可以指定合并方式：<code>leftOuterJoin,rightOuterJoin,fullOuterJoin</code>。</p>
<p><code>cogroup(otherStream,numPartitions=None)</code>：合并数据流，将每个数据流相同键值的数据聚合为一个序列再进行拼接，<code>(K,V1)+(K,V2)...+(K,W1)+(K,W2)+...-&gt;(K,(V1,V2,...),(W1,W2,...))</code>。</p>
<h4 id="输出过程"><a class="header" href="#输出过程">输出过程</a></h4>
<p>针对当前批次数据执行输出操作（标准输出、文件、数据库、流引擎……），无返回数据。==流处理流程需要以输出过程来触发处理过程执行，否则系统会直接丢弃数据而不会执行变换处理操作==。</p>
<p><code>pprint: (num=10)</code>：输出当前批次数据<code>RDD</code>中前<code>num</code>条记录；如果<code>RDD</code>为序列类型则输出为序列，如果为标量，则输出标量。</p>
<p><code>saveAsTextFiles(prefix, [suffix])</code>：输出文件名称格式<code>prefix-TIME_IN_MS[.suffix]</code>（PythonAPI仅支持文本文件）。</p>
<p><code>foreachRDD(proc_rdd)</code>：对当前批次数据进行自定义处理。可在处理逻辑中添加输出方法。<code>proc_rdd</code>是==运行在Driver侧==的方法（<a href="https://spark.apache.org/docs/latest/streaming-programming-guide.html#design-patterns-for-using-foreachrdd">不要将连接对象传递给执行器</a>），因此可以将数据输出到终端、保存到Driver节点的文件系统、输出到数据库或HDFS。也可将<code>RDD</code>转换为<code>DataFrame</code>再执行输出处理。</p>
<pre><code class="language-python">def proc_rdd(data: RDD):
   data = rdd.map(...).reduce(...) # 进一步分布式操作
   print(data)  # 输出到driver终端
   pd.DataFrame.from_records(data).to_parquet(FILEPATH) # 输出到文件
</code></pre>
<h3 id="checkpointing容错机制"><a class="header" href="#checkpointing容错机制">Checkpointing容错机制</a></h3>
<p><a href="https://spark.apache.org/docs/latest/streaming-programming-guide.html#how-to-configure-checkpointing">How to configure Checkpointing</a></p>
<h3 id="性能优化"><a class="header" href="#性能优化">性能优化</a></h3>
<p><a href="https://spark.apache.org/docs/latest/streaming-programming-guide.html#performance-tuning">Performance Tuning</a></p>
<h2 id="structured-streaming"><a class="header" href="#structured-streaming">Structured Streaming</a></h2>
<p>结构化流处理是基于Spark SQL引擎的可扩展、高容错流处理引擎。可以使用Dataset/DataFrame API来描述数据处理过程。</p>
<p>容错机制：checkpointing and Write-Ahead Logs。</p>
<p>处理模式：</p>
<ul>
<li><em><strong>micro-batch processing</strong></em>：最少延迟100ms（默认）；</li>
<li><em><strong>continuous processing</strong></em>：最少1ms延迟（Spark 2.3+）。</li>
</ul>
<h3 id="流处理程序框架-1"><a class="header" href="#流处理程序框架-1">流处理程序框架</a></h3>
<pre><code class="language-python">stream_df = spark\
    .readStream\
    .format(&quot;kafka&quot;)\
    .trigger(processingTime=None,...)\ # 流处理周期
    .option(&quot;kafka.bootstrap.servers&quot;, &quot;node1:9092,node2:9092,node3:9092&quot;)\
    .option(&quot;subscribe&quot;, &quot;tpoics&quot;)\  
    .load()
# &quot;topic1,topic2&quot; | &quot;topic.*&quot; 
query = stream_df.select(...)\
                 .writeStream.foreachBatch(batch_func)\
                 .start()
query.awaitTermination()
</code></pre>
<p>流处理程序必须以流式<code>DataFrame</code>进程传递，最后调用<code>writeStream</code>进行输出。</p>
<blockquote>
<p>变换过程必须返回流式<code>DataFrame</code>，否则产生*<code>Queries with streaming sources must be executed with writeStream.start();</code>*</p>
</blockquote>
<h5 id="流处理周期"><a class="header" href="#流处理周期">流处理周期</a></h5>
<p>可设置一项触发选项，指定处理周期。</p>
<pre><code class="language-python">reader.trigger(processingTime='5 seconds',once=None,continuous='1 minute')
</code></pre>
<p><a href="https://spark.apache.org/docs/latest/structured-streaming-programming-guide.html">Structured Streaming Programming Guide - Spark 3.2.0 Documentation (apache.org)</a></p>
<p><a href="https://spark.apache.org/docs/latest/api/python/reference/pyspark.ss.html">Structured Streaming API Reference — PySpark 3.2.0 documentation (apache.org)</a></p>
<h3 id="输入-4"><a class="header" href="#输入-4">输入</a></h3>
<p>可使用与批量处理<a href="%E6%9C%8D%E5%8A%A1%E5%99%A8/Spark%20Python%20API.html#%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6">相同的接口读取文件</a>，此外还可指定流数据源（如Kafka）。</p>
<blockquote>
<p>Kafka输入流数据可能是以字节序列存储，需要在接收数据后自行进行反序列化（解码）。</p>
</blockquote>
<h3 id="变换处理"><a class="header" href="#变换处理">变换处理</a></h3>
<p>由于数据流以结构化的流式<code>DataFrame</code>组织，因此Spark SQL的DataFrame API都适用于流数据的处理。</p>
<blockquote>
<p>Kafka数据流除了数据字段<code>value</code>，还包含元数据字段，包括<code>key</code>，<code>topic</code>，<code>partition</code>，<code>offset</code>，<code>timestamp</code>，<code>timestampType</code>，<code>headers</code>。实际处理开始前，需要首先从<code>value</code>字段（例如JSON文本）中<a href="%E6%9C%8D%E5%8A%A1%E5%99%A8/Spark%20Python%20API.html#JSON%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86">将数据字段提取出来并结构化</a>为新的<code>DataFrame</code>。</p>
</blockquote>
<h3 id="输出-3"><a class="header" href="#输出-3">输出</a></h3>
<p><code>writer.outputMode('append|complete|update')</code>：</p>
<p><code>writer.queryName('streaming_query')</code>：指定处理流程的名称（<code>query.name</code>）；</p>
<h4 id="外部存储"><a class="header" href="#外部存储">外部存储</a></h4>
<p>参考<a href="%E6%9C%8D%E5%8A%A1%E5%99%A8/Spark%20Python%20API.html#%E5%AD%98%E5%82%A8%E6%96%B9%E6%B3%95">批量处理的输出方式</a>，仅支持<code>append</code>模式。</p>
<h4 id="输出至kafka"><a class="header" href="#输出至kafka">输出至Kafka</a></h4>
<h4 id="自定义处理"><a class="header" href="#自定义处理">自定义处理</a></h4>
<h5 id="foreach-2"><a class="header" href="#foreach-2"><a href="https://spark.apache.org/docs/latest/structured-streaming-programming-guide.html#foreach">foreach</a></a></h5>
<pre><code class="language-python">def proc_row(row):
   # ......
class ForeachWriter:
   def open(self, partition_id, epoch_id): # 创建到目标的writer连接
   def process(self, row): # 处理和写入数据
   def close(self, error): # 关闭writer连接
df_stream = writeStream.foreach(proc_row).start()  # Append,Update,Complete
</code></pre>
<h5 id="foreachbatch"><a class="header" href="#foreachbatch">foreachBatch</a></h5>
<pre><code class="language-python">def batch_print(df: DataFrame, epoch_id: int):
    print(f&quot;_________________ {epoch_id} ____________________&quot;)
    df.persist()    # 防止重复计算
    df.printSchema()
    df.show()
df_stream = writeStream.foreachBatch(batch_func).start() # Append,Update,Complete
</code></pre>
<blockquote>
<p>不支持连续模式，使用<code>foreach</code>。</p>
</blockquote>
<h4 id="调试输出"><a class="header" href="#调试输出">调试输出</a></h4>
<h5 id="console"><a class="header" href="#console">console</a></h5>
<pre><code class="language-python">writeStream.format('console')\
           .option('numRows', 20)\
           .option('truncate', True)\
           .start()                    # Append,Update,Complete
</code></pre>
<h5 id="memory"><a class="header" href="#memory">memory</a></h5>
<pre><code class="language-python">writeStream.format(&quot;memory&quot;).queryName(&quot;tableName&quot;).start()  # Append,Complete
</code></pre>
<h2 id="图分析算法-1"><a class="header" href="#图分析算法-1">图分析算法</a></h2>
<h3 id="graphframe"><a class="header" href="#graphframe">GraphFrame</a></h3>
<p>GraphFrame库用于在Spark上基于<code>DataFrame</code>表示图数据，并封装了图分析算法。</p>
<pre><code class="language-shell">conda create -n graph -c conda-forge pyspark graphframes
</code></pre>
<p>在代码中引用GraphFrame库：</p>
<pre><code class="language-python">from graphframes import *
spark = SparkSession.builder\
        .appName('Spark Graph')\
        .config('spark.jars.packages', 'graphframes:graphframes:0.8.1-spark3.0-s_2.12')\
        .getOrCreate()
</code></pre>
<p>或通过命令行（<code>spark-submit</code>或<code>pyspark</code>）参数添加引用：</p>
<pre><code class="language-shell">pyspark --packages graphframes:graphframes:0.7.0-spark2.4-s_2.11 #*
</code></pre>
<blockquote>
<p><code>*</code>：根据实际安装的Spark版本，从<a href="https://mvnrepository.com/artifact/graphframes/graphframes">Maven仓库</a>选择对应版本的库。</p>
</blockquote>
<p>通过分别表示图的节点和边的<code>DataFrame</code>构造图对象，通过<code>edges</code>和<code>vertices</code>访问图的边和节点。</p>
<pre><code class="language-python">g = GraphFrame(v, e)
g.vertices
 .filter(&quot;population &gt; 100000 and population &lt; 300000&quot;)
 .sort(&quot;population&quot;)
</code></pre>
<h4 id="图分析算法-2"><a class="header" href="#图分析算法-2">图分析算法</a></h4>
<pre><code class="language-python">from_expr = &quot;id='Den Haag'&quot;
to_expr = &quot;population &gt; 100000 and population &lt; 300000 and id &lt;&gt; 'Den Haag'&quot;
result = g.bfs(from_expr, to_expr)
</code></pre>
<h3 id="graphx"><a class="header" href="#graphx">GraphX</a></h3>
<h2 id="mllib"><a class="header" href="#mllib">MLlib</a></h2>
<p><a href="https://spark.apache.org/docs/latest/ml-guide.html">MLlib: Main Guide - Spark 3.2.0 Documentation (apache.org)</a></p>
<p><a href="https://spark.apache.org/docs/latest/api/python/reference/pyspark.ml.html">MLlib (DataFrame-based) API Reference — PySpark 3.2.0 documentation (apache.org)</a></p>
<blockquote>
<p><a href="http://www.scalanlp.org/">Breeze</a>, which depends on <a href="https://github.com/fommil/netlib-java">netlib-java</a></p>
<p>native BLAS such as <a href="https://software.intel.com/en-us/mkl">Intel MKL</a>, <a href="http://www.openblas.net/">OpenBLAS</a>, can use multiple threads in a single operation, which can conflict with Spark’s execution model.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="流式大数据处理"><a class="header" href="#流式大数据处理">流式大数据处理</a></h1>
<h2 id="kafka-1"><a class="header" href="#kafka-1">Kafka</a></h2>
<p><strong>event streaming</strong></p>
<blockquote>
<p><em>Kafka is a distributed system consisting of servers and clients that communicate via a high-performance TCP network protocol.</em></p>
<ul>
<li>Server
<ul>
<li>Broker</li>
<li>Kafka Connect</li>
</ul>
</li>
<li>Client</li>
</ul>
</blockquote>
<h3 id="concepts"><a class="header" href="#concepts">Concepts</a></h3>
<p><strong>Event</strong></p>
<p><strong>Publisher</strong></p>
<p><strong>Consumer</strong></p>
<p><strong>Topic</strong>: event organized as topics. Topics in Kafka are always multi-producer and multi-subscriber.</p>
<blockquote>
<p>Events in a topic can be ==read as often as needed==—unlike traditional messaging systems, events are ==not deleted after consumption==. </p>
<p>Instead, you define for how long Kafka should retain your events through a per-topic configuration setting, after which old events will be discarded. </p>
<p>Kafka's performance is effectively constant with respect to data size, so ==storing data for a long time is perfectly fine==.</p>
<p>Topics are <strong>partitioned</strong>, for scalability.</p>
<p>To make your data fault-tolerant and highly-available, every topic can be <strong>replicated</strong>, even across geo-regions or datacenters</p>
</blockquote>
<h3 id="安装运行-2"><a class="header" href="#安装运行-2">安装运行</a></h3>
<h4 id="linux-3"><a class="header" href="#linux-3">Linux</a></h4>
<h5 id="启动服务-3"><a class="header" href="#启动服务-3">启动服务</a></h5>
<pre><code class="language-shell">bin/zookeeper-server-start.sh config/zookeeper.properties
bin/kafka-server-start.sh config/server.properties
</code></pre>
<blockquote>
<p>可将<code>bin</code>目录加入路径，后续直接引用命令脚本。</p>
</blockquote>
<h4 id="docker-4"><a class="header" href="#docker-4">docker</a></h4>
<p>创建集群：</p>
<pre><code class="language-yaml">version: &quot;2.2&quot;
services:
  zookeeper:
    image: bitnami/zookeeper:3.7
    ports:
      - 2181:2181
    volumes:
      - zookeeper_data:/bitnami
    networks:
      - kafka
    environment:
      - ALLOW_ANONYMOUS_LOGIN=yes
  node-01:
    image: bitnami/kafka:2
    volumes:
      - data01:/bitnami
      - ./server01.properties:/bitnami/kafka/config/server.properties
    networks:
      - kafka
    ports:
      - 9092:9092
    environment:
      - KAFKA_CFG_ZOOKEEPER_CONNECT=zookeeper:2181
      - ALLOW_PLAINTEXT_LISTENER=yes
      - KAFKA_CFG_BROKER_ID=0
      - KAFKA_CFG_LISTENERS=PLAINTEXT://node-01:9092
      - KAFKA_CFG_ADVERTISED_LISTENERS=PLAINTEXT://node-01:9092
    depends_on:
      - zookeeper
  node-02: 
    environment:
      - KAFKA_CFG_BROKER_ID=1
      - KAFKA_CFG_ADVERTISED_LISTENERS=PLAINTEXT://node-02:9093
    ports:
      - 9093:9093   
volumes:
  zookeeper_data:
    driver: local
  data01:
    driver: local
  ......
networks:
  kafka:
    driver: bridge
</code></pre>
<p>由于外部需要访问所有节点，因此需要将每个服务的端口映射到宿主机的不同端口。外部访问时，仅指定其中一台节点。</p>
<blockquote>
<p>额外配置项：指定容器名和容器主机名。</p>
<pre><code class="language-yaml">container_name: kafka-zookeeper
hostname: zookeeper
</code></pre>
</blockquote>
<p><a href="https://github.com/bitnami/bitnami-docker-kafka">bitnami/bitnami-docker-kafka: Bitnami Docker Image for Kafka (github.com)</a></p>
<h3 id="管理"><a class="header" href="#管理">管理</a></h3>
<h4 id="cli"><a class="header" href="#cli">CLI</a></h4>
<h5 id="主题管理"><a class="header" href="#主题管理">主题管理</a></h5>
<p>创建主题：</p>
<pre><code class="language-shell">kafka-topics.sh --create --topic topic-name \
                --zookeeper HOST1:2181,HOST2:PORT2,...\
                --bootstrap-server HOST1:9092,...\ # [3.x]
                --partitions 1 \
                --replication-factor 2
</code></pre>
<blockquote>
<p>对于2.x版本，必须指定<code>zookeeper</code>选项，不支持<code>bootstrap-server</code>选项；对于3.x版本可仅指定<code>bootstrap-server</code>。<a href="https://stackoverflow.com/questions/46173003/bootstrap-server-vs-zookeeper-in-kafka">Bootstrap server vs zookeeper in kafka? - Stack Overflow</a></p>
</blockquote>
<p>状态监控：</p>
<pre><code class="language-shell">kafka-topics.sh ... --list all # 列出所有主题名称
kafka-topics.sh ... --describe [--topic topic] # 输出主题信息--desc
# Topic: first-topic  TopicId: CjMZOiXeSXOaaXBlfZx_fQ PartitionCount: 1       ReplicationFactor: 1    Configs: segment.bytes=1073741824
# Topic: first-topic  Partition: 0    Leader: 0       Replicas: 0     Isr: 0
</code></pre>
<h5 id="写入数据生产者"><a class="header" href="#写入数据生产者">写入数据（生产者）</a></h5>
<p>启动生产者以写入数据（通过<code>Ctrl+C</code>终止）。</p>
<pre><code class="language-shell">kafka-console-producer.sh --topic topic-name \
                          --zookeeper node1:2181,node2:2181,... \
                          --bootstrap-server node1:9092,...
</code></pre>
<blockquote>
<p>对于2.x版本，必须指定<code>zookeeper</code>选项，<code>bootstrap-server</code>为可选项；对于3.x版本可仅指定<code>bootstrap-server</code>（消费者参数同理）。</p>
</blockquote>
<h5 id="读取数据消费者"><a class="header" href="#读取数据消费者">读取数据（消费者）</a></h5>
<pre><code class="language-shell">kafka-console-consumer.sh --topic topic-name \
                          --from-beginning \
                          --bootstrap-server ... --zookeeper ...
</code></pre>
<blockquote>
<p><code>--from-beginning</code>：从kafka缓存的数据开始处开始读取（默认从当前时间点读取）。</p>
</blockquote>
<h3 id="api-1"><a class="header" href="#api-1">API</a></h3>
<blockquote>
<p>There are multiple Python libraries available for usage:</p>
<ul>
<li><a href="https://github.com/dpkp/kafka-python"><strong>Kafka-Python</strong></a> — An open-source community-based library.</li>
<li><a href="https://github.com/Parsely/pykafka"><strong>PyKafka</strong></a> — This library is maintained by Parsly and it’s claimed to be a Pythonic API. Unlike Kafka-Python you can’t create dynamic topics.</li>
<li><a href="https://github.com/confluentinc/confluent-kafka-python"><strong>Confluent Python Kafka</strong></a>:- It is offered by Confluent as a thin wrapper around <a href="https://github.com/edenhill/librdkafka"><strong>librdkafka</strong></a>, hence it’s performance is better than the two.</li>
</ul>
</blockquote>
<h4 id="kafka-python"><a class="header" href="#kafka-python">Kafka-Python</a></h4>
<h5 id="admin"><a class="header" href="#admin">Admin</a></h5>
<h5 id="producer"><a class="header" href="#producer">Producer</a></h5>
<h5 id="consumer"><a class="header" href="#consumer">Consumer</a></h5>
<p><a href="https://towardsdatascience.com/getting-started-with-apache-kafka-in-python-604b3250aa05">Getting started with Apache Kafka in Python | by Adnan Siddiqi | Towards Data Science</a></p>
<pre><code class="language-python">import json
from time import sleep

from kafka import KafkaConsumer
import msgpack 

if __name__ == '__main__':
    parsed_topic_name = 'parsed_recipes'
    # Notify if a recipe has more than 200 calories
    calories_threshold = 200

    consumer = KafkaConsumer(
       parsed_topic_name, 
       auto_offset_reset='earliest',
       bootstrap_servers=['localhost:9092'], 
       api_version=(0, 10), 
       consumer_timeout_ms=1000,
       value_deserializer=msgpack.loads  # 解码：可能采用其他解码方法
    )
    for msg in consumer:
        record = json.loads(msg.value)
        calories = int(record['calories'])
        title = record['title']

        if calories &gt; calories_threshold:
            print('Alert: {} calories count is {}'.format(title, calories))
        sleep(3)

    if consumer is not None:
        consumer.close()
</code></pre>
<h5 id="解码方法"><a class="header" href="#解码方法">解码方法</a></h5>
<p>根据Kafka的数据序列化方法，可能需要选择合适的解码方法：</p>
<ul>
<li>纯文本，无需解码；</li>
<li><code>msgpack</code>：使用<code>msgpack.loads</code>解码；如果kafka记录的<code>value</code>字段为JSON对象文本，则会自动将其转换为字典。</li>
</ul>
<h5 id="kafka-stream处理数据"><a class="header" href="#kafka-stream处理数据">Kafka Stream：处理数据</a></h5>
<h5 id="kafka-connect导入导出数据事件流"><a class="header" href="#kafka-connect导入导出数据事件流">Kafka Connect：导入导出数据（事件流）</a></h5>
<p><a href="https://kafka.apache.org/documentation/#connect">Apache Kafka</a></p>
<p><strong>message queue</strong></p>
<h3 id="对接elasticsearch"><a class="header" href="#对接elasticsearch">对接Elasticsearch</a></h3>
<p><a href="https://cloud.tencent.com/developer/article/1362324">当Elasticsearch遇见Kafka--Kafka Connect - 云+社区 - 腾讯云 (tencent.com)</a></p>
<p><a href="https://cloud.tencent.com/developer/article/1362320?from=10680">当Elasticsearch遇见Kafka--Logstash kafka input插件 - 云+社区 - 腾讯云 (tencent.com)</a></p>
<h3 id="对接spark"><a class="header" href="#对接spark">对接Spark</a></h3>
<ul>
<li><code>spark-streaming-kafka</code>：Spark流处理对接Kafka数据源；</li>
<li><code>spark-sql-kafka</code>：Spark结构化流处理对接Kafka数据源；</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="容器编排"><a class="header" href="#容器编排">容器编排</a></h1>
<h2 id="容器技术"><a class="header" href="#容器技术">容器技术</a></h2>
<h3 id="namespace-1"><a class="header" href="#namespace-1">Namespace</a></h3>
<p>Namesapce：资源隔离和虚拟化。</p>
<ul>
<li>UTS</li>
<li>IPC</li>
<li>PID</li>
<li>Network</li>
<li>Mount</li>
<li>User</li>
</ul>
<h3 id="cgroup"><a class="header" href="#cgroup">Cgroup</a></h3>
<h3 id="文件系统-7"><a class="header" href="#文件系统-7">文件系统</a></h3>
<h3 id="网络-2"><a class="header" href="#网络-2">网络</a></h3>
<h2 id="docker-5"><a class="header" href="#docker-5">Docker</a></h2>
<p>docker LXC, namespace, cgroups, 资源隔离与安全保障</p>
<p>docker client/server： REST API</p>
<p><img src="%E6%9C%8D%E5%8A%A1%E5%99%A8/./docker.assets/engine-components-flow.png" alt="Docker Engine Components Flow" /></p>
<p>docker组件：</p>
<ul>
<li>镜像（Image）</li>
<li>容器（Container）</li>
<li>仓库（Repository）</li>
</ul>
<p><img src="%E6%9C%8D%E5%8A%A1%E5%99%A8/./docker.assets/whats-the-diff-container-vs-vm.jpg" alt="What's the Diff: Containers vs VMs" /></p>
<p>https://www.backblaze.com/blog/vm-vs-containers/</p>
<p>https://docs.docker.com/get-started/overview/</p>
<h3 id="容器的优点"><a class="header" href="#容器的优点">容器的优点</a></h3>
<p>面向产品：简化交付</p>
<p>面向开发：简化环境配置</p>
<p>面向测试：多版本测试</p>
<p>面向运维：环境一致性（一次构建、代码与配置分离）</p>
<p>面向架构：自动化扩容（微服务）</p>
<p>不可变基础设施：用替换代替变更</p>
<h3 id="安装docker-engine"><a class="header" href="#安装docker-engine">安装Docker Engine</a></h3>
<h4 id="ubuntu-4"><a class="header" href="#ubuntu-4">Ubuntu</a></h4>
<pre><code class="language-shell"># install necessray tools
sudo apt-get install apt-transport-https ca-certificates \
    curl gnupg-agent software-properties-common
curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -
sudo apt-key fingerprint 0EBFCD88
# Add repository
sudo add-apt-repository \
   &quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu \
   $(lsb_release -cs) \
   stable&quot;
# install docker
sudo apt install docker-ce docker-ce-cli containerd.io docker-compose
</code></pre>
<p>https://learnku.com/articles/34941</p>
<h4 id="fedoracentos"><a class="header" href="#fedoracentos">Fedora/CentOS</a></h4>
<p>目前支持Fedora ==34/35/36==版本和CentOS ==7/8/9==（<code>centos-extras</code>仓库需要启用）<sup class="footnote-reference"><a href="#docker-install">1</a></sup>。</p>
<pre><code class="language-sh">yum install -y yum-utils # dnf -y install dnf-plugins-core
yum-config-manager --add-repo \ 
 	https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo
# dnf config-manager --add-repo
#     https://mirrors.aliyun.com/docker-ce/linux/fedora/docker-ce.repo
yum install docker-ce docker-ce-cli containerd.io docker-compose-plugin
systemctl enable --now docker  # start and enable
</code></pre>
<h5 id="移除旧版本docker"><a class="header" href="#移除旧版本docker">移除旧版本docker</a></h5>
<pre><code class="language-shell">yum remove docker docker-latest \
           docker-client docker-client-latest \
           docker-common \
           docker-logrotate docker-latest-logrotate \
           docker-engine
</code></pre>
<blockquote>
<p>位于<code>/var/lib/docker</code>的镜像、容器、卷和网络等数据不会被移除。</p>
</blockquote>
<h4 id="windows-6"><a class="header" href="#windows-6">Windows</a></h4>
<p>安装Doker Desktop，需要启用<a href="https://docs.docker.com/docker-for-windows/wsl/">Hyper-V/WSL2支持</a>。</p>
<h3 id="管理镜像"><a class="header" href="#管理镜像">管理镜像</a></h3>
<pre><code class="language-sh">docker pull centos[:tag] # get docker iamge from DockerHub
docker images  # show local images
docker save -o centos.tar centos  # save image as archive
docker load --input centos.tar    # load image from archive
docker rmi [ID|tag] # remove image
docker rmi $(docker images -q)  # remove all iamges
</code></pre>
<blockquote>
<p>Ubuntu（不包括WSL发行版）不支持<code>root</code>账号，因此需要使用<code>sudo</code>运行命令。</p>
</blockquote>
<h3 id="运行容器"><a class="header" href="#运行容器">运行容器</a></h3>
<img src="服务器/容器编排.assets/docker-host-5d47dcbc68e7d.png" alt="img" style="zoom: 67%;" />
<pre><code class="language-sh">docker run [--name NAME] centos[:latest] echo &quot;Hello World&quot;
docker run --name mydocker -d -t -i centos /bin/bash
# [start,stop]
docker start mydocker   # start an existing iamge
docker ps [-a]  # show docker instance (and history process)
</code></pre>
<ul>
<li><code>-d,--detach</code>：Run container in background and print container ID.</li>
<li><code>--network &lt;net&gt;</code>：Connect a container to a network.</li>
<li><code>--name &lt;name&gt;</code>：Assign a name to the container.</li>
<li><code>-e, --env &lt;vars&gt;</code>：设置环境变量；</li>
<li><code>-i, --interactive </code>：Keep STDIN open even if not attached</li>
<li><code>--ip string</code>：IPv4 address (e.g., 172.30.100.104)</li>
<li><code>-t, --tty</code>：Allocate a pseudo-TTY</li>
<li><code>-h, --hostname string </code>：Container host name</li>
</ul>
<p>查看容器的输出信息：</p>
<pre><code class="language-shell">docker logs [OPTIONS] CONTAINER
</code></pre>
<h4 id="进入容器"><a class="header" href="#进入容器">进入容器</a></h4>
<h5 id="attach"><a class="header" href="#attach">attach</a></h5>
<p>连接到docker的进程。</p>
<pre><code class="language-sh">docker attach mydocker
</code></pre>
<blockquote>
<p>在我们使用<code>attach</code>进入容器的时候，如果同时有多个窗口<code>attach</code>到同一个容器的时候，所有窗口都会同步显示。某个窗口因命令阻塞时,其他窗口也无法执行操作。一个窗口执行<code>exit</code>，则容器就推出运行。</p>
</blockquote>
<h5 id="nsenter"><a class="header" href="#nsenter">nsenter</a></h5>
<pre><code class="language-sh">PID=$(docker inspect --format &quot;{{ .State.Pid }}&quot; mydocker)
nsenter --target $PID --mount --uts --ipc --net --pid
</code></pre>
<h5 id="exec"><a class="header" href="#exec">exec</a></h5>
<p>通过docker让容器执行命令。</p>
<pre><code class="language-sh">docker exec mydocker ln -sf target destfile
</code></pre>
<p>容器中执行命令的返回值将通过上述命令返回。</p>
<p>进入容器：</p>
<pre><code class="language-sh">docker exec -it mydocker /bin/bash
</code></pre>
<blockquote>
<p>此时重新在容器中启动了一个shell。</p>
</blockquote>
<h4 id="删除容器"><a class="header" href="#删除容器">删除容器</a></h4>
<pre><code class="language-sh">docker rm [id|name]
docker run --rm centos /bin/echo &quot;One&quot;  # remove after stop
# 执行完命令后退出
docker kill $(docker ps -a -q) # kill all containers
docker rm $(docker ps -a -q)  # remove all stopped containers
</code></pre>
<h3 id="数据管理"><a class="header" href="#数据管理">数据管理</a></h3>
<pre><code class="language-shell">docker volume create &lt;vol_name&gt; -d,--driver &lt;driver&gt;
docker [ps|rm|prune]
</code></pre>
<p><code>driver</code>：默认为<code>local</code>，卷的物理位置。</p>
<p><code>prune</code>：删除所有未被任何容器所使用的数据卷。</p>
<p>创建的数据卷位于<code>/var/lib/docker/volumes</code>目录下。在WSL2中，数据卷的物理映射路径（<code>/var/lib/docker/volumes</code>）不变但无法访问。其实际位置在Windows的文件系统上（通过网络访问：<code>\\wsl$\docker-desktop-data\version-pack-data\community\docker\volumes</code>）。</p>
<blockquote>
<p><em>查看容器挂载的WSL卷时，发现其不是指定的目录，这里应该是做了某种映射（新版本已经做了更改）。</em></p>
<p>当停止并删除容器后，容器曾挂载过的卷仍被docker所占用，因此无法删除，需要首先退出Docker Desktop。</p>
<p>在Windows虚拟机（WSL2，VMware等）中挂载Windows目录时需要注意，容器挂载路径不要映射到Windows卷。由于Windows和Linux的读写权限配置不同，容器在Windows卷下读写文件可能会失败；因此目前最好使用WSL或虚拟机内部存储映射到容器路径。</p>
<p>VMware可以为虚拟机添加额外的虚拟磁盘或物理磁盘/分区供虚拟机独占使用。 </p>
</blockquote>
<h4 id="挂载数据"><a class="header" href="#挂载数据">挂载数据</a></h4>
<p>使用<code>-v</code>、<code>--volume</code>或<code>--mount</code>挂载目录或文件。</p>
<pre><code class="language-sh">-v /root/mediawiki:/usr/local/mediawiki
-v /root/mediawiki/logo.png:/var/www/html/resources/assets/wiki.png
</code></pre>
<p>如果目标不存在，则<code>-v</code>、<code>--volume</code>将自动创建目标，而<code>--mount</code>会产生错误。</p>
<h3 id="网络管理-4"><a class="header" href="#网络管理-4">网络管理</a></h3>
<pre><code class="language-sh">docker network create &lt;netname&gt; \
    -d,--driver &lt;driver&gt; \
    --gateway strings --ip-range strings --subnet strings
docker network connect|disconnect
docker network ls|rm|prune
docker network inspect &lt;net&gt;  # show detail of network
</code></pre>
<p><code>driver</code>：指定网络类型（管理网络的驱动：<code>bridge/host/null</code>）。系统中分别存在以每个类型名命名的默认网络实例。</p>
<h4 id="地址端口映射"><a class="header" href="#地址端口映射">地址端口映射</a></h4>
<p>将主机物理端口绑定到容器端口。</p>
<pre><code class="language-shell">-p &lt;host_addr&gt;:&lt;host_port&gt;:&lt;container_port&gt;/protocol
</code></pre>
<blockquote>
<p><code>protocol=tcp|udp</code>.</p>
<p><a href="%E6%9C%8D%E5%8A%A1%E5%99%A8/../Windows/Windows%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86.html#Docker-on-WSL2">WSL2中的端口映射</a>。</p>
</blockquote>
<h4 id="容器域名映射"><a class="header" href="#容器域名映射">容器域名映射</a></h4>
<p><code>hosts</code>文件属于镜像的只读层，重启容器后对该文件的修改丢失。在构建容器阶段替换<code>hosts</code>文件或者在启动容器时在<code>hosts</code>文件中添加额外内容。</p>
<pre><code class="language-sh">--add-host wiki.ica.caep.cn:127.0.0.1
</code></pre>
<blockquote>
<p>容器主机名（ID）映射将由docker在最后添加：<code>172.18.0.3      d6e8e32ea99b</code>。</p>
</blockquote>
<p>位于同一网络中的容器（通常使用<code>docker-compose</code>等工具构建）可通过容器名互相访问（由<code>dockerd</code>提供映射查询）。</p>
<h4 id="docker-desktop网络"><a class="header" href="#docker-desktop网络">Docker Desktop网络</a></h4>
<p>Docker Desktop使用<code>vpnkit</code>管理外发流量（TCP/IP协议栈代理，非NAT），同时使用<code>vpnkit</code>处理DNS查询和HTTP(S)代理<sup class="footnote-reference"><a href="#docker-desktop-net">2</a></sup>。</p>
<blockquote>
<p>HTTP(S)代理可在Docker Desktop配置界面中设置。</p>
<p>对于未配置DNS服务器的容器，其域名请求将由<code>vpnkit</code>转发至Docker Desktop内部的DNS服务（包括<code>dockerd</code>和CoreDNS服务）。通过CoreDNS服务，容器中的域名解析依赖主机的域名服务配置，因此容器内部服务也能够与外部主机正常通信。</p>
</blockquote>
<p>Docker Desktop通过<code>com.docker.backend</code>将Docker端口映射到主机端口<code>0.0.0.0:port</code>，从而对外提供服务。外部机器可直接通过主机地址访问相应端口（到<code>com.docker.backend.exe</code>的防火墙访问策略通过询问用户打开）。</p>
<blockquote>
<p>类似于<code>wslhost.exe</code>，但不同于<code>wslhost.exe</code>默认仅限于<code>localhost</code>访问。</p>
</blockquote>
<h3 id="docker-compose"><a class="header" href="#docker-compose">docker-compose</a></h3>
<p>除了直接通过<code>docker</code>命令接收参数的形式配置容器，也可以通过<code>docker-compose</code>输入配置文件的形式配置容器参数并构建容器（两者参数对应）。</p>
<pre><code class="language-yaml">services:
  &lt;service_name&gt;:              # service_name作为主机名
    image: &lt;image_name&gt;[:version]
	container_name: &lt;name&gt;     # --name &lt;name&gt; 容器名
    environment:               # 容器中的环境变量 (array)          
      # docker属性
      - node.name=&lt;hostname&gt;   # -h, --hostname &lt;hostname&gt;
      # 环境变量                # -e,--env &lt;vars&gt;
      - &quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot;
      - DEBUG                  # 传递shell环境变量
    volumes:
      - data01:/usr/share/elasticsearch/data  # 卷-&gt;容器路径
    networks:     # --network &lt;net&gt;
      - net         
    ports:
      - 9200:9200    # host -&gt; docker, expose is only informative
    depends_on:
      db:
        condition: service_healthy
  &lt;service_name&gt;:
    build: path_to_dockerfile
    environment:               # 容器中的环境变量 (dict)          
      key1: value1
      key2: value2
    depends_on:   # 依赖服务
      - &lt;service_name&gt;
    restart: always   # no, always, on-failure, unless-stopped
    dns:
       - 8.8.8.8
       - 9.9.9.9
    domainname: app.net
    hostname: node-1 # 主机名
    ports:
       target: 80
       host_ip: 127.0.0.1
       published: 8080
       protocol: tcp
       mode: host
    networks:
    	net:
    	  aliases:   # 网络上的主机别名
    	    - node-alias_name1
    	    - node-alias-name2
    	  ipv4_address: 172.16.238.10      # 需要在网络声明中配置子网
        ipv6_address: 2001:3984:3989::10
    extra_hosts:
    - &quot;somehost:162.242.195.82&quot;
    - &quot;otherhost:50.31.209.229&quot;
    healthcheck:
       test: [&quot;CMD&quot;, &quot;curl&quot;, &quot;-f&quot;, &quot;http://localhost&quot;]
       interval: 1m30s
       timeout: 10s
       retries: 3
       start_period: 40s
volumes: 
  data01:
    driver: local      # docker volumn create data01 --driver local
networks:
  net:
    driver: bridge     # docker network create --driver local
  net2:                # 配置子网，如果需要为容器设置IP，则需设置子网
    ipam:
      driver: default
      config:
        - subnet: &quot;172.16.238.0/24&quot;
        - subnet: &quot;2001:3984:3989::/64&quot;
</code></pre>
<h5 id="环境变量-5"><a class="header" href="#环境变量-5">环境变量</a></h5>
<p>在<code>docker-compose.yml</code>文件中，通过<code>${VAR}</code>引用环境变量。环境变量包含：</p>
<ul>
<li>
<p><code>.env</code>文件：声明编排过程中的环境变量，默认位于项目文件夹下或使用<code>--env-file</code>指定环境变量定义文件；项目文件夹即<code>docker-compose.yml</code>文件所在目录根据<code>--file</code>或<code>COMPOSE_FILE</code>环境变量确定，默认为<code>docker-compose</code>启动目录；</p>
<blockquote>
<pre><code class="language-shell">COMPOSE_PROJECT_NAME=elastic
VERSION=7.14.1
</code></pre>
</blockquote>
</li>
<li>
<p>Shell环境变量，优先级高于<code>.env</code>文件（可以在执行<code>docker-compose</code>命令前声明）；</p>
</li>
<li>
<p><code>project-name</code>由环境变量<code>COMPOSE_PROJECT_NAME</code>指定（默认为<code>docker-compose.yaml</code>文件所在目录名）。由<code>docker-compose</code>创建的对象（服务、卷、网络等）名称将自动添加<code>project-name</code>作为前缀。</p>
</li>
</ul>
<h5 id="网络配置-3"><a class="header" href="#网络配置-3">网络配置</a></h5>
<p>根据<code>networks</code>声明自动创建网络；如果没有声明网络，则会自动创建默认的网络（<code>&lt;project-name&gt;_default</code>）。</p>
<h5 id="数据卷配置"><a class="header" href="#数据卷配置">数据卷配置</a></h5>
<p>自动创建卷位于<a href="%E6%9C%8D%E5%8A%A1%E5%99%A8/%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92.html#%E5%8D%B7%E7%AE%A1%E7%90%86"><code>/var/lib/docker/volumes/</code></a>，卷名为<code>&lt;project-name&gt;_&lt;volume-name&gt;</code>。</p>
<h4 id="启动顺序"><a class="header" href="#启动顺序">启动顺序</a></h4>
<p><a href="https://docs.docker.com/compose/startup-order/">Control startup and shutdown order in Compose | Docker Documentation</a></p>
<h4 id="管理-1"><a class="header" href="#管理-1">管理</a></h4>
<pre><code class="language-shell"># [up,create,start,restart]
docker-compose up -d  # Create and start containers (as daemon)
# [start,pause,unpause,stop,restart]
docker-compose kill   # 
docker-compose rm     # 删除停止服务（镜像）
docker-compose down -v # 删除容器以及相关网络、数据卷等
docker-compose ps     # at dir with docker-compose.yaml
</code></pre>
<h5 id="状态检查"><a class="header" href="#状态检查">状态检查</a></h5>
<p><a href="https://docs.docker.com/compose/compose-file/compose-file-v3/#healthcheck">Compose file version 3 reference | Docker Documentation</a></p>
<h3 id="构建镜像"><a class="header" href="#构建镜像">构建镜像</a></h3>
<h4 id="手动"><a class="header" href="#手动">手动</a></h4>
<p>手动向容器添加内容，并将该容器保存为镜像。</p>
<pre><code class="language-shell">docker commit -m &quot;message&quot; container_id image_name:tag
</code></pre>
<h4 id="dockerfile"><a class="header" href="#dockerfile">Dockerfile</a></h4>
<p>Dockerfile：构建容器镜像的声明文件。</p>
<pre><code class="language-dockerfile"># This docker file uses the centos image
# VERSION 1
# Author: Jason Zhao
# Base image
FROM centos
# Maintainer
MAINTAINER shundong.zhao zhaoshundong@gmail.com
#Commands to update the image
# LABEL url=&quot;&quot;
ENV DEBIAN_FRONTEND noninteractive   # 环境变量
RUN rpm -ivh http://mirrors.aliyun.com/epel/epel-release-latest-7.noarch.rpm
RUN yum install -y nginx --enablerepo=epel  # 在容器中运行命令
# VOLUME 
WORKDIR /your/path   # 切换工作目录
ADD index.html /usr/share/nginx/html/index.html
COPY host/src container/target       # 拷贝文件
RUN echo &quot;daemon off;&quot; &gt;&gt; /etc/nginx/nginx.conf
EXPOSE 80    # 暴露容器端口
CMD  [&quot;python3&quot;, &quot;-m&quot;, &quot;pelican.server&quot;, &quot;80&quot;]  # 运行命令，可添加多个参数
USER xxx   # 
</code></pre>
<blockquote>
<p><em><code>COPY</code>命令似乎不支持符号链接拷贝。</em></p>
<p><code>ARG</code>存在于<code>docker build</code>命令执行期间。默认值写在 Dockerfile里。如果需要修改，可以通过<code>docker build</code>命令里的<code>--build-arg</code>参数来指定。</p>
<p><code>ENV</code>存在于<code>docker run</code>命令执行期间。默认值写在Dockerfile里。如果要修改，可以通过<code>docker run</code>命令的 <code>--env</code>参数来指定。</p>
<p><code>ARGENV</code>：如果要把<code>ARG</code>的值保存到<code>container</code>运行起来之后仍然可以可用。</p>
</blockquote>
<h5 id="run"><a class="header" href="#run">RUN</a></h5>
<p>在镜像容器中执行命令。</p>
<h5 id="构建命令"><a class="header" href="#构建命令">构建命令</a></h5>
<pre><code class="language-sh">docker build -t img_name:img_tag -f app.dockerfile PATH
</code></pre>
<p><code>-f</code>指定<code>Dockerfile</code>的路径，默认为<code>PATH/Dockerfile</code>；<code>PATH</code>参数不可省略（当前路径使用<code>&quot;.&quot;</code>）</p>
<p>镜像分层设计：</p>
<ul>
<li>操作系统</li>
<li>运行环境</li>
<li>应用</li>
</ul>
<p>SSH</p>
<p>Supervisor</p>
<h3 id="docker仓库"><a class="header" href="#docker仓库">Docker仓库</a></h3>
<h4 id="设置镜像源"><a class="header" href="#设置镜像源">设置镜像源</a></h4>
<p>创建或修改<code>/etc/docker/daemon.json</code>文件，修改为如下形式：</p>
<pre><code class="language-json">{ &quot;registry-mirrors&quot; : [
  &quot;https://famqhaa8.mirror.aliyuncs.com&quot;,  
  &quot;https://docker.mirrors.ustc.edu.cn&quot;,
  &quot;http://hub-mirror.c.163.com&quot;,
  &quot;https://registry.docker-cn.com&quot;
]}
</code></pre>
<blockquote>
<p><a href="https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors">容器镜像服务 (aliyun.com)</a></p>
</blockquote>
<p>重启docker服务使配置生效。</p>
<pre><code class="language-sh">systemctl daemon-reload
systemctl restart docker
</code></pre>
<h4 id="docker-registry"><a class="header" href="#docker-registry">Docker Registry</a></h4>
<h4 id="harbor"><a class="header" href="#harbor">Harbor</a></h4>
<h4 id="nexus"><a class="header" href="#nexus">Nexus</a></h4>
<pre><code class="language-sh">docker login reg.example.com
docker push
</code></pre>
<h2 id="容器编排-1"><a class="header" href="#容器编排-1">容器编排</a></h2>
<p>https://mp.weixin.qq.com/s/spNSMozSrCO7AgqyRVfwug</p>
<p>常见的容器编排引擎包括：Kubernetes、Docker Swarm、Apache Mesos等。</p>
<blockquote>
<p><em>With that said, if you’re just looking to get up and running and test out using an orchestration engine, then Docker Swarm is probably a good choice. When you’re ready to delve further into the subject, or possibly deploy something leaning toward industrial grade, look to Kubernetes. If flexibility and massive scale are your goals, then consider Apache Mesos.</em>   https://www.sumologic.com/insight/kubernetes-vs-mesos-vs-swarm/</p>
</blockquote>
<h3 id="kubernetes架构"><a class="header" href="#kubernetes架构">Kubernetes架构</a></h3>
<p><img src="%E6%9C%8D%E5%8A%A1%E5%99%A8/docker.assets/components-of-kubernetes.png" alt="Kubernetes 组件" /></p>
<p>https://kubernetes.io/zh/docs/concepts/overview/what-is-kubernetes/</p>
<h4 id="物理节点"><a class="header" href="#物理节点">物理节点</a></h4>
<h5 id="master"><a class="header" href="#master">Master</a></h5>
<ul>
<li><strong>API Server</strong>：提供Kubernetes API接口，主要处理 Rest操作以及更新Etcd中的对象。是所有资源增删改查的唯一入口。</li>
<li><strong>Scheduler</strong>：绑定Pod到Node上，主要做资源调度。</li>
<li><strong>Controller Manager</strong>：所有其他群集级别的功能，目前由控制器Manager执行。资源对象的自动化控制中心，Kubernetes集群有很多控制器。</li>
<li><strong>Etcd</strong>：所有持久化的状态信息存储在Etcd中，这个是Kubernetes集群的数据库。</li>
</ul>
<h5 id="node"><a class="header" href="#node">Node</a></h5>
<p>从节点上运行<code>kubelet</code>、<code>kube-proxy</code>分别作为计算节点的代理和网络代理。</p>
<p>节点上运行容器引擎（例如Docker），负责容器创建等具体工作。</p>
<h4 id="虚拟节点"><a class="header" href="#虚拟节点">虚拟节点</a></h4>
<h5 id="pod"><a class="header" href="#pod">Pod</a></h5>
<p>封装一个或多个容器（通常为1个）。Pod中封装的容器由容器引擎创建。</p>
<h5 id="service-cluster"><a class="header" href="#service-cluster">Service Cluster</a></h5>
<p>运行同一服务的所有Pod组成的集合。</p>
<h4 id="kubernetis网络"><a class="header" href="#kubernetis网络">Kubernetis网络</a></h4>
<p><a href="https://opensource.com/article/22/6/kubernetes-networking-fundamentals?check_logged_in=1">A visual guide to Kubernetes networking fundamentals | Opensource.com</a></p>
<h5 id="intra-pod-and-inter-pod"><a class="header" href="#intra-pod-and-inter-pod">intra-pod and inter-pod</a></h5>
<img src="服务器/容器编排.assets/1containerandpodnets.jpg" alt="Container-to-container and pod-to-pod networking" style="zoom: 67%;" />
<h5 id="podinternet-to-service"><a class="header" href="#podinternet-to-service">pod/internet-to-service</a></h5>
<img src="服务器/容器编排.assets/2podtoservicenets.jpg" alt="Pod-to-Service networking" style="zoom:67%;" />
<img src="服务器/容器编排.assets/3internettoservicenets.jpg" alt="Internet-to-service" style="zoom:67%;" />
<h3 id="安装配置kubernetes集群"><a class="header" href="#安装配置kubernetes集群">安装配置Kubernetes集群</a></h3>
<h3 id="管理集群"><a class="header" href="#管理集群">管理集群</a></h3>
<h4 id="常用管理命令"><a class="header" href="#常用管理命令">常用管理命令</a></h4>
<h5 id="创建资源"><a class="header" href="#创建资源">创建资源</a></h5>
<p>将集群中的资源进行抽象封装，由Kubernetes进行管理。</p>
<pre><code class="language-sh">kubectl create -f res-manifest.yaml  # create resources
kubectl apply  -f res-manifest.yaml  # apply changes to created resources
kubectl delete &lt;type&gt; &lt;resource&gt;  # delete resources
</code></pre>
<p>Kubernetes管理的资源类型包括计算资源（Pod）、网络资源（Service）、存储资源（Volumn）等类型。</p>
<pre><code class="language-sh">kubectl api-resources  # list type of kubernetes resources
</code></pre>
<blockquote>
<p>某些资源名称可使用缩写代替，<code>all</code>可以代表所有资源类型</p>
</blockquote>
<h5 id="资源信息"><a class="header" href="#资源信息">资源信息</a></h5>
<pre><code class="language-sh">kubectl get &lt;type&gt; [&lt;resource&gt;]  # list specified (type of) resource
kubectl get &lt;type&gt; -l app=nginx
</code></pre>
<blockquote>
<p><code>-o wide</code>：默认按列表形式显示，该选项可显示更多列内容；
<code>-o yaml</code>：输出资源对应的配置； 
<code>-l expr</code>：通过标签筛选；</p>
</blockquote>
<pre><code class="language-sh">kubectl describe &lt;type&gt; [&lt;resource&gt;] # get details of specified (type of) resources
</code></pre>
<p>虚拟资源可按命名空间分组。</p>
<pre><code class="language-sh">kubectl create ns &lt;namedspace&gt;
kubectl &lt;command&gt; -n nginx  # 在指定命名空间进行操作
</code></pre>
<h3 id="计算资源"><a class="header" href="#计算资源">计算资源</a></h3>
<h4 id="node-1"><a class="header" href="#node-1">Node</a></h4>
<p>添加标签。标签可用于创建资源时对节点进行筛选。</p>
<pre><code class="language-sh">kubectl label node &lt;host&gt; &lt;label=value&gt;
kubectl get node --show-labels
</code></pre>
<h4 id="pod-1"><a class="header" href="#pod-1">Pod</a></h4>
<pre><code class="language-yaml"># pod.yaml
apiVersion: v1
kind: Pod
metadata:
  name: nginx-pod
  labels:
    app: pod-nginx   # lable and values can be customized
spec:
  containers:
  - name: nginx
    image: nginx:1.13.12
    ports:
- containerPort: 80
</code></pre>
<p>将Pod运行在指定的Node上。</p>
<pre><code class="language-yaml"># deploy.yaml
spec:
  template:
    spec:
      nodeSelector:
        disktype: ssd
</code></pre>
<h4 id="控制器-1"><a class="header" href="#控制器-1">控制器</a></h4>
<p>通过控制器实现容器应用的自动化管理。</p>
<h5 id="replicationcontroller-rc"><a class="header" href="#replicationcontroller-rc">ReplicationController (RC)</a></h5>
<p>确保应用运行的Pod的数量。与手动创建的 pod 不同，如果有 pod 失败、被删除或被终止，ReplicationController 会自动维护并替代这些 pod 。</p>
<h5 id="replicaset-rs"><a class="header" href="#replicaset-rs">ReplicaSet (RS)</a></h5>
<p>ReplicaSet支持标签选择器，而ReplicationController仅支持基于等级的选择器。</p>
<h5 id="deployment"><a class="header" href="#deployment">Deployment</a></h5>
<p>封装了Pod的副本管理、部署更新、回滚、扩容、缩容等功能。</p>
<blockquote>
<p>Deployment封装了ReplicaSet。</p>
</blockquote>
<pre><code class="language-yaml"># deploy.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  namespace: nginx
  name: nginx-deployment  # must be lowercase alphabet, '.', or '-'
  labels:
    app: deploy-nginx
spec:
  replicas: 3    # number of pod instance
  selector:
    matchLabels: # ?
      app: nginx
  template:
    metadata:
      labels: # pod label
        app: pod-nginx
    spec:
      containers:
      - name: nginx
        image: nginx:1.13.12
        ports:
        - containerPort: 80
</code></pre>
<p>更新和回滚：</p>
<pre><code class="language-sh">kubectl set image deployment/nginx-deployment nginx=nginx:1.14.2 --record # update and record history version
kubectl rollout history deployment/nginx-deployment # output history
kubectl rollout history deployment/nginx-deployment --revision=1
kubectl rollout undo deployment/nginx-deployment
</code></pre>
<p>Scale-in/out：设置应用运行的<code>pod</code>实例数量。</p>
<pre><code class="language-sh">kubectl scale deployment nginx-deployment --replicas &lt;n&gt;
</code></pre>
<h5 id="daemonset"><a class="header" href="#daemonset">DaemonSet</a></h5>
<p><code>DaemonSet+nodeSelector</code>：使容器仅运行在通过标签筛选的节点上，且每个节点上只运行一个Pod实例。</p>
<h5 id="statefulset"><a class="header" href="#statefulset">StatefulSet</a></h5>
<p>有状态的应用，为 Pod 提供唯一的标识，它可以保证部署和 scale 的顺序。</p>
<h5 id="job"><a class="header" href="#job">Job</a></h5>
<p>使用Kubernetes运行单一任务。</p>
<h5 id="cronjob"><a class="header" href="#cronjob">CronJob</a></h5>
<p>使用Kubernetes运行定时任务。</p>
<h3 id="网络资源"><a class="header" href="#网络资源">网络资源</a></h3>
<p>Node网络指的是Kubernetes Node节点本地的网络，所有的Node和Master在该网段都可以正常通信。</p>
<p>每一个Pod都会有一个IP地址（Pod内的容器/进程共享一个IP地址），这个IP地址网络段被称之为Pod网络。</p>
<p>Service是为Pod提供访问和负载均衡的网络地址段。</p>
<h4 id="服务-3"><a class="header" href="#服务-3">服务</a></h4>
<p>由于Pod的生命周期是短暂的，而且每次重启Pod的IP地址都会发生变化。Kubernetes使用Service来实现Pod的访问，而且Service有一个Cluster IP，通常也称之为VIP，是固定不变的。</p>
<img src="服务器/docker.assets/2e61328894d1eaf548ad6ff06d85a6a3.png" alt="img" style="zoom:67%;" />
<p>每个Service实例存在一个对应的Endpoint实例，记录了该Service中的Pod实例信息。</p>
<p>Serivce类型：</p>
<ul>
<li>
<p>ClusterIP：使用Serivce的IP访问服务，只能在集群内部使用；</p>
</li>
<li>
<p>NodePort：使用边缘节点的IP和端口映射到Service的VIP和端口（传输层负载均衡）；</p>
<pre><code class="language-yaml"># service.yaml
kind: Service
apiVersion: v1
metadata:
  namespace: nginx
  name: svc-nginx-nodeport
spec:
  type: NodePort
  selector:
    app: pod-nginx    # match pod's label 
  ports:
  - protocol: TCP
    port: 80          # sevice port
    targetPort: 80    # pod port
    nodePort: 32222   # mapping service port to edge node port
</code></pre>
</li>
</ul>
<h4 id="负载均衡-2"><a class="header" href="#负载均衡-2">负载均衡</a></h4>
<p>应用层负载均衡：根据URL进行转发。</p>
<h5 id="lvs-1"><a class="header" href="#lvs-1">LVS</a></h5>
<p><code>ipvs</code></p>
<p>http://www.linuxvirtualserver.org/zh/lvs1.html</p>
<h5 id="ingress-controller"><a class="header" href="#ingress-controller">Ingress Controller</a></h5>
<p>Ingress Controller目前有两大开源项目，一个是Nginx Controller，一个是目前比较流行的Traefik。</p>
<h6 id="创建ingress实例"><a class="header" href="#创建ingress实例">创建ingress实例</a></h6>
<pre><code class="language-sh">
</code></pre>
<h6 id="设置ingress规则"><a class="header" href="#设置ingress规则">设置ingress规则</a></h6>
<p>从Service处获取Endpoint信息，从而直接转发到Pod。</p>
<pre><code class="language-yaml"># ingress.yaml
apiVersion: extensions/v1beta1
kind: Ingress
metadata:
  namespace: nginx
  name: ingress-webserver
spec:
  rules:
  - host: nginx.example.com
    http:
      paths:
      - path: /
        backend:
          serviceName: nginx-web-server  # service name (not deploy)
          servicePort: 80
</code></pre>
<h3 id="存储-1"><a class="header" href="#存储-1">存储</a></h3>
<p>Volume：需要在Pod中进行定义，生命周期和Pod一样；</p>
<ul>
<li>emptyDir卷</li>
<li>HostPath卷</li>
</ul>
<p>PersistentVolume（PV）：集群中的存储资源。</p>
<p>访问模式：</p>
<ul>
<li>ReadWriteOnce——该卷可以被单个节点以读/写模式挂载</li>
<li>ReadOnlyMany——该卷可以被多个节点以只读模式挂载</li>
<li>ReadWriteMany——该卷可以被多个节点以读/写模式挂载</li>
</ul>
<p>回收策略：</p>
<ul>
<li>Retain（保留）——手动回收</li>
<li>Recycle（回收）——基本擦除（<code>rm -rf /thevolume/*</code>）</li>
<li>Delete（删除）——关联的存储资产（例如 AWS EBS、GCE PD、Azure Disk 和 OpenStack Cinder 卷）将被删除</li>
</ul>
<p>storageClassName</p>
<p>PersistentVolumeClaim （PVC）：请求并关联PV资源。声明可以请求特定的大小和访问模式（例如，可以以读/写一次或只读多次模式挂载）。</p>
<p>StorageClass</p>
<h4 id="nfs"><a class="header" href="#nfs">NFS</a></h4>
<pre><code class="language-sh">salt-ssh '*' -r 'yum install -y nfs-utils rpcbind'
echo &quot;/data/k8s-nfs *(rw,sync,no_root_squash)&quot; &gt;&gt; /etc/exports
systemctl enable --now rpcbind
showmount -e &lt;host&gt;  # show mounted NFS
</code></pre>
<h5 id="创建pv"><a class="header" href="#创建pv">创建PV</a></h5>
<pre><code class="language-yaml">apiVersion: v1
kind: PersistentVolume
metadata:
  name: pv-demo
spec:
  capacity:
    storage: 1Gi
  accessModes:
    - ReadWriteOnce
  persistentVolumeReclaimPolicy: Recycle
  storageClassName: nfs
  nfs:
    path: /data/k8s-nfs/pv-demo
    server: 192.168.56.11
</code></pre>
<h5 id="创建pvc"><a class="header" href="#创建pvc">创建PVC</a></h5>
<pre><code class="language-yaml"># pvc.yaml
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  namespace: nginx
  name: pvc0
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 1Gi
  storageClassName: nfs
</code></pre>
<p>PVC的使用在应用部署声明中给出：</p>
<pre><code class="language-yaml"># deployment.yaml
template:
  spec:
    containers:
    - name: nginx
      volumnMounts:
      - mountPath: &quot;/usr/share/nginx/html&quot;
        name: pvc0
    volumes:
      - name: pvc0
        persistentVolumeClaim:
          claimName: pvc0
</code></pre>
<blockquote>
<p><em>persistentvolume-controller  Volume recycled</em></p>
</blockquote>
<h3 id="部署应用"><a class="header" href="#部署应用">部署应用</a></h3>
<pre><code class="language-sh"># create a name space
kubectl create ns &lt;namedspace&gt;
kubectl label ns nginx name=&quot;NginxWebServer&quot;
# creat a deployment (computing)
# specify name space in &lt;yaml&gt; file or by &quot;-n &lt;namespace&gt;&quot;
kubectl apply -f nginx-deployment-web.yaml
# creat a service (networking)
# creat a NodePort mapping
kubectl create -f nginx-service-web.yaml
# set an ingress rule for &quot;nginx.example.com&quot;
kubectl create -f nginx-ingress-web.yaml
# mount data volumn (storage)
kubectl apply -f nginx-deployment-pvc-web.yaml
</code></pre>
<h2 id="应用-3"><a class="header" href="#应用-3">应用</a></h2>
<h3 id="使用docker"><a class="header" href="#使用docker">使用Docker</a></h3>
<h5 id="mediawiki"><a class="header" href="#mediawiki">Mediawiki</a></h5>
<p>https://hub.docker.com/_/mediawiki</p>
<p>Mediawiki使用MySQL存储数据，首先在数据库中为Mediawiki<a href="%E6%9C%8D%E5%8A%A1%E5%99%A8/../%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL.html#%E8%B4%A6%E6%88%B7%E7%AE%A1%E7%90%86">创建用户并分配权限</a>。</p>
<pre><code class="language-shell">docker run -d \
	--net=xwiki-nw \
	--name mysql-xwiki \
	-v /home/gary/mysql:/var/lib/mysql \
	-v /home/gary/mysql-init:/docker-entrypoint-initdb.d \
	-e MYSQL_ROOT_PASSWORD=xwiki \
	-e MYSQL_USER=xwiki \
	-e MYSQL_PASSWORD=xwiki \
	-e MYSQL_DATABASE=xwiki  \
	mysql \
	--character-set-server=utf8mb4 \
	--collation-server=utf8mb4_bin \
	--explicit-defaults-for-timestamp=1 \
	--default-authentication-plugin=mysql_native_password # mysql 8.0
</code></pre>
<pre><code class="language-mysql">CREATE USER mediawiki IDENTIFIED BY 'mediawiki'; % 创建额外用户
grant all privileges on *.* to xwiki@'%', mediawiki@'%';
</code></pre>
<pre><code class="language-sh">sudo docker run -d \
	--name my-mediawiki \
	--net xwiki-nw \
	-p 10080:80 \
  -v /home/gary/mediawiki:/usr/local/mediawiki \
  -v 
  mediawiki
</code></pre>
<blockquote>
<p>可能需要配置数据库权限</p>
<p>生成的<code>LocalSettings.php</code> 文件放到<code>/var/www/html</code>目录下（与<code>index.php</code>同级）。可以在其中添加并修改<code>includes/DefaultSettings.php</code>中的配置项。可以将该文件所在的外部目录挂载到容器中，并链接到http服务主目录下。</p>
</blockquote>
<h5 id="xwiki"><a class="header" href="#xwiki">xwiki</a></h5>
<p>https://github.com/xwiki-contrib/docker-xwiki/blob/master/README.md</p>
<pre><code class="language-sh">docker network create -d bridge xwiki-nw
</code></pre>
<p>首先创建<a href="%E6%9C%8D%E5%8A%A1%E5%99%A8/%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92.html#%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%B9%E5%99%A8">数据库</a>。</p>
<pre><code class="language-sh">docker run -d \
	--net=xwiki-nw \
	--name xwiki \
	-p 8080:8080 \
	-v /my/path/xwiki:/usr/local/xwiki \
	-e DB_USER=xwiki \
	-e DB_PASSWORD=xwiki \
	-e DB_DATABASE=xwiki \
	-e DB_HOST=mysql-xwiki \ 
	xwiki:lts-mysql-tomcat
</code></pre>
<blockquote>
<p><code>Mysql&gt;=5.7</code>。</p>
</blockquote>
<h2 id="参考资料-15"><a class="header" href="#参考资料-15">参考资料</a></h2>
<div class="footnote-definition" id="docker-install"><sup class="footnote-definition-label">1</sup>
<p><a href="https://docs.docker.com/engine/install/">Install Docker Engine | Docker Documentation</a></p>
</div>
<div class="footnote-definition" id="docker-desktop-net"><sup class="footnote-definition-label">2</sup>
<p><a href="https://www.docker.com/blog/how-docker-desktop-networking-works-under-the-hood/">How Docker Desktop Networking Works Under the Hood - Docker</a>.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="虚拟化"><a class="header" href="#虚拟化">虚拟化</a></h1>
<h2 id="vmware"><a class="header" href="#vmware">VMWare</a></h2>
<h3 id="网络配置-4"><a class="header" href="#网络配置-4">网络配置</a></h3>
<h4 id="虚拟网络-2"><a class="header" href="#虚拟网络-2">虚拟网络</a></h4>
<h5 id="vmware虚拟网桥"><a class="header" href="#vmware虚拟网桥">VMware虚拟网桥</a></h5>
<p><code>vmnet0</code>：与主机网络连接复用物理接口。</p>
<p><img src="%E6%9C%8D%E5%8A%A1%E5%99%A8/%E8%99%9A%E6%8B%9F%E5%8C%96.assets/clip_image001.png" alt="img" /></p>
<blockquote>
<p>虚拟网桥的物理主机是透明的。在Windows中，无需通过<strong>网络管理</strong>配置接口的桥接。</p>
</blockquote>
<p>==配置自动桥接的主机网络适配器==：可选列表中可能包含了Hyper-V的虚拟适配器，应该取消选择，否则其IP地址与物理网卡地址可能不在同一网段。</p>
<p><code>vmnet1</code>：Host-Only网络模式，类似于<code>vmnet0</code>但无法访问物理网络。</p>
<h5 id="vmware-nat"><a class="header" href="#vmware-nat">VMware NAT</a></h5>
<p><code>vmnet8</code>：宿主机地址为：<code>192.168.xxx.1</code>，虚拟网关/DNS服务器地址为：<code>192.168.xxx.2</code>（见配置文件<code>%PROGRAMDATA%/VMWare/vmnetnat.conf</code>）；</p>
<p><img src="%E6%9C%8D%E5%8A%A1%E5%99%A8/%E8%99%9A%E6%8B%9F%E5%8C%96.assets/clip_image002.png" alt="img" /></p>
<blockquote>
<p><strong>NAT设备</strong>：通过网络地址转换为物理机IP地址，由物理网络接口收发数据。</p>
</blockquote>
<p>通过<code>vmnetnat.conf</code>可配置入网流量的NAT端口地址映射。</p>
<pre><code class="language-shell">[incomingtcp]
# Use these with care - anyone can enter into your virtual machine through these...
#
# WEB (make sure that if you are using named webhosting, names point to
#   your host, not to guest... And if you are forwarding port other
#   than 80 make sure that your server copes with mismatched port 
#   number in Host: header)
#   lynx http://localhost:8888
#8888 = 192.168.27.128:80
[incomingudp]
# UDP port forwarding example
#6000 = 192.168.27.128:6001
</code></pre>
<p>完成后重启VMWare NAT服务。在宿主机或其他主机上，可通过宿主机的IP地址和映射后的端口访问虚拟机中开放的服务。==如果防火墙开启，则需要设置一条防火墙入站规则，允许访问主机的目标端口。==</p>
<p>https://www.vmware.com/support/ws3/doc/ws32_network21.html</p>
<h3 id="共享"><a class="header" href="#共享">共享</a></h3>
<h4 id="宿主磁盘文件共享"><a class="header" href="#宿主磁盘文件共享">宿主磁盘文件共享</a></h4>
<h5 id="安装vmware-tools"><a class="header" href="#安装vmware-tools">安装vmware-tools</a></h5>
<p><code>vmware-tools</code>需要Linux虚拟机安装perl解释器。</p>
<p>在Linux虚拟机中安装<code>vmware-tools</code>时找不到<code>gcc</code>、<code>kernel-headers</code>，需要安装编译工具和依赖库。</p>
<pre><code class="language-shell">yum install gcc binutils make kernel-devel -y
</code></pre>
<p>无法在虚拟机中访问已共享的宿主机文件夹。</p>
<pre><code class="language-shell">sudo vi /etc/fstab
# append following content
# .host:/     /mnt/hgfs    fuse.vmhgfs-fuse  allow_other    0    0
</code></pre>
<h3 id="显示"><a class="header" href="#显示">显示</a></h3>
<h4 id="虚拟机屏幕尺寸"><a class="header" href="#虚拟机屏幕尺寸">虚拟机屏幕尺寸</a></h4>
<p>问题：虚拟机不能自适应屏幕尺寸。</p>
<blockquote>
<p>The issue is that <code>libresolutionKMS.so</code> is not loaded into the Wayland session on Fedora. It works as expected in Ubuntu 20.10 with either Wayland or Xorg.</p>
</blockquote>
<pre><code class="language-shell">cp /etc/vmware-tools/tools.conf.example /etc/vmware-tools/tools.conf
nano /etc/vmware-tools/tools.conf
</code></pre>
<p>Remove the # from this block:</p>
<pre><code class="language-shell">[resolutionKMS]
enable=true
</code></pre>
<pre><code class="language-shell">systemctl restart vmtoolsd.service
</code></pre>
<h3 id="移动和复制虚拟机"><a class="header" href="#移动和复制虚拟机">移动和复制虚拟机</a></h3>
<p>当移动或复制虚拟机后，VMWare会提示用户查虚拟机磁盘文件（对应虚拟机配置文件中的<code>scsi0:0.fileName</code>），并在虚拟机配置文件<code>.vmx</code>中增加一个搜索路径<code>fileSearchPath</code>；当再次复制或移动上述虚拟机，如果仍在本机上，由于<code>fileSearchPath</code>存在，将直接访问该路径下的虚拟磁盘文件，而非复制到当前虚拟机目录下的虚拟磁盘文件。因此需要修改或删除该搜索路径。</p>
<h3 id="虚拟机快照"><a class="header" href="#虚拟机快照">虚拟机快照</a></h3>
<p>删除快照：每个快照会在磁盘上额外生成一个较小的虚拟磁盘文件；删除快照将删除该文件。可删除某些不再使用的快照以节约存储空间。</p>
<h2 id="window-sub-system-of-linux-wsl"><a class="header" href="#window-sub-system-of-linux-wsl">Window Sub-system of Linux (WSL)</a></h2>
<h3 id="安装-35"><a class="header" href="#安装-35">安装</a></h3>
<h4 id="自动安装"><a class="header" href="#自动安装">自动安装</a></h4>
<p>自动安装WSL需要的系统组件、Linux内核并安装默认的Linux发行版（默认为Ubuntu）<sup class="footnote-reference"><a href="#WSL">1</a></sup>。</p>
<blockquote>
<p>版本要求：Windows 10 2004+(Build 19041+) or Windows 11。</p>
</blockquote>
<pre><code class="language-powershell">wsl --set-default-version 2    # 安装保证WSL2已经启用
wsl --install                  # 安装默认发行版
wsl --update                   # 升级至应用商店版本(或通过应用商店升级)
wsl --version                  # 商店版本可用
</code></pre>
<h4 id="手动安装-1"><a class="header" href="#手动安装-1">手动安装</a></h4>
<p>启用WSL<sup class="footnote-reference"><a href="#WSL-mannual">2</a></sup>：</p>
<pre><code class="language-powershell">dism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart
dism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart
# Restart before updating to WSL 2
</code></pre>
<ul>
<li>下载Linux内核更新包：<a href="https://wslstorestorage.blob.core.windows.net/wslblob/wsl_update_x64.msi">WSL2 Linux kernel update package for x64 machines</a>。</li>
</ul>
<p>设置WSL2，WSL2需要开启Hyper-V。</p>
<pre><code class="language-powershell">wsl --set-default-version 2     # 更改默认安装的版本 (WSL2)
wsl --set-version &lt;dist-name&gt; 2 # 转换已安装的版本 (WSL2)
</code></pre>
<h4 id="安装管理发行版"><a class="header" href="#安装管理发行版">安装管理发行版</a></h4>
<p>从应用商店查找安装Linux发行版。发行版管理：</p>
<pre><code class="language-powershell">wsl --set-default &lt;dist-name&gt;  # 设置默认发行版
wsl --install -d &lt;DistroName&gt;  # 安装一个发行版
wsl --list [--all|--running] [--quiet|--verbose] # 列出系统中的发行版
</code></pre>
<h4 id="离线安装-6"><a class="header" href="#离线安装-6">离线安装</a></h4>
<p>如果联网安装下载发行版很慢，或者机器离线，则在开启系统的WSL组件后可以<a href="https://docs.microsoft.com/en-us/windows/wsl/install-manual#downloading-distributions">离线下载</a>并手动安装WSL发行版。如果应用商店不可用，则从<code>appx</code>文件（<code>zip</code>）中提取安装内容（解压其中的<code>Ubuntu_2004_*.appx</code>到安装位置，同级目录下还包含不同缩放比例下的图标资源文件，解压到安装目录下的<code>Assets</code>目录中），并手动执行安装（运行<code>ubuntu.exe</code>）。</p>
<p><strong>配置WindowsTerminal</strong>：由于是手动安装，需要修改启动目录（否则找不到路径无法启动，可设置为WSL用户主目录<code>\\wsl$\Ubuntu\home\gary</code>）和资源图标文件（任意图片文件，可使用安装自带的图标<code>$INSTALLPATH\Assets\StoreLogo.scale-100.png</code>）。</p>
<h4 id="开启systemd"><a class="header" href="#开启systemd">开启systemd</a></h4>
<p>编辑<code>/etc/wsl.conf</code>，重启WSL。（需要WSL版本为0.67.6及以上）</p>
<pre><code class="language-ini">[boot]
systemd=true
</code></pre>
<h3 id="wsl系统配置"><a class="header" href="#wsl系统配置">WSL系统配置</a></h3>
<h4 id="忘记密码"><a class="header" href="#忘记密码">忘记密码</a></h4>
<pre><code class="language-powershell"># windows CLI
ubuntu config --default-user root
# login WSL with root
passwd &lt;username&gt;
# windows terminal
ubuntu config --default-user &lt;username&gt;
</code></pre>
<blockquote>
<p>其他发行版，将<code>ubunut</code>替换为其他发行版名称。</p>
</blockquote>
<h4 id="网络配置-5"><a class="header" href="#网络配置-5">网络配置</a></h4>
<h5 id="wsl端口转发"><a class="header" href="#wsl端口转发"><a href="%E6%9C%8D%E5%8A%A1%E5%99%A8/../Windows/Windows%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86.html#WSL%E8%99%9A%E6%8B%9F%E7%BD%91%E7%BB%9C">WSL端口转发</a></a></h5>
<p><a href="https://docs.microsoft.com/en-us/windows/wsl/wsl-config#configure-global-options-with-wslconfig">Advanced settings configuration in WSL | Microsoft Docs</a>。</p>
<h3 id="使用wsl"><a class="header" href="#使用wsl">使用WSL</a></h3>
<h4 id="启动和停止wsl"><a class="header" href="#启动和停止wsl">启动和停止WSL</a></h4>
<pre><code class="language-powershell">wsl --user root  # 以指定用户身份运行
wsl --exec cmd   # 不启动shell运行命令
wsl --distribution,-d &lt;distname&gt;  # 运行指定发行版
wsl --shutdown                 # 终止所有正在运行WSL2实例
wsl --terminate  &lt;dist-name&gt;   # -t, 终止指定发行版
</code></pre>
<h4 id="windows下执行wsl命令"><a class="header" href="#windows下执行wsl命令">Windows下执行WSL命令</a></h4>
<p>不启动WSL终端，直接运行命令：</p>
<pre><code class="language-powershell">wsl [wsl_opts] -- [linux_args]
# wsl -- ip a '|' grep -E 'inet.*eth0'
</code></pre>
<h4 id="文件共享"><a class="header" href="#文件共享">文件共享</a></h4>
<p>本地磁盘位于<code>/mnt</code>目录下，例如<code>C</code>盘位于<code>/mnt/c</code>。</p>
<p>文件权限：WSL挂载的Windows目录权限均为<code>777</code>（WSL也不能改动该目录中的内容的权限），代表WSL未对该目录做任何权限控制，其实际权限由Windows文件系统决定。</p>
<blockquote>
<p>某些应用要令其某些文件的权限为特定值，如果设置失败会产生异常。</p>
</blockquote>
<h4 id="开发环境-7"><a class="header" href="#开发环境-7">开发环境</a></h4>
<p>Visual Studio Code server：在WSL中运行<code>code</code>便可以从Windows中启动VS Code Remote Extension连接至WSL。 </p>
<h2 id="qemu"><a class="header" href="#qemu">QEMU</a></h2>
<p>QEMU目前支持模拟的架构包括ARM、CRIS、i386、M68k (ColdFire)、MicroBlaze、MIPS、PowerPC、SH4、SPARC和x86-64。</p>
<blockquote>
<p><em>In <strong>system emulation</strong> mode QEMU emulates a full system, including a processor and various peripherals.</em></p>
<p><em>In <strong>user mode</strong>, QEMU can launch Linux processes compiled for one CPU on another CPU.</em></p>
</blockquote>
<h3 id="安装-36"><a class="header" href="#安装-36">安装</a></h3>
<h4 id="linuxapt"><a class="header" href="#linuxapt">Linux/apt</a></h4>
<p>QEMU包含多个架构的模拟功能，而用户通常不会使用到所有架构，因此只需要安装对应架构的包<code>qemu-system-ARCH</code>。如果要使用用户模式模拟，则安装<code>qemu-user</code>或<code>qemu-user-static</code>。</p>
<pre><code class="language-shell">sudo apt install qemu-system     # full installation
sudo apt install qemu-system-arm # only specific architecture
sudo apt install qemu-system-gui qemu-utils ipxe-qemu \
                 qemu-efi-aarch64 qemu-efi-arm
</code></pre>
<blockquote>
<p><code>qemu-system</code>包含以下架构的包：<code>arm, mips, ppc, sparc, x86, s390x, misc</code>。</p>
<p><code>qemu-system-arm</code>支持<code>aarch64</code>（64位）和<code>arm</code>（32位）架构。</p>
<p><code>qemu-system-x86</code>支持<code>x86_64</code>（64位）和<code>i386</code>（32位）架构。</p>
<ul>
<li><code>qemu-kvm</code>在（<code>x86</code>机器）KVM模式下运行<code>qemu-system-x86</code>（后向兼容）；</li>
<li><code>qemu-system-x86-microvm</code>裁剪了大量功能提供轻量容器用于KVM隔离（常规用途使用<code>qemu-system-x86</code>）;</li>
<li><code>qemu-system-x86-xen</code>：<em>run Xen in HVM mode.</em></li>
</ul>
<p><code>qemu-system-gui</code>提供（GTK）图形界面。</p>
<p><code>qemu-utils</code>提供虚拟磁盘镜像工具、网络磁盘访问等工具。</p>
<p><code>qemu-efi-aarch64</code>提供BIOS固件，支持包含安全启动的UEFI。</p>
</blockquote>
<h5 id="安装管理工具"><a class="header" href="#安装管理工具">安装管理工具</a></h5>
<pre><code class="language-shell">sudo apt install libvirt-daemon-system libvirt-clients bridge-utils
sudo apt install virt-manager
</code></pre>
<blockquote>
<p><em>Libvirt is a C toolkit to interact with the virtualization capabilities
of recent versions of Linux (and other OSes). The library aims at providing
a long term stable C API for different virtualization mechanisms. It currently
supports QEMU, KVM, XEN, OpenVZ, LXC, and VirtualBox.</em></p>
<p><em><code>libvirt-daemon-system</code> contains the configuration files to run the <code>libvirt</code> daemon as a system service.</em>
<em><code>libvirt-clients</code> contains the libvirt shell <code>virsh</code> and other client binaries.</em>
<em><code>bridge-utils</code> contains utilities for configuring the Linux Ethernet
bridge in Linux.</em></p>
<p><em><code>virt-manager</code> presents a summary view of running domains and their live performance &amp; resource utilization statistics. A detailed view presents graphs showing performance &amp; utilization over time. Ultimately it will allow creation of new domains, and configuration &amp; adjustment of a domain's resource allocation &amp; virtual hardware.  Finally an embedded VNC client viewer presents a full graphical console to the guest domain.</em></p>
</blockquote>
<h3 id="创建虚拟机"><a class="header" href="#创建虚拟机">创建虚拟机</a></h3>
<p>创建磁盘镜像：</p>
<pre><code class="language-powershell">qemu-img create --format &quot;raw|qcow2&quot; arm64linux.img 40G
</code></pre>
<p>创建虚拟机：</p>
<pre><code class="language-powershell">qemu-system-aarch64.exe \
  -M virt \
	-bios QEMU_EFI.fd \
	-cpu cortex-a72 -smp 4,cores=4,threads=1,sockets=1 \
	-m 8192 \
	-netdev tap,id=mynet0,ifname=tap1 \
  -device e1000,netdev=mynet0,mac=52:55:00:d1:55:01 \
	-device nec-usb-xhci \
	-device usb-kbd \
	-device usb-mouse \
	-device VGA \
	-device virtio-scsi-device \
	-device virtio-blk-device,drive=hd0 \
	-drive if=none,file=arm64linux.img,id=hd0 \
	-device scsi-cd,drive=cdrom \
	-drive if=none,file=Kylin-Server-10-SP1-Release-Build04-20200711-arm64.iso,id=cdrom,media=cdrom
</code></pre>
<p>启动虚拟机时，无需再指定CD驱动器设备；可重新指定虚拟网卡(<code>tap</code>)。</p>
<h4 id="虚拟机网络配置"><a class="header" href="#虚拟机网络配置">虚拟机网络配置</a></h4>
<p>需要为虚拟机添加虚拟网络设备，否则虚拟机启动后无法与宿主机进行通信，仅能通过QEMU提供的终端操作虚拟机。创建虚拟机时指定以下选项以创建虚拟网络设备：</p>
<pre><code class="language-shell">-netdev tap,id=mynet0,ifname=tap1 # 指定虚拟网络设备类型、名称和ID
-device e1000,netdev=mynet0       # 指定虚拟机网络设备对应的虚拟网络设备
</code></pre>
<blockquote>
<p><code>-device</code>还可添加附加参数：<code>mac=52:55:00:d1:55:01</code>。</p>
</blockquote>
<h5 id="创建windows-tap网络接口"><a class="header" href="#创建windows-tap网络接口">创建Windows Tap网络接口</a></h5>
<ul>
<li>在Windows主机上安装TAP网卡驱动：可下载openvpn客户端软件，只安装其中的TAP驱动；在网络连接中，会看到一个新的虚拟网卡，属性类似于<code>TAP-Windows Adapter V9</code>，将其名称修改为<code>tap0</code>。</li>
<li>将虚拟网卡和Windows上真实网卡桥接：选中这两块网卡并桥接生成网桥。==生成的网桥将使用所选的第一个设备的物理信息作为外部接口信息==。</li>
</ul>
<h5 id="创建linux虚拟网桥和tap网络接口"><a class="header" href="#创建linux虚拟网桥和tap网络接口">创建Linux虚拟网桥和Tap网络接口</a></h5>
<p>以管理员身份运行以下命令，<a href="https://wiki.qemu.org/Documentation/Networking">创建虚拟网桥和Tap接口</a>。</p>
<pre><code class="language-shell">ip link add br0 type bridge          # 创建虚拟网桥 =&gt; brctl addbr br0
ip addr delete IP/MASK dev eth0      # 删除主机连接的IP =&gt; ip addr flush dev eth0
ip link set dev eth0 master br0      # 将主机连接绑定到网桥 =&gt; brctl addif br0 eth0
ip addr add IP/MASK dev br0          # 为网桥添加IP地址,或自动分配 dhclient -v br0
ip link set br0 up                   # 启用网桥 =&gt; ifconfig br0/tap1/eth0 up
ip route add default via IP dev br0  # 主机通过网桥访问网络

ip tuntap add dev tap1 mode tap      # 创建tap接口
ip link set dev tap0 master br0      # 将tap接口绑定到网桥 =&gt; brctl addif br0 tap1
</code></pre>
<blockquote>
<p><em><code>ifconfig</code>, <code>tunctl</code> and <code>brctl</code> are mostly considered deprecated nowadays</em>.</p>
</blockquote>
<p>查看网桥和接口信息：</p>
<pre><code class="language-shell">brctl show               # show bridge information
ip link show qemu_bridge # show link information of bridge
ip link show qemu_tap1   # show link information of tap interface
</code></pre>
<p>虚拟网桥通过数据链路层协议(Ethernet)连接物理接口和虚拟接口构成虚拟网络，同时网桥也承载主机的IP协议栈以代替主机原有的网络连接(<code>eth0</code>)提供主机的网络服务。</p>
<img src="服务器/虚拟化.assets/linux_vbridge_tap.jpg" alt="img" style="zoom: 80%;" />
<p>Tap网络接口则通过虚拟网桥复用物理接口：网桥从主机的上层协议接收的数据以及其他Tap接口接收到的外发数据将转发给物理接口，物理接口执行外发操作；对于接收数据，物理接口将数据转发给网桥，网桥根据MAC地址按端口进行转发。（通常，一个物理网卡应该只与一个虚拟网桥连接）</p>
<h2 id="参考文献-18"><a class="header" href="#参考文献-18">参考文献</a></h2>
<div class="footnote-definition" id="WSL"><sup class="footnote-definition-label">1</sup>
<p><a href="https://docs.microsoft.com/en-us/windows/wsl/install">Install WSL | Microsoft Docs</a>.
<sup class="footnote-reference"><a href="#WSL-mannual">2</a></sup>: <a href="https://docs.microsoft.com/en-us/windows/wsl/install-manual">Manual installation steps for older versions of WSL | Microsoft Docs</a>.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="airflow"><a class="header" href="#airflow">Airflow</a></h1>
<blockquote>
<p>Airflow is a platform to programmatically author, schedule and monitor workflows.</p>
<p>Use Airflow to author workflows as <strong>Directed Acyclic Graphs (DAGs)</strong> of tasks. The <strong>Airflow scheduler</strong> executes your tasks on an array of workers while following the specified dependencies.</p>
<p>Airflow is used to process data, but has the opinion that tasks should ideally be idempotent (i.e. results of the task will be the same, and will not create duplicated data in a destination system), and should not pass large quantities of data from one task to the next (though tasks can pass metadata using Airflow's <a href="https://airflow.apache.org/docs/apache-airflow/stable/concepts.html#xcoms">Xcom feature</a>). </p>
<p>Airflow is not a streaming solution, but it is often used to process real-time data, pulling data <strong>off streams</strong> in batches.</p>
</blockquote>
<h2 id="安装-37"><a class="header" href="#安装-37">安装</a></h2>
<h3 id="单机试用"><a class="header" href="#单机试用">单机试用</a></h3>
<p>试用环境配置：使用SQLite+<code>SequentialExecutor</code><sup class="footnote-reference"><a href="#local-quick">1</a></sup>。</p>
<pre><code class="language-shell">airflow standalone
# airflow db init
# airflow users create \
#     --username admin \
#     --firstname Peter \
#     --lastname Parker \
#     --role Admin \
#     --email spiderman@superhero.org
# airflow webserver --port 8080
# airflow scheduler
</code></pre>
<h3 id="部署airflow"><a class="header" href="#部署airflow">部署Airflow</a></h3>
<h4 id="使用docker部署"><a class="header" href="#使用docker部署">使用Docker部署</a></h4>
<p>从官方获取示例<code>docker-compose.yaml</code>文件<sup class="footnote-reference"><a href="#docker-quick">2</a></sup>，并根据生产环境进行定制。</p>
<pre><code class="language-shell">VERSION=&quot;2.2.5&quot;
curl -LfO &quot;https://airflow.apache.org/docs/apache-airflow/$VERSION/docker-compose.yaml&quot;
</code></pre>
<ul>
<li><code>airflow-scheduler</code> - The <a href="https://airflow.apache.org/docs/apache-airflow/stable/concepts/scheduler.html">scheduler</a> monitors all tasks and DAGs, then triggers the task instances once their dependencies are complete.</li>
<li><code>airflow-webserver</code> - The webserver is available at <code>http://localhost:8080</code>.</li>
<li><code>airflow-worker</code> - The worker that executes the tasks given by the scheduler.</li>
<li><code>airflow-init</code> - The initialization service（执行后正常退出）.</li>
<li><code>flower</code> - <a href="https://flower.readthedocs.io/en/latest/">The flower app</a> for monitoring the environment. It is available at <code>http://localhost:5555</code>.</li>
<li><code>postgres</code> - The database.</li>
<li><code>redis</code> - <a href="https://redis.io/">The redis</a> - broker that forwards messages from scheduler to worker.</li>
</ul>
<p>在<code>.env</code>文件设置要使用的Airflow版本（默认为<code>docker-compose.yaml</code>文件中指定的默认版本）以及用户名和密码。</p>
<pre><code class="language-shell">COMPOSE_PROJECT_NAME=airflow2
# AIRFLOW_IMAGE_NAME=&quot;apache/airflow:2.2.5&quot;
_AIRFLOW_WWW_USER_USERNAME=&quot;gary&quot;
_AIRFLOW_WWW_USER_PASSWORD=&quot;gang2019&quot;
AIRFLOW_UID=50000  # run service as the user with UID inside the containers
</code></pre>
<blockquote>
<p>如果需要映射主机目录到容器，则设置<code>AIRFLOW_UID=$(id -u)</code>，防止在相关数据目录下以<code>root</code>账户创建文件。如果使用数据卷则使用默认值即可。</p>
</blockquote>
<p>此外，配置额外插件及插件的配置参数，插件将在初始化阶段安装。不推荐在生产环境中使用这种方式安装插件，而是应该<a href="https://airflow.apache.org/docs/docker-stack/build.html">构建自定义Docker镜像</a>。</p>
<pre><code class="language-shell">_PIP_ADDITIONAL_REQUIREMENTS=&quot;airflow-code-editor black&quot;
AIRFLOW__CODE_EDITOR__ROOT_DIRECTORY=&quot;/opt/airflow/dags&quot;
AIRFLOW__CODE_EDITOR__LINE_LENGTH=90
AIRFLOW__CODE_EDITOR__STRING_NORMALIZATION=False
AIRFLOW__CODE_EDITOR__GIT_ENABLED=False
</code></pre>
<p>执行数据库初始化并创建首个用户（初始化成功返回状态为<code>0</code>）。</p>
<pre><code class="language-shell">docker-compose up airflow-init
docker-compose down --volumes --remove-orphans  # 如果出现错误，清理环境，检查配置文件重新执行初始化
</code></pre>
<p>启动Airflow服务集群（<code>docker-compose up -d</code>）并检查服务状态（<code>docker-compose ps</code>）。</p>
<h5 id="数据存储"><a class="header" href="#数据存储">数据存储</a></h5>
<p>在上述集群配置文件中，所有相关服务共享同一个Airflow的工作目录（包括<code>dags</code>，<code>logs</code>和<code>plugins</code>）。</p>
<h5 id="自定义镜像"><a class="header" href="#自定义镜像">自定义镜像</a></h5>
<p>https://airflow.apache.org/docs/docker-stack/build.html</p>
<h4 id="安装插件-3"><a class="header" href="#安装插件-3">安装插件</a></h4>
<p>插件以Python模块的形式提供。</p>
<ul>
<li>Docker：在<code>_PIP_ADDITIONAL_REQUIREMENTS</code>中指定附加插件，或构建自定义镜像时安装插件。</li>
</ul>
<h4 id="安装providers"><a class="header" href="#安装providers">安装Providers</a></h4>
<p>http://airflow.apache.org/docs/apache-airflow-providers/index.html</p>
<h4 id="eco-system"><a class="header" href="#eco-system">eco-system</a></h4>
<p><a href="https://github.com/andreax79/airflow-code-editor">andreax79/airflow-code-editor: A plugin for Apache Airflow that allows you to edit DAGs in browser (github.com)</a></p>
<p><a href="http://airflow.apache.org/ecosystem/">Ecosystem | Apache Airflow</a></p>
<p><a href="https://elyra.readthedocs.io/en/stable/">Elyra Documentation — Elyra 3.2.2 documentation</a></p>
<p><a href="https://stackoverflow.com/questions/48986732/airflow-creating-a-dag-in-airflow-via-ui">Airflow: Creating a DAG in airflow via UI - Stack Overflow</a></p>
<h3 id="配置-16"><a class="header" href="#配置-16">配置</a></h3>
<pre><code class="language-shell">export AIRFLOW_HOME=/opt/airflow/  # 默认工作目录: 包含dags，logs等子目录
</code></pre>
<p><code>$AIRFLOW_HOME/airflow.cfg</code>：配置文件。</p>
<h2 id="概念-2"><a class="header" href="#概念-2">概念</a></h2>
<h5 id="dag"><a class="header" href="#dag">DAG</a></h5>
<p>作业设计说明（有向无环图）。有一个或多个任务构成。</p>
<pre><code class="language-shell">airflow dags list
airflow dags list-jobs   # 列出作业
airflow dags list-runs
airflow dags test dag_id run_date
</code></pre>
<blockquote>
<p>默认路径位于<code>$AIRFLOW_HOME/dags</code>，在该目录下创建的作业会被airflow扫描并自动加载（有一定的时延）。</p>
</blockquote>
<h5 id="task"><a class="header" href="#task">task</a></h5>
<p>[Tasks — Airflow Documentation (apache.org)](https://airflow.apache.org/docs/apache-airflow/stable/concepts/tasks.html?highlight=create task)</p>
<p>任务。</p>
<pre><code class="language-shell">airflow run dag_id task_id date
</code></pre>
<h5 id="jobs"><a class="header" href="#jobs">jobs</a></h5>
<p>正在运行的作业。</p>
<pre><code class="language-shell">airflow jobs check
</code></pre>
<h2 id="使用airflow"><a class="header" href="#使用airflow">使用Airflow</a></h2>
<h3 id="cli-1"><a class="header" href="#cli-1">CLI</a></h3>
<p>进入任意服务节点的终端，执行<code>airflow info</code>可查看Airflow的配置以及系统环境信息。</p>
<pre><code class="language-shell">airflow [-h] GROUP_OR_COMMAND ...

positional arguments:
  GROUP_OR_COMMAND

    Groups:
      celery         Celery components
      config         View configuration
      connections    Manage connections
      dags           Manage DAGs
      db             Database operations
      jobs           Manage jobs
      kubernetes     Tools to help run the KubernetesExecutor
      pools          Manage pools
      providers      Display providers
      roles          Manage roles
      tasks          Manage tasks
      users          Manage users
      variables      Manage variables

    Commands:
      cheat-sheet    Display cheat sheet
      info           Show information about current Airflow and environment
      kerberos       Start a kerberos ticket renewer
      plugins        Dump information about loaded plugins
      rotate-fernet-key
                     Rotate encrypted connection credentials and variables
      scheduler      Start a scheduler instance
      standalone     Run an all-in-one copy of Airflow
      sync-perm      Update permissions for existing roles and optionally DAGs
      triggerer      Start a triggerer instance
      version        Show the version
      webserver      Start a Airflow webserver instance
</code></pre>
<pre><code class="language-shell">usage: airflow dags [-h] COMMAND ...

Manage DAGs

positional arguments:
  COMMAND
    backfill      Run subsections of a DAG for a specified date range
    delete        Delete all DB records related to the specified DAG
    list          List all the DAGs
    list-jobs     List the jobs
    list-runs     List DAG runs given a DAG id
    next-execution
                  Get the next execution datetimes of a DAG
    pause         Pause a DAG
    report        Show DagBag loading report
    show          Displays DAG's tasks with their dependencies
    state         Get the status of a dag run
    test          Execute one single DagRun
    trigger       Trigger a DAG run
    unpause       Resume a paused DAG
</code></pre>
<h4 id="dags"><a class="header" href="#dags">dags</a></h4>
<h4 id="tasks"><a class="header" href="#tasks">tasks</a></h4>
<pre><code class="language-shell">airflow tasks test $DAG_ID $TASK_ID $DATE # 执行任务
</code></pre>
<h3 id="使用web界面"><a class="header" href="#使用web界面">使用Web界面</a></h3>
<p>访问<code>airflow-web</code>服务开启的HTTP端口（默认为http://localhost:8080，默认用户名和密码为预先使用环境变量配置的）。</p>
<h3 id="使用rest接口"><a class="header" href="#使用rest接口">使用REST接口</a></h3>
<p>使用REST API访问Web服务。</p>
<pre><code class="language-shell">ENDPOINT_URL=&quot;http://localhost:8080/&quot;
curl -X GET --user &quot;USER:PASSWD&quot; &quot;${ENDPOINT_URL}/api/v1/pools&quot;
</code></pre>
<p>Airflow提供了封装的Python API客户端访问Web服务（<a href="https://github.com/apache/airflow-client-python">apache/airflow-client-python: Apache Airflow - OpenApi Client for Python (github.com)</a>）</p>
<h2 id="任务编排"><a class="header" href="#任务编排">任务编排</a></h2>
<p>为任务添加标签方便查询相关任务。</p>
<pre><code class="language-python">with DAG(dag_id=&quot;first_airflow_dag&quot;, 
          schedule_interval='* * * * *', # crontab语法或@once/hourly/daily/weekly/monthly/yearly
          start_date=datetime(year=2022, month=2, day=1),
          tags = [&quot;team1&quot;, &quot;sql&quot;]) as dag:
  task_get_datetime = BashOperator(
    task_id='get_datetime',
    bash_command='date'
  )
  task_get_datetime &gt;&gt; task_process_datetime &gt;&gt; task_save_datetime
</code></pre>
<p>任务保存在工作目录的<code>dags/</code>目录下，可从Web界面访问并<strong>执行/暂停</strong>任务（可在DAG列表或DAG页面执行）。</p>
<p><img src="%E6%9C%8D%E5%8A%A1%E5%99%A8/Airflow.assets/image-20220406112048869.png" alt="image-20220406112048869" /></p>
<p>任务执行的返回值由Airflow内部保存，可通过<code>xcoms</code>接口获取。</p>
<p>使用<code>&gt;&gt;</code>或<code>set_downstream()</code>连接任务，保证任务按正确顺序执行。</p>
<img src="服务器/Airflow.assets/image-20220406111545204.png" alt="任务执行流程" style="zoom:50%;" />
<p><img src="%E6%9C%8D%E5%8A%A1%E5%99%A8/Airflow.assets/image-20220406111639213.png" alt="任务树和对应的执行状态" /></p>
<p>Airflow将动态检测任务编排文件，并应用最新的任务调度配置。</p>
<p><a href="https://airflow.apache.org/docs/apache-airflow/stable/tutorial.html">Tutorial — Airflow Documentation (apache.org)</a></p>
<p><a href="http://airflow.apache.org/docs/apache-airflow/stable/howto/index.html">How-to Guides</a> </p>
<p><a href="https://airflow.apache.org/docs/apache-airflow/stable/best-practices.html">Best Practices — Airflow Documentation (apache.org)</a></p>
<h3 id="内置任务模块"><a class="header" href="#内置任务模块">内置任务模块</a></h3>
<p><code>BashOperator(task_id, bash_command)</code></p>
<p><code>PythonOperator(task_id, python_callable=pyfunc)</code></p>
<h3 id="系统内置变量"><a class="header" href="#系统内置变量">系统内置变量</a></h3>
<p>访问Airflow网页，进入<code>Admin-Variables</code>创建变量（<code>Key-Value-Description</code>）。变量可在任务编排代码中引用。</p>
<pre><code class="language-python">var_name = Variable.get('var_name')
</code></pre>
<h2 id="问题-7"><a class="header" href="#问题-7">问题</a></h2>
<p><a href="https://stackoverflow.com/questions/45534535/airflow-not-loading-dags-in-usr-local-airflow-dags">Airflow not loading dags in /usr/local/airflow/dags - Stack Overflow</a></p>
<p><a href="https://stackoverflow.com/questions/38992997/dag-not-visible-in-web-ui">python - DAG not visible in Web-UI - Stack Overflow</a></p>
<h2 id="任务编排工具对比"><a class="header" href="#任务编排工具对比">任务编排工具对比</a></h2>
<p>最好的任务编排工具：Airflow vs Luigi vs Argo vs MLFlow - 数据黑客的文章 - 知乎 https://zhuanlan.zhihu.com/p/321231718</p>
<p><a href="https://luigi.readthedocs.io/en/stable/index.html">Getting Started — Luigi 2.8.13 documentation</a></p>
<h2 id="参考文献-19"><a class="header" href="#参考文献-19">参考文献</a></h2>
<div class="footnote-definition" id="install-list"><sup class="footnote-definition-label">3</sup>
<p><a href="https://airflow.apache.org/docs/apache-airflow/stable/installation/index.html">Installation — Airflow Documentation (apache.org)</a>
<sup class="footnote-reference"><a href="#local-quick">1</a></sup>: <a href="https://airflow.apache.org/docs/apache-airflow/stable/start/local.html#running-airflow-locally">Running Airflow locally — Airflow Documentation (apache.org)</a>
<sup class="footnote-reference"><a href="#docker-quick">2</a></sup>: <a href="https://airflow.apache.org/docs/apache-airflow/stable/start/docker.html">Running Airflow in Docker — Airflow Documentation (apache.org)</a></p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="数据序列化语言"><a class="header" href="#数据序列化语言">数据序列化语言</a></h1>
<h2 id="json-4"><a class="header" href="#json-4">JSON</a></h2>
<p>JSON（<em>JavaScript Object Notation</em>）是存储和交换文本信息的语法，类似 XML，JSON 比 XML 更小、更快，更易解析。JSON 使用 JavaScript 语法来描述数据对象，但是 JSON 仍然独立于语言和平台。</p>
<pre><code class="language-json">{
  &quot;employees&quot;: [
    { &quot;firstName&quot;:&quot;Bill&quot; , &quot;lastName&quot;:&quot;Gates&quot; },
    { &quot;firstName&quot;:&quot;George&quot; , &quot;lastName&quot;:&quot;Bush&quot; },
    { &quot;firstName&quot;:&quot;Thomas&quot; , &quot;lastName&quot;:&quot;Carter&quot; }
  ]
}
</code></pre>
<h3 id="json-语法规则"><a class="header" href="#json-语法规则">JSON 语法规则</a></h3>
<p>JSON语法是JavaScript对象表示法语法的子集，使用简单标记储存文本数据类型。</p>
<ul>
<li>
<p>JSON定义的数据类型包括：</p>
<ul>
<li>数字（整数或浮点数）</li>
<li>字符串（在双引号中）</li>
<li>逻辑值（true 或 false）</li>
<li><code>null</code></li>
<li>数组（在方括号中）：数组元素是JSON类型；</li>
<li>对象（在花括号中）：对象封装了字典，每个成员及其值构成字典的键值对，值是JSON类型。</li>
</ul>
<blockquote>
<p>数组元素和对象的成员的值可以嵌套JSON对象。</p>
</blockquote>
</li>
<li>
<p>同一级数据由逗号分隔</p>
</li>
<li>
<p>花括号定义对象</p>
</li>
<li>
<p>方括号定义数组</p>
</li>
</ul>
<p>JSON不支持添加注释。注释内容可以作为数据的一个字段（例如<code>_comment</code>）</p>
<p>https://raw.githubusercontent.com/microsoft/winget-cli/master/schemas/JSON/settings/settings.schema.0.2.json</p>
<h3 id="jsonpath查询语言"><a class="header" href="#jsonpath查询语言">JSONPath查询语言</a></h3>
<p><a href="https://support.smartbear.com/alertsite/docs/monitors/api/endpoint/jsonpath.html">JSONPath Syntax | AlertSite Documentation (smartbear.com)</a></p>
<h5 id="访问路径"><a class="header" href="#访问路径">访问路径</a></h5>
<p><code>$</code>表示对象或数组的根，以绝对路径访问元素。省略<code>$</code>则直接以当前节点的键名访问数据。</p>
<h5 id="直接子节点内容"><a class="header" href="#直接子节点内容">直接子节点内容</a></h5>
<p>选择元素可使用<code>.KEY</code>或<code>['KEY']</code>运算符，获取当前节点的子元素。（中括号表达可处理特殊标识符，如包含括号）</p>
<pre><code class="language-shell">$.store.book[0].title          # dot notation
$['store']['book'][0]['title'] # bracket notation
</code></pre>
<h5 id="任意层级节点内容"><a class="header" href="#任意层级节点内容">任意层级节点内容</a></h5>
<p><code>X..KEY</code>：递归获取键名为<code>KEY</code>的值。</p>
<h4 id="数组内容"><a class="header" href="#数组内容">数组内容</a></h4>
<h5 id="下标访问"><a class="header" href="#下标访问">下标访问</a></h5>
<pre><code class="language-shell">$.store.book[0,1,3,...]     # 获取固定顺序位置的值
$.store.book[0:10:2]        # 获取数组切片的值
$.store.book[5:]            # 省略切片区间结束位置
$.store.book[:10]           # 省略
$.store.book[-1:-5]         # 反向迭代
</code></pre>
<p>使用表达式确定下标：</p>
<pre><code class="language-shell"># $.store.book[(expression)]
$.store.book[(@.length-1)]  # $.store.book[-1]
</code></pre>
<h5 id="条件过滤-1"><a class="header" href="#条件过滤-1">条件过滤</a></h5>
<p>获取满足条件的所有数组元素构成的列表。</p>
<pre><code class="language-shell"># $.store.book[?(expression)]
$.store.book[?(@.price)]       # 存在price字段
$.store.book[?(@.price &lt; 10)]  # book.price &lt; 10
</code></pre>
<blockquote>
<p><code>@</code>用于引用当前节点名。</p>
</blockquote>
<p>返回当前对象或数组的所有元素：<code>*</code>可以匹配任意键名或数组下标。</p>
<pre><code class="language-shell">$.store.book[*]
</code></pre>
<h5 id="获取数据元素字段"><a class="header" href="#获取数据元素字段">获取数据元素字段</a></h5>
<pre><code class="language-shell">$.store.book[*].title     # 所有数组元素的title字段的值组成的序列
</code></pre>
<h2 id="yaml-1"><a class="header" href="#yaml-1">YAML</a></h2>
<blockquote>
<p><em>YAML is primarily a data serialization language. XML was designed to be backwards compatible with the Standard Generalized Markup Language (SGML), which was designed to support structured documentation. XML therefore had many design constraints placed on it that YAML does not share. XML is a pioneer in many domains, YAML is the result of lessons learned from XML and other technologies.</em></p>
</blockquote>
<h3 id="语法-7"><a class="header" href="#语法-7">语法</a></h3>
<p>YAML可视为JSON的超集（YAML不支持重复的key，JSON允许出现重复key）<sup class="footnote-reference"><a href="#yaml">1</a></sup>。</p>
<h4 id="基本元素类型"><a class="header" href="#基本元素类型">基本元素类型</a></h4>
<h5 id="序列"><a class="header" href="#序列">序列</a></h5>
<pre><code class="language-yaml">- Mark McGwire
- Sammy Sosa
- Ken Griffey
</code></pre>
<h5 id="字典-2"><a class="header" href="#字典-2">字典</a></h5>
<pre><code class="language-yaml">hr:  65    # Home runs
avg: 0.278 # Batting average
rbi: 147   # Runs Batted In
</code></pre>
<h5 id="字符串-9"><a class="header" href="#字符串-9">字符串</a></h5>
<p>YAML支持无引号、双引号和单引号表示字符串。字符串支持换行（换行符被替换），其中双引号可包含转义序列。</p>
<pre><code class="language-yaml">unicode: &quot;Sosa did fine.\u263A&quot;
control: &quot;\b1998\t1999\t2000\n&quot;
hex esc: &quot;\x0d\x0a is \r\n&quot;

single: '&quot;Howdy!&quot; he cried.'
quoted: ' # Not a ''comment''.'
tie-fighter: '|\-*-/|'
</code></pre>
<h5 id="文本块"><a class="header" href="#文本块">文本块</a></h5>
<p>使用<code>|</code>或<code>&gt;</code>声明文本块。</p>
<pre><code class="language-yaml">text_block: | # 保留换行
  Mark McGwire's
  year was crippled
  by a knee injury.
text_block2: &gt;  # 将换行替换为空格，单独空行与额外缩进内容的换行将得到保留
  Sammy Sosa completed another
  fine season with great stats.

    63 Home Runs
    0.288 Batting Average

  What a year!
</code></pre>
<h5 id="注释-4"><a class="header" href="#注释-4">注释</a></h5>
<p><code>#</code>及其后内容为注释内容。</p>
<h4 id="复合类型"><a class="header" href="#复合类型">复合类型</a></h4>
<p>序列类型和字典类型可以相互嵌套。</p>
<h5 id="值为序列的字典"><a class="header" href="#值为序列的字典">值为序列的字典</a></h5>
<pre><code class="language-yaml">american:
  - Boston Red Sox
  - Detroit Tigers
  - New York Yankees
national: [New York Mets, Chicago Cubs, Atlanta Braves]
</code></pre>
<h5 id="元素为字典的序列"><a class="header" href="#元素为字典的序列">元素为字典的序列</a></h5>
<pre><code class="language-yaml">-
  name: Mark McGwire
  hr:   65
  avg:  0.278
- item    : Super Hoop   # 紧凑写法
  quantity: 1
- {name: Sammy Sosa, hr:   63, avg:  0.288}  # 以{}确定范围，可以换行，无需对齐缩进
</code></pre>
<h5 id="复杂映射类型"><a class="header" href="#复杂映射类型">复杂映射类型</a></h5>
<p>使用<code>?</code>可定义除字符串外复杂的映射键类型（如序列和字典）：</p>
<pre><code class="language-yaml">? - Detroit Tigers
  - Chicago cubs
:
  - 2001-07-23

? [ New York Yankees, Atlanta Braves ]
: [ 2001-07-02, 2001-08-12, 2001-08-14 ]
</code></pre>
<h4 id="类型标记"><a class="header" href="#类型标记">类型标记</a></h4>
<h5 id="整数字面值"><a class="header" href="#整数字面值">整数字面值</a></h5>
<pre><code class="language-yaml">canonical: 12345
decimal: +12345
octal: 0o14
hexadecimal: 0xC
</code></pre>
<h5 id="浮点数字面值"><a class="header" href="#浮点数字面值">浮点数字面值</a></h5>
<pre><code class="language-yaml">canonical: 1.23015e+3
exponential: 12.3015e+02
fixed: 1230.15
negative infinity: -.inf
not a number: .NaN
</code></pre>
<h5 id="时间日期字面值"><a class="header" href="#时间日期字面值">时间日期字面值</a></h5>
<pre><code class="language-yaml">canonical: 2001-12-15T02:59:43.1Z
iso8601: 2001-12-14t21:59:43.10-05:00
spaced: 2001-12-14 21:59:43.10 -5
date: 2002-12-14
</code></pre>
<h5 id="其他类型"><a class="header" href="#其他类型">其他类型</a></h5>
<pre><code class="language-yaml">null:   # 空值
booleans: [ true, false ]
string: '012345'  # 默认字面值类型都为字符串文本
</code></pre>
<h5 id="显式类型声明"><a class="header" href="#显式类型声明">显式类型声明</a></h5>
<pre><code class="language-yaml">not-date: !!str 2002-04-28  # 表示字符串而非日期
picture: !!binary |         # 二进制编码序列
 R0lGODlhDAAMAIQAAP//9/X
 17unp5WZmZgAAAOfn515eXv
 Pz7Y6OjuDg4J+fn5OTk6enp
 56enmleECcgggoBADs=
--- !!set  # Sets are special Mapping where key is mapped to null value
? Mark McGwire
? Sammy Sosa
? Ken Griff
--- !!omap # Ordered maps 
- Mark McGwire: 65
- Sammy Sosa: 63
- Ken Griffy: 58
</code></pre>
<p>自定义类型声明</p>
<h4 id="结构"><a class="header" href="#结构">结构</a></h4>
<p>一个<code>yaml</code>文件可包含多个YAML文档，每个文档以<code>---</code>行开始。<code>...</code>用于显式声明一个文档的结束，后续直到发现<code>---</code>才开始新的文档（通常用于流式传输）。</p>
<h5 id="锚点与引用"><a class="header" href="#锚点与引用">锚点与引用</a></h5>
<p>在需要引用的对象前添加<code>&amp;id_obj</code>，在其他位置引用该对象使用<code>*id_obj</code>。</p>
<pre><code class="language-yaml">bill-to: &amp;id001
    given  : Chris
    family : Dumars
    address:
        lines: |
            458 Walkman Dr.
            Suite #292
        city    : Royal Oak
        state   : MI
        postal  : 48046
ship-to: *id001   # refer to the above address information block
</code></pre>
<h2 id="参考文献-20"><a class="header" href="#参考文献-20">参考文献</a></h2>
<div class="footnote-definition" id="yaml"><sup class="footnote-definition-label">1</sup>
<p>Oren Ben-Kiki, Clark Evans, Ingy döt Net, <a href="%E6%95%B0%E6%8D%AE%E4%BA%A4%E6%8D%A2%E8%AF%AD%E8%A8%80/JSON%20and%20YAML.html#https://yaml.org/spec/1.2.2/">YAML Ain’t Markup Language (YAML™) Version 1.2</a>, 3rd Edition, Revision 1.2.2 (2021-10-01), YAML Language Development Team.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="xml-2"><a class="header" href="#xml-2">XML</a></h1>
<h2 id="简介"><a class="header" href="#简介">简介</a></h2>
<h5 id="xml与html"><a class="header" href="#xml与html">XML与HTML</a></h5>
<ul>
<li>XML被设计用来传输和存储数据，HTML被设计用来显示数据。</li>
<li>XML标签没有被预定义，需要自行定义标签，XML 被设计为具有自我描述性； HTML中使用的标签（以及 HTML的结构）是预定义的，HTML文档只使用在HTML标准中定义过的标签（比如 <code>&lt;p&gt;</code> 、<code>&lt;h1&gt;</code> 等等）。</li>
</ul>
<h2 id="结构-1"><a class="header" href="#结构-1">结构</a></h2>
<h3 id="命名空间-5"><a class="header" href="#命名空间-5">命名空间</a></h3>
<p>XML 命名空间提供避免元素命名冲突的方法。（使用前缀来避免命名冲突）</p>
<pre><code class="language-xml">xmlns:namespace-prefix=\&quot;namespaceURI\&quot;
</code></pre>
<p>用于标示命名空间的地址不会被解析器用于查找信息。其惟一的作用是赋予命名空间一个惟一的名称。不过，很多公司常常会作为指针来使用命名空间指向实际存在的网页，这个网页包含关于命名空间的信息。</p>
<p>默认的命名空间（Default Namespaces）：为元素定义默认的命名空间可以让我们省去在所有的子元素中使用前缀的工作。</p>
<pre><code class="language-xml">xmlns =\&quot;namespaceURI\&quot;
</code></pre>
<p>XML 文档形成了一种树结构，它从&quot;根部&quot;开始，然后扩展到&quot;枝叶&quot;。</p>
<pre><code class="language-xml">&lt;bookstore&gt;
&lt;book category=&quot;CHILDREN&quot;&gt;
    &lt;title&gt;Harry Potter&lt;/title&gt; 
    &lt;author&gt;J K. Rowling&lt;/author&gt; 
    &lt;year&gt;2005&lt;/year&gt; 
    &lt;price&gt;29.99&lt;/price&gt; 
&lt;/book&gt;
&lt;book category=&quot;WEB&quot;&gt;
    &lt;title&gt;Learning XML&lt;/title&gt; 
    &lt;author&gt;Erik T. Ray&lt;/author&gt; 
    &lt;year&gt;2003&lt;/year&gt; 
    &lt;price&gt;39.95&lt;/price&gt; 
&lt;/book&gt;
&lt;/bookstore&gt;
</code></pre>
<p>元素（Element）：从（且包括）开始标签直到（且包括）结束标签的部分。
父元素，子元素；</p>
<p>XML 文档必须有一个元素是所有其他元素的父元素。该元素称为根元素。</p>
<p>标签（Tag）：XML 元素使用 XML 标签进行定义。XML 标签对大小写敏感。所有元素都必须有结束标签（声明不属于XML本身的组成部分。它不是XML 元素，也不需要关闭标签。）</p>
<p>属性（Attribute）：键值对，值必须加引号（单引号和双引号均可使用，如果属性值本身包含双引号，那么有必要使用单引号包围它）。</p>
<pre><code class="language-xml">\&lt;note date=\&quot;08/08/2008\&quot;\&gt;
</code></pre>
<p>因使用属性而引起的一些问题：</p>
<ul>
<li>属性无法包含多重的值（元素可以）</li>
<li>属性无法描述树结构（元素可以）</li>
<li>属性不易扩展（为未来的变化）</li>
<li>属性难以阅读和维护</li>
</ul>
<p>在 XML 中，您应该尽量避免使用属性。元数据（有关数据的数据）应当存储为属性，而数据本身应当存储为元素。</p>
<p>特殊字符</p>
<div class="table-wrapper"><table><thead><tr><th>命令</th><th>特殊字符</th><th>意义</th></tr></thead><tbody>
<tr><td><code>&amp;lt;</code></td><td>&lt;</td><td>小于</td></tr>
<tr><td><code>&amp;gt;</code></td><td>&gt;</td><td>大于</td></tr>
<tr><td><code>&amp;amp;</code></td><td>&amp;</td><td>和号</td></tr>
<tr><td><code>&amp;apos;</code></td><td>'</td><td>单引号</td></tr>
<tr><td><code>&amp;quot;</code></td><td>&quot;</td><td>引号</td></tr>
</tbody></table>
</div>
<p>空格</p>
<p>文档中的空格不会被缩减。</p>
<p>注释</p>
<pre><code class="language-xml">\&lt;!\-- This is a comment \--\&gt;
</code></pre>
<h2 id="xml验证"><a class="header" href="#xml验证">XML验证</a></h2>
<p>XML DTD</p>
<p>XML Schema：An XML schema language is used to describe the structure and content of an XML document. The one that currently rules the roost is the <em>W3C XML Schema Definition Language</em> typically abbreviated as XSD.</p>
<p>如果 XML 文档存在错误，那么程序就不应当继续处理这个文档。</p>
<h2 id="显示-1"><a class="header" href="#显示-1">显示</a></h2>
<p>CSS</p>
<p>XSLT 是首选的 XML 样式表语言。</p>
<h2 id="xml解析"><a class="header" href="#xml解析">XML解析</a></h2>
<h3 id="解析方法"><a class="header" href="#解析方法">解析方法</a></h3>
<ol>
<li>DOM 
XML DOM (XML Document Object Model) 定义了访问和操作 XML文档的标准方法。 
DOM 把 XML 文档作为树结构来查看。能够通过 DOM树来访问所有元素。可以修改或删除它们的内容，并创建新的元素。元素，它们的文本，以及它们的属性，都被认为是节点。</li>
<li>SAX</li>
</ol>
<h3 id="xml解析器"><a class="header" href="#xml解析器">XML解析器</a></h3>
<p>Tree Model-based APIs：把 XML 转换为 DOM对象。</p>
<p>Cursor-based APIs</p>
<p>Streaming APIs</p>
<h4 id="net-framework实现"><a class="header" href="#net-framework实现">.NET Framework实现</a></h4>
<ol>
<li>
<p><strong>XmlReader, XmlWriter</strong></p>
</li>
<li>
<p><strong>System.Xml.XPath</strong><br />
快速查询定位XML元素。</p>
</li>
</ol>
<p>System.Xml.Xsl</p>
<p>System.Xml.Schema</p>
<p>System.Xml.Linq</p>
<p>System.Xml.XmlDocument/XmlNode</p>
<ul>
<li>
<p>Properties</p>
<ul>
<li>
<p>Attributes</p>
</li>
<li>
<p>DocumentElement：获取根元素。</p>
</li>
<li>
<p>DocumentType：DOCTYPE</p>
</li>
<li>
<p>ChildNodes</p>
</li>
<li>
<p>FirstChild</p>
</li>
<li>
<p>LastChild</p>
</li>
<li>
<p>ParentNode</p>
</li>
<li>
<p>Item[String]：获取为指定名称的第一个子节点。</p>
</li>
<li>
<p>Name</p>
</li>
<li>
<p>LocalName</p>
<p>If the node does not have a prefix, LocalName is the same as
Name.</p>
</li>
<li>
<p>Value</p>
</li>
</ul>
</li>
<li>
<p>Methods</p>
<ul>
<li>AppendChild</li>
</ul>
</li>
</ul>
<p>XPathNavigator</p>
<p>Namespace: System.Xml.XPath</p>
<ol>
<li>Assembly: System.Xml (in System.Xml.dll)</li>
</ol>
<p>Provides a cursor model for navigating and editing XML data.</p>
<ol>
<li>System.Xml.XmlReader</li>
</ol>
<p>Represents a reader that provides fast, noncached, forward-only access
to XML data.</p>
<h4 id="java实现"><a class="header" href="#java实现">Java实现</a></h4>
<p><a href="https://www.journaldev.com/1240/java-xml-parser">Java XML Parser - JournalDev</a></p>
<h4 id="python实现"><a class="header" href="#python实现">Python实现</a></h4>
<p>Python有三种方法解析XML，SAX，DOM，以及ElementTree。ElementTree就像一个轻量级的DOM，具有方便友好的API。代码可用性好，速度快，消耗内存少。</p>
<blockquote>
<p>**注：**因DOM需要将XML数据映射到内存中的树，一是比较慢，二是比较耗内存，而SAX流式读取XML文件，比较快，占用内存少，但需要用户实现回调函数（handler）。</p>
</blockquote>
<h2 id="xpath查询语言"><a class="header" href="#xpath查询语言">XPath查询语言</a></h2>
<p>XPath 是用于XML文档的查询语言，可以查询XML元素节点并计算相应的值。</p>
<h3 id="简写语法abbreviated-syntax"><a class="header" href="#简写语法abbreviated-syntax">简写语法（Abbreviated syntax）</a></h3>
<p>使用节点名，按XML树结构逐级限定查询节点位置。</p>
<ol>
<li>绝对路径</li>
</ol>
<pre><code>/tag1/tag2/.../tagn
/tag1/tag2/.../@prop
xxx//tag/...
xxx/tag/*
</code></pre>
<p><code>//</code>查询指定范围内所有层级的节点。</p>
<p><code>*</code>查询指定层级的所有节点。</p>
<ol start="2">
<li>相对路径</li>
</ol>
<pre><code>childname/...
./childname
../tag
</code></pre>
<p>使用节点名，根据当前节点位置指定查询节点。</p>
<p>多个路径可以由<code>|</code>运算符连接，从而同时选择多个路径。</p>
<h4 id="限定声明predicates"><a class="header" href="#限定声明predicates">限定声明（Predicates）</a></h4>
<p>每一层级声明可以附加限定声明。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">限定表达式</th><th style="text-align: left">结果</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>name[1]</code></td><td style="text-align: left">选取满足表达式条件的第一个元素。</td></tr>
<tr><td style="text-align: left"><code>name[last()]</code></td><td style="text-align: left">选取满足表达式条件的最后一个元素。</td></tr>
<tr><td style="text-align: left"><code>name[last()-n]</code></td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left"><code>name[position()&lt;n]</code></td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left"><code>name[@lang]</code></td><td style="text-align: left">选取满足表达式且具有<code>lang</code>属性的元素。</td></tr>
<tr><td style="text-align: left"><code>name[@lang='en']</code></td><td style="text-align: left">选取满足表达式且<code>lang='en'</code>的元素</td></tr>
<tr><td style="text-align: left"><code>name[@*]</code></td><td style="text-align: left">选取具有属性的节点。</td></tr>
<tr><td style="text-align: left"><code>name[price&gt;100]</code></td><td style="text-align: left">选取满足表达式且其子元素<code>price&gt;100的</code>节点。</td></tr>
</tbody></table>
</div>
<h3 id="完整语法full-syntax"><a class="header" href="#完整语法full-syntax">完整语法（Full Syntax）</a></h3>
<p>使用路径表达式（Location Path）扩展简写语法：</p>
<pre><code>/step1/step2/step3...
step1/step2/...
</code></pre>
<p>每一级<code>step</code>由三部分组成（可省略）：</p>
<pre><code>axis::test[predicates]
</code></pre>
<ul>
<li>
<p>轴（<code>axis</code>）: 指定基于当前节点的查询范围，简写语法中的轴总是<code>child</code>（省略）。</p>
</li>
<li>
<p>节点测试（<code>test</code>）: 测试满足条件的节点，简写语法中总是<strong>节点名</strong>。</p>
<p><code>text()</code>：获取节点的文本内容</p>
<p><code>comment()</code>：获取节点内的注释内容</p>
<p><code>node()</code>：获取节点。</p>
</li>
<li>
<p>限定声明（<code>predicates</code>）：与简写语法一致。</p>
</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">完整语法</th><th style="text-align: center">简写语法</th><th style="text-align: left">Notes</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>ancestor</code></td><td style="text-align: center"></td><td style="text-align: left">选取当前节点的<strong>所有</strong>先辈（父、祖父等）。</td></tr>
<tr><td style="text-align: left"><code>ancestor-or-self</code></td><td style="text-align: center"></td><td style="text-align: left">选取当前节点及其<strong>所有</strong>先辈（父、祖父等）。</td></tr>
<tr><td style="text-align: left"><code>attribute</code></td><td style="text-align: center"><code>@</code></td><td style="text-align: left"><code>@abc</code> is short for <code>attribute::abc</code></td></tr>
<tr><td style="text-align: left"><code>child</code></td><td style="text-align: center"></td><td style="text-align: left"><code>xyz</code> is short for <code>child::xyz</code></td></tr>
<tr><td style="text-align: left"><code>descendant</code></td><td style="text-align: center"></td><td style="text-align: left">选取当前节点的所有后代元素（子、孙等）。</td></tr>
<tr><td style="text-align: left"><code>descendant-or-self</code></td><td style="text-align: center"><code>//</code></td><td style="text-align: left"><code>//</code> is short for <code>/descendant-or-self::node()/</code></td></tr>
<tr><td style="text-align: left"><code>following</code></td><td style="text-align: center"></td><td style="text-align: left">选取文档中当前节点的结束标签之后的所有节点。</td></tr>
<tr><td style="text-align: left"><code>following-sibling</code></td><td style="text-align: center"></td><td style="text-align: left">选取当前节点之后的所有同级节点。</td></tr>
<tr><td style="text-align: left"><code>namespace</code></td><td style="text-align: center"></td><td style="text-align: left">选取当前节点的所有命名空间节点。</td></tr>
<tr><td style="text-align: left"><code>parent</code></td><td style="text-align: center"><code>..</code></td><td style="text-align: left"><code>..</code> is short for <code>parent::node()</code></td></tr>
<tr><td style="text-align: left"><code>preceding</code></td><td style="text-align: center"></td><td style="text-align: left">选取文档中当前节点的开始标签之前的所有节点。</td></tr>
<tr><td style="text-align: left"><code>preceding-sibling</code></td><td style="text-align: center"></td><td style="text-align: left">选取当前节点之前的所有同级节点。</td></tr>
<tr><td style="text-align: left"><code>self</code></td><td style="text-align: center"><code>.</code></td><td style="text-align: left"><code>.</code> is short for <code>self::node()</code></td></tr>
</tbody></table>
</div>
<p><a href="http://www.w3school.com.cn/xpath/xpath_operators.asp">运算符</a></p>
<p><a href="http://www.w3school.com.cn/xpath/xpath_examples.asp">实例</a></p>
<pre><code class="language-python">//div[@class='tab-content-item']  # 查询所有指定类型的div节点
div[@class='p-name p-name-type-2']/a/em//text() # 查询指定范围内所有层级的文本
div[@class='p-operate']/a[1]/attribute::data-sku[1] # 查询指定节点的指定属性
</code></pre>
<h2 id="xslt"><a class="header" href="#xslt">XSLT</a></h2>
<h2 id="xquery"><a class="header" href="#xquery">XQuery</a></h2>
<p>XML Query</p>
<h2 id="xlink和xpointer"><a class="header" href="#xlink和xpointer">Xlink和XPointer</a></h2>
<h2 id="svg"><a class="header" href="#svg">SVG</a></h2>
<h5 id="使用svg构造网站图标"><a class="header" href="#使用svg构造网站图标">使用SVG构造网站图标</a></h5>
<pre><code class="language-xml">&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; viewBox=&quot;0 0 100 100&quot;&gt;
    &lt;text y=&quot;0.9em&quot; font-size=&quot;90&quot;&gt;🍦&lt;/text&gt;
&lt;/svg&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="html"><a class="header" href="#html">HTML</a></h1>
<h2 id="语法-8"><a class="header" href="#语法-8">语法</a></h2>
<h3 id="术语-1"><a class="header" href="#术语-1">术语</a></h3>
<h5 id="html元素"><a class="header" href="#html元素">HTML元素</a></h5>
<img src="数据交换语言/HTML.assets/grumpy-cat-small.png" alt="img" style="zoom:50%;" />
<ul>
<li>
<p>元素（Element）</p>
</li>
<li>
<p>标签（Tag）</p>
</li>
<li>
<p>内容（Content）</p>
</li>
</ul>
<img src="数据交换语言/HTML.assets/grumpy-cat-attribute-small.png" alt="img" style="zoom:50%;" />
<ul>
<li>属性（Attribute）</li>
</ul>
<h5 id="嵌套元素"><a class="header" href="#嵌套元素">嵌套元素</a></h5>
<pre><code class="language-html">&lt;p&gt;My cat is &lt;strong&gt;very&lt;/strong&gt; grumpy.&lt;/p&gt;
</code></pre>
<h5 id="空元素"><a class="header" href="#空元素">空元素</a></h5>
<pre><code class="language-html">&lt;img src=&quot;images/firefox-icon.png&quot; alt=&quot;My test image&quot;&gt;
</code></pre>
<h5 id="css"><a class="header" href="#css">CSS</a></h5>
<blockquote>
<p><em><strong>Cascading Style Sheets</strong></em> are used to selectively style HTML elements.</p>
</blockquote>
<img src="数据交换语言/HTML.assets/css-declaration-small.png" alt="CSS p declaration color red" style="zoom:50%;" />
<ul>
<li>选择器（Selector）：匹配HTML元素。</li>
<li>声明（Declaration）：包含要一个或多个元素属性；</li>
</ul>
<h5 id="布局-3"><a class="header" href="#布局-3">布局</a></h5>
<img src="数据交换语言/HTML.assets/box-model.png" style="zoom:80%;" alt="box model"/>
<blockquote>
<p><em>CSS layout is mostly based on the <strong>box model</strong>,</em> where properties <code>padding</code>, <code>border</code> and <code>margin</code> are involved. Besides, the size (<code>width, height</code>) of the element itself also affects the final layout.</p>
</blockquote>
<h3 id="html结构"><a class="header" href="#html结构">HTML结构</a></h3>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en-US&quot;&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;title&gt;My test page&lt;/title&gt;
    &lt;link rel=&quot;icon&quot; href=&quot;favicon.ico&quot; type=&quot;image/x-icon&quot;&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;styles/style.css&quot;&gt; &lt;!--CSS--&gt;
    &lt;script src=&quot;my-js-file.js&quot; defer&gt;&lt;/script&gt; &lt;!--load JavaScript*--&gt;
  &lt;/head&gt;
  &lt;!-- 注释 --&gt;
  &lt;body&gt;
    &lt;img src=&quot;images/firefox-icon.png&quot; alt=&quot;My test image&quot;&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<blockquote>
<p><code>*</code>：<code>defer</code>表示在HTML加载完后再加载JavaScript程序文件，以避免程序访问还未解析的HTML元素。</p>
</blockquote>
<h4 id="元数据"><a class="header" href="#元数据">元数据</a></h4>
<pre><code class="language-html">&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;meta name=&quot;author&quot; content=&quot;Chris Mills&quot;&gt;
&lt;meta name=&quot;description&quot; content=&quot;The MDN Web Docs.&quot;&gt; &lt;!--*-&gt;
</code></pre>
<blockquote>
<p><code>*</code>：描述信息用于搜索引擎搜索结果展示。</p>
</blockquote>
<p><a href="https://developer.mozilla.org/en-US/docs/Learn/HTML/Introduction_to_HTML/The_head_metadata_in_HTML#other_types_of_metadata">What's in the head? Metadata in HTML - Learn web development | MDN (mozilla.org)</a></p>
<h4 id="标题-1"><a class="header" href="#标题-1">标题</a></h4>
<p>标签标题：<code>&lt;title&gt;</code>位于<code>&lt;head&gt;</code>，显示在浏览器标签上。</p>
<p>章节标题：HTML contains 6 <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/Heading_Elements">heading levels</a>, <code>&lt;h1&gt;</code>-<code>&lt;h6&gt;</code>。<code>&lt;h1&gt;</code>作为正文的文章标题。</p>
<pre><code class="language-html">&lt;h1&gt;My main title&lt;/h1&gt; 
</code></pre>
<h4 id="段落"><a class="header" href="#段落">段落</a></h4>
<pre><code class="language-html">&lt;p&gt;This is a single paragraph&lt;/p&gt;
</code></pre>
<h5 id="列表-1"><a class="header" href="#列表-1">列表</a></h5>
<p>无编号列表<code>&lt;ul&gt;</code>和编号列表<code>&lt;ol&gt;</code>。列表可嵌套在段落中，或独立成为段落。</p>
<pre><code class="language-html">&lt;ul&gt;
  &lt;li&gt;technologists&lt;/li&gt;
  &lt;li&gt;thinkers&lt;/li&gt;
  &lt;li&gt;builders&lt;/li&gt;
&lt;/ul&gt;
</code></pre>
<blockquote>
<h5 id="文字风格"><a class="header" href="#文字风格">文字风格</a></h5>
<p>强调：<code>&lt;em&gt;</code>，<code>&lt;strong&gt;</code>；</p>
<p>斜体：<code>&lt;i&gt;</code></p>
<p>粗体：<code>&lt;b&gt;</code></p>
<p>下划线：<code>&lt;u&gt;</code>。</p>
<p>斜体、粗体、下划线等文字风格是元素的呈现形式而非元素，因此不推荐使用这种形式。考虑使用<code>&lt;span&gt;</code>等元素代替。</p>
</blockquote>
<h4 id="图像"><a class="header" href="#图像">图像</a></h4>
<p><code>alt</code>属性：图像的描述性文本；</p>
<h4 id="表格-1"><a class="header" href="#表格-1">表格</a></h4>
<p>✨<a href="https://developer.mozilla.org/en-US/docs/Learn/HTML/Tables/Basics">HTML table basics - Learn web development | MDN (mozilla.org)</a></p>
<h4 id="链接-1"><a class="header" href="#链接-1">链接</a></h4>
<pre><code class="language-html">&lt;a href=&quot;https://www.mozilla.org/en-US/about/manifesto/&quot;&gt;Mozilla Manifesto&lt;/a&gt;
</code></pre>
<p>链接不仅可用于文本，也可用于整个元素，例如图像（<code>&lt;img&gt;</code>）：</p>
<pre><code class="language-html">&lt;a href=&quot;https://www.mozilla.org/en-US/&quot;&gt;
  &lt;img src=&quot;mozilla-image.png&quot; alt=&quot;logo of the Mozilla homepage&quot;&gt;
&lt;/a&gt;
</code></pre>
<p>链接支持使用相对路径，即相对当前文档访问链接目标的路径。</p>
<p>使用文档片段指向目标文档中<code>id</code>属性对应的元素，从而直接跳转到该元素位置而非文档顶部。</p>
<pre><code class="language-html">&lt;a href=&quot;contacts.html#Mailing_address&quot;&gt;mailing address&lt;/a&gt;
</code></pre>
<p>下载链接，<code>download</code>属性提供文件默认保存名称：</p>
<pre><code class="language-html">&lt;a href=&quot;https://download.mozilla.org/&quot;
   download=&quot;firefox-latest-64bit-installer.exe&quot;&gt;
  Download Latest Firefox for Windows (64-bit) (English, US)
&lt;/a&gt;
</code></pre>
<h3 id="css-1"><a class="header" href="#css-1">CSS</a></h3>
<p>CSS使HTML所呈现的内容与格式分离。</p>
<p>✨<a href="https://developer.mozilla.org/en-US/docs/Learn/CSS">Learn to style HTML using CSS - Learn web development | MDN (mozilla.org)</a></p>
<h4 id="选择器"><a class="header" href="#选择器">选择器</a></h4>
<h5 id="元素选择器"><a class="header" href="#元素选择器">==元素选择器==</a></h5>
<p>选择多个元素</p>
<pre><code class="language-css">p, li, h1 {
  color: red;
}
</code></pre>
<h5 id="标识选择器"><a class="header" href="#标识选择器">标识选择器</a></h5>
<pre><code class="language-css">#my-id {}  /* -&gt; &lt;p id=&quot;my-id&quot;&gt; */ 
</code></pre>
<blockquote>
<p><em>On a given HTML page, each id value should be unique.</em></p>
</blockquote>
<h5 id="类选择器"><a class="header" href="#类选择器">==类选择器==</a></h5>
<p>选择所有属于该类的元素。</p>
<pre><code class="language-css">.my-class {} /* -&gt; &lt;p class=&quot;my-class&quot;&gt; */
</code></pre>
<h5 id="伪类选择器"><a class="header" href="#伪类选择器">伪类选择器</a></h5>
<p>选择处于某一状态的所有元素。</p>
<pre><code class="language-css">a:hover {}
</code></pre>
<h5 id="属性选择器"><a class="header" href="#属性选择器">属性选择器</a></h5>
<p>选择包含指定属性的所有元素。</p>
<pre><code class="language-css">img[src] {} /* -&gt; &lt;img src=&quot;myimage.png&quot;&gt; not &lt;img&gt; */
</code></pre>
<p>更多选择器：https://developer.mozilla.org/en-US/docs/Learn/CSS/Building_blocks/Selectors。</p>
<p><a href="https://developer.mozilla.org/en-US/docs/Learn/CSS/First_steps/Getting_started#combining_selectors_and_combinators">Getting started with CSS - Combining selectors and combinators</a>。</p>
<h4 id="边距与填充声明语法"><a class="header" href="#边距与填充声明语法">边距与填充声明语法</a></h4>
<pre><code class="language-css">p {
  margin: all
  margin: tb lr;
  margin: t r b [l];    
}
</code></pre>
<p>距离声明：</p>
<ul>
<li>
<p><code>12px</code>：固定值（像素），<code>0</code>表示<code>0px</code>。</p>
</li>
<li>
<p><code>auto</code>：与其他元素共同分配剩余空间。</p>
</li>
</ul>
<h4 id="inline-styles"><a class="header" href="#inline-styles">Inline Styles</a></h4>
<pre><code class="language-html">&lt;head&gt;
  &lt;style&gt;
    h1 {}
    p {}
  &lt;/style&gt;  
&lt;/head&gt;
</code></pre>
<h2 id="格式-1"><a class="header" href="#格式-1">格式</a></h2>
<p>以下使用<code>css</code>来书写HTML元素属性，相应的属性可直接用于HTML元素。</p>
<h3 id="布局-4"><a class="header" href="#布局-4">布局</a></h3>
<pre><code class="language-css">body {
  width: 600px;
  margin: 0 auto;
  padding: 0 20px 20px 20px;
  border: 5px solid black;
}
</code></pre>
<h3 id="字体-4"><a class="header" href="#字体-4">字体</a></h3>
<pre><code class="language-css">html {
  font-size: 10px;
  font-family: &quot;Open Sans&quot;, sans-serif;
  font-weight: bold;
}
</code></pre>
<h3 id="颜色-2"><a class="header" href="#颜色-2">颜色</a></h3>
<pre><code class="language-css">html {
  color: #00539F;
  background-color: #FF9500;
}
</code></pre>
<p>颜色表示法：</p>
<ul>
<li>十六进制RGB：<code>#00539F</code>；</li>
<li>RGBA：<code>rgba(0,0,200,0.3)</code></li>
<li>颜色名称：<code>red</code>，<code>blue</code>，<code>green</code>，……</li>
</ul>
<h4 id="阴影"><a class="header" href="#阴影">阴影</a></h4>
<pre><code class="language-css">p {
  text-shadow: 3px 3px 1px black;
  box-shadow: 1px 1px 2px rgba(0,0,200,0.4);
}
</code></pre>
<h3 id="段落格式"><a class="header" href="#段落格式">段落格式</a></h3>
<h5 id="间距"><a class="header" href="#间距">间距</a></h5>
<pre><code class="language-css">p,li {
  line-height: 2;
  letter-spacing: 1px;
}
</code></pre>
<h5 id="对齐-1"><a class="header" href="#对齐-1">对齐</a></h5>
<pre><code class="language-css">p,li {
  text-align: center;
}
</code></pre>
<h4 id="编号1"><a class="header" href="#编号1">编号<sup class="footnote-reference"><a href="#css-counter">1</a></sup></a></h4>
<pre><code class="language-css">h1 {
    counter-reset: h2counter;    
}
h2::before {
    counter-increment: h2counter; 
    content: &quot;Section &quot; counter(h2counter) &quot;: &quot;; /*显示在对应内容前, 由指定内容拼接成 */
}
</code></pre>
<h3 id="交互格式"><a class="header" href="#交互格式">交互格式</a></h3>
<pre><code class="language-css">p {
  cursor: pointer;
}
</code></pre>
<h2 id="网页结构"><a class="header" href="#网页结构">网页结构</a></h2>
<p>✨<a href="https://developer.mozilla.org/en-US/docs/Learn/HTML/Introduction_to_HTML/Document_and_website_structure">Document and website structure - Learn web development | MDN (mozilla.org)</a></p>
<h3 id="表单-1"><a class="header" href="#表单-1">表单</a></h3>
<p>✨<a href="https://developer.mozilla.org/en-US/docs/Learn/Forms">Web forms — Working with user data - Learn web development | MDN (mozilla.org)</a></p>
<h2 id="多媒体嵌入"><a class="header" href="#多媒体嵌入">多媒体嵌入</a></h2>
<p>✨<a href="https://developer.mozilla.org/en-US/docs/Learn/HTML/Multimedia_and_embedding">Multimedia and embedding - Learn web development | MDN (mozilla.org)</a></p>
<h2 id="参考资料-16"><a class="header" href="#参考资料-16">参考资料</a></h2>
<div class="footnote-definition" id="css-counter"><sup class="footnote-definition-label">1</sup>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Counter_Styles/Using_CSS_counters">Using CSS counters - CSS: Cascading Style Sheets | MDN (mozilla.org)</a>.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="http-2"><a class="header" href="#http-2">HTTP</a></h1>
<h2 id="通信流程"><a class="header" href="#通信流程">通信流程</a></h2>
<p>HTTP使用TCP协议在客户端和服务器间传输数据，从而保证传输的可靠性，使得HTTP应用无需关注传输细节。</p>
<p>HTTP程序从URL获取服务器域名和端口号，并通过DNS得到服务器的IP地址。</p>
<h3 id="dns查询"><a class="header" href="#dns查询">DNS查询</a></h3>
<ol>
<li>查询浏览器DNS缓存</li>
<li>查询本机<code>hosts</code>文件</li>
<li>查询DNS服务器</li>
</ol>
<h3 id="http报文"><a class="header" href="#http报文">HTTP报文</a></h3>
<p>HTTP报文由<a href="Protocols/http.html#GET">起始行、头部和主体</a>组成。</p>
<p>行终止符：<code>CRLF</code>（<code>0x0D0A</code>）；标准要求行终止符为两个字符，但应用程序也应该接受单个字符作为行终止符。</p>
<h5 id="起始行"><a class="header" href="#起始行">起始行</a></h5>
<p>请求报文的起始行由方法、URL（路径）和HTTP版本组成：</p>
<pre><code class="language-http">GET /index.html http/1.1
</code></pre>
<p>响应报文的起始行由HTTP版本、状态码和状态信息组成：</p>
<pre><code class="language-http">http/1.1 200 OK
</code></pre>
<h4 id="状态码"><a class="header" href="#状态码">状态码</a></h4>
<p>所有处理过程都使用响应码而非其文本描述。</p>
<h5 id="1xx信息提示"><a class="header" href="#1xx信息提示"><code>1xx</code>信息提示</a></h5>
<h5 id="2xx成功"><a class="header" href="#2xx成功"><code>2XX</code>成功</a></h5>
<p><code>200</code>：returns with a response body</p>
<p><code>201</code>：Created</p>
<p><code>204</code>：no content</p>
<h5 id="3xx重定向"><a class="header" href="#3xx重定向"><code>3XX</code>重定向</a></h5>
<p><code>301 Moved Permanently</code>：请求资源已经被永久移动，返回资源的新地址；</p>
<p><code>302 Found</code>：请求资源被暂时修改，客户端随后应该使用该URI请求更新内容；</p>
<p><code>304 Not Modified</code>：请求的资源未被修改过，客户端可使用已缓存内容；</p>
<h5 id="4xx客户端错误"><a class="header" href="#4xx客户端错误"><code>4XX</code>客户端错误</a></h5>
<p><code>400 Bad Request</code>：服务器无法解析请求数据；</p>
<p><code>401 Unauthorized</code>：需要输入用户名和密码；</p>
<p><code>403 Forbidden</code>：拒绝访问；</p>
<p><code>404 Not Found</code>：no item matches the requested URL</p>
<h5 id="5xx服务器错误"><a class="header" href="#5xx服务器错误"><code>5XX</code>服务器错误</a></h5>
<p><code>5xx</code>：Unhandled exceptions</p>
<h4 id="头部字段"><a class="header" href="#头部字段">头部字段</a></h4>
<h5 id="user-agent"><a class="header" href="#user-agent">User-Agent</a></h5>
<p>让网络协议的对端来识别发起请求的用户代理软件的应用类型、操作系统、软件开发商以及版本号。</p>
<pre><code class="language-http">User-Agent: Mozilla/&lt;version&gt; (&lt;system-information&gt;) &lt;platform&gt; (&lt;platform-details&gt;) &lt;extensions&gt;
User-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:47.0) Gecko/20100101 Firefox/47.0
User-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.103 Safari/537.36
User-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.106 Safari/537.36 OPR/38.0.2220.41
User-Agent: Mozilla/5.0 (iPhone; CPU iPhone OS 10_3_1 like Mac OS X) AppleWebKit/603.1.30 (KHTML, like Gecko) Version/10.0 Mobile/14E304 Safari/602.1
User-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows Phone OS 7.5; Trident/5.0; IEMobile/9.0)
User-Agent: Googlebot/2.1 (+http://www.google.com/bot.html)
</code></pre>
<h5 id="content-type"><a class="header" href="#content-type">Content-Type</a></h5>
<p>用于指示资源的MIME类型。</p>
<pre><code class="language-http">Content-Type: text/html; charset=utf-8
Content-Type: multipart/form-data; boundary=something
</code></pre>
<p><code>boundary</code>由1~70个字符组成（<em>known to be very robust through email gateways</em>），用于封装消息的多个部分的边界，对于多部分实体（multipart entities，具有一组而不是单个内容体）是必需的。通常头部边界前缀添加<code>--</code>，尾部边界后缀添加<code>--</code>。</p>
<h5 id="content-disposition"><a class="header" href="#content-disposition">Content-Disposition</a></h5>
<p>https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Disposition</p>
<pre><code class="language-http">Content-Disposition: inline
Content-Disposition: attachment
Content-Disposition: attachment; filename=&quot;filename.jpg&quot;
</code></pre>
<pre><code class="language-http">Content-Disposition: form-data
Content-Disposition: form-data; name=&quot;fieldName&quot;
Content-Disposition: form-data; name=&quot;field2&quot;; filename=&quot;example.txt&quot;
</code></pre>
<h5 id="content-encoding"><a class="header" href="#content-encoding">Content-Encoding</a></h5>
<p>媒体数据的压缩编码。通常尽可能压缩数据，但对于已经压缩过的类型（如<code>jpeg</code>）则不必要。</p>
<pre><code class="language-http">Content-Encoding: gzip
Content-Encoding: compress
Content-Encoding: deflate
Content-Encoding: br
Content-Encoding: deflate, gzip
</code></pre>
<h5 id="content-language"><a class="header" href="#content-language">Content-Language</a></h5>
<p>用于设定内容的目标观众所适用的语言。</p>
<pre><code class="language-http">Content-Language: en-US
Content-Language: de-DE, en-CA
</code></pre>
<h5 id="set-cookie"><a class="header" href="#set-cookie">Set-Cookie</a></h5>
<p>服务器向客户代理发送cookie，从而客户代理随后能将其返回给服务器。要设置多个cookies，则设置多个该字段。</p>
<pre><code class="language-http">Set-Cookie: &lt;cookie-name&gt;=&lt;cookie-value&gt;
Set-Cookie: &lt;cookie-name&gt;=&lt;cookie-value&gt;; Expires=&lt;date&gt;
Set-Cookie: &lt;cookie-name&gt;=&lt;cookie-value&gt;; Domain=&lt;domain-value&gt;
Set-Cookie: &lt;cookie-name&gt;=&lt;cookie-value&gt;; Path=&lt;path-value&gt;
// Multiple attributes are also possible, for example:
Set-Cookie: &lt;cookie-name&gt;=&lt;cookie-value&gt;; Secure; HttpOnly; SameSite=Strict
</code></pre>
<p>https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie</p>
<h2 id="web资源"><a class="header" href="#web资源">Web资源</a></h2>
<h3 id="uri"><a class="header" href="#uri">URI</a></h3>
<p>URI（Uniform Resource Identifier）分为URL（Uniform Resource Locator）和URN（Uniform Resource Name）</p>
<h4 id="url-2"><a class="header" href="#url-2">URL</a></h4>
<p>URL描述一台特定服务器上特定资源的位置及其访问方式。</p>
<p><a href="https://www.ibm.com/docs/en/cics-ts/5.1?topic=concepts-components-url">The components of a URL - IBM Documentation</a></p>
<p><a href="https://en.wikipedia.org/wiki/Uniform_Resource_Identifier">Uniform Resource Identifier - Wikipedia</a></p>
<h5 id="url格式"><a class="header" href="#url格式"><a href="Protocols/URL.txt">URL格式</a></a></h5>
<p>URL通常由协议、服务器地址和路径（服务器上资源的位置）组成。</p>
<pre><code>scheme://user:password@host:port/path;params?query#frag
query:key1=value1&amp;key2=value2&amp;...
</code></pre>
<p><code>frag</code>（片段）并不会发送给服务器，服务器将资源返回后，客户端通过片段决定显示的资源内容。</p>
<h5 id="相对url"><a class="header" href="#相对url">相对URL</a></h5>
<p>相对于当前文档路径的URL。</p>
<h5 id="url编码-1"><a class="header" href="#url编码-1">URL编码</a></h5>
<h4 id="urn"><a class="header" href="#urn">URN</a></h4>
<p>URN作为特定内容的全局唯一标识，与资源位置无关（例如<a href="https://en.wikipedia.org/wiki/Digital_object_identifier">DOI</a>）。</p>
<h3 id="资源类型"><a class="header" href="#资源类型">资源类型</a></h3>
<p>MIME (Multipurpose Internet Mail Extension)类型最初用于电子邮件系统，在HTTP中用于标识媒体资源类型（<code>Content-Type</code>）。</p>
<h2 id="web服务架构"><a class="header" href="#web服务架构">Web服务架构</a></h2>
<h3 id="代理-1"><a class="header" href="#代理-1">代理</a></h3>
<h3 id="缓存-1"><a class="header" href="#缓存-1">缓存</a></h3>
<h3 id="网关"><a class="header" href="#网关">网关</a></h3>
<h3 id="隧道"><a class="header" href="#隧道">隧道</a></h3>
<p>HTTP/SSL</p>
<h3 id="代理-2"><a class="header" href="#代理-2">代理</a></h3>
<p>代表用户发起HTTP请求的程序（客户端），例如浏览器、爬虫。</p>
<h2 id="http方法-1"><a class="header" href="#http方法-1">HTTP方法</a></h2>
<h5 id="get"><a class="header" href="#get">GET</a></h5>
<p>获取记录。</p>
<pre><code class="language-http">GET https://localhost:5001/api/TodoItems
User-Agent: PostmanRuntime/7.26.8
Accept: */*
Postman-Token: 4241178d-38d3-4b68-a7e1-6d2540938bdb
Host: localhost:5001
Accept-Encoding: gzip, deflate, br
Connection: keep-alive
-------------------------------------
HTTP/1.1 200 OK
Date: Fri, 08 Jan 2021 13:05:35 GMT
Content-Type: application/json; charset=utf-8
Server: Kestrel
Transfer-Encoding: chunked
[{&quot;id&quot;:1,&quot;name&quot;:&quot;walk dog&quot;,&quot;isComplete&quot;:true}]
</code></pre>
<h5 id="post"><a class="header" href="#post">POST</a></h5>
<p>添加记录。</p>
<pre><code class="language-http">POST https://localhost:5001/api/TodoItems
Content-Type: application/json5
# User-Agent/Accept/Postman-Token/Host/Accept-Encoding/Connection
Content-Length: 47
{&quot;name&quot;:&quot;walk dog&quot;,&quot;isComplete&quot;:true}
---------------------------------------
HTTP/1.1 201
Date: Fri, 08 Jan 2021 13:05:22 GMT
Content-Type: application/json; charset=utf-8
Server: Kestrel
Transfer-Encoding: chunked
Location: https://localhost:5001/api/TodoItems/1
{&quot;id&quot;:1,&quot;name&quot;:&quot;walk dog&quot;,&quot;isComplete&quot;:true}
</code></pre>
<h5 id="put"><a class="header" href="#put">PUT</a></h5>
<p>更新记录</p>
<pre><code class="language-http">PUT https://localhost:5001/api/TodoItems/1
Content-Type/User-Agent/Accept/Postman-Token/Host/Accept-Encoding/Connection/Content-Length
{&quot;id&quot;:1,&quot;name&quot;:&quot;walk cat&quot;,&quot;isComplete&quot;:true}
--------------------------------------------
HTTP/1.1 204
Date: Fri, 08 Jan 2021 13:53:03 GMT
Server: Kestrel
</code></pre>
<blockquote>
<p>在URL和请求数据中都需要包含<code>id</code>。</p>
</blockquote>
<h5 id="delete"><a class="header" href="#delete">DELETE</a></h5>
<pre><code class="language-http">DELETE https://localhost:5001/api/TodoItems/1
---------------------------------------------
HTTP/1.1 204
Date: Fri, 08 Jan 2021 14:00:06 GMT
Server: Kestrel
</code></pre>
<h2 id="http-cookies"><a class="header" href="#http-cookies">HTTP cookies</a></h2>
<h2 id="附录-3"><a class="header" href="#附录-3">附录</a></h2>
<h3 id="http版本"><a class="header" href="#http版本">HTTP版本</a></h3>
<p><strong>HTTP/0.9</strong>：只支持<code>GET</code>方法，不支持MIME类型、HTTP首部和版本号。</p>
<p><strong>HTTP/1.0</strong>：添加了版本号，HTTP首部和多媒体对象处理。</p>
<p><strong>HTTP/1.0+</strong>：很多特性被加入，包括：keep-alive连接、虚拟主机、代理连接。</p>
<p><strong>HTTP/1.1</strong>：校正设计中的结构性缺陷，明确语义，引入重要的性能优化措施，并删除一些不好的特性。</p>
<p><strong>HTTP/2.0</strong>：性能优化，服务逻辑远程执行框架。</p>
<p><a href="https://www.w3.org/Protocols/WhyHTTP.html">HTTP: Why a new protocol? (w3.org)</a></p>
<p><a href="https://www.w3.org/DesignIssues/Architecture.html">Web Architecture from 50,000 feet (w3.org)</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="domain-name-service"><a class="header" href="#domain-name-service">Domain Name Service</a></h1>
<h2 id="传输协议"><a class="header" href="#传输协议">传输协议</a></h2>
<p>DNS主要使用UDP 53端口服务请求。</p>
<blockquote>
<p><em>DNS queries consist of a single UDP request from the client followed by a single UDP reply from the server.</em></p>
</blockquote>
<p>当响应长度大于512字节且客户端和服务器都支持EDNS，则使用长UDP分组；否则使用TCP重新发起查询。某些解析器全部采用TCP进行查询。 </p>
<p>https://en.wikipedia.org/wiki/Domain_Name_System</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="端口分配"><a class="header" href="#端口分配">端口分配</a></h1>
<h2 id="well-known-ports"><a class="header" href="#well-known-ports">Well-known ports</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Ports</th><th></th><th></th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td>1</td><td>Yes</td><td>Assigned</td><td style="text-align: left"><a href="https://en.wikipedia.org/wiki/TCP_Port_Service_Multiplexer">TCP Port Service Multiplexer</a> (TCPMUX). Historic. Both TCP and UDP have been assigned to TCPMUX by IANA,[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-IANA-1">1]</a> but by design only TCP is specified.[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-rfc1078-6">6]</a></td></tr>
<tr><td>5</td><td>Assigned</td><td>Assigned</td><td style="text-align: left"><a href="https://en.wikipedia.org/wiki/Remote_Job_Entry">Remote Job Entry</a>[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-rfc407-7">7]</a> was historically using socket 5 in its <a href="https://en.wikipedia.org/wiki/Network_socket#History">old socket form</a>, while MIB PIM has identified it as TCP/5[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-rfc2896-8">8]</a> and IANA has assigned both TCP and UDP 5 to it.</td></tr>
<tr><td>7</td><td>Yes</td><td>Yes</td><td style="text-align: left"><a href="https://en.wikipedia.org/wiki/Echo_Protocol">Echo Protocol</a>[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-rfc862-9">9]</a>[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-apple-kb-HT202944-10">10]</a></td></tr>
<tr><td>9</td><td>Yes</td><td>Yes</td><td style="text-align: left"><a href="https://en.wikipedia.org/wiki/Discard_Protocol">Discard Protocol</a>[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-rfc863-11">11]</a></td></tr>
<tr><td>No</td><td>Yes</td><td>Unofficial</td><td style="text-align: left"></td></tr>
<tr><td>11</td><td>Yes</td><td>Yes</td><td style="text-align: left">Active Users (<a href="https://en.wikipedia.org/wiki/Systat_(protocol)">systat</a> service)[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-systat-netstat-14">14]</a>[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-RFC866-15">15]</a></td></tr>
<tr><td>13</td><td>Yes</td><td>Yes</td><td style="text-align: left"><a href="https://en.wikipedia.org/wiki/Daytime_Protocol">Daytime Protocol</a>[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-rfc867-16">16]</a></td></tr>
<tr><td>15</td><td>Yes</td><td>No</td><td style="text-align: left">Previously <a href="https://en.wikipedia.org/wiki/Netstat">netstat</a> service[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-IANA-1">1]</a>[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-systat-netstat-14">14]</a></td></tr>
<tr><td>17</td><td>Yes</td><td>Yes</td><td style="text-align: left"><a href="https://en.wikipedia.org/wiki/QOTD">Quote of the Day</a> (QOTD)[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-rfc865-17">17]</a></td></tr>
<tr><td>18</td><td>Yes</td><td>Yes</td><td style="text-align: left"><a href="https://en.wikipedia.org/wiki/Message_Send_Protocol">Message Send Protocol</a>[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-rfc1159-18">18]</a>[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-rfc1312-19">19]</a></td></tr>
<tr><td>19</td><td>Yes</td><td>Yes</td><td style="text-align: left"><a href="https://en.wikipedia.org/wiki/Character_Generator_Protocol">Character Generator Protocol</a> (CHARGEN)[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-rfc864-20">20]</a></td></tr>
<tr><td>20</td><td>Yes</td><td>Assigned</td><td style="text-align: left"><a href="https://en.wikipedia.org/wiki/File_Transfer_Protocol">File Transfer Protocol</a> (FTP) data transfer[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-apple-kb-HT202944-10">10]</a></td></tr>
<tr><td>21</td><td>Yes</td><td>Assigned</td><td style="text-align: left"><a href="https://en.wikipedia.org/wiki/File_Transfer_Protocol">File Transfer Protocol</a> (FTP) control (command)[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-apple-kb-HT202944-10">10]</a>[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-rfc4960-12">12]</a>[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-rfc765-21">21]</a>[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-rfc959-22">22]</a></td></tr>
<tr><td>22</td><td>Yes</td><td>Assigned</td><td style="text-align: left"><a href="https://en.wikipedia.org/wiki/Secure_Shell">Secure Shell</a> (SSH),[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-apple-kb-HT202944-10">10]</a> secure logins, <a href="https://en.wikipedia.org/wiki/File_transfer">file transfers</a> (<a href="https://en.wikipedia.org/wiki/Secure_copy">scp</a>, <a href="https://en.wikipedia.org/wiki/SSH_file_transfer_protocol">sftp</a>) and port forwarding</td></tr>
<tr><td>23</td><td>Yes</td><td>Assigned</td><td style="text-align: left"><a href="https://en.wikipedia.org/wiki/Telnet">Telnet</a> protocol—unencrypted text communications[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-apple-kb-HT202944-10">10]</a>[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-rfc854-23">23]</a></td></tr>
<tr><td>25</td><td>Yes</td><td>Assigned</td><td style="text-align: left"><a href="https://en.wikipedia.org/wiki/Simple_Mail_Transfer_Protocol">Simple Mail Transfer Protocol</a> (SMTP),[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-apple-kb-HT202944-10">10]</a>[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-rfc821-24">24]</a> used for email routing between mail servers</td></tr>
<tr><td>28</td><td>Yes</td><td></td><td style="text-align: left">Palo Alto Networks' Panorama High Availability (HA) sync encrypted port.[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-PAN-OS_HALinksAndBackupLinks-25">25]</a></td></tr>
<tr><td>37</td><td>Yes</td><td>Yes</td><td style="text-align: left"><a href="https://en.wikipedia.org/wiki/Time_Protocol">Time Protocol</a>[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-rfc868-26">26]</a></td></tr>
<tr><td>42</td><td>Assigned</td><td>Yes</td><td style="text-align: left"><a href="https://en.wikipedia.org/wiki/ARPA_Host_Name_Server_Protocol">Host Name Server Protocol</a>[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-ien116-27">27]</a></td></tr>
<tr><td>43</td><td>Yes</td><td>Assigned</td><td style="text-align: left"><a href="https://en.wikipedia.org/wiki/WHOIS">WHOIS</a> protocol[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-rfc812-28">28]</a>[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-rfc954-29">29]</a>[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-rfc3912-30">30]</a></td></tr>
<tr><td>47</td><td>Reserved</td><td>Reserved</td><td style="text-align: left"></td></tr>
<tr><td>49</td><td>Yes</td><td>Yes</td><td style="text-align: left"><a href="https://en.wikipedia.org/wiki/TACACS">TACACS</a> Login Host protocol.[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-rfc1492-31">31]</a> <a href="https://en.wikipedia.org/wiki/TACACS%2B">TACACS+</a>, still in draft which is an improved but distinct version of TACACS, only uses TCP 49.[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-32">32]</a></td></tr>
<tr><td>51</td><td>Reserved</td><td>Reserved</td><td style="text-align: left">Historically used for <a href="https://en.wikipedia.org/wiki/Interface_Message_Processor">Interface Message Processor</a> logical address management,[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-bbnreport5256-33">33]</a> entry has been removed by IANA on 2013-05-25</td></tr>
<tr><td>52</td><td>Assigned</td><td>Assigned</td><td style="text-align: left"><a href="https://en.wikipedia.org/wiki/Xerox_Network_Systems">Xerox Network Systems</a> (XNS) Time Protocol. Despite this port being assigned by IANA, the service is meant to work on <a href="https://en.wikipedia.org/wiki/Sequenced_Packet_Protocol">SPP</a> (ancestor of <a href="https://en.wikipedia.org/wiki/IPX/SPX">IPX/SPX</a>), instead of TCP/IP.[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-xns-34">34]</a></td></tr>
<tr><td>53</td><td>Yes</td><td>Yes</td><td style="text-align: left"><a href="https://en.wikipedia.org/wiki/Domain_Name_System">Domain Name System</a> (DNS)[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-rfc1035-35">35]</a>[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-apple-kb-HT202944-10">10]</a></td></tr>
<tr><td>54</td><td>Assigned</td><td>Assigned</td><td style="text-align: left">Xerox Network Systems (XNS) Clearinghouse (Name Server). Despite this port being assigned by IANA, the service is meant to work on <a href="https://en.wikipedia.org/wiki/Sequenced_Packet_Protocol">SPP</a> (ancestor of <a href="https://en.wikipedia.org/wiki/IPX/SPX">IPX/SPX</a>), instead of TCP/IP.[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-xns-34">34]</a></td></tr>
<tr><td>56</td><td>Assigned</td><td>Assigned</td><td style="text-align: left">Xerox Network Systems (XNS) Authentication Protocol. Despite this port being assigned by IANA, the service is meant to work on <a href="https://en.wikipedia.org/wiki/Sequenced_Packet_Protocol">SPP</a> (ancestor of <a href="https://en.wikipedia.org/wiki/IPX/SPX">IPX/SPX</a>), instead of TCP/IP.[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-xns-34">34]</a></td></tr>
<tr><td>58</td><td>Assigned</td><td>Assigned</td><td style="text-align: left">Xerox Network Systems (XNS) Mail. Despite this port being assigned by IANA, the service is meant to work on <a href="https://en.wikipedia.org/wiki/Sequenced_Packet_Protocol">SPP</a> (ancestor of <a href="https://en.wikipedia.org/wiki/IPX/SPX">IPX/SPX</a>), instead of TCP/IP.[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-xns-34">34]</a></td></tr>
<tr><td>61</td><td>Reserved</td><td>Reserved</td><td style="text-align: left">Historically assigned to the <a href="https://en.wikipedia.org/w/index.php?title=NIFTP-Based_Mail&amp;action=edit&amp;redlink=1">NIFTP-Based Mail</a> protocol,[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-rfc1060-36">36]</a> but was never documented in the related <a href="https://en.wikipedia.org/wiki/Internet_Experiment_Note">IEN</a>.[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-ien169-37">37]</a> The port number entry was removed from IANA's registry on 2017-05-18.[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-IANA-1">1]</a></td></tr>
<tr><td>67</td><td>Assigned</td><td>Yes</td><td style="text-align: left"><a href="https://en.wikipedia.org/wiki/Bootstrap_Protocol">Bootstrap Protocol</a> (BOOTP) server;[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-apple-kb-HT202944-10">10]</a> also used by <a href="https://en.wikipedia.org/wiki/Dynamic_Host_Configuration_Protocol">Dynamic Host Configuration Protocol</a> (DHCP)</td></tr>
<tr><td>68</td><td>Assigned</td><td>Yes</td><td style="text-align: left">Bootstrap Protocol (BOOTP) client;[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-apple-kb-HT202944-10">10]</a> also used by Dynamic Host Configuration Protocol (DHCP)</td></tr>
<tr><td>69</td><td>Assigned</td><td>Yes</td><td style="text-align: left"><a href="https://en.wikipedia.org/wiki/Trivial_File_Transfer_Protocol">Trivial File Transfer Protocol</a> (TFTP)[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-apple-kb-HT202944-10">10]</a>[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-ien133-38">38]</a>[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-rfc783-39">39]</a>[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-rfc1350-40">40]</a></td></tr>
<tr><td>70</td><td>Yes</td><td>Assigned</td><td style="text-align: left"><a href="https://en.wikipedia.org/wiki/Gopher_(protocol)">Gopher</a> protocol[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-rfc1436-41">41]</a></td></tr>
<tr><td>71–74</td><td>Yes</td><td>Yes</td><td style="text-align: left"><a href="https://en.wikipedia.org/wiki/NETRJS">NETRJS</a> protocol[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-rfc88-42">42]</a>[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-rfc740-43">43]</a>[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-rfc820-44">44]</a></td></tr>
<tr><td>79</td><td>Yes</td><td>Assigned</td><td style="text-align: left"><a href="https://en.wikipedia.org/wiki/Finger_protocol">Finger protocol</a>[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-apple-kb-HT202944-10">10]</a>[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-rfc742-45">45]</a>[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-rfc1288-46">46]</a></td></tr>
<tr><td>80</td><td>Yes</td><td>Yes</td><td style="text-align: left"><a href="https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol">Hypertext Transfer Protocol</a> (HTTP)[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-rfc7230-47">47]</a>[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-rfc7540-48">48]</a> uses TCP in versions 1.x and 2. <a href="https://en.wikipedia.org/wiki/HTTP/3">HTTP/3</a> uses <a href="https://en.wikipedia.org/wiki/QUIC">QUIC</a>,[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-quic-49">49]</a> a transport protocol on top of UDP.</td></tr>
<tr><td>81</td><td>Yes</td><td></td><td style="text-align: left"><a href="https://en.wikipedia.org/wiki/TorPark">TorPark</a> <a href="https://en.wikipedia.org/wiki/Onion_routing">onion routing</a>[<em><a href="https://en.wikipedia.org/wiki/Wikipedia:Verifiability">verification needed</a></em>]</td></tr>
<tr><td>82</td><td></td><td>Yes</td><td style="text-align: left"><a href="https://en.wikipedia.org/wiki/TorPark">TorPark</a> control[<em><a href="https://en.wikipedia.org/wiki/Wikipedia:Verifiability">verification needed</a></em>]</td></tr>
<tr><td>83</td><td>Yes</td><td>Assigned</td><td style="text-align: left">MIT ML Device, networking file system [<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-50">50]</a></td></tr>
<tr><td>88</td><td>Yes</td><td>Assigned</td><td style="text-align: left"><a href="https://en.wikipedia.org/wiki/Kerberos_(protocol)">Kerberos</a>[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-apple-kb-HT202944-10">10]</a>[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-rfc1510-51">51]</a>[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-rfc4120-52">52]</a> authentication system</td></tr>
<tr><td>90</td><td>Yes</td><td>Yes</td><td style="text-align: left"><a href="https://en.wikipedia.org/wiki/PointCast_(dotcom)">PointCast (dotcom)</a>[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-IANA-1">1]</a>[<em><a href="https://en.wikipedia.org/wiki/Wikipedia:Independent_sources">third-party source needed</a></em>]</td></tr>
<tr><td>95</td><td>Yes</td><td>Assigned</td><td style="text-align: left">SUPDUP, terminal-independent remote login [<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-53">53]</a></td></tr>
<tr><td>101</td><td>Yes</td><td>Assigned</td><td style="text-align: left"><a href="https://en.wikipedia.org/wiki/History_of_the_Internet#NIC,_InterNIC,_IANA_and_ICANN">NIC</a> <a href="https://en.wikipedia.org/wiki/Hostname">host name</a>[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-rfc953-54">54]</a></td></tr>
<tr><td>102</td><td>Yes</td><td>Assigned</td><td style="text-align: left"><a href="https://en.wikipedia.org/wiki/International_Organization_for_Standardization">ISO</a> Transport Service Access Point (<a href="https://en.wikipedia.org/wiki/TSAP">TSAP</a>) Class 0 protocol;[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-rfc983-55">55]</a>[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-rfc1006-56">56]</a></td></tr>
<tr><td>104</td><td>Yes</td><td>Yes</td><td style="text-align: left"><a href="https://en.wikipedia.org/wiki/Digital_Imaging_and_Communications_in_Medicine">Digital Imaging and Communications in Medicine</a> (DICOM; also port 11112)</td></tr>
<tr><td>105</td><td>Yes</td><td>Yes</td><td style="text-align: left"><a href="https://en.wikipedia.org/wiki/CCSO_Nameserver">CCSO Nameserver</a>[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-rfc2378-57">57]</a></td></tr>
<tr><td>107</td><td>Yes</td><td>Yes</td><td style="text-align: left"><a href="https://en.wikipedia.org/wiki/Rtelnet">Remote User Telnet Service</a> (RTelnet)[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-rfc818-58">58]</a></td></tr>
<tr><td>108</td><td>Yes</td><td>Yes</td><td style="text-align: left">IBM <a href="https://en.wikipedia.org/wiki/Systems_Network_Architecture">Systems Network Architecture</a> (SNA) gateway access server</td></tr>
<tr><td>109</td><td>Yes</td><td>Assigned</td><td style="text-align: left"><a href="https://en.wikipedia.org/wiki/Post_Office_Protocol">Post Office Protocol</a>, version 2 (POP2)[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-rfc937-59">59]</a></td></tr>
<tr><td>110</td><td>Yes</td><td>Assigned</td><td style="text-align: left">Post Office Protocol, version 3 (POP3)[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-apple-kb-HT202944-10">10]</a>[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-rfc1081-60">60]</a>[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-rfc1939-61">61]</a></td></tr>
<tr><td>111</td><td>Yes</td><td>Yes</td><td style="text-align: left"><a href="https://en.wikipedia.org/wiki/Open_Network_Computing_Remote_Procedure_Call">Open Network Computing Remote Procedure Call</a> (<strong>ONC RPC</strong>, sometimes referred to as <strong>Sun RPC</strong>)</td></tr>
<tr><td>113</td><td>Yes</td><td>No</td><td style="text-align: left"><a href="https://en.wikipedia.org/wiki/Ident_protocol">Ident</a>, authentication service/identification protocol,[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-apple-kb-HT202944-10">10]</a>[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-rfc1413-62">62]</a> used by <a href="https://en.wikipedia.org/wiki/Internet_Relay_Chat">IRC</a> servers to identify users</td></tr>
<tr><td>Yes</td><td>Assigned</td><td>Official</td><td style="text-align: left"></td></tr>
<tr><td>115</td><td>Yes</td><td>Assigned</td><td style="text-align: left"><a href="https://en.wikipedia.org/wiki/Simple_File_Transfer_Protocol">Simple File Transfer Protocol</a>[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-apple-kb-HT202944-10">10]</a>[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-rfc913-64">64]</a></td></tr>
<tr><td>117</td><td>Yes</td><td>Yes</td><td style="text-align: left"><a href="https://en.wikipedia.org/wiki/UUCP_Mapping_Project">UUCP Mapping Project</a> (path service)[<em><a href="https://en.wikipedia.org/wiki/Wikipedia:Citation_needed">citation needed</a></em>]</td></tr>
<tr><td>118</td><td>Yes</td><td>Yes</td><td style="text-align: left">Structured Query Language (<a href="https://en.wikipedia.org/wiki/SQL">SQL</a>) Services[<em><a href="https://en.wikipedia.org/wiki/Wikipedia:Manual_of_Style#Technical_language">jargon</a></em>]</td></tr>
<tr><td>119</td><td>Yes</td><td>Assigned</td><td style="text-align: left"><a href="https://en.wikipedia.org/wiki/Network_News_Transfer_Protocol">Network News Transfer Protocol</a> (NNTP),[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-apple-kb-HT202944-10">10]</a> retrieval of newsgroup messages[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-rfc977-65">65]</a>[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-rfc3977-66">66]</a></td></tr>
<tr><td>123</td><td>Assigned</td><td>Yes</td><td style="text-align: left"><a href="https://en.wikipedia.org/wiki/Network_Time_Protocol">Network Time Protocol</a> (NTP), used for time synchronization[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-apple-kb-HT202944-10">10]</a></td></tr>
<tr><td>126</td><td>Yes</td><td>Yes</td><td style="text-align: left">Formerly <a href="https://en.wikipedia.org/wiki/Unisys">Unisys</a> Unitary Login, renamed by Unisys to NXEdit. Used by Unisys Programmer's Workbench for Clearpath MCP, an IDE for <a href="https://en.wikipedia.org/wiki/Unisys_MCP_programming_languages">Unisys MCP software development</a></td></tr>
<tr><td>135</td><td>Yes</td><td>Yes</td><td style="text-align: left"><a href="https://en.wikipedia.org/wiki/Distributed_Computing_Environment">DCE</a> <a href="https://en.wikipedia.org/wiki/Communication_endpoint">endpoint</a> resolution</td></tr>
<tr><td>Yes</td><td>Yes</td><td>Official</td><td style="text-align: left"></td></tr>
<tr><td>137</td><td>Yes</td><td>Yes</td><td style="text-align: left"><a href="https://en.wikipedia.org/wiki/NetBIOS">NetBIOS</a> Name Service, used for name registration and <a href="https://en.wikipedia.org/wiki/Name_resolution_(computer_systems)">resolution</a>[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-rfc1001-68">68]</a>[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-rfc1002-69">69]</a></td></tr>
<tr><td>138</td><td>Assigned</td><td>Yes</td><td style="text-align: left">NetBIOS Datagram Service[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-apple-kb-HT202944-10">10]</a>[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-rfc1001-68">68]</a>[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-rfc1002-69">69]</a></td></tr>
<tr><td>139</td><td>Yes</td><td>Assigned</td><td style="text-align: left">NetBIOS Session Service[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-rfc1001-68">68]</a>[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-rfc1002-69">69]</a></td></tr>
<tr><td>143</td><td>Yes</td><td>Assigned</td><td style="text-align: left"><a href="https://en.wikipedia.org/wiki/Internet_Message_Access_Protocol">Internet Message Access Protocol</a> (IMAP),[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-apple-kb-HT202944-10">10]</a> management of <a href="https://en.wikipedia.org/wiki/Email">electronic mail</a> messages on a server[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-rfc3501-70">70]</a></td></tr>
<tr><td>152</td><td>Yes</td><td>Yes</td><td style="text-align: left"><a href="https://en.wikipedia.org/w/index.php?title=Background_File_Transfer_Program&amp;action=edit&amp;redlink=1">Background File Transfer Program</a> (BFTP)[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-rfc1068-71">71]</a>[<em><a href="https://en.wikipedia.org/wiki/Wikipedia:What_Wikipedia_is_not#Encyclopedic_content">importance?</a></em>]</td></tr>
<tr><td>153</td><td>Yes</td><td>Yes</td><td style="text-align: left"><a href="https://en.wikipedia.org/wiki/Simple_Gateway_Monitoring_Protocol">Simple Gateway Monitoring Protocol</a> (SGMP), a protocol for remote inspection and alteration of gateway management information[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-rfc1028-72">72]</a></td></tr>
<tr><td>156</td><td>Yes</td><td>Yes</td><td style="text-align: left">Structured Query Language (<a href="https://en.wikipedia.org/wiki/SQL">SQL</a>) Service[<em><a href="https://en.wikipedia.org/wiki/Wikipedia:Manual_of_Style#Technical_language">jargon</a></em>]</td></tr>
<tr><td>158</td><td>Yes</td><td>Yes</td><td style="text-align: left"><a href="https://en.wikipedia.org/w/index.php?title=Distributed_Mail_System_Protocol&amp;action=edit&amp;redlink=1">Distributed Mail System Protocol</a> (<strong>DMSP</strong>, sometimes referred to as <strong>Pcmail</strong>)[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-rfc1056-73">73]</a>[<em><a href="https://en.wikipedia.org/wiki/Wikipedia:What_Wikipedia_is_not#Encyclopedic_content">importance?</a></em>]</td></tr>
<tr><td>161</td><td>Assigned</td><td>Yes</td><td style="text-align: left"><a href="https://en.wikipedia.org/wiki/Simple_Network_Management_Protocol">Simple Network Management Protocol</a> (SNMP)[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-rfc1157-74">74]</a>[<em><a href="https://en.wikipedia.org/wiki/Wikipedia:Citation_needed">citation needed</a></em>][<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-apple-kb-HT202944-10">10]</a></td></tr>
<tr><td>162</td><td>Yes</td><td>Yes</td><td style="text-align: left"><a href="https://en.wikipedia.org/wiki/Simple_Network_Management_Protocol">Simple Network Management Protocol</a> Trap (SNMPTRAP)[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-rfc1157-74">74]</a>[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-cisco-support-7244-75">75]</a>[<em><a href="https://en.wikipedia.org/wiki/Wikipedia:Citation_needed">citation needed</a></em>]</td></tr>
<tr><td>170</td><td>Yes</td><td>Yes</td><td style="text-align: left">Network <a href="https://en.wikipedia.org/wiki/PostScript">PostScript</a> <a href="https://en.wikipedia.org/wiki/Print_server">print server</a></td></tr>
<tr><td>177</td><td>Yes</td><td>Yes</td><td style="text-align: left"><a href="https://en.wikipedia.org/wiki/X_Display_Manager_Control_Protocol">X Display Manager Control Protocol</a> (XDMCP), used for remote logins to an <a href="https://en.wikipedia.org/wiki/X_display_manager_(program_type)">X Display Manager</a> server[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-X11R7.6-doc-xdmcp-76">76]</a>[<em><a href="https://en.wikipedia.org/wiki/Wikipedia:Verifiability#Self-published_sources">self-published source</a></em>]</td></tr>
<tr><td>179</td><td>Yes</td><td>Assigned</td><td style="text-align: left"><a href="https://en.wikipedia.org/wiki/Border_Gateway_Protocol">Border Gateway Protocol</a> (BGP),[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-rfc4271-77">77]</a> used to exchange routing and reachability information among <a href="https://en.wikipedia.org/wiki/Autonomous_system_(Internet)">autonomous systems</a> (AS) on the <a href="https://en.wikipedia.org/wiki/Internet">Internet</a></td></tr>
<tr><td>194</td><td>Yes</td><td>Yes</td><td style="text-align: left"><a href="https://en.wikipedia.org/wiki/Internet_Relay_Chat">Internet Relay Chat</a> (IRC)[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-rfc7194-78">78]</a></td></tr>
<tr><td>199</td><td>Yes</td><td>Yes</td><td style="text-align: left"><a href="https://en.wikipedia.org/wiki/SNMP">SNMP</a> Unix Multiplexer (SMUX)[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-rfc1227-79">79]</a></td></tr>
<tr><td>201</td><td>Yes</td><td>Yes</td><td style="text-align: left"><a href="https://en.wikipedia.org/wiki/AppleTalk">AppleTalk</a> Routing Maintenance</td></tr>
<tr><td>209</td><td>Yes</td><td>Assigned</td><td style="text-align: left"><a href="https://en.wikipedia.org/wiki/Quick_Mail_Transfer_Protocol">Quick Mail Transfer Protocol</a>[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-qmtp.txt-80">80]</a>[<em><a href="https://en.wikipedia.org/wiki/Wikipedia:Verifiability#Self-published_sources">self-published source</a></em>]</td></tr>
<tr><td>210</td><td>Yes</td><td>Yes</td><td style="text-align: left"><a href="https://en.wikipedia.org/wiki/ANSI">ANSI</a> <a href="https://en.wikipedia.org/wiki/Z39.50">Z39.50</a></td></tr>
<tr><td>213</td><td>Yes</td><td>Yes</td><td style="text-align: left"><a href="https://en.wikipedia.org/wiki/Internetwork_Packet_Exchange">Internetwork Packet Exchange</a> (IPX)</td></tr>
<tr><td>218</td><td>Yes</td><td>Yes</td><td style="text-align: left">Message posting protocol (MPP)</td></tr>
<tr><td>220</td><td>Yes</td><td>Yes</td><td style="text-align: left"><a href="https://en.wikipedia.org/wiki/Internet_Message_Access_Protocol">Internet Message Access Protocol</a> (IMAP), version 3</td></tr>
<tr><td>225–241</td><td>Reserved</td><td>Reserved</td><td style="text-align: left"></td></tr>
<tr><td>249–255</td><td>Reserved</td><td>Reserved</td><td style="text-align: left"></td></tr>
<tr><td>259</td><td>Yes</td><td>Yes</td><td style="text-align: left">Efficient Short Remote Operations (ESRO)</td></tr>
<tr><td>262</td><td>Yes</td><td>Yes</td><td style="text-align: left">Arcisdms</td></tr>
<tr><td>264</td><td>Yes</td><td>Yes</td><td style="text-align: left"><a href="https://en.wikipedia.org/wiki/Border_Gateway_Multicast_Protocol">Border Gateway Multicast Protocol</a> (BGMP)</td></tr>
<tr><td>280</td><td>Yes</td><td>Yes</td><td style="text-align: left">http-mgmt</td></tr>
<tr><td>300</td><td>Yes</td><td></td><td style="text-align: left"><a href="https://en.wikipedia.org/wiki/ThinLinc">ThinLinc</a> Web Access</td></tr>
<tr><td>308</td><td>Yes</td><td></td><td style="text-align: left">Novastor Online Backup</td></tr>
<tr><td>311</td><td>Yes</td><td>Assigned</td><td style="text-align: left"><a href="https://en.wikipedia.org/wiki/Mac_OS_X_Server">Mac OS X Server</a> Admin[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-apple-kb-HT202944-10">10]</a> (officially <a href="https://en.wikipedia.org/wiki/AppleShare">AppleShare</a> IP Web administration[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-IANA-1">1]</a>)</td></tr>
<tr><td>318</td><td>Yes</td><td>Yes</td><td style="text-align: left">PKIX <a href="https://en.wikipedia.org/wiki/Time_Stamp_Protocol">Time Stamp Protocol</a> (TSP)</td></tr>
<tr><td>319</td><td></td><td>Yes</td><td style="text-align: left"><a href="https://en.wikipedia.org/wiki/Precision_Time_Protocol">Precision Time Protocol</a> (PTP) event messages</td></tr>
<tr><td>320</td><td></td><td>Yes</td><td style="text-align: left"><a href="https://en.wikipedia.org/wiki/Precision_Time_Protocol">Precision Time Protocol</a> (PTP) general messages</td></tr>
<tr><td>350</td><td>Yes</td><td>Yes</td><td style="text-align: left"><a href="https://en.wikipedia.org/wiki/Mapping_of_Airline_Traffic_over_Internet_Protocol">Mapping of Airline Traffic over Internet Protocol</a> (MATIP) type A</td></tr>
<tr><td>351</td><td>Yes</td><td>Yes</td><td style="text-align: left">MATIP type B</td></tr>
<tr><td>356</td><td>Yes</td><td>Yes</td><td style="text-align: left">cloanto-net-1 (used by Cloanto Amiga Explorer and VMs)</td></tr>
<tr><td>366</td><td>Yes</td><td>Yes</td><td style="text-align: left">On-Demand Mail Relay (ODMR)</td></tr>
<tr><td>369</td><td>Yes</td><td>Yes</td><td style="text-align: left">Rpc2portmap</td></tr>
<tr><td>370</td><td>Yes</td><td>Yes</td><td style="text-align: left">codaauth2, Coda authentication server</td></tr>
<tr><td></td><td>Yes</td><td>Official</td><td style="text-align: left"></td></tr>
<tr><td>371</td><td>Yes</td><td>Yes</td><td style="text-align: left">ClearCase albd</td></tr>
<tr><td>376</td><td>Yes</td><td>Yes</td><td style="text-align: left"><a href="https://en.wikipedia.org/wiki/Amiga">Amiga</a> Envoy <strong>N</strong>etwork <strong>I</strong>nquiry <strong>P</strong>rotocol</td></tr>
<tr><td>383</td><td>Yes</td><td>Yes</td><td style="text-align: left">HP data alarm manager</td></tr>
<tr><td>384</td><td>Yes</td><td>Yes</td><td style="text-align: left">A Remote Network Server System</td></tr>
<tr><td>387</td><td>Yes</td><td>Yes</td><td style="text-align: left">AURP (<a href="https://en.wikipedia.org/wiki/AppleTalk">AppleTalk</a> Update-based Routing Protocol)[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-82">82]</a></td></tr>
<tr><td>388</td><td>Yes</td><td>Assigned</td><td style="text-align: left"><a href="https://en.wikipedia.org/wiki/Local_Data_Manager">Unidata LDM</a> near real-time data distribution protocol[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-83">83]</a>[<em><a href="https://en.wikipedia.org/wiki/Wikipedia:Verifiability#Self-published_sources">self-published source</a></em>][<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-84">84]</a>[<em><a href="https://en.wikipedia.org/wiki/Wikipedia:Verifiability#Self-published_sources">self-published source</a></em>]</td></tr>
<tr><td>389</td><td>Yes</td><td>Assigned</td><td style="text-align: left"><a href="https://en.wikipedia.org/wiki/Lightweight_Directory_Access_Protocol">Lightweight Directory Access Protocol</a> (LDAP)[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-apple-kb-HT202944-10">10]</a></td></tr>
<tr><td>399</td><td>Yes</td><td>Yes</td><td style="text-align: left"><a href="https://en.wikipedia.org/wiki/Digital_Equipment_Corporation">Digital Equipment Corporation</a> <a href="https://en.wikipedia.org/w/index.php?title=DECnet%2B&amp;action=edit&amp;redlink=1">DECnet+</a> (Phase V) over TCP/IP (RFC1859)</td></tr>
<tr><td>401</td><td>Yes</td><td>Yes</td><td style="text-align: left"><a href="https://en.wikipedia.org/wiki/Uninterruptible_power_supply">Uninterruptible power supply</a> (UPS)</td></tr>
<tr><td>427</td><td>Yes</td><td>Yes</td><td style="text-align: left"><a href="https://en.wikipedia.org/wiki/Service_Location_Protocol">Service Location Protocol</a> (SLP)[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-apple-kb-HT202944-10">10]</a></td></tr>
<tr><td>433</td><td>Yes</td><td>Yes</td><td style="text-align: left">NNSP, part of <a href="https://en.wikipedia.org/wiki/Network_News_Transfer_Protocol">Network News Transfer Protocol</a></td></tr>
<tr><td>434</td><td>Yes</td><td>Yes</td><td style="text-align: left"><a href="https://en.wikipedia.org/wiki/Mobile_IP">Mobile IP</a> Agent (<a href="https://tools.ietf.org/html/rfc5944">RFC 5944</a>)</td></tr>
<tr><td>443</td><td>Yes</td><td>Yes</td><td style="text-align: left"><a href="https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol">Hypertext Transfer Protocol</a> (HTTP)[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-rfc7230-47">47]</a>[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-rfc7540-48">48]</a> uses TCP in versions 1.x and 2. <a href="https://en.wikipedia.org/wiki/HTTP/3">HTTP/3</a> uses QUIC,[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-quic-49">49]</a> a transport protocol on top of UDP.</td></tr>
<tr><td>444</td><td>Yes</td><td>Yes</td><td style="text-align: left"><a href="https://en.wikipedia.org/wiki/Simple_Network_Paging_Protocol">Simple Network Paging Protocol</a> (SNPP), <a href="https://tools.ietf.org/html/rfc1568">RFC 1568</a></td></tr>
<tr><td>445</td><td>Yes</td><td>Yes</td><td style="text-align: left">Microsoft-DS (Directory Services) <a href="https://en.wikipedia.org/wiki/Active_Directory">Active Directory</a>,[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-msft-tn-dd772723-85">85]</a> Windows shares</td></tr>
<tr><td>Yes</td><td>Assigned</td><td>Official</td><td style="text-align: left"></td></tr>
<tr><td>464</td><td>Yes</td><td>Yes</td><td style="text-align: left"><a href="https://en.wikipedia.org/wiki/Kerberos_(protocol)">Kerberos</a> Change/Set password</td></tr>
<tr><td>465</td><td>Yes</td><td>No</td><td style="text-align: left">URL Rendezvous Directory for SSM (Cisco protocol)[<em><a href="https://en.wikipedia.org/wiki/Wikipedia:What_Wikipedia_is_not#Encyclopedic_content">importance?</a></em>]</td></tr>
<tr><td>Yes</td><td>No</td><td>Official</td><td style="text-align: left"></td></tr>
<tr><td>475</td><td>Yes</td><td>Yes</td><td style="text-align: left">tcpnethaspsrv, <a href="https://en.wikipedia.org/wiki/Aladdin_Knowledge_Systems">Aladdin Knowledge Systems</a> Hasp services</td></tr>
<tr><td>491</td><td>Yes</td><td></td><td style="text-align: left"><a href="https://en.wikipedia.org/wiki/GO-Global">GO-Global remote access and application publishing software</a></td></tr>
<tr><td>497</td><td>Yes</td><td>Yes</td><td style="text-align: left"><a href="https://en.wikipedia.org/wiki/Retrospect_(software)">Retrospect</a></td></tr>
<tr><td>500</td><td>Assigned</td><td>Yes</td><td style="text-align: left"><a href="https://en.wikipedia.org/wiki/Internet_Security_Association_and_Key_Management_Protocol">Internet Security Association and Key Management Protocol</a> (ISAKMP) / <a href="https://en.wikipedia.org/wiki/Internet_Key_Exchange">Internet Key Exchange</a> (IKE)[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-apple-kb-HT202944-10">10]</a></td></tr>
<tr><td>502</td><td>Yes</td><td>Yes</td><td style="text-align: left"><a href="https://en.wikipedia.org/wiki/Modbus">Modbus</a> Protocol</td></tr>
<tr><td>504</td><td>Yes</td><td>Yes</td><td style="text-align: left"><a href="https://en.wikipedia.org/wiki/Citadel/UX">Citadel</a>, multiservice protocol for dedicated clients for the Citadel groupware system</td></tr>
<tr><td>510</td><td>Yes</td><td>Yes</td><td style="text-align: left">FirstClass Protocol (FCP), used by <a href="https://en.wikipedia.org/wiki/FirstClass">FirstClass</a> client/server groupware system</td></tr>
<tr><td>512</td><td>Yes</td><td></td><td style="text-align: left"><a href="https://en.wikipedia.org/wiki/Remote_Process_Execution">Rexec</a>, Remote Process Execution</td></tr>
<tr><td></td><td>Yes</td><td>Official</td><td style="text-align: left"></td></tr>
<tr><td>513</td><td>Yes</td><td></td><td style="text-align: left"><a href="https://en.wikipedia.org/wiki/Rlogin">rlogin</a></td></tr>
<tr><td></td><td>Yes</td><td>Official</td><td style="text-align: left"></td></tr>
<tr><td>514</td><td>Yes</td><td></td><td style="text-align: left"><a href="https://en.wikipedia.org/wiki/Remote_Shell">Remote Shell</a>, used to execute non-interactive commands on a remote system (Remote Shell, rsh, remsh)</td></tr>
<tr><td>No</td><td>Yes</td><td>Official</td><td style="text-align: left"></td></tr>
<tr><td>515</td><td>Yes</td><td>Assigned</td><td style="text-align: left"><a href="https://en.wikipedia.org/wiki/Line_Printer_Daemon_protocol">Line Printer Daemon</a> (LPD),[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-apple-kb-HT202944-10">10]</a> print service</td></tr>
<tr><td>517</td><td></td><td>Yes</td><td style="text-align: left">Talk</td></tr>
<tr><td>518</td><td></td><td>Yes</td><td style="text-align: left">NTalk</td></tr>
<tr><td>520</td><td>Yes</td><td></td><td style="text-align: left">efs, extended file name server</td></tr>
<tr><td></td><td>Yes</td><td>Official</td><td style="text-align: left"></td></tr>
<tr><td>521</td><td></td><td>Yes</td><td style="text-align: left"><a href="https://en.wikipedia.org/wiki/RIPng">Routing Information Protocol Next Generation</a> (RIPng)</td></tr>
<tr><td>524</td><td>Yes</td><td>Yes</td><td style="text-align: left"><a href="https://en.wikipedia.org/wiki/NetWare_Core_Protocol">NetWare Core Protocol</a> (NCP) is used for a variety things such as access to primary NetWare server resources, Time Synchronization, etc.</td></tr>
<tr><td>525</td><td></td><td>Yes</td><td style="text-align: left">Timed, <a href="https://en.wikipedia.org/wiki/Timeserver">Timeserver</a></td></tr>
<tr><td>530</td><td>Yes</td><td>Yes</td><td style="text-align: left"><a href="https://en.wikipedia.org/wiki/Remote_procedure_call">Remote procedure call</a> (RPC)</td></tr>
<tr><td>532</td><td>Yes</td><td>Assigned</td><td style="text-align: left">netnews[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-apple-kb-HT202944-10">10]</a></td></tr>
<tr><td>533</td><td></td><td>Yes</td><td style="text-align: left">netwall, For Emergency Broadcasts</td></tr>
<tr><td>540</td><td>Yes</td><td></td><td style="text-align: left">Unix-to-Unix Copy Protocol (<a href="https://en.wikipedia.org/wiki/UUCP">UUCP</a>)</td></tr>
<tr><td>542</td><td>Yes</td><td>Yes</td><td style="text-align: left"><a href="https://en.wikipedia.org/wiki/Commerce">commerce</a> (Commerce Applications)</td></tr>
<tr><td>543</td><td>Yes</td><td></td><td style="text-align: left">klogin, <a href="https://en.wikipedia.org/wiki/Kerberos_(protocol)">Kerberos</a> login</td></tr>
<tr><td>544</td><td>Yes</td><td></td><td style="text-align: left">kshell, <a href="https://en.wikipedia.org/wiki/Kerberos_(protocol)">Kerberos</a> Remote shell</td></tr>
<tr><td>546</td><td>Yes</td><td>Yes</td><td style="text-align: left"><a href="https://en.wikipedia.org/wiki/DHCPv6">DHCPv6</a> client</td></tr>
<tr><td>547</td><td>Yes</td><td>Yes</td><td style="text-align: left"><a href="https://en.wikipedia.org/wiki/DHCPv6">DHCPv6</a> server</td></tr>
<tr><td>548</td><td>Yes</td><td>Assigned</td><td style="text-align: left"><a href="https://en.wikipedia.org/wiki/Apple_Filing_Protocol">Apple Filing Protocol</a> (AFP) over <a href="https://en.wikipedia.org/wiki/Transmission_Control_Protocol">TCP</a>[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-apple-kb-HT202944-10">10]</a></td></tr>
<tr><td>550</td><td>Yes</td><td>Yes</td><td style="text-align: left">new-rwho, new-who[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-rfc1340-87">87]</a></td></tr>
<tr><td>554</td><td>Yes</td><td>Yes</td><td style="text-align: left"><a href="https://en.wikipedia.org/wiki/Real_Time_Streaming_Protocol">Real Time Streaming Protocol</a> (RTSP)[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-apple-kb-HT202944-10">10]</a></td></tr>
<tr><td>556</td><td>Yes</td><td></td><td style="text-align: left">Remotefs, <a href="https://en.wikipedia.org/wiki/Remote_File_System">RFS</a>, rfs_server</td></tr>
<tr><td>560</td><td></td><td>Yes</td><td style="text-align: left">rmonitor, Remote Monitor</td></tr>
<tr><td>561</td><td></td><td>Yes</td><td style="text-align: left">monitor</td></tr>
<tr><td>563</td><td>Yes</td><td>Yes</td><td style="text-align: left"><a href="https://en.wikipedia.org/wiki/NNTP">NNTP</a> over <a href="https://en.wikipedia.org/wiki/Transport_Layer_Security">TLS/SSL</a> (NNTPS)</td></tr>
<tr><td>564</td><td>Yes</td><td></td><td style="text-align: left"><a href="https://en.wikipedia.org/wiki/9P_(protocol)">9P</a> (<a href="https://en.wikipedia.org/wiki/Plan_9_from_Bell_Labs">Plan 9</a>)</td></tr>
<tr><td>585</td><td>Port 993</td><td>?</td><td style="text-align: left">Legacy use of <a href="https://en.wikipedia.org/wiki/Internet_Message_Access_Protocol">Internet Message Access Protocol</a> over <a href="https://en.wikipedia.org/wiki/Transport_Layer_Security">TLS/SSL</a> (IMAPS), now in use at port 993.[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-oreilly-fire-2ndEd-88">88]</a></td></tr>
<tr><td>587</td><td>Yes</td><td>Assigned</td><td style="text-align: left"><a href="https://en.wikipedia.org/wiki/Mail_submission_agent">email message submission</a>[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-apple-kb-HT202944-10">10]</a>[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-89">89]</a> (<a href="https://en.wikipedia.org/wiki/Simple_Mail_Transfer_Protocol">SMTP</a>)</td></tr>
<tr><td>591</td><td>Yes</td><td></td><td style="text-align: left"><a href="https://en.wikipedia.org/wiki/FileMaker">FileMaker</a> 6.0 (and later) Web Sharing (HTTP Alternate, also see port 80)</td></tr>
<tr><td>593</td><td>Yes</td><td>Yes</td><td style="text-align: left">HTTP RPC Ep Map, <a href="https://en.wikipedia.org/wiki/Remote_procedure_call">Remote procedure call</a> over <a href="https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol">Hypertext Transfer Protocol</a>, often used by <a href="https://en.wikipedia.org/wiki/Distributed_Component_Object_Model">Distributed Component Object Model</a> services and <a href="https://en.wikipedia.org/wiki/Microsoft_Exchange_Server">Microsoft Exchange Server</a></td></tr>
<tr><td>601</td><td>Yes</td><td></td><td style="text-align: left">Reliable <a href="https://en.wikipedia.org/wiki/Syslog">Syslog</a> Service — used for system logging</td></tr>
<tr><td>604</td><td>Yes</td><td></td><td style="text-align: left">TUNNEL profile,[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-90">90]</a> a protocol for <a href="https://en.wikipedia.org/wiki/BEEP">BEEP</a> <a href="https://en.wikipedia.org/wiki/Peer-to-peer">peers</a> to form an <a href="https://en.wikipedia.org/wiki/Application_layer">application layer</a> <a href="https://en.wikipedia.org/wiki/Tunneling_protocol">tunnel</a></td></tr>
<tr><td>623</td><td></td><td>Yes</td><td style="text-align: left">ASF Remote Management and Control Protocol (ASF-RMCP) &amp; IPMI Remote Management Protocol</td></tr>
<tr><td>625</td><td>Yes</td><td>No</td><td style="text-align: left">Open Directory Proxy (ODProxy)[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-apple-kb-HT202944-10">10]</a></td></tr>
<tr><td>631</td><td>Yes</td><td>Yes</td><td style="text-align: left"><a href="https://en.wikipedia.org/wiki/Internet_Printing_Protocol">Internet Printing Protocol</a> (IPP)[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-apple-kb-HT202944-10">10]</a></td></tr>
<tr><td>Yes</td><td>Yes</td><td>Unofficial</td><td style="text-align: left"></td></tr>
<tr><td>635</td><td>Yes</td><td>Yes</td><td style="text-align: left">RLZ DBase</td></tr>
<tr><td>636</td><td>Yes</td><td>Assigned</td><td style="text-align: left"><a href="https://en.wikipedia.org/wiki/Lightweight_Directory_Access_Protocol">Lightweight Directory Access Protocol</a> over <a href="https://en.wikipedia.org/wiki/Transport_Layer_Security">TLS/SSL</a> (LDAPS)[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-apple-kb-HT202944-10">10]</a></td></tr>
<tr><td>639</td><td>Yes</td><td>Yes</td><td style="text-align: left">MSDP, <a href="https://en.wikipedia.org/wiki/Multicast_Source_Discovery_Protocol">Multicast Source Discovery Protocol</a></td></tr>
<tr><td>641</td><td>Yes</td><td>Yes</td><td style="text-align: left">SupportSoft Nexus Remote Command (control/listening), a proxy gateway connecting remote control traffic</td></tr>
<tr><td>643</td><td>Yes</td><td>Yes</td><td style="text-align: left">SANity</td></tr>
<tr><td>646</td><td>Yes</td><td>Yes</td><td style="text-align: left"><a href="https://en.wikipedia.org/wiki/Label_Distribution_Protocol">Label Distribution Protocol</a> (LDP), a routing protocol used in <a href="https://en.wikipedia.org/wiki/Multiprotocol_Label_Switching">MPLS</a> networks</td></tr>
<tr><td>647</td><td>Yes</td><td></td><td style="text-align: left"><a href="https://en.wikipedia.org/wiki/Dynamic_Host_Configuration_Protocol#Reliability">DHCP Failover</a> protocol[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-91">91]</a></td></tr>
<tr><td>648</td><td>Yes</td><td></td><td style="text-align: left">Registry Registrar Protocol (RRP)[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-92">92]</a></td></tr>
<tr><td>651</td><td>Yes</td><td>Yes</td><td style="text-align: left">IEEE-MMS</td></tr>
<tr><td>653</td><td>Yes</td><td>Yes</td><td style="text-align: left">SupportSoft Nexus Remote Command (data), a proxy gateway connecting remote control traffic</td></tr>
<tr><td>654</td><td>Yes</td><td></td><td style="text-align: left">Media Management System (MMS) Media Management Protocol (MMP)[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-93">93]</a></td></tr>
<tr><td>655</td><td>Yes</td><td>Yes</td><td style="text-align: left"><a href="https://en.wikipedia.org/wiki/Tinc_(protocol)">Tinc</a> VPN daemon</td></tr>
<tr><td>657</td><td>Yes</td><td>Yes</td><td style="text-align: left"><a href="https://en.wikipedia.org/wiki/IBM">IBM</a> RMC (Remote monitoring and Control) protocol, used by <a href="https://en.wikipedia.org/wiki/IBM_System_p">System p5</a> <a href="https://en.wikipedia.org/wiki/IBM_AIX">AIX</a> Integrated Virtualization Manager (IVM)[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-94">94]</a> and <a href="https://en.wikipedia.org/wiki/IBM_Hardware_Management_Console">Hardware Management Console</a> to connect managed <a href="https://en.wikipedia.org/wiki/LPAR">logical partitions (LPAR)</a> to enable dynamic partition reconfiguration</td></tr>
<tr><td>660</td><td>Yes</td><td>Assigned</td><td style="text-align: left"><a href="https://en.wikipedia.org/wiki/Mac_OS_X_Server">Mac OS X Server</a> administration,[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-IANA-1">1]</a> version 10.4 and earlier[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-apple-kb-HT202944-10">10]</a></td></tr>
<tr><td><a href="https://en.wikipedia.org/wiki/Number_of_the_Beast">666</a></td><td>Yes</td><td>Yes</td><td style="text-align: left"><a href="https://en.wikipedia.org/wiki/Doom_(game)">Doom</a>, first online <a href="https://en.wikipedia.org/wiki/First-person_shooter">first-person shooter</a></td></tr>
<tr><td>Yes</td><td></td><td>Unofficial</td><td style="text-align: left"></td></tr>
<tr><td>674</td><td>Yes</td><td></td><td style="text-align: left"><a href="https://en.wikipedia.org/wiki/Application_Configuration_Access_Protocol">Application Configuration Access Protocol</a> (ACAP)</td></tr>
<tr><td>688</td><td>Yes</td><td>Yes</td><td style="text-align: left">REALM-RUSD (ApplianceWare Server Appliance Management Protocol)</td></tr>
<tr><td>690</td><td>Yes</td><td>Yes</td><td style="text-align: left">Velneo Application Transfer Protocol (VATP)</td></tr>
<tr><td>691</td><td>Yes</td><td></td><td style="text-align: left"><a href="https://en.wikipedia.org/wiki/Microsoft">MS</a> <a href="https://en.wikipedia.org/wiki/Microsoft_Exchange_Server">Exchange</a> Routing</td></tr>
<tr><td>694</td><td>Yes</td><td>Yes</td><td style="text-align: left"><a href="https://en.wikipedia.org/wiki/Linux-HA">Linux-HA</a> high-availability heartbeat</td></tr>
<tr><td>695</td><td>Yes</td><td></td><td style="text-align: left"><a href="https://en.wikipedia.org/wiki/IEEE">IEEE</a> Media Management System over <a href="https://en.wikipedia.org/wiki/Transport_Layer_Security">SSL</a> (IEEE-MMS-SSL)[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-95">95]</a></td></tr>
<tr><td>698</td><td></td><td>Yes</td><td style="text-align: left"><a href="https://en.wikipedia.org/wiki/Optimized_Link_State_Routing_protocol">Optimized Link State Routing</a> (OLSR)</td></tr>
<tr><td>700</td><td>Yes</td><td></td><td style="text-align: left"><a href="https://en.wikipedia.org/wiki/Extensible_Provisioning_Protocol">Extensible Provisioning Protocol</a> (EPP), a protocol for communication between <a href="https://en.wikipedia.org/wiki/Domain_name_registry">domain name registries</a> and <a href="https://en.wikipedia.org/wiki/Domain_name_registrar">registrars</a> (<a href="https://tools.ietf.org/html/rfc5734">RFC 5734</a>)</td></tr>
<tr><td>701</td><td>Yes</td><td></td><td style="text-align: left">Link Management Protocol (LMP),[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-96">96]</a> a protocol that runs between a pair of <a href="https://en.wikipedia.org/wiki/Node_(networking)">nodes</a> and is used to manage <a href="https://en.wikipedia.org/wiki/Teletraffic_engineering">traffic engineering</a> (TE) <a href="https://en.wikipedia.org/wiki/Telecommunications_link">links</a></td></tr>
<tr><td>702</td><td>Yes</td><td></td><td style="text-align: left">IRIS[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-97">97]</a>[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-98">98]</a> (Internet Registry Information Service) over <a href="https://en.wikipedia.org/wiki/BEEP">BEEP</a> (Blocks Extensible Exchange Protocol)[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-99">99]</a> (<a href="https://tools.ietf.org/html/rfc3983">RFC 3983</a>)</td></tr>
<tr><td>706</td><td>Yes</td><td></td><td style="text-align: left"><a href="https://en.wikipedia.org/wiki/SILC_(protocol)">Secure Internet Live Conferencing</a> (SILC)</td></tr>
<tr><td>711</td><td>Yes</td><td></td><td style="text-align: left"><a href="https://en.wikipedia.org/wiki/Cisco">Cisco</a> Tag Distribution Protocol[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-100">100]</a>[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-101">101]</a>[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-102">102]</a>—being replaced by the MPLS <a href="https://en.wikipedia.org/wiki/Label_Distribution_Protocol">Label Distribution Protocol</a>[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-103">103]</a></td></tr>
<tr><td>712</td><td>Yes</td><td></td><td style="text-align: left"><a href="https://en.wikipedia.org/wiki/Topology_Broadcast_based_on_Reverse-Path_Forwarding_routing_protocol">Topology Broadcast based on Reverse-Path Forwarding routing protocol</a> (TBRPF; <a href="https://tools.ietf.org/html/rfc3684">RFC 3684</a>)</td></tr>
<tr><td>749</td><td>Yes</td><td>Yes</td><td style="text-align: left"><a href="https://en.wikipedia.org/wiki/Kerberos_(protocol)">Kerberos (protocol)</a> administration[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-apple-kb-HT202944-10">10]</a></td></tr>
<tr><td>750</td><td></td><td>Yes</td><td style="text-align: left">kerberos-iv, <a href="https://en.wikipedia.org/wiki/Kerberos_(protocol)">Kerberos</a> version IV</td></tr>
<tr><td>751</td><td>Yes</td><td>Yes</td><td style="text-align: left">kerberos_master, <a href="https://en.wikipedia.org/wiki/Kerberos_(protocol)">Kerberos</a> authentication</td></tr>
<tr><td>752</td><td></td><td>Yes</td><td style="text-align: left">passwd_server, <a href="https://en.wikipedia.org/wiki/Kerberos_(protocol)">Kerberos</a> password (kpasswd) server</td></tr>
<tr><td>753</td><td>Yes</td><td>Yes</td><td style="text-align: left">Reverse Routing Header (RRH)[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-104">104]</a></td></tr>
<tr><td></td><td>Yes</td><td>Unofficial</td><td style="text-align: left"></td></tr>
<tr><td>754</td><td>Yes</td><td>Yes</td><td style="text-align: left">tell send</td></tr>
<tr><td>Yes</td><td></td><td>Unofficial</td><td style="text-align: left"></td></tr>
<tr><td>760</td><td>Yes</td><td>Yes</td><td style="text-align: left">krbupdate [kreg], <a href="https://en.wikipedia.org/wiki/Kerberos_(protocol)">Kerberos</a> registration</td></tr>
<tr><td>782</td><td>Yes</td><td></td><td style="text-align: left"><a href="https://en.wikipedia.org/wiki/Conserver">Conserver</a> serial-console management server</td></tr>
<tr><td>783</td><td>Yes</td><td></td><td style="text-align: left"><a href="https://en.wikipedia.org/wiki/SpamAssassin">SpamAssassin</a> spamd daemon</td></tr>
<tr><td>800</td><td>Yes</td><td>Yes</td><td style="text-align: left">mdbs-daemon</td></tr>
<tr><td>802</td><td>Yes</td><td>Yes</td><td style="text-align: left"><a href="https://en.wikipedia.org/wiki/Modbus">MODBUS</a>/TCP Security[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-mbap-s-105">105]</a></td></tr>
<tr><td>808</td><td>Yes</td><td></td><td style="text-align: left">Microsoft Net.TCP Port Sharing Service</td></tr>
<tr><td>829</td><td>Yes</td><td>Assigned</td><td style="text-align: left"><a href="https://en.wikipedia.org/wiki/Certificate_Management_Protocol">Certificate Management Protocol</a>[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-rfc4210-106">106]</a></td></tr>
<tr><td>830</td><td>Yes</td><td>Yes</td><td style="text-align: left"><a href="https://en.wikipedia.org/wiki/NETCONF">NETCONF</a> over <a href="https://en.wikipedia.org/wiki/Secure_Shell">SSH</a></td></tr>
<tr><td>831</td><td>Yes</td><td>Yes</td><td style="text-align: left">NETCONF over <a href="https://en.wikipedia.org/wiki/BEEP">BEEP</a></td></tr>
<tr><td>832</td><td>Yes</td><td>Yes</td><td style="text-align: left">NETCONF for <a href="https://en.wikipedia.org/wiki/SOAP">SOAP</a> over <a href="https://en.wikipedia.org/wiki/HTTPS">HTTPS</a></td></tr>
<tr><td>833</td><td>Yes</td><td>Yes</td><td style="text-align: left">NETCONF for SOAP over <a href="https://en.wikipedia.org/wiki/BEEP">BEEP</a></td></tr>
<tr><td>843</td><td>Yes</td><td></td><td style="text-align: left"><a href="https://en.wikipedia.org/wiki/Adobe_Flash">Adobe Flash</a>[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-107">107]</a></td></tr>
<tr><td>847</td><td>Yes</td><td></td><td style="text-align: left"><a href="https://en.wikipedia.org/wiki/Dynamic_Host_Configuration_Protocol#Reliability">DHCP Failover</a> protocol</td></tr>
<tr><td>848</td><td>Yes</td><td>Yes</td><td style="text-align: left">Group Domain Of Interpretation (GDOI) protocol</td></tr>
<tr><td>853</td><td>Yes</td><td>Yes</td><td style="text-align: left"><a href="https://en.wikipedia.org/wiki/Domain_Name_System">DNS</a> over <a href="https://en.wikipedia.org/wiki/Transport_Layer_Security">TLS</a> (<a href="https://tools.ietf.org/html/rfc7858">RFC 7858</a>)</td></tr>
<tr><td>860</td><td>Yes</td><td></td><td style="text-align: left"><a href="https://en.wikipedia.org/wiki/ISCSI">iSCSI</a> (<a href="https://tools.ietf.org/html/rfc3720">RFC 3720</a>)</td></tr>
<tr><td>861</td><td>Yes</td><td>Yes</td><td style="text-align: left">OWAMP control (<a href="https://tools.ietf.org/html/rfc4656">RFC 4656</a>)</td></tr>
<tr><td>862</td><td>Yes</td><td>Yes</td><td style="text-align: left">TWAMP control (<a href="https://tools.ietf.org/html/rfc5357">RFC 5357</a>)</td></tr>
<tr><td>873</td><td>Yes</td><td></td><td style="text-align: left"><a href="https://en.wikipedia.org/wiki/Rsync">rsync</a> file synchronization protocol</td></tr>
<tr><td>888</td><td>Yes</td><td></td><td style="text-align: left">cddbp, <a href="https://en.wikipedia.org/wiki/CD_database">CD DataBase</a> (<a href="https://en.wikipedia.org/wiki/CDDB">CDDB</a>) protocol (CDDBP)</td></tr>
<tr><td>Yes</td><td></td><td>Unofficial</td><td style="text-align: left"></td></tr>
<tr><td>897</td><td>Yes</td><td>Yes</td><td style="text-align: left"><a href="https://en.wikipedia.org/wiki/Brocade_Communications_Systems">Brocade</a> SMI-S RPC</td></tr>
<tr><td>898</td><td>Yes</td><td>Yes</td><td style="text-align: left">Brocade SMI-S RPC SSL</td></tr>
<tr><td>902</td><td>Yes</td><td>Yes</td><td style="text-align: left"><a href="https://en.wikipedia.org/wiki/VMware_ESXi">VMware ESXi</a>[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-vmware-kb-1022256-108">108]</a>[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-vmware-kb-1005189-109">109]</a></td></tr>
<tr><td>903</td><td>Yes</td><td></td><td style="text-align: left">VMware ESXi[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-vmware-kb-1022256-108">108]</a>[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-vmware-kb-1005189-109">109]</a></td></tr>
<tr><td>953</td><td>Yes</td><td>Reserved</td><td style="text-align: left"><a href="https://en.wikipedia.org/wiki/BIND">BIND</a> remote name daemon control (RNDC)[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-centos-5-deployment-rndc-110">110]</a>[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-man-rndc.8-111">111]</a></td></tr>
<tr><td>981</td><td>Yes</td><td></td><td style="text-align: left">Remote HTTPS management for firewall devices running embedded <a href="https://en.wikipedia.org/wiki/Check_Point_VPN-1">Check Point VPN-1</a> software[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-fw-1-ports-ng-112">112]</a></td></tr>
<tr><td>987</td><td>Yes</td><td></td><td style="text-align: left"><a href="https://en.wikipedia.org/wiki/Microsoft_Remote_Web_Workplace">Microsoft Remote Web Workplace</a>, a feature of <a href="https://en.wikipedia.org/wiki/Windows_Small_Business_Server">Windows Small Business Server</a>[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-msft-tn-cc52751-113">113]</a></td></tr>
<tr><td>989</td><td>Yes</td><td>Yes</td><td style="text-align: left"><a href="https://en.wikipedia.org/wiki/FTPS">FTPS</a> Protocol (data), <a href="https://en.wikipedia.org/wiki/FTP">FTP</a> over <a href="https://en.wikipedia.org/wiki/Transport_Layer_Security">TLS/SSL</a></td></tr>
<tr><td>990</td><td>Yes</td><td>Yes</td><td style="text-align: left"><a href="https://en.wikipedia.org/wiki/FTPS">FTPS</a> Protocol (control), <a href="https://en.wikipedia.org/wiki/FTP">FTP</a> over <a href="https://en.wikipedia.org/wiki/Transport_Layer_Security">TLS/SSL</a></td></tr>
<tr><td>991</td><td>Yes</td><td>Yes</td><td style="text-align: left"><a href="https://en.wikipedia.org/wiki/Netnews">Netnews</a> Administration System (NAS)[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-114">114]</a></td></tr>
<tr><td>992</td><td>Yes</td><td>Yes</td><td style="text-align: left"><a href="https://en.wikipedia.org/wiki/Telnet">Telnet</a> protocol over <a href="https://en.wikipedia.org/wiki/Transport_Layer_Security">TLS/SSL</a></td></tr>
<tr><td>993</td><td>Yes</td><td>Assigned</td><td style="text-align: left"><a href="https://en.wikipedia.org/wiki/Internet_Message_Access_Protocol">Internet Message Access Protocol</a> over <a href="https://en.wikipedia.org/wiki/Transport_Layer_Security">TLS/SSL</a> (IMAPS)[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-apple-kb-HT202944-10">10]</a></td></tr>
<tr><td>994</td><td>Reserved</td><td>Reserved</td><td style="text-align: left"></td></tr>
<tr><td>Maybe</td><td>Maybe</td><td>Unofficial</td><td style="text-align: left"></td></tr>
<tr><td>995</td><td>Yes</td><td>Yes</td><td style="text-align: left"><a href="https://en.wikipedia.org/wiki/Post_Office_Protocol">Post Office Protocol</a> 3 over <a href="https://en.wikipedia.org/wiki/Transport_Layer_Security">TLS/SSL</a> (POP3S)[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-apple-kb-HT202944-10">10]</a></td></tr>
<tr><td>1010</td><td>Yes</td><td></td><td style="text-align: left"><a href="https://en.wikipedia.org/wiki/ThinLinc">ThinLinc</a> web-based administration interface[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-cendio-docs-tag-tcp-ports-115">115]</a>[<em><a href="https://en.wikipedia.org/wiki/Wikipedia:Verifiability#Self-published_sources">self-published source?</a></em>]</td></tr>
<tr><td>1011–1020</td><td>Reserved</td><td>Reserved</td><td style="text-align: left"></td></tr>
<tr><td>1023</td><td>Reserved</td><td>Reserved</td><td style="text-align: left">[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-IANA-1">1]</a></td></tr>
<tr><td>Yes</td><td>Yes</td><td>Unofficial</td><td style="text-align: left"></td></tr>
</tbody></table>
</div>
<h2 id="registered-ports"><a class="header" href="#registered-ports">Registered ports</a></h2>
<div class="table-wrapper"><table><thead><tr><th>1024</th><th>Reserved</th><th>Reserved</th><th>Reserved</th><th>Official</th></tr></thead><tbody>
<tr><td>1027</td><td>Reserved</td><td></td><td>Reserved</td><td>Official</td></tr>
<tr><td></td><td>Yes</td><td>Native IPv6 behind IPv4-to-IPv4 NAT Customer Premises Equipment (6a44)[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-rfc6751-117">117]</a></td><td>Official</td><td></td></tr>
<tr><td>1028</td><td></td><td></td><td>Deprecated</td><td>Official</td></tr>
<tr><td>1029</td><td></td><td></td><td>Microsoft <a href="https://en.wikipedia.org/wiki/Distributed_Component_Object_Model">DCOM</a> services</td><td>Unofficial</td></tr>
<tr><td>1058</td><td>Yes</td><td>Yes</td><td>nim, <a href="https://en.wikipedia.org/wiki/IBM">IBM</a> <a href="https://en.wikipedia.org/wiki/IBM_AIX">AIX</a> <a href="https://en.wikipedia.org/wiki/Network_Installation_Manager">Network Installation Manager</a> (NIM)</td><td>Official</td></tr>
<tr><td>1059</td><td>Yes</td><td>Yes</td><td>nimreg, IBM AIX Network Installation Manager (NIM)</td><td>Official</td></tr>
<tr><td>1080</td><td>Yes</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/SOCKS">SOCKS</a> proxy</td><td>Official</td></tr>
<tr><td>1085</td><td>Yes</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/WebObjects">WebObjects</a>[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-apple-kb-HT202944-10">10]</a></td><td>Official</td></tr>
<tr><td>1098</td><td>Yes</td><td>Yes</td><td>rmiactivation, <a href="https://en.wikipedia.org/wiki/Java_remote_method_invocation">Java remote method invocation</a> (RMI) activation</td><td>Official</td></tr>
<tr><td>1099</td><td>Yes</td><td>Assigned</td><td>rmiregistry, Java remote method invocation (RMI) registry</td><td>Official</td></tr>
<tr><td>1109</td><td></td><td></td><td>Reserved – IANA</td><td>Official</td></tr>
<tr><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/Kerberos_(protocol)">Kerberos</a> Post Office Protocol (<a href="https://en.wikipedia.org/wiki/Kerberized_Post_Office_Protocol">KPOP</a>)[<em><a href="https://en.wikipedia.org/wiki/Wikipedia:Citation_needed">citation needed</a></em>]</td><td>Unofficial</td><td></td></tr>
<tr><td>1113</td><td>Assigned[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-118">note 1]</a>[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-119">118]</a></td><td>Yes[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-120">119]</a></td><td><a href="https://en.wikipedia.org/wiki/Licklider_Transmission_Protocol">Licklider Transmission Protocol</a> (LTP) delay tolerant networking protocol</td><td>Official</td></tr>
<tr><td>1119</td><td>Yes</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/Battle.net">Battle.net</a> chat/game protocol, used by <a href="https://en.wikipedia.org/wiki/Blizzard_Entertainment">Blizzard</a>'s games[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-blizzard-121">120]</a></td><td>Official</td></tr>
<tr><td>1167</td><td>Yes, and SCTP</td><td>Yes</td><td>Cisco <a href="https://en.wikipedia.org/wiki/IP_SLA">IP SLA</a> (Service Assurance Agent)</td><td>Official</td></tr>
<tr><td>1194</td><td>Yes</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/OpenVPN#Networking">OpenVPN</a></td><td>Official</td></tr>
<tr><td>1198</td><td>Yes</td><td>Yes</td><td>The <a href="https://en.wikipedia.org/wiki/Cajo_project">cajo project</a> Free dynamic transparent distributed computing in Java</td><td>Official</td></tr>
<tr><td>1214</td><td>Yes</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/Kazaa">Kazaa</a></td><td>Official</td></tr>
<tr><td>1218</td><td>Yes</td><td>No</td><td>William POWER</td><td>Official</td></tr>
<tr><td>1220</td><td>Yes</td><td>Assigned</td><td><a href="https://en.wikipedia.org/wiki/QuickTime_Streaming_Server">QuickTime Streaming Server</a> administration[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-apple-kb-HT202944-10">10]</a></td><td>Official</td></tr>
<tr><td>1234</td><td>Yes</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/Infoseek">Infoseek</a> search agent</td><td>Official</td></tr>
<tr><td></td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/VLC_media_player">VLC media player</a> default port for UDP/RTP stream</td><td>Unofficial</td><td></td></tr>
<tr><td>1241</td><td>Yes</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/Nessus_(software)">Nessus</a> Security Scanner</td><td>Official</td></tr>
<tr><td>1270</td><td>Yes</td><td>Yes</td><td>Microsoft <a href="https://en.wikipedia.org/wiki/System_Center_Operations_Manager">System Center Operations Manager</a> (SCOM) (formerly Microsoft Operations Manager (MOM)) agent</td><td>Official</td></tr>
<tr><td>1293</td><td>Yes</td><td>Yes</td><td>Internet Protocol Security (<a href="https://en.wikipedia.org/wiki/IPSec">IPSec</a>)</td><td>Official</td></tr>
<tr><td>1311</td><td>Yes</td><td>Yes</td><td>Windows <code>RxMon.exe</code></td><td>Official</td></tr>
<tr><td>Yes</td><td></td><td>Dell <a href="https://en.wikipedia.org/wiki/OpenManage">OpenManage</a> HTTPS[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-dell-opnmang-srvr-admin-122">121]</a></td><td>Unofficial</td><td></td></tr>
<tr><td>1314</td><td>?</td><td>?</td><td><a href="https://en.wikipedia.org/wiki/Festival_Speech_Synthesis_System">Festival Speech Synthesis System</a> server[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-festival_7-123">122]</a>[<em><a href="https://en.wikipedia.org/wiki/Wikipedia:Verifiability#Self-published_sources">self-published source?</a></em>]</td><td>Unofficial</td></tr>
<tr><td><a href="https://en.wikipedia.org/wiki/Leet">1337</a></td><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/Neo4j">neo4j-shell</a>[<em><a href="https://en.wikipedia.org/wiki/Wikipedia:Citation_needed">citation needed</a></em>]</td><td>Unofficial</td></tr>
<tr><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/w/index.php?title=Strapi&amp;action=edit&amp;redlink=1">Strapi</a>[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-124">123]</a></td><td>Unofficial</td><td></td></tr>
<tr><td>Yes</td><td>?</td><td><a href="https://en.wikipedia.org/wiki/Sails.js">Sails.js</a> default port[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-125">124]</a></td><td>Unofficial</td><td></td></tr>
<tr><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/WASTE">WASTE</a> Encrypted File Sharing Program[<em><a href="https://en.wikipedia.org/wiki/Wikipedia:Citation_needed">citation needed</a></em>]</td><td>Unofficial</td><td></td></tr>
<tr><td>1341</td><td>Yes</td><td>Yes</td><td>Qubes (<a href="https://en.wikipedia.org/wiki/Manufacturing_Execution_System">Manufacturing Execution System</a>)</td><td>Official</td></tr>
<tr><td>1344</td><td>Yes</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/Internet_Content_Adaptation_Protocol">Internet Content Adaptation Protocol</a></td><td>Official</td></tr>
<tr><td>1352</td><td>Yes</td><td>Yes</td><td>IBM <a href="https://en.wikipedia.org/wiki/Lotus_Notes">Lotus Notes</a>/<a href="https://en.wikipedia.org/wiki/IBM_Lotus_Domino">Domino</a> <a href="https://en.wikipedia.org/wiki/Remote_procedure_call">(RPC)</a> protocol</td><td>Official</td></tr>
<tr><td>1360</td><td>Yes</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/Mimer_SQL">Mimer SQL</a></td><td>Official</td></tr>
<tr><td>1414</td><td>Yes</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/IBM">IBM</a> <a href="https://en.wikipedia.org/wiki/WebSphere_MQ">WebSphere MQ</a> (formerly known as <a href="https://en.wikipedia.org/wiki/MQSeries">MQSeries</a>)</td><td>Official</td></tr>
<tr><td>1417</td><td>Yes</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/Timbuktu_(software)">Timbuktu</a> Service 1 Port</td><td>Official</td></tr>
<tr><td>1418</td><td>Yes</td><td>Yes</td><td>Timbuktu Service 2 Port</td><td>Official</td></tr>
<tr><td>1419</td><td>Yes</td><td>Yes</td><td>Timbuktu Service 3 Port</td><td>Official</td></tr>
<tr><td>1420</td><td>Yes</td><td>Yes</td><td>Timbuktu Service 4 Port</td><td>Official</td></tr>
<tr><td>1431</td><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/w/index.php?title=Reverse_Gossip_Transport_Protocol&amp;action=edit&amp;redlink=1">Reverse Gossip Transport Protocol</a> (RGTP), used to access a General-purpose Reverse-Ordered Gossip Gathering System (GROGGS) <a href="https://en.wikipedia.org/wiki/Bulletin_board_system">bulletin board</a>, such as that implemented on the <a href="https://en.wikipedia.org/wiki/University_of_Cambridge">Cambridge University</a>'s <a href="https://en.wikipedia.org/wiki/Phoenix_(computer)">Phoenix system</a></td><td>Official</td></tr>
<tr><td>1433</td><td>Yes</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/Microsoft_SQL_Server">Microsoft SQL Server</a> <a href="https://en.wikipedia.org/wiki/Database_management_system">database management system</a> (MSSQL) server</td><td>Official</td></tr>
<tr><td>1434</td><td>Yes</td><td>Yes</td><td>Microsoft SQL Server database management system (MSSQL) monitor</td><td>Official</td></tr>
<tr><td>1481</td><td>Yes</td><td>Yes</td><td>AIRS data interchange.</td><td>Official</td></tr>
<tr><td>1492</td><td>Yes</td><td></td><td><em><a href="https://en.wikipedia.org/wiki/Sid_Meier&#x27;s_CivNet">Sid Meier's CivNet</a></em>, a multiplayer remake of the original <em>Sid Meier's Civilization</em> game[<em><a href="https://en.wikipedia.org/wiki/Wikipedia:Citation_needed">citation needed</a></em>]</td><td>Unofficial</td></tr>
<tr><td>1494</td><td>Yes</td><td>Yes</td><td>Citrix <a href="https://en.wikipedia.org/wiki/Independent_Computing_Architecture">Independent Computing Architecture</a> (ICA)[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-citrixblogger-126">125]</a></td><td>Unofficial</td></tr>
<tr><td>1500</td><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/IBM_Tivoli_Storage_Manager">IBM Tivoli Storage Manager</a> server[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-ibm-support-swg21625297-127">126]</a></td><td>Unofficial</td></tr>
<tr><td>1501</td><td>Yes</td><td></td><td>IBM Tivoli Storage Manager client scheduler[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-ibm-support-swg21625297-127">126]</a></td><td>Unofficial</td></tr>
<tr><td>1503</td><td>Yes</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/Windows_Live_Messenger">Windows Live Messenger</a> (Whiteboard and Application Sharing)[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-msft-kb-927847-128">127]</a></td><td>Unofficial</td></tr>
<tr><td>1512</td><td>Yes</td><td>Yes</td><td>Microsoft's <a href="https://en.wikipedia.org/wiki/Windows_Internet_Name_Service">Windows Internet Name Service</a> (WINS)</td><td>Official</td></tr>
<tr><td>1513</td><td>Yes</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/Garena">Garena</a> game client[<em><a href="https://en.wikipedia.org/wiki/Wikipedia:Citation_needed">citation needed</a></em>]</td><td>Unofficial</td></tr>
<tr><td>1521</td><td>Yes</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/NCUBE">nCUBE</a> License Manager</td><td>Official</td></tr>
<tr><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/Oracle_database">Oracle database</a> default listener, in future releases[<em><a href="https://en.wikipedia.org/wiki/Wikipedia:Manual_of_Style/Dates_and_numbers#Chronological_items">when?</a></em>][<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-129">128]</a> official port 2483 (TCP/IP) and 2484 (TCP/IP with SSL)</td><td>Unofficial</td><td></td></tr>
<tr><td>1524</td><td>Yes</td><td>Yes</td><td>ingreslock, <a href="https://en.wikipedia.org/wiki/Ingres_(database)">ingres</a></td><td>Official</td></tr>
<tr><td>1527</td><td>Yes</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/Oracle_Net_Services">Oracle Net Services</a>, formerly known as SQL*Net[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-toadworld-1635-130">129]</a></td><td>Official</td></tr>
<tr><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/Apache_Derby#Derby_Network_Server">Apache Derby Network Server</a>[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-apache-derby-into-131">130]</a></td><td>Unofficial</td><td></td></tr>
<tr><td>1533</td><td>Yes</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/IBM_Sametime">IBM Sametime</a> Virtual Places Chat</td><td>Official</td></tr>
<tr><td>1534</td><td>No</td><td>Yes</td><td>Eclipse Target Communication Framework [<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-Eclipse_Foundation-132">131]</a></td><td>Unofficial</td></tr>
<tr><td>1540</td><td>Yes</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/1C:Enterprise">1C:Enterprise</a> server agent (ragent)[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-enterprise1c-ports-133">132]</a>[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-enterprise1c-admin-guide-134">133]</a>[<em><a href="https://en.wikipedia.org/wiki/Wikipedia:Verifiability#Self-published_sources">self-published source</a></em>]</td><td>Unofficial</td></tr>
<tr><td>1541</td><td>Yes</td><td>Yes</td><td>1C:Enterprise master cluster manager (rmngr)[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-enterprise1c-ports-133">132]</a></td><td>Unofficial</td></tr>
<tr><td>1542</td><td>Yes</td><td>Yes</td><td>1C:Enterprise configuration repository server[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-enterprise1c-ports-133">132]</a></td><td>Unofficial</td></tr>
<tr><td>1545</td><td>Yes</td><td>Yes</td><td>1C:Enterprise cluster administration server (RAS)[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-enterprise1c-ports-133">132]</a></td><td>Unofficial</td></tr>
<tr><td>1547</td><td>Yes</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/Laplink">Laplink</a></td><td>Official</td></tr>
<tr><td>1550</td><td>Yes</td><td>Yes</td><td>1C:Enterprise debug server[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-enterprise1c-ports-133">132]</a></td><td>Unofficial</td></tr>
<tr><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/Gadu-Gadu">Gadu-Gadu</a> (direct client-to-client)[<em><a href="https://en.wikipedia.org/wiki/Wikipedia:Citation_needed">citation needed</a></em>]</td><td>Unofficial</td><td></td></tr>
<tr><td>1560–1590</td><td>Yes</td><td>Yes</td><td>1C:Enterprise cluster working processes[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-enterprise1c-ports-133">132]</a></td><td>Unofficial</td></tr>
<tr><td>1581</td><td>Yes</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/Combat-net_radio">MIL STD 2045-47001 VMF</a></td><td>Official</td></tr>
<tr><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/IBM_Tivoli_Storage_Manager">IBM Tivoli Storage Manager</a> web client[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-ibm-support-swg21625297-127">126]</a></td><td>Unofficial</td><td></td></tr>
<tr><td>1582–1583</td><td>Yes</td><td></td><td>IBM Tivoli Storage Manager server web interface[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-ibm-support-swg21625297-127">126]</a></td><td>Unofficial</td></tr>
<tr><td>1583</td><td>?</td><td>?</td><td><a href="https://en.wikipedia.org/wiki/Pervasive_PSQL">Pervasive PSQL</a>[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-PSQLVx_SP3_readme-135">134]</a></td><td>Unofficial</td></tr>
<tr><td>1589</td><td>Yes</td><td>Yes</td><td>Cisco VLAN Query Protocol (<a href="https://en.wikipedia.org/wiki/VQP">VQP</a>)</td><td>Official</td></tr>
<tr><td>1604</td><td>Yes</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/DarkComet">DarkComet</a> remote administration tool (RAT)[<em><a href="https://en.wikipedia.org/wiki/Wikipedia:Citation_needed">citation needed</a></em>]</td><td>Unofficial</td></tr>
<tr><td>1626</td><td>Yes</td><td>?</td><td><a href="https://en.wikipedia.org/wiki/ISketch">iSketch</a>[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-isketch-help-136">135]</a></td><td>Unofficial</td></tr>
<tr><td>1627</td><td>Yes</td><td>?</td><td>iSketch[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-isketch-help-136">135]</a></td><td>Unofficial</td></tr>
<tr><td>1628</td><td>Yes</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/LonTalk">LonTalk</a> normal</td><td>Official</td></tr>
<tr><td>1629</td><td>Yes</td><td>Yes</td><td>LonTalk urgent</td><td>Official</td></tr>
<tr><td>1645</td><td></td><td>Yes</td><td>Early deployment of <a href="https://en.wikipedia.org/wiki/RADIUS">RADIUS</a> before RFC standardization was done using UDP port number 1645. Enabled for compatibility reasons by default on <a href="https://en.wikipedia.org/wiki/Cisco">Cisco</a>[<em><a href="https://en.wikipedia.org/wiki/Wikipedia:Citation_needed">citation needed</a></em>] and <a href="https://en.wikipedia.org/wiki/Juniper_Networks">Juniper Networks</a> RADIUS servers.[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-juniper-radius-overview-137">136]</a> Official port is 1812. TCP port 1645 <strong>MUST NOT</strong> be used.[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-rfc6613-138">137]</a></td><td>Unofficial</td></tr>
<tr><td>1646</td><td></td><td>Yes</td><td>Old <code>radacct</code> port,[<em><a href="https://en.wikipedia.org/wiki/Wikipedia:Manual_of_Style/Dates_and_numbers#Chronological_items">when?</a></em>] RADIUS accounting protocol. Enabled for compatibility reasons by default on <a href="https://en.wikipedia.org/wiki/Cisco">Cisco</a>[<em><a href="https://en.wikipedia.org/wiki/Wikipedia:Citation_needed">citation needed</a></em>] and <a href="https://en.wikipedia.org/wiki/Juniper_Networks">Juniper Networks</a> RADIUS servers.[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-juniper-radius-overview-137">136]</a> Official port is 1813. TCP port 1646 <strong>MUST NOT</strong> be used.[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-rfc6613-138">137]</a></td><td>Unofficial</td></tr>
<tr><td>1666</td><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/Perforce">Perforce</a>[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-perforce-cmdref-p4port-139">138]</a></td><td>Unofficial</td></tr>
<tr><td>1677</td><td>Yes</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/Novell_GroupWise">Novell GroupWise</a> clients in client/server access mode</td><td>Official</td></tr>
<tr><td>1688</td><td>Yes</td><td></td><td>Microsoft <a href="https://en.wikipedia.org/wiki/Key_Management_Service">Key Management Service</a> (KMS) for Windows Activation[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-msft-tn-ee939272-140">139]</a></td><td>Unofficial</td></tr>
<tr><td>1701</td><td>Yes</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/Layer_2_Forwarding_Protocol">Layer 2 Forwarding Protocol</a> (L2F)</td><td>Official</td></tr>
<tr><td>Assigned</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/Layer_2_Tunneling_Protocol">Layer 2 Tunneling Protocol</a> (L2TP)[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-apple-kb-HT202944-10">10]</a></td><td>Official</td><td></td></tr>
<tr><td>1707</td><td>Yes</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/Windward_Studios">Windward Studios</a> games (vdmplay)</td><td>Official</td></tr>
<tr><td></td><td>Yes</td><td>L2TP/IPsec, for establish an initial connection[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-rfc3193-141">140]</a></td><td>Unofficial</td><td></td></tr>
<tr><td>1716</td><td></td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/America&#x27;s_Army">America's Army</a>, a <a href="https://en.wikipedia.org/wiki/Massively_multiplayer_online_game">massively multiplayer online game</a> (MMO)[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-aa-manual-ls-142">141]</a></td><td>Unofficial</td></tr>
<tr><td>1719</td><td>Yes</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/H.323">H.323</a> registration and alternate communication</td><td>Official</td></tr>
<tr><td>1720</td><td>Yes</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/H.323">H.323</a> call signaling</td><td>Official</td></tr>
<tr><td>1723</td><td>Yes</td><td>Assigned</td><td><a href="https://en.wikipedia.org/wiki/Point-to-Point_Tunneling_Protocol">Point-to-Point Tunneling Protocol</a> (PPTP)[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-apple-kb-HT202944-10">10]</a></td><td>Official</td></tr>
<tr><td>1755</td><td>Yes</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/Microsoft_Media_Services">Microsoft Media Services</a> (MMS, <code>ms-streaming</code>)</td><td>Official</td></tr>
<tr><td>1761</td><td>Yes</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/Novell_ZENworks">Novell ZENworks</a>[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-novell-kb-3880659-143">142]</a>[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-novell-zen11-b18151xi-144">143]</a></td><td>Unofficial</td></tr>
<tr><td>1783</td><td></td><td></td><td>Decomissioned [<em><a href="https://en.wikipedia.org/wiki/Sic">sic</a></em>] Port 04/14/00, ms</td><td>Official</td></tr>
<tr><td>1801</td><td>Yes</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/Microsoft_Message_Queuing">Microsoft Message Queuing</a></td><td>Official</td></tr>
<tr><td>1812</td><td>Yes</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/RADIUS">RADIUS</a> authentication protocol, <code>radius</code></td><td>Official</td></tr>
<tr><td>1813</td><td>Yes</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/RADIUS">RADIUS</a> accounting protocol, <code>radius-acct</code></td><td>Official</td></tr>
<tr><td>1863</td><td>Yes</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/Microsoft_Notification_Protocol">Microsoft Notification Protocol</a> (MSNP), used by the <a href="https://en.wikipedia.org/wiki/Microsoft_Messenger_service">Microsoft Messenger service</a> and a number of instant messaging <a href="https://en.wikipedia.org/wiki/Microsoft_Messenger_service#Official_clients">Messenger clients</a></td><td>Official</td></tr>
<tr><td>1880</td><td>?</td><td>?</td><td><a href="https://en.wikipedia.org/wiki/Node-RED">Node-RED</a>[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-nodered-docs-config-145">144]</a></td><td>Unofficial</td></tr>
<tr><td>1883</td><td>Yes</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/MQTT">MQTT</a> (formerly MQ Telemetry Transport)</td><td>Official</td></tr>
<tr><td>1900</td><td>Assigned</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/Simple_Service_Discovery_Protocol">Simple Service Discovery Protocol</a> (SSDP),[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-apple-kb-HT202944-10">10]</a> discovery of <a href="https://en.wikipedia.org/wiki/Universal_Plug_and_Play">UPnP</a> devices</td><td>Official</td></tr>
<tr><td>1935</td><td>Yes</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/Macromedia_Flash">Macromedia Flash</a> Communications <a href="https://en.wikipedia.org/wiki/Macromedia_Studio_MX">Server MX</a>, the precursor to <a href="https://en.wikipedia.org/wiki/Adobe_Flash_Media_Server">Adobe Flash Media Server</a> before <a href="https://en.wikipedia.org/wiki/Macromedia">Macromedia</a>'s acquisition by <a href="https://en.wikipedia.org/wiki/Adobe_Inc">Adobe</a> on December 3, 2005</td><td>Official</td></tr>
<tr><td>Yes</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/Real_Time_Messaging_Protocol">Real Time Messaging Protocol</a> (RTMP)[<em><a href="https://en.wikipedia.org/wiki/Wikipedia:Citation_needed">citation needed</a></em>], primarily used in <a href="https://en.wikipedia.org/wiki/Adobe_Flash">Adobe Flash</a>[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-adobe-helpx-ports-firewalls-146">145]</a></td><td>Unofficial</td><td></td></tr>
<tr><td>1965</td><td>Yes</td><td>No</td><td>Gemini protocol, a lightweight, collaboratively designed protocol, striving to fill the gap between Gopher and HTTP[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-gemini-specification-147">146]</a></td><td>Unofficial</td></tr>
<tr><td>1967</td><td></td><td>Yes</td><td>Cisco IOS IP Service Level Agreements (<a href="https://en.wikipedia.org/wiki/IP_SLA">IP SLAs</a>) Control Protocol[<em><a href="https://en.wikipedia.org/wiki/Wikipedia:Citation_needed">citation needed</a></em>]</td><td>Unofficial</td></tr>
<tr><td>1970</td><td>Yes</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/Netop_Remote_Control">Netop Remote Control</a></td><td>Official</td></tr>
<tr><td>1972</td><td>Yes</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/InterSystems_Cach%C3%A9">InterSystems Caché</a></td><td>Official</td></tr>
<tr><td>1984</td><td>Yes</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/Big_Brother_(software)">Big Brother</a></td><td>Official</td></tr>
<tr><td>1985</td><td>Assigned</td><td>Yes</td><td>Cisco <a href="https://en.wikipedia.org/wiki/Hot_Standby_Router_Protocol">Hot Standby Router Protocol</a> (HSRP)[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-cisco-support-hsrp-faq-148">147]</a>[<em><a href="https://en.wikipedia.org/wiki/Wikipedia:Verifiability#Self-published_sources">self-published source</a></em>]</td><td>Official</td></tr>
<tr><td>1998</td><td>Yes</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/Cisco">Cisco</a> X.25 over TCP (<a href="https://en.wikipedia.org/wiki/XOT">XOT</a>) service</td><td>Official</td></tr>
<tr><td>2000</td><td>Yes</td><td>Yes</td><td>Cisco <a href="https://en.wikipedia.org/wiki/Skinny_Client_Control_Protocol">Skinny Client Control Protocol</a> (SCCP)</td><td>Official</td></tr>
<tr><td>2010</td><td>?</td><td>?</td><td><a href="https://en.wikipedia.org/wiki/Artemis:_Spaceship_Bridge_Simulator">Artemis: Spaceship Bridge Simulator</a>[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-149">148]</a>[<em><a href="https://en.wikipedia.org/wiki/Wikipedia:Verifiability#Self-published_sources">self-published source?</a></em>]</td><td>Unofficial</td></tr>
<tr><td>2033</td><td>Yes</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/Civilization_IV">Civilization IV</a> multiplayer[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-2k-support-201333253-150">149]</a></td><td>Unofficial</td></tr>
<tr><td>2049</td><td>Yes, and SCTP</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/Network_File_System">Network File System</a> (NFS)[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-apple-kb-HT202944-10">10]</a></td><td>Official</td></tr>
<tr><td>2056</td><td>Yes</td><td>Yes</td><td>Civilization IV multiplayer[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-2k-support-201333253-150">149]</a></td><td>Unofficial</td></tr>
<tr><td>2080</td><td>Yes</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/Autodesk">Autodesk</a> NLM (<a href="https://en.wikipedia.org/wiki/FLEXlm">FLEXlm</a>)</td><td>Official</td></tr>
<tr><td>2082</td><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/CPanel">cPanel</a> default[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-cpanel-ckb-login-151">150]</a></td><td>Unofficial</td></tr>
<tr><td>2083</td><td>Yes</td><td>Yes</td><td>Secure <a href="https://en.wikipedia.org/wiki/RADIUS">RADIUS</a> Service (radsec)</td><td>Official</td></tr>
<tr><td>Yes</td><td></td><td>cPanel default <a href="https://en.wikipedia.org/wiki/Secure_Sockets_Layer">SSL</a>[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-cpanel-ckb-login-151">150]</a></td><td>Unofficial</td><td></td></tr>
<tr><td>2086</td><td>Yes</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/GNUnet">GNUnet</a></td><td>Official</td></tr>
<tr><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/WHM">WebHost Manager</a> default[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-cpanel-ckb-login-151">150]</a></td><td>Unofficial</td><td></td></tr>
<tr><td>2087</td><td>Yes</td><td></td><td>WebHost Manager default <a href="https://en.wikipedia.org/wiki/Secure_Sockets_Layer">SSL</a>[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-cpanel-ckb-login-151">150]</a></td><td>Unofficial</td></tr>
<tr><td>2095</td><td>Yes</td><td></td><td>cPanel default web mail[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-cpanel-ckb-login-151">150]</a></td><td>Official</td></tr>
<tr><td>2096</td><td>Yes</td><td></td><td>cPanel default <a href="https://en.wikipedia.org/wiki/Secure_Sockets_Layer">SSL</a> web mail[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-cpanel-ckb-login-151">150]</a></td><td>Unofficial</td></tr>
<tr><td>2100</td><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/Warzone_2100">Warzone 2100</a> multiplayer[<em><a href="https://en.wikipedia.org/wiki/Wikipedia:Citation_needed">citation needed</a></em>]</td><td>Unofficial</td></tr>
<tr><td>2101</td><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/Networked_Transport_of_RTCM_via_Internet_Protocol">Networked Transport of RTCM via Internet Protocol</a> (NTRIP)[<em><a href="https://en.wikipedia.org/wiki/Wikipedia:Citation_needed">citation needed</a></em>]</td><td>Unofficial</td></tr>
<tr><td>2102</td><td>Yes</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/Zephyr_(protocol)">Zephyr Notification Service</a> server</td><td>Official</td></tr>
<tr><td>2103</td><td>Yes</td><td>Yes</td><td>Zephyr Notification Service <code>serv-hm</code> connection</td><td>Official</td></tr>
<tr><td>2104</td><td>Yes</td><td>Yes</td><td>Zephyr Notification Service hostmanager</td><td>Official</td></tr>
<tr><td>2123</td><td>Yes</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/GPRS_Tunnelling_Protocol">GTP</a> control messages (GTP-C)</td><td>Official</td></tr>
<tr><td>2142</td><td>Yes</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/TDMoIP">TDMoIP</a> (TDM over IP)</td><td>Official</td></tr>
<tr><td>2152</td><td>Yes</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/GPRS_Tunnelling_Protocol">GTP</a> user data messages (GTP-U)</td><td>Official</td></tr>
<tr><td>2159</td><td>Yes</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/Gdbserver">GDB remote debug port</a></td><td>Official</td></tr>
<tr><td>2181</td><td>Yes</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/EForward">EForward</a>-document transport system</td><td>Official</td></tr>
<tr><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/Apache_ZooKeeper">Apache ZooKeeper</a> default client port[<em><a href="https://en.wikipedia.org/wiki/Wikipedia:Citation_needed">citation needed</a></em>]</td><td>Unofficial</td><td></td></tr>
<tr><td>2195</td><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/Apple_Push_Notification_Service">Apple Push Notification Service</a>[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-apple-kb-HT202944-10">10]</a>[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-apple-kb-HT203609-152">151]</a></td><td>Unofficial</td></tr>
<tr><td>2196</td><td>Yes</td><td></td><td>Apple Push Notification Service, feedback service[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-apple-kb-HT202944-10">10]</a>[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-apple-kb-HT203609-152">151]</a></td><td>Unofficial</td></tr>
<tr><td>2210</td><td>Yes</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/National_Weather_Service">NOAAPORT</a> Broadcast Network</td><td>Official</td></tr>
<tr><td>2211</td><td>Yes</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/EMWIN">EMWIN</a></td><td>Official</td></tr>
<tr><td>2221</td><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/ESET">ESET</a> anti-virus updates[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-eset_user_guide_5_2-153">152]</a></td><td>Unofficial</td></tr>
<tr><td>2222</td><td>Yes</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/EtherNet/IP">EtherNet/IP</a> implicit messaging for IO data</td><td>Official</td></tr>
<tr><td>?</td><td>?</td><td><a href="https://en.wikipedia.org/wiki/DirectAdmin">DirectAdmin</a> Access[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-directadmin-help-71-154">153]</a></td><td>Unofficial</td><td></td></tr>
<tr><td>2222–2226</td><td>Yes</td><td></td><td>ESET Remote administrator[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-eset_user_guide_5_2-153">152]</a></td><td>Official</td></tr>
<tr><td>2240</td><td>Yes</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/General_Dynamics">General Dynamics</a> Remote Encryptor Configuration Information Protocol (RECIPe)</td><td>Official</td></tr>
<tr><td>2261</td><td>Yes</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/CoMotion">CoMotion</a> master</td><td>Official</td></tr>
<tr><td>2262</td><td>Yes</td><td>Yes</td><td>CoMotion backup</td><td>Official</td></tr>
<tr><td>2302</td><td></td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/ArmA">ArmA</a> multiplayer[<em><a href="https://en.wikipedia.org/wiki/Wikipedia:Citation_needed">citation needed</a></em>]</td><td>Unofficial</td></tr>
<tr><td></td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/Halo:_Combat_Evolved">Halo: Combat Evolved</a> multiplayer host[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-msft-kb-829469-155">154]</a></td><td>Unofficial</td><td></td></tr>
<tr><td>2303</td><td></td><td>Yes</td><td>ArmA multiplayer <em>(default port for game +1)</em>[<em><a href="https://en.wikipedia.org/wiki/Wikipedia:Citation_needed">citation needed</a></em>]</td><td>Unofficial</td></tr>
<tr><td></td><td>Yes</td><td>Halo: Combat Evolved multiplayer listener[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-msft-kb-829469-155">154]</a></td><td>Unofficial</td><td></td></tr>
<tr><td>2305</td><td></td><td>Yes</td><td>ArmA multiplayer <em>(default port for game +3)</em>[<em><a href="https://en.wikipedia.org/wiki/Wikipedia:Citation_needed">citation needed</a></em>]</td><td>Unofficial</td></tr>
<tr><td>2351</td><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/AOL_Instant_Messenger">AIM</a> game LAN network port[<em><a href="https://en.wikipedia.org/wiki/Wikipedia:Citation_needed">citation needed</a></em>]</td><td>Unofficial</td></tr>
<tr><td>2368</td><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/Ghost_(blogging_platform)">Ghost (blogging platform)</a>[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-gfb-config-156">155]</a></td><td>Unofficial</td></tr>
<tr><td>2369</td><td>Yes</td><td></td><td>Default for <a href="https://en.wikipedia.org/wiki/BMC_Control-M">BMC Control-M/Server</a> Configuration Agent</td><td>Unofficial</td></tr>
<tr><td>2370</td><td>Yes</td><td></td><td>Default for BMC Control-M/Server, to allow the Control-M/Enterprise Manager to connect to the Control-M/Server</td><td>Unofficial</td></tr>
<tr><td>2372</td><td>Yes</td><td></td><td>Default for <a href="https://en.wikipedia.org/wiki/K9_Web_Protection">K9 Web Protection</a>/parental controls, content filtering agent[<em><a href="https://en.wikipedia.org/wiki/Wikipedia:Citation_needed">citation needed</a></em>]</td><td>Unofficial</td></tr>
<tr><td>2375</td><td>Yes</td><td>Reserved</td><td><a href="https://en.wikipedia.org/wiki/Docker_(software)">Docker</a> REST API (plain)</td><td>Official</td></tr>
<tr><td>2376</td><td>Yes</td><td>Reserved</td><td>Docker REST API (SSL)</td><td>Official</td></tr>
<tr><td>2377</td><td>Yes</td><td>Reserved</td><td>Docker Swarm cluster management communications[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-docker-swarm-tutorial-157">156]</a>[<em><a href="https://en.wikipedia.org/wiki/Wikipedia:Verifiability#Self-published_sources">self-published source</a></em>]</td><td>Official</td></tr>
<tr><td>2379</td><td>Yes</td><td>Reserved</td><td>CoreOS <a href="https://en.wikipedia.org/wiki/Etcd">etcd</a> client communication</td><td>Official</td></tr>
<tr><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/KGS_Go_Server">KGS Go Server</a>[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-gokgs-prefs-158">157]</a></td><td>Unofficial</td><td></td></tr>
<tr><td>2380</td><td>Yes</td><td>Reserved</td><td>CoreOS etcd server communication</td><td>Official</td></tr>
<tr><td>2389</td><td>Assigned</td><td>Assigned</td><td>OpenView Session Mgr</td><td>Official</td></tr>
<tr><td>2399</td><td>Yes</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/FileMaker">FileMaker</a> Data Access Layer (ODBC/JDBC)</td><td>Official</td></tr>
<tr><td>2401</td><td>Yes</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/Concurrent_Versions_System">CVS</a> version control system password-based server</td><td>Official</td></tr>
<tr><td>2404</td><td>Yes</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/IEC_60870-5-104">IEC 60870-5-104</a>, used to send electric power telecontrol messages between two systems via directly connected <a href="https://en.wikipedia.org/w/index.php?title=Data_circuit&amp;action=edit&amp;redlink=1">data circuits</a></td><td>Official</td></tr>
<tr><td>2424</td><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/OrientDB">OrientDB</a> database listening for binary client connections[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-orientdb-docs-dbserver-159">158]</a></td><td>Unofficial</td></tr>
<tr><td>2427</td><td>Yes</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/Media_Gateway_Control_Protocol">Media Gateway Control Protocol</a> (MGCP) media gateway</td><td>Official</td></tr>
<tr><td>2447</td><td>Yes</td><td>Yes</td><td>ovwdb—<a href="https://en.wikipedia.org/wiki/OpenView">OpenView</a> <a href="https://en.wikipedia.org/wiki/Network_Node_Manager">Network Node Manager</a> (NNM) daemon</td><td>Official</td></tr>
<tr><td>2459</td><td>Yes</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/Xrp">XRPL</a></td><td>Official</td></tr>
<tr><td>2480</td><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/OrientDB">OrientDB</a> database listening for HTTP client connections[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-orientdb-docs-dbserver-159">158]</a></td><td>Unofficial</td></tr>
<tr><td>2483</td><td>Yes</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/Oracle_database">Oracle database</a> listening for insecure client connections to the listener, replaces port 1521[<em><a href="https://en.wikipedia.org/wiki/Wikipedia:Manual_of_Style/Dates_and_numbers#Chronological_items">when?</a></em>]</td><td>Official</td></tr>
<tr><td>2484</td><td>Yes</td><td>Yes</td><td>Oracle database listening for <a href="https://en.wikipedia.org/wiki/Secure_Sockets_Layer">SSL</a> client connections to the listener</td><td>Official</td></tr>
<tr><td>2500</td><td>Yes</td><td>Yes</td><td>NetFS communication[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-160">159]</a></td><td>Unofficial</td></tr>
<tr><td>2501</td><td></td><td>Yes</td><td>NetFS probe</td><td>Unofficial</td></tr>
<tr><td>2535</td><td>Yes</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/Multicast_Address_Dynamic_Client_Allocation_Protocol">Multicast Address Dynamic Client Allocation Protocol</a> (MADCAP).[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-rfc2730-port-161">160]</a> All standard messages are UDP datagrams.[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-rfc2730-udp-162">161]</a></td><td>Official</td></tr>
<tr><td>2541</td><td>Yes</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/LonTalk">LonTalk</a>/IP</td><td>Official</td></tr>
<tr><td>2546–2548</td><td>Yes</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/EVault">EVault</a> data protection services</td><td>Official</td></tr>
<tr><td>2593</td><td>Yes</td><td>Yes</td><td><em><a href="https://en.wikipedia.org/wiki/Ultima_Online">Ultima Online</a></em> servers[<em><a href="https://en.wikipedia.org/wiki/Wikipedia:Citation_needed">citation needed</a></em>]</td><td>Unofficial</td></tr>
<tr><td>2598</td><td>Yes</td><td></td><td>Citrix <a href="https://en.wikipedia.org/wiki/Independent_Computing_Architecture">Independent Computing Architecture</a> (ICA) with Session Reliability; port 1494 without session reliability[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-citrixblogger-126">125]</a></td><td>Unofficial</td></tr>
<tr><td>2599</td><td>Yes</td><td>Yes</td><td><em>Ultima Online</em> servers[<em><a href="https://en.wikipedia.org/wiki/Wikipedia:Citation_needed">citation needed</a></em>]</td><td>Unofficial</td></tr>
<tr><td>2628</td><td>Yes</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/DICT">DICT</a> [<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-163">162]</a></td><td>Official</td></tr>
<tr><td>2638</td><td>Yes</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/SQL_Anywhere">SQL Anywhere</a> database server[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-164">163]</a>[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-165">164]</a></td><td>Official</td></tr>
<tr><td>2710</td><td>Yes</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/XBT_Tracker">XBT Tracker</a>.[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-sf-xbtt-port-166">165]</a> UDP tracker extension is considered experimental.[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-sf-xbtt-udp-167">166]</a></td><td>Unofficial</td></tr>
<tr><td>2727</td><td>Yes</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/Media_Gateway_Control_Protocol">Media Gateway Control Protocol</a> (MGCP) media gateway controller (call agent)</td><td>Official</td></tr>
<tr><td>2775</td><td>Yes</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/Short_Message_Peer-to-Peer">Short Message Peer-to-Peer</a> (SMPP)[<em><a href="https://en.wikipedia.org/wiki/Wikipedia:Citation_needed">citation needed</a></em>]</td><td>Official</td></tr>
<tr><td>2809</td><td>Yes</td><td>Yes</td><td>corbaloc:iiop URL, per the <a href="https://en.wikipedia.org/wiki/CORBA">CORBA</a> 3.0.3 specification</td><td>Official</td></tr>
<tr><td>2811</td><td>Yes</td><td>Yes</td><td>gsi ftp, per the <a href="https://en.wikipedia.org/wiki/GridFTP">GridFTP</a> specification</td><td>Official</td></tr>
<tr><td>2827</td><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/I2P">I2P</a> BOB Bridge[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-geti2p-ports-168">167]</a></td><td>Unofficial</td></tr>
<tr><td>2944</td><td>Yes</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/Megaco">Megaco</a> text H.248</td><td>Official</td></tr>
<tr><td>2945</td><td>Yes</td><td>Yes</td><td>Megaco binary (ASN.1) H.248</td><td>Official</td></tr>
<tr><td>2947</td><td>Yes</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/Gpsd">gpsd</a>, GPS daemon</td><td>Official</td></tr>
<tr><td>2948</td><td>Yes</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/Wireless_Application_Protocol">WAP</a> push <a href="https://en.wikipedia.org/wiki/Multimedia_Messaging_Service">Multimedia Messaging Service</a> (MMS)</td><td>Official</td></tr>
<tr><td>2949</td><td>Yes</td><td>Yes</td><td>WAP push secure (MMS)</td><td>Official</td></tr>
<tr><td>2967</td><td>Yes</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/Symantec_AntiVirus">Symantec System Center</a> agent (SSC-AGENT)</td><td>Official</td></tr>
<tr><td>3000</td><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/Cloud9_IDE">Cloud9 IDE</a> server[<em><a href="https://en.wikipedia.org/wiki/Wikipedia:Citation_needed">citation needed</a></em>]</td><td>Unofficial</td></tr>
<tr><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/Ruby_on_Rails">Ruby on Rails</a> development default[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-169">168]</a></td><td>Unofficial</td><td></td></tr>
<tr><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/Meteor_(web_framework)">Meteor</a> development default[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-170">169]</a>[<em><a href="https://en.wikipedia.org/wiki/Wikipedia:Verifiability">failed verification</a></em>]</td><td>Unofficial</td><td></td></tr>
<tr><td>Yes</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/Resilio_Sync">Resilio Sync</a>,[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-getsync-kb-204754759-171">170]</a> spun from BitTorrent Sync.</td><td>Unofficial</td><td></td></tr>
<tr><td></td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/Distributed_Interactive_Simulation">Distributed Interactive Simulation</a> (DIS)[<em><a href="https://en.wikipedia.org/wiki/Wikipedia:Citation_needed">citation needed</a></em>]</td><td>Unofficial</td><td></td></tr>
<tr><td>3004</td><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/ISync">iSync</a>[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-apple-kb-HT202944-10">10]</a></td><td>Unofficial</td></tr>
<tr><td>3020</td><td>Yes</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/Common_Internet_File_System">Common Internet File System</a> (CIFS). See also port 445 for <a href="https://en.wikipedia.org/wiki/Server_Message_Block">Server Message Block</a> (SMB), a dialect of CIFS.</td><td>Official</td></tr>
<tr><td>3050</td><td>Yes</td><td>Yes</td><td>gds-db (<a href="https://en.wikipedia.org/wiki/Interbase">Interbase</a>/<a href="https://en.wikipedia.org/wiki/Firebird_(database_server)">Firebird</a> databases)</td><td>Official</td></tr>
<tr><td>3052</td><td>Yes</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/APC_by_Schneider_Electric">APC</a> <a href="https://en.wikipedia.org/wiki/PowerChute">PowerChute Network</a></td><td>Official</td></tr>
<tr><td>3074</td><td>Yes</td><td>Yes</td><td>Xbox LIVE and <a href="https://en.wikipedia.org/wiki/Games_for_Windows_%E2%80%93_Live">Games for Windows – Live</a></td><td>Official</td></tr>
<tr><td>3101</td><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/BlackBerry_Enterprise_Server">BlackBerry Enterprise Server</a> communication protocol[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-blkbr-kb-3735-172">171]</a></td><td>Unofficial</td></tr>
<tr><td>3128</td><td>Yes</td><td>?</td><td><a href="https://en.wikipedia.org/wiki/Squid_(software)">Squid</a> caching web proxy[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-squid-doc-http_port-173">172]</a></td><td>Unofficial</td></tr>
<tr><td>3225</td><td>Yes</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/Fibre_Channel_over_IP">Fibre Channel over IP</a> (FCIP)</td><td>Official</td></tr>
<tr><td>3233</td><td>Yes</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/WhiskerControl">WhiskerControl</a> research control protocol</td><td>Official</td></tr>
<tr><td>3260</td><td>Yes</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/ISCSI">iSCSI</a></td><td>Official</td></tr>
<tr><td>3268</td><td>Yes</td><td>Yes</td><td>msft-gc, Microsoft Global Catalog (<a href="https://en.wikipedia.org/wiki/LDAP">LDAP</a> service which contains data from <a href="https://en.wikipedia.org/wiki/Active_Directory">Active Directory</a> forests)</td><td>Official</td></tr>
<tr><td>3269</td><td>Yes</td><td>Yes</td><td>msft-gc-ssl, Microsoft Global Catalog over <a href="https://en.wikipedia.org/wiki/Secure_Sockets_Layer">SSL</a> (similar to port 3268, <a href="https://en.wikipedia.org/wiki/LDAP">LDAP</a> over <a href="https://en.wikipedia.org/wiki/Secure_Sockets_Layer">SSL</a>)</td><td>Official</td></tr>
<tr><td>3283</td><td>Yes</td><td>Yes</td><td><em>Net Assistant</em>,[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-apple-kb-HT202944-10">10]</a> a predecessor to <em>Apple Remote Desktop</em></td><td>Official</td></tr>
<tr><td>Yes</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/Apple_Remote_Desktop">Apple Remote Desktop</a> 2.0 or later[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-apple-kb-HT202944-10">10]</a></td><td>Unofficial</td><td></td></tr>
<tr><td>3290</td><td></td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/VATSIM">Virtual Air Traffic Simulation</a> (VATSIM) network voice communication[<em><a href="https://en.wikipedia.org/wiki/Wikipedia:Citation_needed">citation needed</a></em>]</td><td>Unofficial</td></tr>
<tr><td>3305</td><td>Yes</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/OFTP">Odette File Transfer Protocol</a> (OFTP)</td><td>Official</td></tr>
<tr><td>3306</td><td>Yes</td><td>Assigned</td><td><a href="https://en.wikipedia.org/wiki/MySQL">MySQL</a> database system[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-apple-kb-HT202944-10">10]</a></td><td>Official</td></tr>
<tr><td>3323</td><td>Yes</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/DECE">DECE</a> GEODI Server</td><td>Unofficial</td></tr>
<tr><td>3332</td><td></td><td>Yes</td><td>Thundercloud DataPath Overlay Control</td><td>Unofficial</td></tr>
<tr><td>3333</td><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/Eggdrop">Eggdrop</a>, an IRC bot default port[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-174">173]</a></td><td>Unofficial</td></tr>
<tr><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/Network_Caller_ID">Network Caller ID</a> server</td><td>Unofficial</td><td></td></tr>
<tr><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/CruiseControl.rb">CruiseControl.rb</a>[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-175">174]</a></td><td>Unofficial</td><td></td></tr>
<tr><td>3351</td><td>?</td><td>?</td><td><a href="https://en.wikipedia.org/wiki/Pervasive_PSQL">Pervasive PSQL</a>[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-PSQLVx_SP3_readme-135">134]</a></td><td>Unofficial</td></tr>
<tr><td>3386</td><td>Yes</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/GTP&#x27;">GTP'</a> <a href="https://en.wikipedia.org/wiki/3GPP">3GPP</a> <a href="https://en.wikipedia.org/wiki/GSM">GSM</a>/<a href="https://en.wikipedia.org/wiki/UMTS">UMTS</a> <a href="https://en.wikipedia.org/wiki/Call_detail_record">CDR</a> logging protocol</td><td>Official</td></tr>
<tr><td>3389</td><td>Yes</td><td>Yes</td><td>Microsoft Terminal Server (<a href="https://en.wikipedia.org/wiki/Remote_Desktop_Protocol">RDP</a>) officially registered as Windows Based Terminal (WBT)[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-176">175]</a></td><td>Official</td></tr>
<tr><td>3396</td><td>Yes</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/Novell">Novell</a> NDPS Printer Agent</td><td>Official</td></tr>
<tr><td>3412</td><td>Yes</td><td>Yes</td><td>xmlBlaster</td><td>Official</td></tr>
<tr><td>3423</td><td>Yes</td><td></td><td>Xware xTrm Communication Protocol</td><td>Official</td></tr>
<tr><td>3424</td><td>Yes</td><td></td><td>Xware xTrm Communication Protocol over SSL</td><td>Official</td></tr>
<tr><td>3455</td><td>Yes</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/Resource_Reservation_Protocol">Resource Reservation Protocol</a> (RSVP)</td><td>Official</td></tr>
<tr><td>3478</td><td>Yes</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/STUN">STUN</a>, a protocol for NAT traversal[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-STUN-177">176]</a></td><td>Official</td></tr>
<tr><td>Yes</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/Traversal_Using_Relay_NAT">TURN</a>, a protocol for NAT traversal[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-TURN-178">177]</a> (extension to STUN)</td><td>Official</td><td></td></tr>
<tr><td>Yes</td><td>Yes</td><td>STUN Behavior Discovery.[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-rfc5780-179">178]</a> See also port 5349.</td><td>Official</td><td></td></tr>
<tr><td>3479</td><td>Yes</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/PlayStation_Network">PlayStation Network</a>[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-playstation-manual-ps4-nw_test-180">179]</a></td><td>Unofficial</td></tr>
<tr><td>3480</td><td>Yes</td><td>Yes</td><td>PlayStation Network[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-playstation-manual-ps4-nw_test-180">179]</a></td><td>Unofficial</td></tr>
<tr><td>3483</td><td></td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/Slim_Devices">Slim Devices</a> discovery protocol</td><td>Official</td></tr>
<tr><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/Slim_Devices">Slim Devices</a> SlimProto protocol</td><td>Official</td><td></td></tr>
<tr><td>3493</td><td>Yes</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/Network_UPS_Tools">Network UPS Tools</a> (NUT)</td><td>Official</td></tr>
<tr><td>3516</td><td>Yes</td><td>Yes</td><td>Smartcard Port</td><td>Official</td></tr>
<tr><td>3527</td><td></td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/Microsoft_Message_Queuing">Microsoft Message Queuing</a></td><td>Official</td></tr>
<tr><td>3535</td><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/SMTP">SMTP</a> alternate[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-181">180]</a></td><td>Unofficial</td></tr>
<tr><td>3544</td><td></td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/Teredo_tunneling">Teredo tunneling</a></td><td>Official</td></tr>
<tr><td>3632</td><td>Yes</td><td>Assigned</td><td><a href="https://en.wikipedia.org/wiki/Distcc">Distcc</a>, distributed compiler[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-apple-kb-HT202944-10">10]</a></td><td>Official</td></tr>
<tr><td>3645</td><td>Yes</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/Cyc">Cyc</a></td><td>Official</td></tr>
<tr><td>3659</td><td>Yes</td><td>Yes</td><td>Apple <a href="https://en.wikipedia.org/wiki/Simple_Authentication_and_Security_Layer">SASL</a>, used by <a href="https://en.wikipedia.org/wiki/Mac_OS_X_Server">Mac OS X Server</a> Password Server[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-apple-kb-HT202944-10">10]</a></td><td>Official</td></tr>
<tr><td></td><td>Yes</td><td>Battlefield 4</td><td>Unofficial</td><td></td></tr>
<tr><td>3667</td><td>Yes</td><td>Yes</td><td>Information Exchange</td><td>Official</td></tr>
<tr><td>3689</td><td>Yes</td><td>Assigned</td><td><a href="https://en.wikipedia.org/wiki/Digital_Audio_Access_Protocol">Digital Audio Access Protocol</a> (DAAP), used by <a href="https://en.wikipedia.org/wiki/Apple_Inc.">Apple's</a> <a href="https://en.wikipedia.org/wiki/ITunes">iTunes</a> and <a href="https://en.wikipedia.org/wiki/AirPlay">AirPlay</a>[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-apple-kb-HT202944-10">10]</a></td><td>Official</td></tr>
<tr><td>3690</td><td>Yes</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/Subversion_(software)">Subversion (SVN)</a>[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-apple-kb-HT202944-10">10]</a> version control system</td><td>Official</td></tr>
<tr><td>3702</td><td>Yes</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/Web_Services_Dynamic_Discovery">Web Services Dynamic Discovery</a> (WS-Discovery), used by various components of <a href="https://en.wikipedia.org/wiki/Windows_Vista">Windows Vista</a> and later</td><td>Official</td></tr>
<tr><td>3724</td><td>Yes</td><td>Yes</td><td>Some <a href="https://en.wikipedia.org/wiki/Blizzard_Entertainment">Blizzard</a> games[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-blizzard-121">120]</a></td><td>Official</td></tr>
<tr><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/Club_Penguin">Club Penguin</a> Disney online game for kids</td><td>Unofficial</td><td></td></tr>
<tr><td>3725</td><td>Yes</td><td>Yes</td><td>Netia NA-ER Port</td><td>Official</td></tr>
<tr><td>3749</td><td>Yes</td><td>Yes</td><td><a href="https://www.cimcor.com/cimtrak/">CimTrak</a> registered port</td><td>Official</td></tr>
<tr><td>3768</td><td>Yes</td><td>Yes</td><td>RBLcheckd server daemon</td><td>Official</td></tr>
<tr><td>3784</td><td></td><td>Yes</td><td>Bidirectional Forwarding Detection (BFD)for IPv4 and IPv6 (Single Hop) (<a href="https://tools.ietf.org/html/rfc5881">RFC 5881</a>)</td><td>Official</td></tr>
<tr><td>3785</td><td></td><td>Yes</td><td>VoIP program used by <a href="https://en.wikipedia.org/wiki/Ventrilo">Ventrilo</a></td><td>Unofficial</td></tr>
<tr><td>3799</td><td></td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/RADIUS">RADIUS</a> change of authorization</td><td>Official</td></tr>
<tr><td>3804</td><td>Yes</td><td>Yes</td><td>Harman Professional <a href="https://en.wikipedia.org/w/index.php?title=HiQnet&amp;action=edit&amp;redlink=1">HiQnet</a> protocol</td><td>Official</td></tr>
<tr><td>3825</td><td>Yes</td><td></td><td>RedSeal Networks client/server connection[<em><a href="https://en.wikipedia.org/wiki/Wikipedia:Citation_needed">citation needed</a></em>]</td><td>Unofficial</td></tr>
<tr><td>3826</td><td>Yes</td><td>Yes</td><td>WarMUX game server</td><td>Official</td></tr>
<tr><td>Yes</td><td></td><td>RedSeal Networks client/server connection[<em><a href="https://en.wikipedia.org/wiki/Wikipedia:Citation_needed">citation needed</a></em>]</td><td>Unofficial</td><td></td></tr>
<tr><td>3835</td><td>Yes</td><td></td><td>RedSeal Networks client/server connection[<em><a href="https://en.wikipedia.org/wiki/Wikipedia:Citation_needed">citation needed</a></em>]</td><td>Unofficial</td></tr>
<tr><td>3830</td><td>Yes</td><td>Yes</td><td>System Management Agent, developed and used by Cerner to monitor and manage solutions</td><td>Official</td></tr>
<tr><td>3856</td><td>Yes</td><td>Yes</td><td>ERP Server Application used by F10 Software</td><td>Unofficial</td></tr>
<tr><td>3880</td><td>Yes</td><td>Yes</td><td>IGRS</td><td>Official</td></tr>
<tr><td>3868</td><td>Yes, and SCTP</td><td></td><td><a href="https://en.wikipedia.org/wiki/Diameter_(protocol)">Diameter</a> base protocol (<a href="https://tools.ietf.org/html/rfc3588">RFC 3588</a>)</td><td>Official</td></tr>
<tr><td>3872</td><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/Oracle_Enterprise_Manager">Oracle Enterprise Manager</a> Remote Agent</td><td>Official</td></tr>
<tr><td>3900</td><td>Yes</td><td></td><td>udt_os, <a href="https://en.wikipedia.org/wiki/IBM_U2">IBM UniData</a> UDT OS[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-182">181]</a></td><td>Official</td></tr>
<tr><td>3960</td><td></td><td>Yes</td><td><em><a href="https://en.wikipedia.org/wiki/Warframe">Warframe</a></em> online interaction[<em><a href="https://en.wikipedia.org/wiki/Wikipedia:Citation_needed">citation needed</a></em>]</td><td>Unofficial</td></tr>
<tr><td>3962</td><td></td><td>Yes</td><td><em>Warframe</em> online interaction[<em><a href="https://en.wikipedia.org/wiki/Wikipedia:Citation_needed">citation needed</a></em>]</td><td>Unofficial</td></tr>
<tr><td>3978</td><td>Yes</td><td>Yes</td><td><em><a href="https://en.wikipedia.org/wiki/OpenTTD">OpenTTD</a></em> game (masterserver and content service)</td><td>Unofficial</td></tr>
<tr><td>3978</td><td>Yes</td><td></td><td>Palo Alto Networks' Panorama management of firewalls and log collectors &amp; pre-PAN-OS 8.0 Panorama-to-managed devices software updates.[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-EDU-120_10-183">182]</a></td><td>Unofficial</td></tr>
<tr><td>3979</td><td>Yes</td><td>Yes</td><td><em>OpenTTD</em> game</td><td>Unofficial</td></tr>
<tr><td>3999</td><td>Yes</td><td>Yes</td><td>Norman distributed scanning service</td><td>Official</td></tr>
<tr><td>4000</td><td>Yes</td><td>Yes</td><td><em><a href="https://en.wikipedia.org/wiki/Diablo_II">Diablo II</a></em> game</td><td>Unofficial</td></tr>
<tr><td>4001</td><td>Yes</td><td></td><td><em><a href="https://en.wikipedia.org/wiki/Microsoft_Ants">Microsoft Ants</a></em> game</td><td>Unofficial</td></tr>
<tr><td>Yes</td><td></td><td>CoreOS <a href="https://en.wikipedia.org/wiki/Etcd">etcd</a> client communication</td><td>Unofficial</td><td></td></tr>
<tr><td>4018</td><td>Yes</td><td>Yes</td><td>Protocol information and warnings[<em><a href="https://en.wikipedia.org/wiki/Wikipedia:Please_clarify">clarification needed</a></em>]</td><td>Official</td></tr>
<tr><td>4035</td><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/IBM">IBM</a> Rational Developer for System z Remote System Explorer Daemon</td><td>Unofficial</td></tr>
<tr><td>4045</td><td>Yes</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/Solaris_(operating_system)">Solaris</a> lockd NFS lock daemon/manager</td><td>Unofficial</td></tr>
<tr><td>4050</td><td>Yes</td><td></td><td>Mud Master Chat protocol (MMCP) - Peer-to-peer communications between <a href="https://en.wikipedia.org/wiki/MUD">MUD</a> clients.[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-184">183]</a></td><td>Unofficial</td></tr>
<tr><td>4069</td><td></td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/Minger_Email_Address_Verification_Protocol">Minger Email Address Verification Protocol</a>[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-185">184]</a></td><td>Official</td></tr>
<tr><td>4070</td><td>Yes</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/Amazon_Echo">Amazon Echo</a> Dot (<a href="https://en.wikipedia.org/wiki/Amazon_Alexa">Amazon Alexa</a>) streaming connection with <a href="https://en.wikipedia.org/wiki/Spotify">Spotify</a>[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-186">185]</a></td><td>Unofficial</td></tr>
<tr><td>4089</td><td>Yes</td><td>Yes</td><td>OpenCORE Remote Control Service</td><td>Official</td></tr>
<tr><td>4090</td><td>Yes</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/Kerio_Technologies">Kerio</a></td><td>Official</td></tr>
<tr><td>4093</td><td>Yes</td><td>Yes</td><td>PxPlus Client server interface <a href="https://en.wikipedia.org/wiki/ProvideX">ProvideX</a></td><td>Official</td></tr>
<tr><td>4096</td><td>Yes</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/Ascom_(company)">Ascom Timeplex</a> Bridge Relay Element (BRE)</td><td>Official</td></tr>
<tr><td>4105</td><td>Yes</td><td>Yes</td><td>Shofar (ShofarNexus)</td><td>Official</td></tr>
<tr><td>4111</td><td>Yes</td><td>Assigned</td><td><a href="https://en.wikipedia.org/wiki/Xgrid">Xgrid</a>[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-apple-kb-HT202944-10">10]</a></td><td>Official</td></tr>
<tr><td>4116</td><td>Yes</td><td>Yes</td><td>Smartcard-TLS</td><td>Official</td></tr>
<tr><td>4125</td><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/Microsoft_Remote_Web_Workplace">Microsoft Remote Web Workplace</a> administration</td><td>Unofficial</td></tr>
<tr><td>4172</td><td>Yes</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/Teradici">Teradici</a> <a href="https://en.wikipedia.org/wiki/PCoIP">PCoIP</a></td><td>Official</td></tr>
<tr><td>4190</td><td>Yes</td><td></td><td>ManageSieve[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-187">186]</a></td><td>Official</td></tr>
<tr><td>4198</td><td>Yes</td><td>Yes</td><td>Couch Potato Android app[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-188">187]</a></td><td>Unofficial</td></tr>
<tr><td>4201</td><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/TinyMUD">TinyMUD</a> and various derivatives</td><td>Unofficial</td></tr>
<tr><td>4222</td><td>Yes</td><td></td><td>NATS server default port[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-189">188]</a></td><td>Unofficial</td></tr>
<tr><td>4226</td><td>Yes</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/Aleph_One_(computer_game)">Aleph One</a>, a computer game</td><td>Unofficial</td></tr>
<tr><td>4242</td><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/Orthanc_(software)">Orthanc</a> – <a href="https://en.wikipedia.org/wiki/DICOM">DICOM</a> server[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-orthanc-book-configuration-190">189]</a></td><td>Unofficial</td></tr>
<tr><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/Quassel">Quassel</a> distributed IRC client</td><td>Unofficial</td><td></td></tr>
<tr><td>4243</td><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/Docker_(software)">Docker</a> implementations, redistributions, and setups default[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-191">190]</a>[<em><a href="https://en.wikipedia.org/wiki/Wikipedia:Manual_of_Style/Dates_and_numbers#Chronological_items">needs update?</a></em>]</td><td>Unofficial</td></tr>
<tr><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/CrashPlan">CrashPlan</a></td><td>Unofficial</td><td></td></tr>
<tr><td>4244</td><td>Yes</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/Viber">Viber</a>[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-viber-192">191]</a></td><td>Unofficial</td></tr>
<tr><td>4303</td><td>Yes</td><td>Yes</td><td>Simple Railroad Command Protocol (SRCP)</td><td>Official</td></tr>
<tr><td>4307</td><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/TrueConf">TrueConf</a> Client - TrueConf Server media data exchange[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-193">192]</a></td><td>Official</td></tr>
<tr><td>4321</td><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/RWhois">Referral Whois (RWhois) Protocol</a>[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-194">193]</a></td><td>Official</td></tr>
<tr><td>4444</td><td>Yes</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/Oracle_Corporation">Oracle</a> WebCenter Content: Content Server—Intradoc Socket port. (formerly known as Oracle <a href="https://en.wikipedia.org/wiki/Universal_Content_Management">Universal Content Management</a>).</td><td>Unofficial</td></tr>
<tr><td>?</td><td>?</td><td><a href="https://en.wikipedia.org/wiki/Metasploit">Metasploit</a>'s default listener port[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-195">194]</a></td><td>Unofficial</td><td></td></tr>
<tr><td>Yes</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/Xvfb">Xvfb</a> X server virtual frame buffer service</td><td>Unofficial</td><td></td></tr>
<tr><td>4444–4445</td><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/I2P">I2P</a> HTTP/S proxy</td><td>Unofficial</td></tr>
<tr><td>4486</td><td>Yes</td><td>Yes</td><td>Integrated Client Message Service (ICMS)</td><td>Official</td></tr>
<tr><td>4488</td><td>Yes</td><td>Assigned</td><td>Apple Wide Area Connectivity Service, used by <a href="https://en.wikipedia.org/wiki/Back_to_My_Mac">Back to My Mac</a>[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-apple-kb-HT202944-10">10]</a></td><td>Official</td></tr>
<tr><td>4500</td><td>Assigned</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/IPsec_Passthrough">IPSec NAT Traversal</a>[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-apple-kb-HT202944-10">10]</a> (<a href="https://tools.ietf.org/html/rfc3947">RFC 3947</a>, <a href="https://tools.ietf.org/html/rfc4306">RFC 4306</a>)</td><td>Official</td></tr>
<tr><td>4502–4534</td><td>Yes</td><td></td><td>Microsoft Silverlight connectable ports under non-elevated trust</td><td>Official</td></tr>
<tr><td>4505–4506</td><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/Salt_(software)">Salt</a> master</td><td>Unofficial</td></tr>
<tr><td>4534</td><td></td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/Armagetron_Advanced">Armagetron Advanced</a> server default</td><td>Unofficial</td></tr>
<tr><td>4560</td><td>Yes</td><td></td><td>default <a href="https://en.wikipedia.org/wiki/Log4j">Log4j</a> socketappender port</td><td>Unofficial</td></tr>
<tr><td>4567</td><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/Sinatra_(software)">Sinatra</a> default server port in development mode (HTTP)</td><td>Unofficial</td></tr>
<tr><td>4569</td><td></td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/Inter-Asterisk_eXchange">Inter-Asterisk eXchange</a> (IAX2)</td><td>Official</td></tr>
<tr><td>4604</td><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/Identity_Registration_Protocol">Identity Registration Protocol</a></td><td>Official</td></tr>
<tr><td>4605</td><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/Direct_End_to_End_Secure_Chat_Protocol">Direct End to End Secure Chat Protocol</a></td><td>Official</td></tr>
<tr><td>4610–4640</td><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/QualiSystems">QualiSystems</a> TestShell Suite Services</td><td>Unofficial</td></tr>
<tr><td>4662</td><td>Yes</td><td>Yes</td><td>OrbitNet Message Service</td><td>Official</td></tr>
<tr><td>Yes</td><td></td><td>Default for older versions of <a href="https://en.wikipedia.org/wiki/EMule">eMule</a>[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-eMule-196">195]</a></td><td>Unofficial</td><td></td></tr>
<tr><td>4664</td><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/Google_Desktop">Google Desktop Search</a></td><td>Unofficial</td></tr>
<tr><td>4672</td><td></td><td>Yes</td><td>Default for older versions of <a href="https://en.wikipedia.org/wiki/EMule">eMule</a>[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-eMule-196">195]</a></td><td>Unofficial</td></tr>
<tr><td>4711</td><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/EMule">eMule</a> optional web interface[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-eMule-196">195]</a></td><td>Unofficial</td></tr>
<tr><td>4713</td><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/PulseAudio">PulseAudio</a> sound server</td><td>Unofficial</td></tr>
<tr><td>4728</td><td>Yes</td><td></td><td>Computer Associates Desktop and Server Management (DMP)/Port Multiplexer[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-SANS-197">196]</a></td><td>Official</td></tr>
<tr><td>4730</td><td>Yes</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/Gearman">Gearman</a>'s job server</td><td>Official</td></tr>
<tr><td>4739</td><td>Yes</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/IP_Flow_Information_Export">IP Flow Information Export</a></td><td>Official</td></tr>
<tr><td>4747</td><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/Apprentice_(software)">Apprentice</a></td><td>Unofficial</td></tr>
<tr><td>4753</td><td>Yes</td><td>Yes</td><td>SIMON (service and discovery)</td><td>Official</td></tr>
<tr><td>4789</td><td></td><td>Yes</td><td>Virtual eXtensible Local Area Network (<a href="https://en.wikipedia.org/wiki/Virtual_Extensible_LAN">VXLAN</a>)</td><td>Official</td></tr>
<tr><td>4791</td><td></td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/RDMA_over_Converged_Ethernet">IP Routable RocE</a> (RoCEv2)</td><td>Official</td></tr>
<tr><td>4840</td><td>Yes</td><td>Yes</td><td>OPC UA Connection Protocol (TCP) and OPC UA Multicast Datagram Protocol (UDP) for <a href="https://en.wikipedia.org/wiki/OPC_Unified_Architecture">OPC Unified Architecture</a> from <a href="https://en.wikipedia.org/wiki/OPC_Foundation">OPC Foundation</a></td><td>Official</td></tr>
<tr><td>4843</td><td>Yes</td><td>Yes</td><td>OPC UA TCP Protocol over TLS/SSL for <a href="https://en.wikipedia.org/wiki/OPC_Unified_Architecture">OPC Unified Architecture</a> from <a href="https://en.wikipedia.org/wiki/OPC_Foundation">OPC Foundation</a></td><td>Official</td></tr>
<tr><td>4847</td><td>Yes</td><td>Yes</td><td>Web Fresh Communication, Quadrion Software &amp; Odorless Entertainment</td><td>Official</td></tr>
<tr><td>4848</td><td>Yes</td><td></td><td>Java, Glassfish Application Server administration default</td><td>Unofficial</td></tr>
<tr><td>4894</td><td>Yes</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/LysKOM">LysKOM</a> Protocol A</td><td>Official</td></tr>
<tr><td>4944</td><td>No</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/DrayTek">DrayTek</a> DSL Status Monitoring[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-draytek-support-5365-198">197]</a>[<em><a href="https://en.wikipedia.org/wiki/Wikipedia:Verifiability#Self-published_sources">self-published source</a></em>]</td><td>Unofficial</td></tr>
<tr><td>4949</td><td>Yes</td><td></td><td>Munin Resource Monitoring Tool</td><td>Official</td></tr>
<tr><td>4950</td><td>Yes</td><td>Yes</td><td>Cylon Controls UC32 Communications Port</td><td>Official</td></tr>
<tr><td>5000</td><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/Universal_Plug_and_Play">UPnP</a>—Windows network device interoperability</td><td>Unofficial</td></tr>
<tr><td>Yes</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/VTun">VTun</a>, <a href="https://en.wikipedia.org/wiki/VPN">VPN</a> Software</td><td>Unofficial</td><td></td></tr>
<tr><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/ASP.NET_Core">ASP.NET Core</a> — Development Webserver</td><td>Unofficial</td><td></td></tr>
<tr><td></td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/FlightGear">FlightGear</a> multiplayer[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-auto-199">198]</a></td><td>Unofficial</td><td></td></tr>
<tr><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/Synology_Inc.">Synology Inc.</a> Management Console, File Station, Audio Station</td><td>Unofficial</td><td></td></tr>
<tr><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/Flask_(web_framework)">Flask</a> Development Webserver</td><td>Unofficial</td><td></td></tr>
<tr><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/Heroku">Heroku</a> console access</td><td>Unofficial</td><td></td></tr>
<tr><td>?</td><td>?</td><td><a href="https://en.wikipedia.org/wiki/Docker_(software)">Docker</a> Registry[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-200">199]</a>[<em><a href="https://en.wikipedia.org/wiki/Wikipedia:Verifiability#Self-published_sources">self-published source</a></em>]</td><td>Unofficial</td><td></td></tr>
<tr><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/AT%26T_U-verse">AT&amp;T U-verse</a> <a href="https://en.wikipedia.org/wiki/Public,_educational,_and_government_access">public, educational, and government access</a> (PEG) streaming over <a href="https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol">HTTP</a>[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-201">200]</a>[<em><a href="https://en.wikipedia.org/wiki/Wikipedia:Verifiability#Self-published_sources">self-published source?</a></em>]</td><td>Unofficial</td><td></td></tr>
<tr><td>?</td><td>?</td><td><a href="https://en.wikipedia.org/wiki/High-Speed_SECS_Message_Services">High-Speed SECS Message Services</a>[<em><a href="https://en.wikipedia.org/wiki/Wikipedia:Citation_needed">citation needed</a></em>]</td><td>Unofficial</td><td></td></tr>
<tr><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/3CX_Phone_System">3CX Phone System</a> Legacy Management Console</td><td>Unofficial</td><td></td></tr>
<tr><td>5000–5500</td><td>No</td><td>Yes</td><td><em><a href="https://en.wikipedia.org/wiki/League_of_Legends">League of Legends</a></em>, a <a href="https://en.wikipedia.org/wiki/Multiplayer_online_battle_arena">multiplayer online battle arena</a> video game[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-riotgames-kb-201752664-202">201]</a></td><td>Unofficial</td></tr>
<tr><td>5001</td><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/Slingbox">Slingbox</a> and Slingplayer</td><td>Unofficial</td></tr>
<tr><td>Yes</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/Iperf">Iperf</a> (Tool for measuring TCP and UDP bandwidth performance)</td><td>Unofficial</td><td></td></tr>
<tr><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/Synology_Inc.">Synology Inc.</a> Secured Management Console, File Station, Audio Station</td><td>Unofficial</td><td></td></tr>
<tr><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/3CX_Phone_System">3CX Phone System</a> Secured Management Console, Secure API</td><td>Unofficial</td><td></td></tr>
<tr><td>5002</td><td>Yes</td><td></td><td>ASSA ARX access control system[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-203">202]</a></td><td>Unofficial</td></tr>
<tr><td>5003</td><td>Yes</td><td>Assigned</td><td><a href="https://en.wikipedia.org/wiki/FileMaker">FileMaker</a> – name binding and transport[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-apple-kb-HT202944-10">10]</a></td><td>Official</td></tr>
<tr><td>5004</td><td>Yes, and DCCP</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/Real-time_Transport_Protocol">Real-time Transport Protocol</a> media data (RTP) (<a href="https://tools.ietf.org/html/rfc3551">RFC 3551</a>, <a href="https://tools.ietf.org/html/rfc4571">RFC 4571</a>)</td><td>Official</td></tr>
<tr><td>5005</td><td>Yes, and DCCP</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/RTP_Control_Protocol">Real-time Transport Protocol control protocol</a> (RTCP) (<a href="https://tools.ietf.org/html/rfc3551">RFC 3551</a>, <a href="https://tools.ietf.org/html/rfc4571">RFC 4571</a>)</td><td>Official</td></tr>
<tr><td>5007</td><td>Yes</td><td></td><td>Palo Alto Networks - User-ID agent</td><td>Unofficial</td></tr>
<tr><td>5010</td><td>Yes</td><td>Yes</td><td>Registered to: TelePath (the IBM FlowMark <a href="https://en.wikipedia.org/wiki/Workflow-management_system">workflow-management system</a> messaging platform)[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-Hill-204">203]</a> The TCP port is now used for: IBM <a href="https://en.wikipedia.org/wiki/WebSphere_MQ">WebSphere MQ</a> Workflow</td><td>Official</td></tr>
<tr><td>5011</td><td>Yes</td><td>Yes</td><td>TelePath (the IBM FlowMark <a href="https://en.wikipedia.org/wiki/Workflow-management_system">workflow-management system</a> messaging platform)[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-Hill-204">203]</a></td><td>Official</td></tr>
<tr><td>5025</td><td>Yes</td><td>Yes</td><td>scpi-raw <a href="https://en.wikipedia.org/wiki/Standard_Commands_for_Programmable_Instruments">Standard Commands for Programmable Instruments</a></td><td>Official</td></tr>
<tr><td>5029</td><td></td><td>Yes</td><td>Sonic Robo Blast 2 and Sonic Robo Blast 2 Kart servers</td><td>Unofficial</td></tr>
<tr><td>5031</td><td>Yes</td><td>Yes</td><td>AVM CAPI-over-TCP (<a href="https://en.wikipedia.org/wiki/ISDN">ISDN</a> over <a href="https://en.wikipedia.org/wiki/Ethernet">Ethernet</a> tunneling)[<em><a href="https://en.wikipedia.org/wiki/Wikipedia:Citation_needed">citation needed</a></em>]</td><td>Unofficial</td></tr>
<tr><td>5037</td><td>Yes</td><td></td><td>Android ADB server</td><td>Unofficial</td></tr>
<tr><td>5044</td><td>Yes</td><td></td><td>Standard port in Filebeats/Logstash implementation of Lumberjack protocol.</td><td>Official</td></tr>
<tr><td>5048</td><td>Yes</td><td></td><td>Texai Message Service</td><td>Official</td></tr>
<tr><td>5050</td><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/Yahoo!_Messenger">Yahoo! Messenger</a></td><td>Unofficial</td></tr>
<tr><td>5051</td><td>Yes</td><td></td><td>ita-agent <a href="https://en.wikipedia.org/wiki/NortonLifeLock">Symantec</a> Intruder Alert[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-205">204]</a></td><td>Official</td></tr>
<tr><td>5060</td><td>Yes</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/Session_Initiation_Protocol">Session Initiation Protocol</a> (SIP)[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-apple-kb-HT202944-10">10]</a></td><td>Official</td></tr>
<tr><td>5061</td><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/Session_Initiation_Protocol">Session Initiation Protocol</a> (SIP) over <a href="https://en.wikipedia.org/wiki/Transport_Layer_Security">TLS</a></td><td>Official</td></tr>
<tr><td>5062</td><td>Yes</td><td>Yes</td><td>Localisation access</td><td>Official</td></tr>
<tr><td>5064</td><td>Yes</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/EPICS">EPICS</a> Channel Access server[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-epics-r3.14-reference-manual-206">205]</a></td><td>Official</td></tr>
<tr><td>5065</td><td>Assigned</td><td>Yes</td><td>EPICS Channel Access repeater beacon[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-epics-r3.14-reference-manual-206">205]</a></td><td>Official</td></tr>
<tr><td>5070</td><td>Yes</td><td>No</td><td><a href="https://en.wikipedia.org/w/index.php?title=Binary_Floor_Control_Protocol&amp;action=edit&amp;redlink=1">Binary Floor Control Protocol</a> (BFCP)[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-rfc4582-207">206]</a></td><td>Unofficial</td></tr>
<tr><td>5084</td><td>Yes</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/EPCglobal">EPCglobal</a> Low Level Reader Protocol (<a href="https://en.wikipedia.org/wiki/LLRP">LLRP</a>)</td><td>Official</td></tr>
<tr><td>5085</td><td>Yes</td><td>Yes</td><td>EPCglobal Low Level Reader Protocol (<a href="https://en.wikipedia.org/wiki/LLRP">LLRP</a>) over <a href="https://en.wikipedia.org/wiki/Transport_Layer_Security">TLS</a></td><td>Official</td></tr>
<tr><td>5090</td><td>Yes</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/3CX_Phone_System">3CX Phone System</a> 3CX Tunnel Protocol, 3CX App API, 3CX Session Border Controller</td><td>Unofficial</td></tr>
<tr><td>5093</td><td></td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/SafeNet">SafeNet, Inc</a> Sentinel LM, Sentinel RMS, License Manager, client-to-server</td><td>Official</td></tr>
<tr><td>5099</td><td>Yes</td><td>Yes</td><td>SafeNet, Inc Sentinel LM, Sentinel RMS, License Manager, server-to-server</td><td>Official</td></tr>
<tr><td>5104</td><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/IBM">IBM</a> <a href="https://en.wikipedia.org/w/index.php?title=IBM_Tivoli_Framework&amp;action=edit&amp;redlink=1">Tivoli Framework</a> NetCOOL/Impact[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-208">207]</a> <a href="https://en.wikipedia.org/wiki/HTTP">HTTP</a> Service</td><td>Unofficial</td></tr>
<tr><td>5121</td><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/Neverwinter_Nights">Neverwinter Nights</a></td><td>Unofficial</td></tr>
<tr><td>5124</td><td>Yes</td><td>Yes</td><td>TorgaNET (<a href="https://en.wikipedia.org/wiki/Micronation">Micronational</a> <a href="https://en.wikipedia.org/wiki/Darknet">Darknet</a>)</td><td>Unofficial</td></tr>
<tr><td>5125</td><td>Yes</td><td>Yes</td><td>TorgaNET (<a href="https://en.wikipedia.org/wiki/Micronation">Micronational</a> Intelligence <a href="https://en.wikipedia.org/wiki/Darknet">Darknet</a>)</td><td>Unofficial</td></tr>
<tr><td>5150</td><td>Yes</td><td>Yes</td><td>ATMP Ascend Tunnel Management Protocol[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-209">208]</a></td><td>Official</td></tr>
<tr><td>5151</td><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/Environmental_Systems_Research_Institute">ESRI</a> SDE Instance</td><td>Official</td></tr>
<tr><td></td><td>Yes</td><td>ESRI SDE Remote Start</td><td>Official</td><td></td></tr>
<tr><td>5154</td><td>Yes</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/BZFlag">BZFlag</a></td><td>Official</td></tr>
<tr><td>5172</td><td>Yes</td><td></td><td>PC over IP Endpoint Management[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-210">209]</a></td><td>Official</td></tr>
<tr><td>5190</td><td>Yes</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/AOL_Instant_Messenger">AOL Instant Messenger</a> protocol.[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-apple-kb-HT202944-10">10]</a> The chat app is defunct as of 15 December 2017.[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-vice-rip-aim-211">210]</a></td><td>Official</td></tr>
<tr><td>5198</td><td></td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/Echolink">EchoLink</a> VoIP Amateur Radio Software (Voice)</td><td>Unofficial</td></tr>
<tr><td>5199</td><td></td><td>Yes</td><td>EchoLink VoIP Amateur Radio Software (Voice)</td><td>Unofficial</td></tr>
<tr><td>5200</td><td>Yes</td><td></td><td>EchoLink VoIP Amateur Radio Software (Information)</td><td>Unofficial</td></tr>
<tr><td>5201</td><td>Yes</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/Iperf3">Iperf3</a> (Tool for measuring TCP and UDP bandwidth performance)</td><td>Unofficial</td></tr>
<tr><td>5222</td><td>Yes</td><td>Reserved</td><td><a href="https://en.wikipedia.org/wiki/Extensible_Messaging_and_Presence_Protocol">Extensible Messaging and Presence Protocol</a> (XMPP) client connection[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-apple-kb-HT202944-10">10]</a>[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-rfc3920-212">211]</a>[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-rfc6120-213">212]</a></td><td>Official</td></tr>
<tr><td>5223</td><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/Apple_Push_Notification_Service">Apple Push Notification Service</a>[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-apple-kb-HT202944-10">10]</a>[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-apple-kb-HT203609-152">151]</a></td><td>Unofficial</td></tr>
<tr><td>Yes</td><td></td><td>Extensible Messaging and Presence Protocol (XMPP) client connection over <a href="https://en.wikipedia.org/wiki/Secure_Sockets_Layer">SSL</a></td><td>Unofficial</td><td></td></tr>
<tr><td>5228</td><td>Yes</td><td></td><td>HP Virtual Room Service</td><td>Official</td></tr>
<tr><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/Google_Play">Google Play</a>, <a href="https://en.wikipedia.org/wiki/Android_Cloud_to_Device_Messaging_Service">Android Cloud to Device Messaging Service</a>, <a href="https://en.wikipedia.org/wiki/Google_Cloud_Messaging">Google Cloud Messaging</a></td><td>Unofficial</td><td></td></tr>
<tr><td>5242</td><td>Yes</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/Viber">Viber</a>[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-viber-192">191]</a></td><td>Unofficial</td></tr>
<tr><td>5243</td><td>Yes</td><td>Yes</td><td>Viber[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-viber-192">191]</a></td><td>Unofficial</td></tr>
<tr><td>5246</td><td></td><td>Yes</td><td>Control And Provisioning of Wireless Access Points (<a href="https://en.wikipedia.org/wiki/CAPWAP">CAPWAP</a>) CAPWAP control[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-rfc5415-214">213]</a></td><td>Official</td></tr>
<tr><td>5247</td><td></td><td>Yes</td><td>Control And Provisioning of Wireless Access Points (CAPWAP) CAPWAP data[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-rfc5415-214">213]</a></td><td>Official</td></tr>
<tr><td>5269</td><td>Yes</td><td></td><td>Extensible Messaging and Presence Protocol (XMPP) server-to-server connection[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-apple-kb-HT202944-10">10]</a>[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-rfc3920-212">211]</a>[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-rfc6120-213">212]</a></td><td>Official</td></tr>
<tr><td>5280</td><td>Yes</td><td></td><td>Extensible Messaging and Presence Protocol (XMPP)[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-215">214]</a></td><td>Official</td></tr>
<tr><td>5281</td><td>Yes</td><td></td><td>Extensible Messaging and Presence Protocol (XMPP)[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-216">215]</a></td><td>Unofficial</td></tr>
<tr><td>5298</td><td>Yes</td><td>Yes</td><td>Extensible Messaging and Presence Protocol (XMPP)[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-217">216]</a></td><td>Official</td></tr>
<tr><td>5310</td><td>Assigned</td><td>Yes</td><td><em><a href="https://en.wikipedia.org/wiki/Outlaws_(1997_video_game)">Outlaws</a></em>, a 1997 first-person shooter video game[<em><a href="https://en.wikipedia.org/wiki/Wikipedia:Citation_needed">citation needed</a></em>]</td><td>Official</td></tr>
<tr><td>5318</td><td>Yes</td><td>Reserved</td><td><a href="https://en.wikipedia.org/wiki/Certificate_Management_over_CMS">Certificate Management over CMS</a>[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-rfc6402-218">217]</a></td><td>Official</td></tr>
<tr><td>5349</td><td>Yes/No</td><td>Yes/No</td><td><a href="https://en.wikipedia.org/wiki/STUN">STUN</a> over <a href="https://en.wikipedia.org/wiki/Transport_Layer_Security">TLS</a>/<a href="https://en.wikipedia.org/wiki/Datagram_Transport_Layer_Security">DTLS</a>, a protocol for <a href="https://en.wikipedia.org/wiki/NAT_traversal">NAT traversal</a>[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-STUN-177">176]</a></td><td>Official</td></tr>
<tr><td>Yes/No</td><td>Yes/No</td><td><a href="https://en.wikipedia.org/wiki/Traversal_Using_Relay_NAT">TURN</a> over TLS/DTLS, a protocol for NAT traversal[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-TURN-178">177]</a></td><td>Official</td><td></td></tr>
<tr><td>Yes</td><td>Reserved</td><td>STUN Behavior Discovery over TLS.[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-rfc5780-179">178]</a> See also port 3478.</td><td>Official</td><td></td></tr>
<tr><td>5351</td><td>Reserved</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/NAT_Port_Mapping_Protocol">NAT Port Mapping Protocol</a> and <a href="https://en.wikipedia.org/wiki/Port_Control_Protocol">Port Control Protocol</a>—client-requested configuration for connections through <a href="https://en.wikipedia.org/wiki/Network_Address_Translation">network address translators</a> and <a href="https://en.wikipedia.org/wiki/Firewall_(computing)">firewalls</a></td><td>Official</td></tr>
<tr><td>5353</td><td>Assigned</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/Multicast_DNS">Multicast DNS</a> (mDNS)[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-apple-kb-HT202944-10">10]</a></td><td>Official</td></tr>
<tr><td>5355</td><td>Yes</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/LLMNR">Link-Local Multicast Name Resolution</a> (LLMNR), allows <a href="https://en.wikipedia.org/wiki/Host_(network)">hosts</a> to perform <a href="https://en.wikipedia.org/wiki/Hostname_resolution">name resolution</a> for hosts on the same <a href="https://en.wikipedia.org/wiki/Local_area_network">local link</a> (only provided by <a href="https://en.wikipedia.org/wiki/Windows_Vista">Windows Vista</a> and <a href="https://en.wikipedia.org/wiki/Server_2008">Server 2008</a>)</td><td>Official</td></tr>
<tr><td>5357</td><td>Yes</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/Web_Services_for_Devices">Web Services for Devices</a> (WSDAPI) (only provided by Windows Vista, Windows 7 and Server 2008)</td><td>Unofficial</td></tr>
<tr><td>5358</td><td>Yes</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/Web_Services_for_Devices">WSDAPI</a> Applications to Use a Secure Channel (only provided by Windows Vista, Windows 7 and Server 2008)</td><td>Unofficial</td></tr>
<tr><td>5394</td><td></td><td>Yes</td><td>Kega Fusion, a Sega multi-console emulator[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-Niobium-219">218]</a>[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-220">219]</a></td><td>Unofficial</td></tr>
<tr><td>5402</td><td>Yes</td><td>Yes</td><td><a href="https://en.wikipedia.org/w/index.php?title=Multicast_File_Transfer_Protocol&amp;action=edit&amp;redlink=1">Multicast File Transfer Protocol</a> (MFTP)[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-draft-miller-mftp-spec-03-221">220]</a>[<em><a href="https://en.wikipedia.org/wiki/Wikipedia:What_Wikipedia_is_not#Encyclopedic_content">importance?</a></em>]</td><td>Official</td></tr>
<tr><td>5405</td><td>Yes</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/NetSupport_Manager">NetSupport Manager</a></td><td>Official</td></tr>
<tr><td>5412</td><td>Yes</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/IBM">IBM</a> Rational Synergy (<a href="https://en.wikipedia.org/wiki/Telelogic_Synergy">Telelogic Synergy</a>) (Continuus CM) Message Router</td><td>Official</td></tr>
<tr><td>5413</td><td>Yes</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/Wonderware">Wonderware</a> SuiteLink service</td><td>Official</td></tr>
<tr><td>5417</td><td>Yes</td><td>Yes</td><td>SNS Agent</td><td>Official</td></tr>
<tr><td>5421</td><td>Yes</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/NetSupport_Manager">NetSupport Manager</a></td><td>Official</td></tr>
<tr><td>5432</td><td>Yes</td><td>Assigned</td><td><a href="https://en.wikipedia.org/wiki/PostgreSQL">PostgreSQL</a>[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-apple-kb-HT202944-10">10]</a> database system</td><td>Official</td></tr>
<tr><td>5433</td><td>Yes</td><td></td><td>Bouwsoft file/webserver[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-222">221]</a></td><td>Unofficial</td></tr>
<tr><td>5445</td><td></td><td>Yes</td><td>Cisco Unified Video Advantage[<em><a href="https://en.wikipedia.org/wiki/Wikipedia:Citation_needed">citation needed</a></em>]</td><td>Unofficial</td></tr>
<tr><td>5480</td><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/VMware">VMware</a> VAMI (Virtual Appliance Management Infrastructure)—used for initial setup of various administration settings on Virtual Appliances designed using the VAMI architecture.</td><td>Unofficial</td></tr>
<tr><td>5481</td><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/Schneider_Electric">Schneider Electric</a>'s ClearSCADA (<a href="https://en.wikipedia.org/wiki/SCADA">SCADA</a> implementation for Windows) — used for client-to-server communication.[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-223">222]</a></td><td>Unofficial</td></tr>
<tr><td>5495</td><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/TM1">IBM Cognos TM1</a> Admin server</td><td>Unofficial</td></tr>
<tr><td>5498</td><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/Hotline_Communications">Hotline</a> tracker server connection</td><td>Unofficial</td></tr>
<tr><td>5499</td><td></td><td>Yes</td><td>Hotline tracker server discovery</td><td>Unofficial</td></tr>
<tr><td>5500</td><td>Yes</td><td></td><td>Hotline control connection</td><td>Unofficial</td></tr>
<tr><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/Virtual_Network_Computing">VNC</a> Remote Frame Buffer <a href="https://en.wikipedia.org/wiki/RFB_protocol">RFB protocol</a>—for incoming listening viewer</td><td>Unofficial</td><td></td></tr>
<tr><td>5501</td><td>Yes</td><td></td><td>Hotline file transfer connection</td><td>Unofficial</td></tr>
<tr><td>5517</td><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/SETI@home#Software">Setiqueue</a> Proxy server client for <a href="https://en.wikipedia.org/wiki/SETI@Home">SETI@Home</a> project</td><td>Unofficial</td></tr>
<tr><td>5550</td><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/Hewlett-Packard">Hewlett-Packard</a> Data Protector[<em><a href="https://en.wikipedia.org/wiki/Wikipedia:Citation_needed">citation needed</a></em>]</td><td>Unofficial</td></tr>
<tr><td>5554</td><td>Yes</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/Fastboot">Fastboot</a> default wireless port</td><td>Unofficial</td></tr>
<tr><td>5555</td><td>Yes</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/Oracle_Corporation">Oracle</a> WebCenter Content: Inbound Refinery—Intradoc Socket port. (formerly known as Oracle <a href="https://en.wikipedia.org/wiki/Universal_Content_Management">Universal Content Management</a>). Port though often changed during installation</td><td>Unofficial</td></tr>
<tr><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/Freeciv">Freeciv</a> versions up to 2.0, <a href="https://en.wikipedia.org/wiki/Hewlett-Packard">Hewlett-Packard</a> Data Protector, <a href="https://en.wikipedia.org/wiki/Comparison_of_disk_encryption_software">McAfee EndPoint Encryption</a> Database Server, <a href="https://en.wikipedia.org/wiki/Session_Announcement_Protocol">SAP</a>, Default for Microsoft Dynamics CRM 4.0, Softether VPN default port</td><td>Unofficial</td><td></td></tr>
<tr><td>5556</td><td>Yes</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/Freeciv">Freeciv</a>, Oracle WebLogic Server Node Manager[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-224">223]</a></td><td>Official</td></tr>
<tr><td>5568</td><td>Yes</td><td>Yes</td><td>Session Data Transport (SDT), a part of <a href="https://en.wikipedia.org/wiki/Architecture_for_Control_Networks">Architecture for Control Networks</a> (ACN)[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-ANSI_E1.17-2010-225">224]</a>[<em><a href="https://en.wikipedia.org/wiki/Wikipedia:Citing_sources#What_information_to_include">full citation needed</a></em>]</td><td>Official</td></tr>
<tr><td>5601</td><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/Kibana">Kibana</a>[<em><a href="https://en.wikipedia.org/wiki/Wikipedia:Citation_needed">citation needed</a></em>]</td><td>Unofficial</td></tr>
<tr><td>5631</td><td>Yes</td><td></td><td>pcANYWHEREdata, <a href="https://en.wikipedia.org/wiki/NortonLifeLock">Symantec</a> <a href="https://en.wikipedia.org/wiki/Pcanywhere">pcAnywhere</a> (version 7.52 and later[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-226">225]</a>)[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-227">226]</a> data</td><td>Official</td></tr>
<tr><td>5632</td><td></td><td>Yes</td><td>pcANYWHEREstat, Symantec pcAnywhere (version 7.52 and later) status</td><td>Official</td></tr>
<tr><td>5656</td><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/IBM_Lotus_Sametime">IBM Lotus Sametime</a> p2p file transfer</td><td>Unofficial</td></tr>
<tr><td>5666</td><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/NRPE">NRPE</a> (<a href="https://en.wikipedia.org/wiki/Nagios">Nagios</a>)</td><td>Unofficial</td></tr>
<tr><td>5667</td><td>Yes</td><td></td><td>NSCA (Nagios)</td><td>Unofficial</td></tr>
<tr><td>5670</td><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/w/index.php?title=FILEMQ&amp;action=edit&amp;redlink=1">FILEMQ</a> ZeroMQ File Message Queuing Protocol</td><td>Official</td></tr>
<tr><td></td><td>Yes</td><td><a href="https://en.wikipedia.org/w/index.php?title=ZRE-DISC&amp;action=edit&amp;redlink=1">ZRE-DISC</a> ZeroMQ Realtime Exchange Protocol (Discovery)</td><td>Official</td><td></td></tr>
<tr><td>5671</td><td>Yes</td><td>Assigned</td><td><a href="https://en.wikipedia.org/wiki/Advanced_Message_Queuing_Protocol">Advanced Message Queuing Protocol</a> (AMQP)[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-ampq-228">227]</a> over <a href="https://en.wikipedia.org/wiki/Transport_Layer_Security">TLS</a></td><td>Official</td></tr>
<tr><td>5672</td><td>Yes, and SCTP</td><td>Assigned</td><td>Advanced Message Queuing Protocol (AMQP)[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-ampq-228">227]</a></td><td>Official</td></tr>
<tr><td>5683</td><td>Yes</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/Constrained_Application_Protocol">Constrained Application Protocol</a> (CoAP)</td><td>Official</td></tr>
<tr><td>5684</td><td>Yes/No</td><td>Yes</td><td>Constrained Application Protocol Secure (CoAPs)</td><td>Official</td></tr>
<tr><td>5693</td><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/Nagios">Nagios</a> Cross Platform Agent (NCPA)[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-229">228]</a></td><td>Unofficial</td></tr>
<tr><td>5701</td><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/Hazelcast">Hazelcast</a> default communication port[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-230">229]</a></td><td>Unofficial</td></tr>
<tr><td>5722</td><td>Yes</td><td>Yes</td><td>Microsoft RPC, DFSR (SYSVOL) Replication Service[<em><a href="https://en.wikipedia.org/wiki/Wikipedia:Citation_needed">citation needed</a></em>]</td><td>Official</td></tr>
<tr><td>5718</td><td>Yes</td><td></td><td>Microsoft DPM Data Channel (with the agent coordinator)</td><td>Unofficial</td></tr>
<tr><td>5719</td><td>Yes</td><td></td><td>Microsoft DPM Data Channel (with the protection agent)</td><td>Unofficial</td></tr>
<tr><td>5723</td><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/System_Center_Operations_Manager">System Center Operations Manager</a>[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-231">230]</a></td><td>Unofficial</td></tr>
<tr><td>5724</td><td>Yes</td><td></td><td>Operations Manager Console</td><td>Unofficial</td></tr>
<tr><td>5741</td><td>Yes</td><td>Yes</td><td>IDA Discover Port 1</td><td>Official</td></tr>
<tr><td>5742</td><td>Yes</td><td>Yes</td><td>IDA Discover Port 2</td><td>Official</td></tr>
<tr><td>5800</td><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/Virtual_Network_Computing">VNC</a> Remote Frame Buffer <a href="https://en.wikipedia.org/wiki/RFB_protocol">RFB protocol</a> over <a href="https://en.wikipedia.org/wiki/HTTP">HTTP</a></td><td>Unofficial</td></tr>
<tr><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/ProjectWise">ProjectWise Server</a>[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-232">231]</a></td><td>Unofficial</td><td></td></tr>
<tr><td>5900</td><td>Yes</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/RFB_protocol">Remote Frame Buffer protocol</a> (RFB)</td><td>Official</td></tr>
<tr><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/Virtual_Network_Computing">Virtual Network Computing</a> (VNC) Remote Frame Buffer <a href="https://en.wikipedia.org/wiki/RFB_protocol">RFB protocol</a>[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-apple-kb-HT202944-10">10]</a>[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-233">232]</a></td><td>Unofficial</td><td></td></tr>
<tr><td>5931</td><td>Yes</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/AMMYY">AMMYY</a> admin Remote Control</td><td>Official</td></tr>
<tr><td>5938</td><td>Yes</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/TeamViewer">TeamViewer</a> remote desktop protocol[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-234">233]</a></td><td>Unofficial</td></tr>
<tr><td>5984</td><td>Yes</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/CouchDB">CouchDB</a> database server</td><td>Official</td></tr>
<tr><td>5985</td><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/Windows_PowerShell">Windows PowerShell</a> Default psSession Port[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-Enter-PSSession-235">234]</a> <a href="https://en.wikipedia.org/wiki/WS-Management">Windows Remote Management Service</a> (WinRM-HTTP)[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-microsoft1-236">235]</a></td><td>Official</td></tr>
<tr><td>5986</td><td>Yes</td><td></td><td>Windows PowerShell Default psSession Port[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-Enter-PSSession-235">234]</a> <a href="https://en.wikipedia.org/wiki/WS-Management">Windows Remote Management Service</a> (WinRM-HTTPS)[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-microsoft1-236">235]</a></td><td>Official</td></tr>
<tr><td>5988–5989</td><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/Common_Information_Model_(computing)">CIM</a>-XML (DMTF Protocol)[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-237">236]</a></td><td>Official</td></tr>
<tr><td>6000–6063</td><td>Yes</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/X_Window_System">X11</a>—used between an X client and server over the network</td><td>Official</td></tr>
<tr><td>6005</td><td>Yes</td><td></td><td>Default for <a href="https://en.wikipedia.org/wiki/BMC_Software">BMC Software</a> <a href="https://en.wikipedia.org/wiki/BMC_Control-M">Control-M/Server</a>—Socket used for communication between Control-M processes—though often changed during installation</td><td>Unofficial</td></tr>
<tr><td>Yes</td><td></td><td>Default for <a href="https://en.wikipedia.org/wiki/Camfrog">Camfrog</a> chat &amp; cam client</td><td>Unofficial</td><td></td></tr>
<tr><td>6009</td><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/JD_Edwards_EnterpriseOne">JD Edwards EnterpriseOne</a> ERP system JDENet messaging client listener</td><td>Unofficial</td></tr>
<tr><td>6050</td><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/Arcserve">Arcserve</a> backup</td><td>Unofficial</td></tr>
<tr><td>6051</td><td>Yes</td><td></td><td>Arcserve backup</td><td>Unofficial</td></tr>
<tr><td>6086</td><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/Peer_Distributed_Transfer_Protocol">Peer Distributed Transfer Protocol</a> (PDTP), FTP like file server in a P2P network</td><td>Official</td></tr>
<tr><td>6100</td><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/Vizrt">Vizrt</a> System</td><td>Unofficial</td></tr>
<tr><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/Ventrilo">Ventrilo</a> authentication for version 3</td><td>Unofficial</td><td></td></tr>
<tr><td>6101</td><td>Yes</td><td></td><td>Backup Exec Agent Browser[<em><a href="https://en.wikipedia.org/wiki/Wikipedia:Citation_needed">citation needed</a></em>]</td><td>Unofficial</td></tr>
<tr><td>6110</td><td>Yes</td><td>Yes</td><td>softcm, <a href="https://en.wikipedia.org/wiki/Hewlett-Packard">HP</a> <a href="https://en.wikipedia.org/wiki/Softbench">Softbench</a> CM</td><td>Official</td></tr>
<tr><td>6111</td><td>Yes</td><td>Yes</td><td>spc, <a href="https://en.wikipedia.org/wiki/Hewlett-Packard">HP</a> <a href="https://en.wikipedia.org/wiki/Softbench">Softbench</a> Sub-Process Control</td><td>Official</td></tr>
<tr><td>6112</td><td>Yes</td><td>Yes</td><td>dtspcd, execute commands and launch applications remotely</td><td>Official</td></tr>
<tr><td>Yes</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/Blizzard_Entertainment">Blizzard</a>'s <a href="https://en.wikipedia.org/wiki/Battle.net">Battle.net</a> gaming service and some games,[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-blizzard-121">120]</a> <a href="https://en.wikipedia.org/wiki/ArenaNet">ArenaNet</a> gaming service, <a href="https://en.wikipedia.org/wiki/Relic_Entertainment">Relic</a> gaming service</td><td>Unofficial</td><td></td></tr>
<tr><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/Club_Penguin">Club Penguin</a> Disney online game for kids</td><td>Unofficial</td><td></td></tr>
<tr><td>6113</td><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/Club_Penguin">Club Penguin</a> Disney online game for kids, Used by some <a href="https://en.wikipedia.org/wiki/Blizzard_Entertainment">Blizzard</a> games[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-blizzard-121">120]</a></td><td>Unofficial</td></tr>
<tr><td>6136</td><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/ObjectDB">ObjectDB</a> database server[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-objectdb-jpa-setting-server-238">237]</a>[<em><a href="https://en.wikipedia.org/wiki/Wikipedia:Verifiability#Self-published_sources">self-published source</a></em>]</td><td>Unofficial</td></tr>
<tr><td>6159</td><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/ARINC">ARINC</a> 840 <a href="https://en.wikipedia.org/wiki/Electronic_flight_bag">EFB</a> Application Control Interface</td><td>Official</td></tr>
<tr><td>6200</td><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/Oracle_WebCenter">Oracle WebCenter</a> Content Portable: Content Server (With Native UI) and Inbound Refinery</td><td>Unofficial</td></tr>
<tr><td>6201</td><td>Yes</td><td></td><td>Oracle WebCenter Content Portable: Admin</td><td>Unofficial</td></tr>
<tr><td>6225</td><td>Yes</td><td></td><td>Oracle WebCenter Content Portable: Content Server Web UI</td><td>Unofficial</td></tr>
<tr><td>6227</td><td>Yes</td><td></td><td>Oracle WebCenter Content Portable: JavaDB</td><td>Unofficial</td></tr>
<tr><td>6240</td><td>Yes</td><td></td><td>Oracle WebCenter Content Portable: Capture</td><td>Unofficial</td></tr>
<tr><td>6244</td><td>Yes</td><td>Yes</td><td>Oracle WebCenter Content Portable: Content Server—Intradoc Socket port</td><td>Unofficial</td></tr>
<tr><td>6255</td><td>Yes</td><td>Yes</td><td>Oracle WebCenter Content Portable: Inbound Refinery—Intradoc Socket port</td><td>Unofficial</td></tr>
<tr><td>6257</td><td></td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/WinMX">WinMX</a> (see also 6699)</td><td>Unofficial</td></tr>
<tr><td>6260</td><td>Yes</td><td>Yes</td><td>planet M.U.L.E.</td><td>Unofficial</td></tr>
<tr><td>6262</td><td>Yes</td><td></td><td>Sybase <a href="https://en.wikipedia.org/wiki/Advantage_Database_Server">Advantage Database Server</a></td><td>Unofficial</td></tr>
<tr><td>6343</td><td></td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/SFlow">SFlow</a>, sFlow traffic monitoring</td><td>Official</td></tr>
<tr><td>6346</td><td>Yes</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/Gnutella">gnutella-svc</a>, gnutella (<a href="https://en.wikipedia.org/wiki/FrostWire">FrostWire</a>, <a href="https://en.wikipedia.org/wiki/Limewire">Limewire</a>, <a href="https://en.wikipedia.org/wiki/Shareaza">Shareaza</a>, etc.)</td><td>Official</td></tr>
<tr><td>6347</td><td>Yes</td><td>Yes</td><td>gnutella-rtr, Gnutella alternate</td><td>Official</td></tr>
<tr><td>6350</td><td>Yes</td><td>Yes</td><td>App Discovery and Access Protocol</td><td>Official</td></tr>
<tr><td>6379</td><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/Redis">Redis</a> key-value data store</td><td>Official</td></tr>
<tr><td>6389</td><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/EMC_Corporation">EMC</a> <a href="https://en.wikipedia.org/wiki/CLARiiON">CLARiiON</a></td><td>Unofficial</td></tr>
<tr><td>6432</td><td>Yes</td><td></td><td>PgBouncer—A connection pooler for PostgreSQL</td><td>Official</td></tr>
<tr><td>6436</td><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/Leap_Motion">Leap Motion</a> Websocket Server TLS</td><td>Unofficial</td></tr>
<tr><td>6437</td><td>Yes</td><td></td><td>Leap Motion Websocket Server</td><td>Unofficial</td></tr>
<tr><td>6444</td><td>Yes</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/Sun_Grid_Engine">Sun Grid Engine</a> Qmaster Service</td><td>Official</td></tr>
<tr><td>6445</td><td>Yes</td><td>Yes</td><td>Sun Grid Engine Execution Service</td><td>Official</td></tr>
<tr><td>6463–6472</td><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/Discord_(software)">Discord</a> RPC[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-239">238]</a></td><td>Unofficial</td></tr>
<tr><td>6464</td><td>Yes</td><td>Yes</td><td>Port assignment for medical device communication in accordance to <a href="https://en.wikipedia.org/wiki/ISO/IEEE_11073">IEEE 11073-20701</a></td><td>Official</td></tr>
<tr><td>6502</td><td>Yes</td><td>Yes</td><td>Netop Remote Control</td><td>Unofficial</td></tr>
<tr><td>6513</td><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/NETCONF">NETCONF</a> over <a href="https://en.wikipedia.org/wiki/Transport_Layer_Security">TLS</a></td><td>Official</td></tr>
<tr><td>6514</td><td>Yes</td><td></td><td>Syslog over TLS[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-240">239]</a></td><td>Official</td></tr>
<tr><td>6515</td><td>Yes</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/Elipse_Software">Elipse</a> RPC Protocol (REC)</td><td>Official</td></tr>
<tr><td>6516</td><td></td><td></td><td><a href="https://en.wikipedia.org/wiki/Windows_Admin_Center">Windows Admin Center</a></td><td>Unofficial</td></tr>
<tr><td>6543</td><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/Pylons_project#Pyramid">Pylons project#Pyramid</a> Default Pylons Pyramid web service port</td><td>Unofficial</td></tr>
<tr><td>6556</td><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/Check_MK">Check MK</a> Agent</td><td>Unofficial</td></tr>
<tr><td>6566</td><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/Scanner_Access_Now_Easy">SANE</a> (Scanner Access Now Easy)—SANE network scanner daemon[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-241">240]</a></td><td>Official</td></tr>
<tr><td>6560–6561</td><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/w/index.php?title=Speech-Dispatcher&amp;action=edit&amp;redlink=1">Speech-Dispatcher</a> daemon[<em><a href="https://en.wikipedia.org/wiki/Wikipedia:Citation_needed">citation needed</a></em>]</td><td>Unofficial</td></tr>
<tr><td>6571</td><td></td><td></td><td><a href="https://en.wikipedia.org/wiki/Windows_Live_FolderShare">Windows Live FolderShare</a> client</td><td>Unofficial</td></tr>
<tr><td>6600</td><td>Yes</td><td></td><td>Microsoft <a href="https://en.wikipedia.org/wiki/Hyper-V">Hyper-V</a> Live</td><td>Official</td></tr>
<tr><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/Music_Player_Daemon">Music Player Daemon</a> (MPD)</td><td>Unofficial</td><td></td></tr>
<tr><td>6601</td><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/Microsoft_Forefront_Threat_Management_Gateway">Microsoft Forefront Threat Management Gateway</a></td><td>Official</td></tr>
<tr><td>6602</td><td>Yes</td><td></td><td>Microsoft Windows WSS Communication</td><td>Official</td></tr>
<tr><td>6619</td><td>Yes</td><td>Yes</td><td>odette-ftps, <a href="https://en.wikipedia.org/wiki/OFTP">Odette File Transfer Protocol</a> (<a href="https://en.wikipedia.org/wiki/OFTP">OFTP</a>) over <a href="https://en.wikipedia.org/wiki/Transport_Layer_Security">TLS</a>/<a href="https://en.wikipedia.org/wiki/Secure_Sockets_Layer">SSL</a></td><td>Official</td></tr>
<tr><td>6622</td><td>Yes</td><td>Yes</td><td>Multicast FTP</td><td>Official</td></tr>
<tr><td>6653</td><td>Yes</td><td>Assigned</td><td><a href="https://en.wikipedia.org/wiki/OpenFlow">OpenFlow</a>[<em><a href="https://en.wikipedia.org/wiki/Wikipedia:Citation_needed">citation needed</a></em>]</td><td>Official</td></tr>
<tr><td>6660–6664</td><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/Internet_Relay_Chat">Internet Relay Chat</a> (IRC)</td><td>Unofficial</td></tr>
<tr><td>6665–6669</td><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/Internet_Relay_Chat">Internet Relay Chat</a> (IRC)</td><td>Official</td></tr>
<tr><td>6679</td><td>Yes</td><td>Yes</td><td>Osorno Automation Protocol (OSAUT)</td><td>Official</td></tr>
<tr><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/Internet_Relay_Chat">IRC</a> <a href="https://en.wikipedia.org/wiki/Secure_Sockets_Layer">SSL</a> (Secure Internet Relay Chat)—often used</td><td>Unofficial</td><td></td></tr>
<tr><td>6690</td><td>Yes</td><td></td><td>Synology Cloud station</td><td>Unofficial</td></tr>
<tr><td>6697</td><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/Internet_Relay_Chat">IRC</a> <a href="https://en.wikipedia.org/wiki/Secure_Sockets_Layer">SSL</a> (Secure Internet Relay Chat)—often used</td><td>Official</td></tr>
<tr><td>6699</td><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/WinMX">WinMX</a> (see also 6257)</td><td>Unofficial</td></tr>
<tr><td>6715</td><td>Yes</td><td></td><td>AberMUD and derivatives default port</td><td>Unofficial</td></tr>
<tr><td>6771</td><td></td><td>Yes</td><td>BitTorrent <a href="https://en.wikipedia.org/wiki/Local_Peer_Discovery">Local Peer Discovery</a></td><td>Unofficial</td></tr>
<tr><td>6783–6785</td><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/Splashtop_Remote">Splashtop Remote</a> server broadcast</td><td>Unofficial</td></tr>
<tr><td>6881–6887</td><td>Yes</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/BitTorrent_(protocol)">BitTorrent</a> part of full range of ports used most often</td><td>Unofficial</td></tr>
<tr><td>6888</td><td>Yes</td><td>Yes</td><td>MUSE</td><td>Official</td></tr>
<tr><td>Yes</td><td>Yes</td><td>BitTorrent part of full range of ports used most often</td><td>Unofficial</td><td></td></tr>
<tr><td>6889–6890</td><td>Yes</td><td>Yes</td><td>BitTorrent part of full range of ports used most often</td><td>Unofficial</td></tr>
<tr><td>6891–6900</td><td>Yes</td><td>Yes</td><td>BitTorrent part of full range of ports used most often</td><td>Unofficial</td></tr>
<tr><td>6891–6900</td><td>Yes</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/Windows_Live_Messenger">Windows Live Messenger</a> (File transfer)</td><td>Unofficial</td></tr>
<tr><td>6901</td><td>Yes</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/Windows_Live_Messenger">Windows Live Messenger</a> (Voice)</td><td>Unofficial</td></tr>
<tr><td>Yes</td><td>Yes</td><td>BitTorrent part of full range of ports used most often</td><td>Unofficial</td><td></td></tr>
<tr><td>6902–6968</td><td>Yes</td><td>Yes</td><td>BitTorrent part of full range of ports used most often</td><td>Unofficial</td></tr>
<tr><td>6969</td><td>Yes</td><td>Yes</td><td>acmsoda</td><td>Official</td></tr>
<tr><td>Yes</td><td></td><td>BitTorrent tracker</td><td>Unofficial</td><td></td></tr>
<tr><td>6970–6999</td><td>Yes</td><td>Yes</td><td>BitTorrent part of full range of ports used most often</td><td>Unofficial</td></tr>
<tr><td></td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/QuickTime_Streaming_Server">QuickTime Streaming Server</a>[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-apple-kb-HT202944-10">10]</a></td><td>Unofficial</td><td></td></tr>
<tr><td>7000</td><td>Yes</td><td></td><td>Default for <a href="https://en.wikipedia.org/wiki/Vuze">Vuze</a>'s built-in <a href="https://en.wikipedia.org/wiki/HTTPS">HTTPS</a> <a href="https://en.wikipedia.org/wiki/Bittorrent_Tracker">Bittorrent Tracker</a></td><td>Unofficial</td></tr>
<tr><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/Avira">Avira</a> Server Management Console</td><td>Unofficial</td><td></td></tr>
<tr><td>7001</td><td>Yes</td><td></td><td>Avira Server Management Console</td><td>Unofficial</td></tr>
<tr><td>Yes</td><td></td><td>Default for <a href="https://en.wikipedia.org/wiki/BEA_Systems">BEA</a> <a href="https://en.wikipedia.org/wiki/WebLogic">WebLogic Server</a>'s <a href="https://en.wikipedia.org/wiki/HTTP">HTTP</a> server, though often changed during installation</td><td>Unofficial</td><td></td></tr>
<tr><td>7002</td><td>Yes</td><td></td><td>Default for BEA WebLogic Server's HTTPS server, though often changed during installation</td><td>Unofficial</td></tr>
<tr><td>7005</td><td>Yes</td><td></td><td>Default for <a href="https://en.wikipedia.org/wiki/BMC_Software">BMC Software</a> <a href="https://en.wikipedia.org/wiki/BMC_Control-M">Control-M/Server</a> and Control-M/Agent for Agent-to-Server, though often changed during installation</td><td>Unofficial</td></tr>
<tr><td>7006</td><td>Yes</td><td></td><td>Default for BMC Software Control-M/Server and Control-M/Agent for Server-to-Agent, though often changed during installation</td><td>Unofficial</td></tr>
<tr><td>7010</td><td>Yes</td><td></td><td>Default for Cisco AON AMC (AON Management Console)[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-242">241]</a></td><td>Unofficial</td></tr>
<tr><td>7022</td><td>Yes</td><td></td><td>Database mirroring endpoints[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-243">242]</a></td><td>Unofficial</td></tr>
<tr><td>7023</td><td></td><td>Yes</td><td>Bryan Wilcutt T2-NMCS Protocol for SatCom Modems</td><td>Official</td></tr>
<tr><td>7025</td><td>Yes</td><td></td><td>Zimbra <a href="https://en.wikipedia.org/wiki/Local_Mail_Transfer_Protocol">LMTP</a> [mailbox]—local mail delivery</td><td>Unofficial</td></tr>
<tr><td>7047</td><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/Zimbra">Zimbra</a> conversion server</td><td>Unofficial</td></tr>
<tr><td>7070</td><td>Yes</td><td>Yes/No</td><td><a href="https://en.wikipedia.org/wiki/Real_Time_Streaming_Protocol">Real Time Streaming Protocol</a> (RTSP), used by <a href="https://en.wikipedia.org/wiki/QuickTime_Streaming_Server">QuickTime Streaming Server</a>. TCP is used by default, UDP is used as an alternate.[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-apple-kb-HT202944-10">10]</a></td><td>Unofficial</td></tr>
<tr><td>7133</td><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/Enemy_Territory:_Quake_Wars">Enemy Territory: Quake Wars</a></td><td>Unofficial</td></tr>
<tr><td>7144</td><td>Yes</td><td></td><td>Peercast[<em><a href="https://en.wikipedia.org/wiki/Wikipedia:Citation_needed">citation needed</a></em>]</td><td>Unofficial</td></tr>
<tr><td>7145</td><td>Yes</td><td></td><td>Peercast[<em><a href="https://en.wikipedia.org/wiki/Wikipedia:Citation_needed">citation needed</a></em>]</td><td>Unofficial</td></tr>
<tr><td>7171</td><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/Tibia_(computer_game)">Tibia</a></td><td>Unofficial</td></tr>
<tr><td>7262</td><td>Yes</td><td>Yes</td><td>CNAP (Calypso Network Access Protocol)</td><td>Official</td></tr>
<tr><td>7272</td><td>Yes</td><td>Yes</td><td>WatchMe - WatchMe Monitoring</td><td>Official</td></tr>
<tr><td>7306</td><td>Yes</td><td></td><td>Zimbra mysql [mailbox][<em><a href="https://en.wikipedia.org/wiki/Wikipedia:Citation_needed">citation needed</a></em>]</td><td>Unofficial</td></tr>
<tr><td>7307</td><td>Yes</td><td></td><td>Zimbra mysql [logger][<em><a href="https://en.wikipedia.org/wiki/Wikipedia:Citation_needed">citation needed</a></em>]</td><td>Unofficial</td></tr>
<tr><td>7312</td><td></td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/Sibelius_notation_program">Sibelius</a> License Server</td><td>Unofficial</td></tr>
<tr><td>7396</td><td>Yes</td><td></td><td>Web control interface for <a href="https://en.wikipedia.org/wiki/Folding@home#V7">Folding@home v7.3.6</a> and later[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-244">243]</a></td><td>Unofficial</td></tr>
<tr><td>7400</td><td>Yes</td><td>Yes</td><td>RTPS (Real Time Publish Subscribe) <a href="https://en.wikipedia.org/wiki/Data_Distribution_Service">DDS</a> Discovery</td><td>Official</td></tr>
<tr><td>7401</td><td>Yes</td><td>Yes</td><td>RTPS (Real Time Publish Subscribe) <a href="https://en.wikipedia.org/wiki/Data_Distribution_Service">DDS</a> User-Traffic</td><td>Official</td></tr>
<tr><td>7402</td><td>Yes</td><td>Yes</td><td>RTPS (Real Time Publish Subscribe) <a href="https://en.wikipedia.org/wiki/Data_Distribution_Service">DDS</a> Meta-Traffic</td><td>Official</td></tr>
<tr><td>7471</td><td>Yes</td><td></td><td>Stateless Transport Tunneling (STT)</td><td>Unofficial</td></tr>
<tr><td>7473</td><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/Rise:_The_Vieneo_Province">Rise: The Vieneo Province</a></td><td>Official</td></tr>
<tr><td>7474</td><td>Yes</td><td></td><td>Neo4J Server webadmin[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-245">244]</a></td><td>Official</td></tr>
<tr><td>7478</td><td>Yes</td><td></td><td>Default port used by <a href="https://en.wikipedia.org/wiki/Open_iT">Open iT</a> Server.[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-246">245]</a></td><td>Official</td></tr>
<tr><td>7542</td><td>Yes</td><td>Yes</td><td><em>Saratoga</em> file transfer protocol[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-draft-wood-tsvwg-saratoga-247">246]</a>[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-10.1109/IWSSC.2007.4409410-248">247]</a></td><td>Official</td></tr>
<tr><td>7547</td><td>Yes</td><td>Yes</td><td>CPE WAN Management Protocol (CWMP) <a href="https://en.wikipedia.org/wiki/TR-069">Technical Report 069</a></td><td>Official</td></tr>
<tr><td>7575</td><td></td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/Populous:_The_Beginning">Populous: The Beginning</a> server</td><td>Unofficial</td></tr>
<tr><td>7624</td><td>Yes</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/Instrument_Neutral_Distributed_Interface">Instrument Neutral Distributed Interface</a></td><td>Official</td></tr>
<tr><td>7631</td><td>Yes</td><td></td><td>ERLPhase</td><td>Official</td></tr>
<tr><td>7634</td><td>Yes</td><td></td><td>hddtemp—Utility to monitor hard drive temperature</td><td>Unofficial</td></tr>
<tr><td>7652–7654</td><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/I2P">I2P</a> anonymizing overlay network</td><td>Unofficial</td></tr>
<tr><td>7655</td><td></td><td>Yes</td><td>I2P SAM Bridge Socket API</td><td>Unofficial</td></tr>
<tr><td>7656–7660</td><td>Yes</td><td></td><td>I2P anonymizing overlay network</td><td>Unofficial</td></tr>
<tr><td>7670</td><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/BrettspielWelt">BrettspielWelt</a> BSW Boardgame Portal</td><td>Unofficial</td></tr>
<tr><td>7680</td><td>Yes</td><td></td><td>Delivery Optimization for <a href="https://en.wikipedia.org/wiki/Windows_10">Windows 10</a>[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-ms-win10-delivery-optimization-249">248]</a></td><td>Unofficial</td></tr>
<tr><td>7687</td><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/Bolt_(network_protocol)">Bolt</a> database connection</td><td>Official</td></tr>
<tr><td>7707–7708</td><td></td><td>Yes</td><td><em><a href="https://en.wikipedia.org/wiki/Killing_Floor_(2009_video_game)">Killing Floor</a></em></td><td>Unofficial</td></tr>
<tr><td>7717</td><td></td><td>Yes</td><td><em>Killing Floor</em></td><td>Unofficial</td></tr>
<tr><td>7777</td><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/IChat">iChat</a> server file transfer proxy[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-apple-kb-HT202944-10">10]</a></td><td>Unofficial</td></tr>
<tr><td>Yes</td><td></td><td>Oracle Cluster File System 2[<em><a href="https://en.wikipedia.org/wiki/Wikipedia:Citation_needed">citation needed</a></em>]</td><td>Unofficial</td><td></td></tr>
<tr><td>Yes</td><td></td><td>Windows backdoor program tini.exe default[<em><a href="https://en.wikipedia.org/wiki/Wikipedia:Citation_needed">citation needed</a></em>]</td><td>Unofficial</td><td></td></tr>
<tr><td>Yes</td><td></td><td><em>Just Cause 2: Multiplayer Mod</em> Server[<em><a href="https://en.wikipedia.org/wiki/Wikipedia:Citation_needed">citation needed</a></em>]</td><td>Unofficial</td><td></td></tr>
<tr><td>Yes</td><td></td><td><em><a href="https://en.wikipedia.org/wiki/Terraria">Terraria</a></em> default server</td><td>Unofficial</td><td></td></tr>
<tr><td></td><td>Yes</td><td><em>San Andreas Multiplayer</em> (SA-MP) default port server</td><td>Unofficial</td><td></td></tr>
<tr><td></td><td>Yes</td><td><em>SCP: Secret Laboratory</em> Multiplayer Server</td><td>Unofficial</td><td></td></tr>
<tr><td>7777–7788</td><td>Yes</td><td>Yes</td><td><em>Unreal Tournament</em> series default server[<em><a href="https://en.wikipedia.org/wiki/Wikipedia:Citation_needed">citation needed</a></em>]</td><td>Unofficial</td></tr>
<tr><td>7831</td><td>Yes</td><td></td><td>Default used by Smartlaunch Internet Cafe Administration[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-250">249]</a> software</td><td>Unofficial</td></tr>
<tr><td>7880</td><td>Yes</td><td>Yes</td><td>PowerSchool Gradebook Server[<em><a href="https://en.wikipedia.org/wiki/Wikipedia:Citation_needed">citation needed</a></em>]</td><td>Unofficial</td></tr>
<tr><td>7890</td><td>Yes</td><td></td><td>Default that will be used by the iControl Internet Cafe Suite Administration software</td><td>Unofficial</td></tr>
<tr><td>7915</td><td>Yes</td><td></td><td>Default for YSFlight server[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-Midnight_Rambler-251">250]</a></td><td>Unofficial</td></tr>
<tr><td>7935</td><td>Yes</td><td></td><td>Fixed port used for Adobe Flash Debug Player to communicate with a debugger (Flash IDE, Flex Builder or fdb).[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-252">251]</a></td><td>Unofficial</td></tr>
<tr><td>7946</td><td>Yes</td><td>Yes</td><td>Docker Swarm communication among nodes[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-docker-swarm-tutorial-157">156]</a></td><td>Unofficial</td></tr>
<tr><td>7990</td><td>Yes</td><td></td><td>Atlassian <a href="https://en.wikipedia.org/wiki/Bitbucket">Bitbucket</a> (default port)[<em><a href="https://en.wikipedia.org/wiki/Wikipedia:Citation_needed">citation needed</a></em>]</td><td>Unofficial</td></tr>
<tr><td>8000</td><td>Yes</td><td></td><td>Commonly used for Internet radio streams such as <a href="https://en.wikipedia.org/wiki/SHOUTcast">SHOUTcast</a>[<em><a href="https://en.wikipedia.org/wiki/Wikipedia:Citation_needed">citation needed</a></em>], <a href="https://en.wikipedia.org/wiki/Icecast">Icecast</a>[<em><a href="https://en.wikipedia.org/wiki/Wikipedia:Citation_needed">citation needed</a></em>] and <a href="https://en.wikipedia.org/wiki/ITunes_Radio">iTunes Radio</a>[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-apple-kb-HT202944-10">10]</a></td><td>Unofficial</td></tr>
<tr><td>?</td><td>?</td><td><a href="https://en.wikipedia.org/wiki/DynamoDB">DynamoDB</a> Local[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-aws-docs-dynamodb-developer-local-253">252]</a>[<em><a href="https://en.wikipedia.org/wiki/Wikipedia:Verifiability#Self-published_sources">self-published source?</a></em>]</td><td>Unofficial</td><td></td></tr>
<tr><td>?</td><td>?</td><td><a href="https://en.wikipedia.org/wiki/Django_(web_framework)">Django</a> Development Webserver[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-django-docs-1.10-tutorial01-254">253]</a>[<em><a href="https://en.wikipedia.org/wiki/Wikipedia:Verifiability#Self-published_sources">self-published source?</a></em>]</td><td>Unofficial</td><td></td></tr>
<tr><td>8005</td><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/Apache_Tomcat">Tomcat</a> remote shutdown[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-apple-kb-HT202944-10">10]</a></td><td>Unofficial</td></tr>
<tr><td>8006</td><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/Quest_AppAssure">Quest AppAssure</a> 5 API[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-appassure-kb-firewall-port-255">254]</a></td><td>Unofficial</td></tr>
<tr><td>Yes</td><td>No</td><td><a href="https://en.wikipedia.org/wiki/Proxmox_Virtual_Environment">Proxmox Virtual Environment</a> admin web interface[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-256">255]</a></td><td>Unofficial</td><td></td></tr>
<tr><td>8007</td><td>Yes</td><td></td><td>Quest AppAssure 5 Engine[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-appassure-kb-firewall-port-255">254]</a></td><td>Unofficial</td></tr>
<tr><td>8008</td><td>Yes</td><td>Yes</td><td>Alternative port for <a href="https://en.wikipedia.org/wiki/HTTP">HTTP</a>. See also ports 80 and 8080.</td><td>Official</td></tr>
<tr><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/IBM_HTTP_Server">IBM HTTP Server</a> administration default[<em><a href="https://en.wikipedia.org/wiki/Wikipedia:What_Wikipedia_is_not#Encyclopedic_content">importance?</a></em>]</td><td>Unofficial</td><td></td></tr>
<tr><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/ICal">iCal</a>, a calendar application by <a href="https://en.wikipedia.org/wiki/Apple,_Inc.">Apple</a>[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-apple-kb-HT202944-10">10]</a></td><td>Unofficial</td><td></td></tr>
<tr><td>Yes</td><td>?</td><td><a href="https://en.wikipedia.org/wiki/Matrix_(protocol)">Matrix</a> homeserver federation over HTTP[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-matrix-homeserver-257">256]</a>[<em><a href="https://en.wikipedia.org/wiki/Wikipedia:Verifiability#Self-published_sources">self-published source?</a></em>]</td><td>Unofficial</td><td></td></tr>
<tr><td>8009</td><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/Apache_JServ_Protocol">Apache JServ Protocol</a> (<code>ajp13</code>)[<em><a href="https://en.wikipedia.org/wiki/Wikipedia:Citation_needed">citation needed</a></em>]</td><td>Unofficial</td></tr>
<tr><td>8010</td><td>Yes</td><td>?</td><td><a href="https://en.wikipedia.org/wiki/Buildbot">Buildbot</a> Web status page[<em><a href="https://en.wikipedia.org/wiki/Wikipedia:Citation_needed">citation needed</a></em>]</td><td>Unofficial</td></tr>
<tr><td>8042</td><td>?</td><td>?</td><td><a href="https://en.wikipedia.org/wiki/Orthanc_(software)">Orthanc</a> – REST API over HTTP[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-orthanc-book-configuration-190">189]</a>[<em><a href="https://en.wikipedia.org/wiki/Wikipedia:Verifiability#Self-published_sources">self-published source?</a></em>]</td><td>Unofficial</td></tr>
<tr><td>8069</td><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/OpenERP">OpenERP</a> 5.0 XML-RPC protocol[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-odoo-doc-5.0-install-linux-web-258">257]</a>[<em><a href="https://en.wikipedia.org/wiki/Wikipedia:Verifiability#Self-published_sources">self-published source?</a></em>]</td><td>Unofficial</td></tr>
<tr><td>8070</td><td>Yes</td><td></td><td>OpenERP 5.0 NET-RPC protocol[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-odoo-doc-5.0-install-linux-web-258">257]</a></td><td>Unofficial</td></tr>
<tr><td>8074</td><td>Yes</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/Gadu-Gadu">Gadu-Gadu</a></td><td>Official</td></tr>
<tr><td>8075</td><td>Yes</td><td></td><td><em>Killing Floor</em> web administration interface[<em><a href="https://en.wikipedia.org/wiki/Wikipedia:Citation_needed">citation needed</a></em>]</td><td>Unofficial</td></tr>
<tr><td>8080</td><td>Yes</td><td>Yes</td><td>Alternative port for <a href="https://en.wikipedia.org/wiki/HTTP">HTTP</a>. See also ports 80 and 8008.</td><td>Official</td></tr>
<tr><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/Apache_Tomcat">Apache Tomcat</a>[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-259">258]</a></td><td>Unofficial</td><td></td></tr>
<tr><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/Jira_(software)">Atlassian JIRA</a> applications[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-atlassian-jira-071-tcp-ports-260">259]</a>[<em><a href="https://en.wikipedia.org/wiki/Wikipedia:Verifiability#Self-published_sources">self-published source?</a></em>]</td><td>Unofficial</td><td></td></tr>
<tr><td>8088</td><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/Asterisk_(PBX)">Asterisk</a> management access via HTTP[<em><a href="https://en.wikipedia.org/wiki/Wikipedia:Citation_needed">citation needed</a></em>]</td><td>Unofficial</td></tr>
<tr><td>8089</td><td>Yes</td><td>No</td><td><a href="https://en.wikipedia.org/wiki/Splunk">Splunk</a> daemon management[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-261">260]</a>[<em><a href="https://en.wikipedia.org/wiki/Wikipedia:Verifiability#Self-published_sources">self-published source</a></em>]</td><td>Unofficial</td></tr>
<tr><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/Fritz!Box">Fritz!Box</a> automatic <a href="https://en.wikipedia.org/wiki/TR-069">TR-069</a> configuration[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-avm-fritzbox-7490-port-8089-262">261]</a></td><td>Unofficial</td><td></td></tr>
<tr><td>8090</td><td>?</td><td>?</td><td><a href="https://en.wikipedia.org/wiki/Atlassian_Confluence">Atlassian Confluence</a>[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-atlassian-confluence-6.0-doc-listen-port-263">262]</a>[<em><a href="https://en.wikipedia.org/wiki/Wikipedia:Verifiability#Self-published_sources">self-published source?</a></em>]</td><td>Unofficial</td></tr>
<tr><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/Coral_Content_Distribution_Network">Coral Content Distribution Network</a> (legacy; 80 and 8080 now supported)[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-coralcdn-wiki-faq-264">263]</a></td><td>Unofficial</td><td></td></tr>
<tr><td>?</td><td>?</td><td>Matrix identity server[<em><a href="https://en.wikipedia.org/wiki/Wikipedia:Citation_needed">citation needed</a></em>]</td><td>Unofficial</td><td></td></tr>
<tr><td>8091</td><td>?</td><td>?</td><td><a href="https://en.wikipedia.org/wiki/CouchBase">CouchBase</a> web administration[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-couchbase-dev-doc-server-ports-265">264]</a></td><td>Unofficial</td></tr>
<tr><td>8092</td><td>?</td><td>?</td><td>CouchBase API[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-couchbase-dev-doc-server-ports-265">264]</a></td><td>Unofficial</td></tr>
<tr><td>8111</td><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/JOSM">JOSM</a> Remote Control</td><td>Unofficial</td></tr>
<tr><td>8112</td><td>Yes</td><td></td><td>PAC Pacifica Coin</td><td>Unofficial</td></tr>
<tr><td>8116</td><td></td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/Check_Point">Check Point</a> Cluster Control Protocol</td><td>Unofficial</td></tr>
<tr><td>8118</td><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/Privoxy">Privoxy</a>—advertisement-filtering Web proxy</td><td>Official</td></tr>
<tr><td>8123</td><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/Polipo">Polipo</a> Web proxy</td><td>Official</td></tr>
<tr><td>Yes</td><td></td><td><a href="https://github.com/burst-apps-team/burstcoin">BURST Reference Software</a> P2P</td><td>Unofficial</td><td></td></tr>
<tr><td>8124</td><td>Yes</td><td></td><td>Standard <a href="https://www.burst-coin.org/">BURST</a> Mining Pool Software Port</td><td>Unofficial</td></tr>
<tr><td>8125</td><td>Yes</td><td></td><td><a href="https://github.com/burst-apps-team/burstcoin">BURST Reference Software</a> Web Interface</td><td>Unofficial</td></tr>
<tr><td>8139</td><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/Puppet_(software)">Puppet (software)</a> Client agent</td><td>Unofficial</td></tr>
<tr><td>8140</td><td>Yes</td><td></td><td>Puppet (software) Master server</td><td>Official</td></tr>
<tr><td>8172</td><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/Microsoft">Microsoft</a> Remote Administration for IIS Manager[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-266">265]</a></td><td>Unofficial</td></tr>
<tr><td>8184</td><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/NCSA_Brown_Dog">NCSA Brown Dog</a> Data Access Proxy</td><td>Unofficial</td></tr>
<tr><td>8194–8195</td><td>?</td><td>?</td><td><a href="https://en.wikipedia.org/wiki/Bloomberg_Terminal">Bloomberg Terminal</a>[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-Bloomberg_TS-267">266]</a></td><td>Official</td></tr>
<tr><td>8200</td><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/GoToMyPC">GoToMyPC</a></td><td>Unofficial</td></tr>
<tr><td>Yes</td><td></td><td>MiniDLNA media server Web Interface</td><td>Unofficial</td><td></td></tr>
<tr><td>8222</td><td>?</td><td>?</td><td><a href="https://en.wikipedia.org/wiki/VMware">VMware</a> VI Web Access via HTTP[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-vmware-server-2.0-rc2-releasenotes-268">267]</a></td><td>Unofficial</td></tr>
<tr><td>8243</td><td>Yes</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/HTTPS">HTTPS</a> listener for <a href="https://en.wikipedia.org/wiki/Apache_Synapse">Apache Synapse</a>[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-Apache_Synapse-269">268]</a></td><td>Official</td></tr>
<tr><td>8245</td><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/Dynamic_DNS">Dynamic DNS</a> for at least <a href="https://en.wikipedia.org/wiki/No-IP">No-IP</a> and DyDNS[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-DyDNS_API-270">269]</a></td><td>Unofficial</td></tr>
<tr><td>8280</td><td>Yes</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/HTTP">HTTP</a> listener for <a href="https://en.wikipedia.org/wiki/Apache_Synapse">Apache Synapse</a>[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-Apache_Synapse-269">268]</a></td><td>Official</td></tr>
<tr><td>8281</td><td>Yes</td><td></td><td>HTTP Listener for Gatecraft Plugin</td><td>Unofficial</td></tr>
<tr><td>8291</td><td>Yes</td><td></td><td>Winbox—Default on a MikroTik RouterOS for a Windows application used to administer MikroTik RouterOS[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-271">270]</a></td><td>Unofficial</td></tr>
<tr><td>8303</td><td></td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/Teeworlds">Teeworlds</a> Server</td><td>Unofficial</td></tr>
<tr><td>8332</td><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/Bitcoin">Bitcoin</a> <a href="https://en.wikipedia.org/wiki/JSON-RPC">JSON-RPC</a> server[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-272">271]</a></td><td>Unofficial</td></tr>
<tr><td>8333</td><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/Bitcoin">Bitcoin</a>[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-ReferenceA-273">272]</a></td><td>Unofficial</td></tr>
<tr><td>?</td><td>?</td><td><a href="https://en.wikipedia.org/wiki/VMware">VMware</a> VI Web Access via HTTPS[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-vmware-server-2.0-rc2-releasenotes-268">267]</a></td><td>Unofficial</td><td></td></tr>
<tr><td>8337</td><td>Yes</td><td></td><td>VisualSVN Distributed File System Service (VDFS)[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-274">273]</a></td><td>Unofficial</td></tr>
<tr><td>8384</td><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/Syncthing">Syncthing</a> web GUI</td><td>Unofficial</td></tr>
<tr><td>8388</td><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/Shadowsocks">Shadowsocks</a> proxy server[<em><a href="https://en.wikipedia.org/wiki/Wikipedia:Citation_needed">citation needed</a></em>]</td><td>Unofficial</td></tr>
<tr><td>8443</td><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/SW_Soft_Plesk">SW Soft Plesk</a> Control Panel</td><td>Unofficial</td></tr>
<tr><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/Apache_Tomcat">Apache Tomcat</a> SSL</td><td>Unofficial</td><td></td></tr>
<tr><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/Promise_Technology">Promise</a> WebPAM SSL</td><td>Unofficial</td><td></td></tr>
<tr><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/ICal">iCal</a> over <a href="https://en.wikipedia.org/wiki/Secure_Socket_Layer">SSL</a>[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-apple-kb-HT202944-10">10]</a></td><td>Unofficial</td><td></td></tr>
<tr><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/w/index.php?title=MineOs&amp;action=edit&amp;redlink=1">MineOs</a> WebUi</td><td>Unofficial</td><td></td></tr>
<tr><td>8444</td><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/Bitmessage">Bitmessage</a></td><td>Unofficial</td></tr>
<tr><td>8448</td><td>Yes</td><td>?</td><td>Matrix homeserver federation over HTTPS[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-matrix-homeserver-257">256]</a></td><td>Unofficial</td></tr>
<tr><td>8484</td><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/MapleStory">MapleStory</a> Login Server</td><td>Unofficial</td></tr>
<tr><td>8500</td><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/Adobe_ColdFusion">Adobe ColdFusion</a> built-in web server[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-adobe-help-cf10-admin-275">274]</a>[<em><a href="https://en.wikipedia.org/wiki/Wikipedia:Verifiability#Self-published_sources">self-published source?</a></em>]</td><td>Unofficial</td></tr>
<tr><td>8530</td><td>?</td><td>?</td><td><a href="https://en.wikipedia.org/wiki/Windows_Server_Update_Services">Windows Server Update Services</a> over <a href="https://en.wikipedia.org/wiki/HTTP">HTTP</a>, when using the default role installation settings in Windows Server 2012 and later versions.[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-msft-tn-bb693717-276">275]</a>[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-msft-tn-hh852346-277">276]</a></td><td>Unofficial</td></tr>
<tr><td>8531</td><td>?</td><td>?</td><td><a href="https://en.wikipedia.org/wiki/Windows_Server_Update_Services">Windows Server Update Services</a> over <a href="https://en.wikipedia.org/wiki/HTTPS">HTTPS</a>, when using the default role installation settings in Windows Server 2012 and later versions.[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-msft-tn-bb693717-276">275]</a>[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-msft-tn-hh852346-277">276]</a></td><td>Unofficial</td></tr>
<tr><td>8580</td><td>?</td><td>?</td><td><a href="https://en.wikipedia.org/wiki/Freegate">Freegate</a>, an Internet <a href="https://en.wikipedia.org/wiki/Anonymizer">anonymizer</a> and proxy tool[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-flossmanuals-bypasscensor-freegate-278">277]</a></td><td>Unofficial</td></tr>
<tr><td>8629</td><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/Tibero">Tibero database</a>[<em><a href="https://en.wikipedia.org/wiki/Wikipedia:Citation_needed">citation needed</a></em>]</td><td>Unofficial</td></tr>
<tr><td>8642</td><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/IBM_Lotus_Notes_Traveler">Lotus Notes Traveler</a> auto synchronization for Windows Mobile and Nokia devices[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-ibm-support-lnt851-planning-net-279">278]</a></td><td>Unofficial</td></tr>
<tr><td>8691</td><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/Ultra_Fractal">Ultra Fractal</a>, a <a href="https://en.wikipedia.org/wiki/Fractal">fractal</a> generation and rendering <a href="https://en.wikipedia.org/wiki/Graphic_art_software">software application</a> – distributed calculations over networked computers[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-ultrafractal-280">279]</a>[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-ultrafractal-help-network-servers-281">280]</a>[<em><a href="https://en.wikipedia.org/wiki/Wikipedia:Verifiability#Self-published_sources">self-published source?</a></em>]</td><td>Unofficial</td></tr>
<tr><td>8765</td><td>Yes</td><td>?</td><td>Default port of a local GUN relay peer that the <a href="https://en.wikipedia.org/wiki/Internet_Archive">Internet Archive</a>[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-282">281]</a>[<em><a href="https://en.wikipedia.org/wiki/Wikipedia:Verifiability#Self-published_sources">self-published source</a></em>] and others use as a decentralized mirror for censorship resistance.[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-283">282]</a>[<em><a href="https://en.wikipedia.org/wiki/Wikipedia:Verifiability#Self-published_sources">self-published source</a></em>]</td><td>Unofficial</td></tr>
<tr><td>8767</td><td></td><td>Yes</td><td>Voice channel of <a href="https://en.wikipedia.org/wiki/TeamSpeak_2">TeamSpeak 2</a>,[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-tsusa-kb-ts2-ports-284">283]</a> a proprietary <a href="https://en.wikipedia.org/wiki/Voice_over_IP">Voice over IP</a> protocol targeted at <a href="https://en.wikipedia.org/wiki/Gamer">gamers</a>[<em><a href="https://en.wikipedia.org/wiki/Wikipedia:Citation_needed">citation needed</a></em>]</td><td>Unofficial</td></tr>
<tr><td>8834</td><td>?</td><td>?</td><td><a href="https://en.wikipedia.org/wiki/Nessus_(software)">Nessus</a>, a <a href="https://en.wikipedia.org/wiki/Vulnerability_scanner">vulnerability scanner</a> – remote <a href="https://en.wikipedia.org/wiki/XML-RPC">XML-RPC</a> web server[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-tenable-docs-nessus68-usermanual-285">284]</a>[<em><a href="https://en.wikipedia.org/wiki/Wikipedia:Independent_sources">third-party source needed</a></em>]</td><td>Unofficial</td></tr>
<tr><td>8840</td><td>?</td><td>?</td><td><a href="https://en.wikipedia.org/w/index.php?title=Opera_Unite&amp;action=edit&amp;redlink=1">Opera Unite</a>, an extensible <a href="https://en.wikipedia.org/wiki/Software_framework">framework</a> for web applications[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-computerworld-article-2525727-286">285]</a>[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-lifehacker-5472050-287">286]</a></td><td>Unofficial</td></tr>
<tr><td>8880</td><td>Yes</td><td></td><td>Alternate port of <a href="https://en.wikipedia.org/wiki/CDDB">CDDB</a> (Compact Disc Database) protocol, used to look up audio CD (<a href="https://en.wikipedia.org/wiki/Compact_disc">compact disc</a>) information over the <a href="https://en.wikipedia.org/wiki/Internet">Internet</a>.[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-ccdb-howto.txt-288">287]</a> See also port 888.</td><td>Official</td></tr>
<tr><td>?</td><td>?</td><td><a href="https://en.wikipedia.org/wiki/IBM_WebSphere_Application_Server">IBM WebSphere Application Server</a> <a href="https://en.wikipedia.org/wiki/SOAP">SOAP</a> connector[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-ibm-support-websphere-express8-portnumber-289">288]</a>[<em><a href="https://en.wikipedia.org/wiki/Wikipedia:Manual_of_Style#Technical_language">jargon</a></em>]</td><td>Unofficial</td><td></td></tr>
<tr><td>8883</td><td>Yes</td><td>Yes</td><td>Secure <a href="https://en.wikipedia.org/wiki/MQTT">MQTT</a> (MQTT over TLS)[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-mqtt-faq-290">289]</a>[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-oasisopen-docs-mqtt-v3.1.1-spec-291">290]</a></td><td>Official</td></tr>
<tr><td>8887</td><td>?</td><td>?</td><td><a href="https://en.wikipedia.org/wiki/HyperVM">HyperVM</a> over HTTP[<em><a href="https://en.wikipedia.org/wiki/Wikipedia:Citation_needed">citation needed</a></em>]</td><td>Unofficial</td></tr>
<tr><td>8888</td><td>?</td><td>?</td><td>HyperVM over <a href="https://en.wikipedia.org/wiki/HTTPS">HTTPS</a>[<em><a href="https://en.wikipedia.org/wiki/Wikipedia:Citation_needed">citation needed</a></em>]</td><td>Unofficial</td></tr>
<tr><td>?</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/Freenet">Freenet</a> web UI (localhost only)[<em><a href="https://en.wikipedia.org/wiki/Wikipedia:Citation_needed">citation needed</a></em>]</td><td>Unofficial</td><td></td></tr>
<tr><td>?</td><td>?</td><td>Default for <a href="https://en.wikipedia.org/wiki/IPython">IPython</a>[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-ipython-doc-3-notebook-server-292">291]</a>[<em><a href="https://en.wikipedia.org/wiki/Wikipedia:Verifiability#Self-published_sources">self-published source?</a></em>] / <a href="https://en.wikipedia.org/wiki/Jupyter">Jupyter</a>[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-jyputer-docs-running-notebook-293">292]</a>[<em><a href="https://en.wikipedia.org/wiki/Wikipedia:Verifiability#Self-published_sources">self-published source?</a></em>] notebook dashboards</td><td>Unofficial</td><td></td></tr>
<tr><td>?</td><td>?</td><td><a href="https://en.wikipedia.org/wiki/MAMP">MAMP</a>[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-osxdaily-mamp-294">293]</a></td><td>Unofficial</td><td></td></tr>
<tr><td>8889</td><td>?</td><td>?</td><td>MAMP[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-osxdaily-mamp-294">293]</a></td><td>Unofficial</td></tr>
<tr><td>8983</td><td>?</td><td>?</td><td><a href="https://en.wikipedia.org/wiki/Apache_Solr">Apache Solr</a>[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-apache-solr-6_6-running-solr-295">294]</a></td><td>Unofficial</td></tr>
<tr><td>8997</td><td>?</td><td>?</td><td>Alternate port for <a href="https://en.wikipedia.org/wiki/I2P">I2P</a> Monotone Proxy[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-geti2p-ports-168">167]</a>[<em><a href="https://en.wikipedia.org/wiki/Wikipedia:Manual_of_Style#Technical_language">jargon</a></em>]</td><td>Unofficial</td></tr>
<tr><td>8998</td><td>?</td><td>?</td><td>I2P Monotone Proxy[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-geti2p-ports-168">167]</a>[<em><a href="https://en.wikipedia.org/wiki/Wikipedia:Manual_of_Style#Technical_language">jargon</a></em>]</td><td>Unofficial</td></tr>
<tr><td>8999</td><td>?</td><td>?</td><td>Alternate port for I2P Monotone Proxy[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-geti2p-ports-168">167]</a>[<em><a href="https://en.wikipedia.org/wiki/Wikipedia:Manual_of_Style#Technical_language">jargon</a></em>]</td><td>Unofficial</td></tr>
<tr><td>9000</td><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/SonarQube">SonarQube</a> Web Server[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-296">295]</a></td><td>Unofficial</td></tr>
<tr><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/DBGp">DBGp</a></td><td>Unofficial</td><td></td></tr>
<tr><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/SqueezeCenter">SqueezeCenter</a> web server &amp; streaming</td><td>Unofficial</td><td></td></tr>
<tr><td></td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/UDPCast">UDPCast</a></td><td>Unofficial</td><td></td></tr>
<tr><td>Yes</td><td></td><td>Play! Framework web server[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-playframeworkdocumentation-297">296]</a></td><td>Unofficial</td><td></td></tr>
<tr><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/Hadoop_Distributed_File_System">Hadoop</a> NameNode default port</td><td>Unofficial</td><td></td></tr>
<tr><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/PHP-FPM">PHP-FPM</a> default port</td><td>Unofficial</td><td></td></tr>
<tr><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/QBittorrent">QBittorrent</a>'s embedded torrent tracker default port[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-298">297]</a></td><td>Unofficial</td><td></td></tr>
<tr><td>9001</td><td>Yes</td><td>Yes</td><td>ETL Service Manager[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-299">298]</a></td><td>Official</td></tr>
<tr><td></td><td></td><td><a href="https://en.wikipedia.org/wiki/Microsoft_SharePoint">Microsoft SharePoint</a> authoring environment</td><td>Unofficial</td><td></td></tr>
<tr><td></td><td></td><td>cisco-xremote router configuration[<em><a href="https://en.wikipedia.org/wiki/Wikipedia:Citation_needed">citation needed</a></em>]</td><td>Unofficial</td><td></td></tr>
<tr><td></td><td></td><td><a href="https://en.wikipedia.org/wiki/Tor_(anonymity_network)">Tor</a> network default</td><td>Unofficial</td><td></td></tr>
<tr><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/DBGp">DBGp</a> Proxy</td><td>Unofficial</td><td></td></tr>
<tr><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/HSQLDB">HSQLDB</a> default port</td><td>Unofficial</td><td></td></tr>
<tr><td>9002</td><td></td><td></td><td>Newforma Server comms</td><td>Unofficial</td></tr>
<tr><td>9006</td><td></td><td></td><td>De-Commissioned Port</td><td>Official</td></tr>
<tr><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/Apache_Tomcat">Tomcat</a> in standalone mode[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-apple-kb-HT202944-10">10]</a></td><td>Unofficial</td><td></td></tr>
<tr><td>9030</td><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/Tor_(anonymity_network)">Tor</a> often used</td><td>Unofficial</td></tr>
<tr><td>9042</td><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/Apache_Cassandra">Apache Cassandra</a> native protocol clients</td><td>Unofficial</td></tr>
<tr><td>9043</td><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/WebSphere_Application_Server">WebSphere Application Server</a> Administration Console secure</td><td>Unofficial</td></tr>
<tr><td>9050–9051</td><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/Tor_(anonymity_network)">Tor</a> (SOCKS-5 proxy client)</td><td>Unofficial</td></tr>
<tr><td>9060</td><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/WebSphere_Application_Server">WebSphere Application Server</a> Administration Console</td><td>Unofficial</td></tr>
<tr><td>9080</td><td>Yes</td><td>Yes</td><td>glrpc, <a href="https://en.wikipedia.org/wiki/Microsoft_Groove">Groove</a> <a href="https://en.wikipedia.org/wiki/Collaboration_software">Collaboration software</a> GLRPC</td><td>Official</td></tr>
<tr><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/WebSphere_Application_Server">WebSphere Application Server</a> <a href="https://en.wikipedia.org/wiki/HTTP">HTTP</a> Transport (port 1) <a href="https://en.wikipedia.org/wiki/Default_(computer_science)">default</a></td><td>Unofficial</td><td></td></tr>
<tr><td>Yes</td><td></td><td>Remote Potato by FatAttitude, Windows Media Center addon</td><td>Unofficial</td><td></td></tr>
<tr><td>Yes</td><td></td><td>ServerWMC, Windows Media Center addon</td><td>Unofficial</td><td></td></tr>
<tr><td>9090</td><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/Prometheus_(software)">Prometheus</a> metrics server</td><td>Unofficial</td></tr>
<tr><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/Openfire">Openfire</a> Administration Console</td><td>Unofficial</td><td></td></tr>
<tr><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/SqueezeCenter">SqueezeCenter</a> control (CLI)</td><td>Unofficial</td><td></td></tr>
<tr><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/Cherokee_(web_server)">Cherokee</a> Admin Panel</td><td>Unofficial</td><td></td></tr>
<tr><td>9091</td><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/Openfire">Openfire</a> Administration Console (SSL Secured)</td><td>Unofficial</td></tr>
<tr><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/Transmission_(BitTorrent_client)">Transmission (BitTorrent client)</a> Web Interface</td><td>Unofficial</td><td></td></tr>
<tr><td>9092</td><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/H2_(DBMS)">H2 (DBMS)</a> Database Server</td><td>Unofficial</td></tr>
<tr><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/Apache_Kafka">Apache Kafka</a> A Distributed Streaming Platform[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-300">299]</a></td><td>Unofficial</td><td></td></tr>
<tr><td>9100</td><td>Yes</td><td>Assigned</td><td><a href="https://en.wikipedia.org/wiki/Page_description_language">PDL</a> Data Stream, used for printing to certain network printers[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-apple-kb-HT202944-10">10]</a></td><td>Official</td></tr>
<tr><td>9101</td><td>Yes</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/Bacula">Bacula</a> Director</td><td>Official</td></tr>
<tr><td>9102</td><td>Yes</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/Bacula">Bacula</a> File Daemon</td><td>Official</td></tr>
<tr><td>9103</td><td>Yes</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/Bacula">Bacula</a> Storage Daemon</td><td>Official</td></tr>
<tr><td>9119</td><td>Yes</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/MXit">MXit</a> Instant Messenger</td><td>Official</td></tr>
<tr><td>9150</td><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/Tor_(anonymity_network)">Tor</a> Browser</td><td>Unofficial</td></tr>
<tr><td>9191</td><td>Yes</td><td></td><td>Sierra Wireless Airlink</td><td>Unofficial</td></tr>
<tr><td>9199</td><td>Yes</td><td></td><td>Avtex LLC—qStats</td><td>Unofficial</td></tr>
<tr><td>9200</td><td>Yes</td><td></td><td>Elasticsearch[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-301">300]</a>—default Elasticsearch port</td><td>Unofficial</td></tr>
<tr><td>9217</td><td>Yes</td><td></td><td>iPass Platform Service</td><td>Unofficial</td></tr>
<tr><td>9293</td><td>Yes</td><td></td><td>Sony PlayStation RemotePlay[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-302">301]</a></td><td>Unofficial</td></tr>
<tr><td>9300</td><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/IBM_Cognos_Business_Intelligence">IBM Cognos BI</a>[<em><a href="https://en.wikipedia.org/wiki/Wikipedia:Citation_needed">citation needed</a></em>]</td><td>Unofficial</td></tr>
<tr><td>9303</td><td></td><td>Yes</td><td><a href="https://en.wikipedia.org/w/index.php?title=D-Link_Shareport&amp;action=edit&amp;redlink=1">D-Link Shareport</a> Share storage and MFP printers[<em><a href="https://en.wikipedia.org/wiki/Wikipedia:Citation_needed">citation needed</a></em>]</td><td>Unofficial</td></tr>
<tr><td>9306</td><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/Sphinx_(search_engine)">Sphinx</a> Native API</td><td>Official</td></tr>
<tr><td>9309</td><td>Yes</td><td>Yes</td><td>Sony PlayStation Vita Host Collaboration WiFi Data Transfer[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-303">302]</a></td><td>Unofficial</td></tr>
<tr><td>9312</td><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/Sphinx_(search_engine)">Sphinx</a> SphinxQL</td><td>Official</td></tr>
<tr><td>9332</td><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/Litecoin">Litecoin</a> <a href="https://en.wikipedia.org/wiki/JSON-RPC">JSON-RPC</a> server</td><td>Unofficial</td></tr>
<tr><td>9333</td><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/Litecoin">Litecoin</a></td><td>Unofficial</td></tr>
<tr><td>9339</td><td>Yes</td><td></td><td>Used by all Supercell games such as Brawl Stars and Clash of Clans, mobile freemium strategy video games</td><td>Unofficial</td></tr>
<tr><td>9389</td><td>Yes</td><td>Yes</td><td>adws, <a href="https://en.wikipedia.org/wiki/Microsoft">Microsoft</a> <a href="https://en.wikipedia.org/wiki/AD_DS">AD DS</a> Web Services, <a href="https://en.wikipedia.org/wiki/Powershell">Powershell</a> uses this port</td><td>Official</td></tr>
<tr><td>9392</td><td>Yes</td><td>?</td><td>OpenVAS Greenbone Security Assistant web interface</td><td>Unofficial</td></tr>
<tr><td>9418</td><td>Yes</td><td>Yes</td><td>git, <a href="https://en.wikipedia.org/wiki/Git_(software)">Git</a> pack transfer service</td><td>Official</td></tr>
<tr><td>9419</td><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/Moose_File_System">MooseFS</a> distributed file system – master control port[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-mfs-manual3.0-ports-304">303]</a>[<em><a href="https://en.wikipedia.org/wiki/Wikipedia:Verifiability#Self-published_sources">self-published source</a></em>]</td><td>Unofficial</td></tr>
<tr><td>9420</td><td>Yes</td><td></td><td>MooseFS distributed file system – master command port[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-mfs-manual3.0-ports-304">303]</a></td><td>Unofficial</td></tr>
<tr><td>9421</td><td>Yes</td><td></td><td>MooseFS distributed file system – master client port[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-mfs-manual3.0-ports-304">303]</a></td><td>Unofficial</td></tr>
<tr><td>9422</td><td>Yes</td><td></td><td>MooseFS distributed file system – Chunkservers[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-mfs-manual3.0-ports-304">303]</a></td><td>Unofficial</td></tr>
<tr><td>9425</td><td>Yes</td><td></td><td>MooseFS distributed file system – CGI server[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-mfs-manual3.0-ports-304">303]</a></td><td>Unofficial</td></tr>
<tr><td>9443</td><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/VMware">VMware</a> Websense Triton console (HTTPS port used for accessing and administrating a vCenter Server via the Web Management Interface)</td><td>Unofficial</td></tr>
<tr><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/NCSA_Brown_Dog">NCSA Brown Dog</a> Data Tilling Service</td><td>Unofficial</td><td></td></tr>
<tr><td>9535</td><td>Yes</td><td>Yes</td><td>mngsuite, <a href="https://en.wikipedia.org/wiki/Landesk">LANDesk</a> Management Suite Remote Control</td><td>Official</td></tr>
<tr><td>9536</td><td>Yes</td><td>Yes</td><td>laes-bf, <a href="https://en.wikipedia.org/wiki/IP_Fabrics">IP Fabrics</a> Surveillance buffering function</td><td>Official</td></tr>
<tr><td>9600</td><td>No</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/Factory_Interface_Network_Service">Factory Interface Network Service</a> (FINS), a network protocol used by <a href="https://en.wikipedia.org/wiki/Omron">Omron</a> <a href="https://en.wikipedia.org/wiki/Programmable_logic_controller">programmable logic controllers</a>[<em><a href="https://en.wikipedia.org/wiki/Wikipedia:Citation_needed">citation needed</a></em>]</td><td>Unofficial</td></tr>
<tr><td>9669</td><td>Yes</td><td>No</td><td>VGG Image Search Engine <a href="https://www.robots.ox.ac.uk/%7Evgg/software/vise/">VISE</a></td><td>Unofficial</td></tr>
<tr><td>9675</td><td>Yes</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/Spiceworks">Spiceworks</a> Desktop, IT Helpdesk Software</td><td>Unofficial</td></tr>
<tr><td>9676</td><td>Yes</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/Spiceworks">Spiceworks</a> Desktop, IT Helpdesk Software</td><td>Unofficial</td></tr>
<tr><td>9695</td><td>?</td><td>?</td><td><a href="https://en.wikipedia.org/wiki/Content_centric_networking">Content centric networking</a> (CCN, CCNx)[<em><a href="https://en.wikipedia.org/wiki/Wikipedia:Citation_needed">citation needed</a></em>]</td><td>Official</td></tr>
<tr><td>9785</td><td>Yes</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/Viber">Viber</a>[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-viber-192">191]</a></td><td>Unofficial</td></tr>
<tr><td>9800</td><td>Yes</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/WebDAV">WebDAV</a> Source</td><td>Official</td></tr>
<tr><td></td><td></td><td><a href="https://en.wikipedia.org/wiki/WebCT">WebCT</a> e-learning portal</td><td>Unofficial</td><td></td></tr>
<tr><td>9875</td><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/Club_Penguin">Club Penguin</a> Disney online game for kids</td><td>Unofficial</td></tr>
<tr><td>9898</td><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/Tripwire_(software)">Tripwire</a>—File Integrity Monitoring Software[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-305">304]</a></td><td>Unofficial</td></tr>
<tr><td>9899</td><td></td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/Stream_Control_Transmission_Protocol">SCTP</a> tunneling (port number used in SCTP packets encapsulated in UDP, <a href="https://tools.ietf.org/html/rfc6951">RFC 6951</a>)</td><td>Official</td></tr>
<tr><td>9901</td><td>Yes</td><td></td><td>Banana for Apache Solr</td><td>Unofficial</td></tr>
<tr><td>9981</td><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/Tvheadend">Tvheadend</a> HTTP server (web interface)[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-tvh-wiki-install-initial-setup-306">305]</a></td><td>Unofficial</td></tr>
<tr><td>9982</td><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/Tvheadend">Tvheadend</a> HTSP server (Streaming protocol)[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-tvh-wiki-install-initial-setup-306">305]</a></td><td>Unofficial</td></tr>
<tr><td>9987</td><td></td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/TeamSpeak">TeamSpeak</a> 3 server default (voice) port (for the conflicting service see the IANA list)</td><td>Unofficial</td></tr>
<tr><td>9993</td><td></td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/ZeroTier">ZeroTier</a> Default port for ZeroTier</td><td>Unofficial</td></tr>
<tr><td>9997</td><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/Splunk">Splunk</a> port for communication between the forwarders and indexers</td><td>Unofficial</td></tr>
<tr><td>9999</td><td></td><td></td><td><a href="https://en.wikipedia.org/wiki/Urchin_Software_Corporation">Urchin</a> Web Analytics[<em><a href="https://en.wikipedia.org/wiki/Wikipedia:Citation_needed">citation needed</a></em>]</td><td>Unofficial</td></tr>
<tr><td>10000</td><td>Yes</td><td>Yes</td><td>Network Data Management Protocol</td><td>Official</td></tr>
<tr><td></td><td></td><td><a href="https://en.wikipedia.org/wiki/BackupExec">BackupExec</a></td><td>Unofficial</td><td></td></tr>
<tr><td></td><td></td><td><a href="https://en.wikipedia.org/wiki/Webmin">Webmin</a>, Web-based Unix/Linux system administration tool (default port)</td><td>Unofficial</td><td></td></tr>
<tr><td>10000–20000</td><td>No</td><td>Yes</td><td>Used on <a href="https://en.wikipedia.org/wiki/Voice_over_IP">VoIP</a> networks for receiving and transmitting voice telephony traffic which includes <a href="https://en.wikipedia.org/wiki/Google_Voice">Google Voice</a> via the <a href="https://en.wikipedia.org/wiki/Obihai_Technology">OBiTalk</a> <a href="https://en.wikipedia.org/wiki/Analog_telephone_adapter">ATA</a> devices as well as on the <a href="https://en.wikipedia.org/wiki/MagicJack">MagicJack</a> and <a href="https://en.wikipedia.org/wiki/Vonage">Vonage</a> ATA network devices.[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-support.vonage.com-307">306]</a></td><td>Unofficial</td></tr>
<tr><td>10001</td><td></td><td>Yes</td><td>Ubiquiti UniFi access points broadcast to 255.255.255.255:10001 (UDP) to locate the controller(s)</td><td>Unofficial</td></tr>
<tr><td>10009</td><td>Yes</td><td>Yes</td><td><em><a href="https://en.wikipedia.org/wiki/CrossFire_(video_game)">CrossFire</a></em>, a multiplayer online First Person Shooter[<em><a href="https://en.wikipedia.org/wiki/Wikipedia:Citation_needed">citation needed</a></em>]</td><td>Unofficial</td></tr>
<tr><td>10011</td><td>?</td><td>?</td><td>Teamspeak3 Chat Server[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-hub.docker.com-308">307]</a></td><td>Unofficial</td></tr>
<tr><td>10024</td><td>Yes</td><td></td><td>Zimbra smtp [mta]—to amavis from postfix[<em><a href="https://en.wikipedia.org/wiki/Wikipedia:Citation_needed">citation needed</a></em>]</td><td>Unofficial</td></tr>
<tr><td>10025</td><td>Yes</td><td></td><td>Zimbra smtp [mta]—back to postfix from amavis[<em><a href="https://en.wikipedia.org/wiki/Wikipedia:Citation_needed">citation needed</a></em>]</td><td>Unofficial</td></tr>
<tr><td>10042</td><td>Yes</td><td></td><td><a href="https://www.mediawiki.org/wiki/Mathoid">Mathoid</a> server[<em><a href="https://en.wikipedia.org/wiki/Wikipedia:Citation_needed">citation needed</a></em>]</td><td>Unofficial</td></tr>
<tr><td>10050</td><td>Yes</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/Zabbix">Zabbix</a> agent</td><td>Official</td></tr>
<tr><td>10051</td><td>Yes</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/Zabbix">Zabbix</a> trapper</td><td>Official</td></tr>
<tr><td>10110</td><td>Yes</td><td>Yes</td><td>NMEA 0183 Navigational Data. Transport of NMEA 0183 sentences over TCP or UDP</td><td>Official</td></tr>
<tr><td>10172</td><td>Yes</td><td></td><td>Intuit <a href="https://en.wikipedia.org/wiki/Quickbooks">Quickbooks</a> client</td><td>Unofficial</td></tr>
<tr><td>10200</td><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/FRISK_Software_International">FRISK Software International</a>'s <em>fpscand</em> virus scanning daemon for Unix platforms[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-309">308]</a></td><td>Unofficial</td></tr>
<tr><td>Yes</td><td></td><td>FRISK Software International's <em>f-protd</em> virus scanning daemon for Unix platforms[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-autogenerated2-310">309]</a></td><td>Unofficial</td><td></td></tr>
<tr><td>10201–10204</td><td>Yes</td><td></td><td>FRISK Software International's <em>f-protd</em> virus scanning daemon for Unix platforms[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-autogenerated2-310">309]</a></td><td>Unofficial</td></tr>
<tr><td>10212</td><td>Yes</td><td></td><td>GE Intelligent Platforms Proficy HMI/SCADA – CIMPLICITY WebView[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-311">310]</a></td><td>Official</td></tr>
<tr><td>10308</td><td>?</td><td>?</td><td><em><a href="https://en.wikipedia.org/wiki/Lock_On:_Modern_Air_Combat">Lock On: Modern Air Combat</a></em>[<em><a href="https://en.wikipedia.org/wiki/Wikipedia:Citation_needed">citation needed</a></em>]</td><td>Unofficial</td></tr>
<tr><td>10480</td><td>?</td><td>?</td><td><em><a href="https://en.wikipedia.org/wiki/SWAT_4">SWAT 4</a></em> Dedicated Server[<em><a href="https://en.wikipedia.org/wiki/Wikipedia:Citation_needed">citation needed</a></em>]</td><td>Unofficial</td></tr>
<tr><td>10505</td><td></td><td>Yes</td><td>BlueStacks (android simulator) broadcast[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-312">311]</a></td><td>Unofficial</td></tr>
<tr><td>10514</td><td>Yes</td><td>Yes</td><td>TLS-enabled Rsyslog (default by convention)</td><td>Unofficial</td></tr>
<tr><td>10800</td><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/Touhou">Touhou</a> fight games (<a href="https://en.wikipedia.org/wiki/Immaterial_and_Missing_Power">Immaterial and Missing Power</a>, <a href="https://en.wikipedia.org/wiki/Scarlet_Weather_Rhapsody">Scarlet Weather Rhapsody</a>, <a href="https://en.wikipedia.org/wiki/Touhou_His%C5%8Dtensoku">Hisoutensoku</a>, <a href="https://en.wikipedia.org/wiki/Hopeless_Masquerade">Hopeless Masquerade</a> and <a href="https://en.wikipedia.org/wiki/Urban_Legend_in_Limbo">Urban Legend in Limbo</a>)</td><td>Unofficial</td></tr>
<tr><td>10823</td><td></td><td>Yes</td><td><em><a href="https://en.wikipedia.org/wiki/Farming_Simulator_2011">Farming Simulator 2011</a></em>[<em><a href="https://en.wikipedia.org/wiki/Wikipedia:Citation_needed">citation needed</a></em>]</td><td>Unofficial</td></tr>
<tr><td>10891</td><td>Yes</td><td></td><td>Jungle Disk (this port is opened by the Jungle Disk Monitor service on the localhost)[<em><a href="https://en.wikipedia.org/wiki/Wikipedia:Citation_needed">citation needed</a></em>]</td><td>Unofficial</td></tr>
<tr><td>10933</td><td>Yes</td><td>No</td><td>Octopus Deploy Tentacle deployment agent[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-313">312]</a></td><td>Official</td></tr>
<tr><td>11001</td><td>Yes</td><td>Yes</td><td>metasys ( Johnson Controls Metasys java AC control environment )</td><td>Official</td></tr>
<tr><td>11100</td><td>No</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/Risk_of_Rain">Risk of Rain</a> multiplayer server</td><td>Unofficial</td></tr>
<tr><td>11111</td><td>Yes</td><td></td><td>RiCcI, Remote Configuration Interface (Redhat Linux)</td><td>Unofficial</td></tr>
<tr><td>11112</td><td>Yes</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/American_College_of_Radiology">ACR</a>/<a href="https://en.wikipedia.org/wiki/National_Electrical_Manufacturers_Association">NEMA</a> <a href="https://en.wikipedia.org/wiki/Digital_Imaging_and_Communications_in_Medicine">Digital Imaging and Communications in Medicine</a> (DICOM)</td><td>Official</td></tr>
<tr><td>11211</td><td>Yes</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/Memcached">memcached</a>[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-apple-kb-HT202944-10">10]</a></td><td>Unofficial</td></tr>
<tr><td>11214</td><td>Yes</td><td>Yes</td><td>memcached incoming SSL proxy</td><td>Unofficial</td></tr>
<tr><td>11215</td><td>Yes</td><td>Yes</td><td>memcached internal outgoing SSL proxy</td><td>Unofficial</td></tr>
<tr><td>11235</td><td></td><td></td><td><em><a href="https://en.wikipedia.org/wiki/Savage:_Battle_for_Newerth">Savage: Battle for Newerth</a></em>[<em><a href="https://en.wikipedia.org/wiki/Wikipedia:Citation_needed">citation needed</a></em>]</td><td>Unofficial</td></tr>
<tr><td>11311</td><td>Yes</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/Robot_Operating_System">Robot Operating System</a> master</td><td>Unofficial</td></tr>
<tr><td>11371</td><td>Yes</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/OpenPGP">OpenPGP</a> HTTP <a href="https://en.wikipedia.org/wiki/Key_server_(cryptographic)">key server</a></td><td>Official</td></tr>
<tr><td>11753</td><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/OpenRCT2">OpenRCT2</a> multiplayer[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-openrct2-docs-multiplayer-314">313]</a>[<em><a href="https://en.wikipedia.org/wiki/Wikipedia:Verifiability#Self-published_sources">self-published source</a></em>]</td><td>Unofficial</td></tr>
<tr><td>12000</td><td>Yes</td><td>Yes</td><td><a href="https://en.wikipedia.org/w/index.php?title=CubeForm&amp;action=edit&amp;redlink=1">CubeForm</a>, Multiplayer SandBox Game</td><td>Unofficial</td></tr>
<tr><td>12012</td><td></td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/Audition_Online_Dance_Battle">Audition Online Dance Battle</a>, Korea Server—Status/Version Check</td><td>Unofficial</td></tr>
<tr><td>12013</td><td>Yes</td><td>Yes</td><td>Audition Online Dance Battle, Korea Server</td><td>Unofficial</td></tr>
<tr><td>12035</td><td></td><td>Yes</td><td><em><a href="https://en.wikipedia.org/wiki/Second_Life">Second Life</a></em>, used for server UDP in-bound[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-http://wiki.secondlife.com/wiki/Authentication_Flow@step_4-315">314]</a></td><td>Unofficial</td></tr>
<tr><td>12043</td><td>Yes</td><td></td><td><em>Second Life</em>, used for LSL HTTPS in-bound[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-wiki.secondlife.com/wiki/LSL_HTTP_server@Functions-316">315]</a></td><td>Unofficial</td></tr>
<tr><td>12046</td><td>Yes</td><td></td><td><em>Second Life</em>, used for LSL HTTP in-bound[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-wiki.secondlife.com/wiki/LSL_HTTP_server@Functions-316">315]</a></td><td>Unofficial</td></tr>
<tr><td>12201</td><td>Yes</td><td>Yes</td><td>Graylog Extended Log Format (GELF)[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-317">316]</a>[<em><a href="https://en.wikipedia.org/wiki/Wikipedia:What_Wikipedia_is_not#Encyclopedic_content">importance?</a></em>]</td><td>Unofficial</td></tr>
<tr><td>12222</td><td></td><td>Yes</td><td>Light Weight Access Point Protocol (<a href="https://en.wikipedia.org/wiki/LWAPP">LWAPP</a>) LWAPP data (<a href="https://tools.ietf.org/html/rfc5412">RFC 5412</a>)</td><td>Official</td></tr>
<tr><td>12223</td><td></td><td>Yes</td><td>Light Weight Access Point Protocol (<a href="https://en.wikipedia.org/wiki/LWAPP">LWAPP</a>) LWAPP control (<a href="https://tools.ietf.org/html/rfc5412">RFC 5412</a>)</td><td>Official</td></tr>
<tr><td>12307</td><td></td><td>Yes</td><td>Makerbot UDP Broadcast (client to printer) (JSON-RPC)[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-https://support.makerbot.com/learn/makerbot-desktop-software/using-makerbot-desktop/network-connectivity-for-enterprise-private-networks-fifth-generation-makerbot-3d-printers_1190-318">317]</a></td><td>Unofficial</td></tr>
<tr><td>12308</td><td></td><td>Yes</td><td>Makerbot UDP Broadcast (printer to client) (JSON-RPC)[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-https://support.makerbot.com/learn/makerbot-desktop-software/using-makerbot-desktop/network-connectivity-for-enterprise-private-networks-fifth-generation-makerbot-3d-printers_1190-318">317]</a></td><td>Unofficial</td></tr>
<tr><td>12345</td><td>Yes</td><td>Yes</td><td><em><a href="https://en.wikipedia.org/wiki/Cube_World">Cube World</a></em>[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-319">318]</a></td><td>Unofficial</td></tr>
<tr><td>Yes</td><td></td><td><em><a href="https://en.wikipedia.org/wiki/Little_Fighter_2">Little Fighter 2</a></em></td><td>Unofficial</td><td></td></tr>
<tr><td></td><td></td><td><a href="https://en.wikipedia.org/wiki/NetBus">NetBus</a> remote administration tool (often <a href="https://en.wikipedia.org/wiki/Trojan_horse_(computing)">Trojan horse</a>).</td><td>Unofficial</td><td></td></tr>
<tr><td>12443</td><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/IBM_Hardware_Management_Console">IBM HMC</a> web browser management access over <a href="https://en.wikipedia.org/wiki/HTTPS">HTTPS</a> instead of default port 443[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-320">319]</a></td><td>Unofficial</td></tr>
<tr><td>12489</td><td>Yes</td><td></td><td>NSClient/NSClient++/NC_Net (Nagios)</td><td>Unofficial</td></tr>
<tr><td>12975</td><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/LogMeIn">LogMeIn</a> <a href="https://en.wikipedia.org/wiki/Hamachi_(software)">Hamachi</a> (VPN tunnel software; also port 32976)—used to connect to Mediation Server (bibi.hamachi.cc); will attempt to use <a href="https://en.wikipedia.org/wiki/Secure_Sockets_Layer">SSL</a> (TCP port 443) if both 12975 &amp; 32976 fail to connect</td><td>Unofficial</td></tr>
<tr><td>13000–13050</td><td></td><td>Yes</td><td><em><a href="https://en.wikipedia.org/wiki/Second_Life">Second Life</a></em>, used for server UDP in-bound[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-321">320]</a></td><td>Unofficial</td></tr>
<tr><td>13008</td><td>Yes</td><td>Yes</td><td><em><a href="https://en.wikipedia.org/wiki/CrossFire_(video_game)">CrossFire</a></em>, a multiplayer online First Person Shooter[<em><a href="https://en.wikipedia.org/wiki/Wikipedia:Citation_needed">citation needed</a></em>]</td><td>Unofficial</td></tr>
<tr><td>13075</td><td>Yes</td><td></td><td>Default[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-322">321]</a> for <a href="https://en.wikipedia.org/wiki/BMC_Software">BMC Software</a> <a href="https://en.wikipedia.org/wiki/BMC_Control-M">Control-M/Enterprise Manager</a> Corba communication, though often changed during installation</td><td>Official</td></tr>
<tr><td>13400</td><td>Yes</td><td>Yes</td><td>ISO 13400 Road vehicles — Diagnostic communication over Internet Protocol(DoIP)</td><td>Official</td></tr>
<tr><td>13720</td><td>Yes</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/NortonLifeLock">Symantec</a> <a href="https://en.wikipedia.org/wiki/NetBackup">NetBackup</a>—bprd (formerly <a href="https://en.wikipedia.org/wiki/Veritas_Software">VERITAS</a>)</td><td>Official</td></tr>
<tr><td>13721</td><td>Yes</td><td>Yes</td><td>Symantec NetBackup—bpdbm (formerly VERITAS)</td><td>Official</td></tr>
<tr><td>13724</td><td>Yes</td><td>Yes</td><td>Symantec Network Utility—vnetd (formerly VERITAS)</td><td>Official</td></tr>
<tr><td>13782</td><td>Yes</td><td>Yes</td><td>Symantec NetBackup—bpcd (formerly VERITAS)</td><td>Official</td></tr>
<tr><td>13783</td><td>Yes</td><td>Yes</td><td>Symantec VOPIED protocol (formerly VERITAS)</td><td>Official</td></tr>
<tr><td>13785</td><td>Yes</td><td>Yes</td><td>Symantec NetBackup Database—nbdb (formerly VERITAS)</td><td>Official</td></tr>
<tr><td>13786</td><td>Yes</td><td>Yes</td><td>Symantec nomdb (formerly VERITAS)</td><td>Official</td></tr>
<tr><td>14550</td><td></td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/MAVLink">MAVLink</a> Ground Station Port</td><td>Unofficial</td></tr>
<tr><td>14567</td><td></td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/Battlefield_1942">Battlefield 1942</a> and mods</td><td>Unofficial</td></tr>
<tr><td>14800</td><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/Age_of_Wonders_III">Age of Wonders III</a> p2p port[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-323">322]</a></td><td>Unofficial</td></tr>
<tr><td>15000</td><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/PsyBNC">psyBNC</a></td><td>Unofficial</td></tr>
<tr><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/Wesnoth">Wesnoth</a></td><td>Unofficial</td><td></td></tr>
<tr><td>Yes</td><td></td><td>Kaspersky Network Agent[<em><a href="https://en.wikipedia.org/wiki/Wikipedia:Citation_needed">citation needed</a></em>]</td><td>Unofficial</td><td></td></tr>
<tr><td></td><td>Yes</td><td>Teltonika networks remote management system (RMS)</td><td>Unofficial</td><td></td></tr>
<tr><td>15009</td><td>Yes</td><td>Yes</td><td>Teltonika networks remote management system (RMS)</td><td>Unofficial</td></tr>
<tr><td>15010</td><td>Yes</td><td>Yes</td><td>Teltonika networks remote management system (RMS)</td><td>Unofficial</td></tr>
<tr><td>15441</td><td>?</td><td>?</td><td><a href="https://en.wikipedia.org/wiki/ZeroNet">ZeroNet</a> fileserver[<em><a href="https://en.wikipedia.org/wiki/Wikipedia:Citation_needed">citation needed</a></em>]</td><td>Unofficial</td></tr>
<tr><td>15567</td><td></td><td>Yes</td><td><em><a href="https://en.wikipedia.org/wiki/Battlefield_Vietnam">Battlefield Vietnam</a></em> and mods</td><td>Unofficial</td></tr>
<tr><td>15345</td><td>Yes</td><td>Yes</td><td><em><a href="https://en.wikipedia.org/wiki/XPilot">XPilot</a></em> Contact</td><td>Official</td></tr>
<tr><td>15672</td><td>Yes</td><td>No</td><td><a href="https://en.wikipedia.org/wiki/RabbitMQ">RabbitMQ</a> management plugin[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-rabbitmq-management-324">323]</a>[<em><a href="https://en.wikipedia.org/wiki/Wikipedia:Verifiability#Self-published_sources">self-published source</a></em>]</td><td>Unofficial</td></tr>
<tr><td>16000</td><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/Oracle_WebCenter">Oracle WebCenter</a> Content: Imaging (formerly known as Oracle <a href="https://en.wikipedia.org/wiki/Universal_Content_Management">Universal Content Management</a>). Port though often changed during installation</td><td>Unofficial</td></tr>
<tr><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/ShroudBNC">shroudBNC</a></td><td>Unofficial</td><td></td></tr>
<tr><td>16080</td><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/Mac_OS_X_Server">Mac OS X Server</a> Web (HTTP) service with performance cache[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-325">324]</a></td><td>Unofficial</td></tr>
<tr><td>16200</td><td>Yes</td><td></td><td>Oracle WebCenter Content: Content Server (formerly known as Oracle <a href="https://en.wikipedia.org/wiki/Universal_Content_Management">Universal Content Management</a>). Port though often changed during installation</td><td>Unofficial</td></tr>
<tr><td>16225</td><td>Yes</td><td></td><td>Oracle WebCenter Content: Content Server Web UI. Port though often changed during installation</td><td>Unofficial</td></tr>
<tr><td>16250</td><td>Yes</td><td></td><td>Oracle WebCenter Content: Inbound Refinery (formerly known as Oracle <a href="https://en.wikipedia.org/wiki/Universal_Content_Management">Universal Content Management</a>). Port though often changed during installation</td><td>Unofficial</td></tr>
<tr><td>16261</td><td>Yes</td><td>Yes</td><td><em><a href="https://en.wikipedia.org/wiki/Project_Zomboid">Project Zomboid</a></em> multiplayer. Additional sequential ports used for each player connecting to server.[<em><a href="https://en.wikipedia.org/wiki/Wikipedia:Citation_needed">citation needed</a></em>]</td><td>Unofficial</td></tr>
<tr><td>16300</td><td>Yes</td><td></td><td>Oracle WebCenter Content: Records Management (formerly known as Oracle <a href="https://en.wikipedia.org/w/index.php?title=Universal_Records_Management&amp;action=edit&amp;redlink=1">Universal Records Management</a>). Port though often changed during installation</td><td>Unofficial</td></tr>
<tr><td>16384</td><td></td><td>Yes</td><td>CISCO Default RTP MIN</td><td>Unofficial</td></tr>
<tr><td>16384-16403</td><td></td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/Real-time_Transport_Protocol">Real-time Transport Protocol</a> (RTP), <a href="https://en.wikipedia.org/wiki/RTP_Control_Protocol">RTP Control Protocol</a> (RTCP), used by <a href="https://en.wikipedia.org/wiki/Apple_Inc.">Apple</a>'s <a href="https://en.wikipedia.org/wiki/IChat">iChat</a> for audio and video[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-apple-kb-HT202944-10">10]</a></td><td>Unofficial</td></tr>
<tr><td>16384-16387</td><td></td><td>Yes</td><td>Real-time Transport Protocol (RTP), RTP Control Protocol (RTCP), used by Apple's <a href="https://en.wikipedia.org/wiki/FaceTime">FaceTime</a> and <a href="https://en.wikipedia.org/wiki/Game_Center">Game Center</a>[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-apple-kb-HT202944-10">10]</a></td><td>Unofficial</td></tr>
<tr><td>16393-16402</td><td></td><td>Yes</td><td>Real-time Transport Protocol (RTP), RTP Control Protocol (RTCP), used by Apple's FaceTime and Game Center[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-apple-kb-HT202944-10">10]</a></td><td>Unofficial</td></tr>
<tr><td>16403-16472</td><td></td><td>Yes</td><td>Real-time Transport Protocol (RTP), RTP Control Protocol (RTCP), used by Apple's Game Center[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-apple-kb-HT202944-10">10]</a></td><td>Unofficial</td></tr>
<tr><td>16400</td><td>Yes</td><td></td><td>Oracle WebCenter Content: Capture (formerly known as Oracle Document Capture). Port though often changed during installation</td><td>Unofficial</td></tr>
<tr><td>16482</td><td></td><td></td><td>CISCO Default RTP MAX</td><td>Official</td></tr>
<tr><td>16567</td><td></td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/Battlefield_2">Battlefield 2</a> and mods</td><td>Unofficial</td></tr>
<tr><td>17011</td><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/Worms_(series)">Worms</a> multiplayer</td><td>Unofficial</td></tr>
<tr><td>17224</td><td>Yes</td><td>Yes</td><td>Train Realtime Data Protocol (TRDP) Process Data, network protocol used in train communication.[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-IANA-1">1]</a>[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-port_17224,_IANA,_2019-326">325]</a></td><td>Official</td></tr>
<tr><td>17225</td><td>Yes</td><td>Yes</td><td>Train Realtime Data Protocol (TRDP) Message Data, network protocol used in train communication.[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-IANA-1">1]</a>[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-port_17225,_IANA,_2019-327">326]</a></td><td>Official</td></tr>
<tr><td>17333</td><td>Yes</td><td></td><td>CS Server (CSMS), default binary protocol port</td><td>Unofficial</td></tr>
<tr><td>17475</td><td>Yes</td><td></td><td>DMXControl 3 Network Broker</td><td>Unofficial</td></tr>
<tr><td>17500</td><td>Yes</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/Dropbox_(storage_provider)">Dropbox</a> LanSync Protocol (db-lsp); used to synchronize file catalogs between Dropbox clients on a local network.</td><td>Official</td></tr>
<tr><td>18080</td><td>Yes</td><td>No</td><td><a href="https://en.wikipedia.org/wiki/Monero_(cryptocurrency)">Monero</a> P2P network communications[<em><a href="https://en.wikipedia.org/wiki/Wikipedia:Citation_needed">citation needed</a></em>]</td><td>Unofficial</td></tr>
<tr><td>18081</td><td>Yes</td><td>No</td><td>Monero incoming RPC calls[<em><a href="https://en.wikipedia.org/wiki/Wikipedia:Citation_needed">citation needed</a></em>]</td><td>Unofficial</td></tr>
<tr><td>18091</td><td>Yes</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/Memcached">memcached</a> Internal REST HTTPS for SSL</td><td>Unofficial</td></tr>
<tr><td>18092</td><td>Yes</td><td>Yes</td><td>memcached Internal CAPI HTTPS for SSL</td><td>Unofficial</td></tr>
<tr><td>18104</td><td>Yes</td><td></td><td>RAD PDF Service</td><td>Official</td></tr>
<tr><td>18200</td><td>Yes</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/Audition_Online_Dance_Battle">Audition Online Dance Battle</a>, AsiaSoft Thailand Server status/version check</td><td>Unofficial</td></tr>
<tr><td>18201</td><td>Yes</td><td>Yes</td><td>Audition Online Dance Battle, AsiaSoft Thailand Server</td><td>Unofficial</td></tr>
<tr><td>18206</td><td>Yes</td><td>Yes</td><td>Audition Online Dance Battle, AsiaSoft Thailand Server FAM database</td><td>Unofficial</td></tr>
<tr><td>18300</td><td>Yes</td><td>Yes</td><td>Audition Online Dance Battle, AsiaSoft SEA Server status/version check</td><td>Unofficial</td></tr>
<tr><td>18301</td><td>Yes</td><td>Yes</td><td>Audition Online Dance Battle, AsiaSoft SEA Server</td><td>Unofficial</td></tr>
<tr><td>18306</td><td>Yes</td><td>Yes</td><td>Audition Online Dance Battle, AsiaSoft SEA Server FAM database</td><td>Unofficial</td></tr>
<tr><td>18333</td><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/Bitcoin">Bitcoin</a> testnet[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-ReferenceA-273">272]</a></td><td>Unofficial</td></tr>
<tr><td>18400</td><td>Yes</td><td>Yes</td><td>Audition Online Dance Battle, KAIZEN Brazil Server status/version check</td><td>Unofficial</td></tr>
<tr><td>18401</td><td>Yes</td><td>Yes</td><td>Audition Online Dance Battle, KAIZEN Brazil Server</td><td>Unofficial</td></tr>
<tr><td>18505</td><td>Yes</td><td>Yes</td><td>Audition Online Dance Battle R4p3 Server, Nexon Server status/version check</td><td>Unofficial</td></tr>
<tr><td>18506</td><td>Yes</td><td>Yes</td><td>Audition Online Dance Battle, Nexon Server</td><td>Unofficial</td></tr>
<tr><td>18605</td><td>Yes</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/X-BEAT">X-BEAT</a> status/version check</td><td>Unofficial</td></tr>
<tr><td>18606</td><td>Yes</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/X-BEAT">X-BEAT</a></td><td>Unofficial</td></tr>
<tr><td>18676</td><td>Yes</td><td>Yes</td><td>YouView</td><td>Unofficial</td></tr>
<tr><td>19000</td><td>Yes</td><td>Yes</td><td>Audition Online Dance Battle, G10/alaplaya Server status/version check</td><td>Unofficial</td></tr>
<tr><td></td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/JACK_Audio_Connection_Kit">JACK</a> sound server</td><td>Unofficial</td><td></td></tr>
<tr><td>19001</td><td>Yes</td><td>Yes</td><td>Audition Online Dance Battle, G10/alaplaya Server</td><td>Unofficial</td></tr>
<tr><td>19132</td><td></td><td>Yes</td><td><em><a href="https://en.wikipedia.org/wiki/Minecraft:_Bedrock_Edition">Minecraft: Bedrock Edition</a></em> multiplayer server[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-minecraft.gamepedia.com-328">327]</a></td><td>Unofficial</td></tr>
<tr><td>19133</td><td></td><td>Yes</td><td><em>Minecraft: Bedrock Edition</em> IPv6 multiplayer server[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-minecraft.gamepedia.com-328">327]</a></td><td>Unofficial</td></tr>
<tr><td>19150</td><td>Yes</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/Gkrellm">Gkrellm</a> Server</td><td>Unofficial</td></tr>
<tr><td>19226</td><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/Panda_Security">Panda Software</a> AdminSecure Communication Agent</td><td>Unofficial</td></tr>
<tr><td>19294</td><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/Google_Talk">Google Talk</a> Voice and Video connections[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-gtalk_voice-329">328]</a></td><td>Unofficial</td></tr>
<tr><td>19295</td><td></td><td>Yes</td><td>Google Talk Voice and Video connections[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-gtalk_voice-329">328]</a></td><td>Unofficial</td></tr>
<tr><td>19302</td><td></td><td>Yes</td><td>Google Talk Voice and Video connections[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-gtalk_voice-329">328]</a></td><td>Unofficial</td></tr>
<tr><td>19531</td><td>Yes</td><td>No</td><td><a href="https://en.wikipedia.org/wiki/Systemd">systemd</a>-journal-gatewayd[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-330">329]</a></td><td>Unofficial</td></tr>
<tr><td>19532</td><td>Yes</td><td>No</td><td><a href="https://en.wikipedia.org/wiki/Systemd">systemd</a>-journal-remote[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-331">330]</a></td><td>Unofficial</td></tr>
<tr><td>19812</td><td>Yes</td><td>No</td><td>4D database SQL Communication[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-4D_ports-332">331]</a></td><td>Official</td></tr>
<tr><td>19813</td><td>Yes</td><td>Yes</td><td>4D database Client Server Communication[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-4D_ports-332">331]</a></td><td>Official</td></tr>
<tr><td>19814</td><td>Yes</td><td></td><td>4D database DB4D Communication[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-4D_ports-332">331]</a></td><td>Official</td></tr>
<tr><td>19999</td><td></td><td></td><td>Distributed Network Protocol—Secure (<a href="https://en.wikipedia.org/wiki/DNP3">DNP</a>—Secure), a secure version of the protocol used in <a href="https://en.wikipedia.org/wiki/SCADA">SCADA</a> systems between communicating <a href="https://en.wiktionary.org/wiki/RTU">RTU</a>'s and <a href="https://en.wiktionary.org/wiki/IED">IED</a>'s</td><td>Official</td></tr>
<tr><td>20000</td><td></td><td></td><td>Distributed Network Protocol (<a href="https://en.wikipedia.org/wiki/DNP3">DNP</a>), a protocol used in <a href="https://en.wikipedia.org/wiki/SCADA">SCADA</a> systems between communicating <a href="https://en.wikipedia.org/wiki/Remote_Terminal_Unit">RTU</a>'s and <a href="https://en.wikipedia.org/wiki/Intelligent_electronic_device">IED</a>'s</td><td>Official</td></tr>
<tr><td></td><td></td><td><a href="https://en.wikipedia.org/wiki/Usermin">Usermin</a>, Web-based Unix/Linux user administration tool (default port)</td><td>Unofficial</td><td></td></tr>
<tr><td></td><td>Yes</td><td>Used on <a href="https://en.wikipedia.org/wiki/Voice_over_IP">VoIP</a> networks for receiving and transmitting voice telephony traffic which includes <a href="https://en.wikipedia.org/wiki/Google_Voice">Google Voice</a> via the <a href="https://en.wikipedia.org/wiki/Obihai_Technology">OBiTalk</a> <a href="https://en.wikipedia.org/wiki/Analog_telephone_adapter">ATA</a> devices as well as on the <a href="https://en.wikipedia.org/wiki/MagicJack">MagicJack</a> and <a href="https://en.wikipedia.org/wiki/Vonage">Vonage</a> ATA network devices.[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-support.vonage.com-307">306]</a></td><td>Unofficial</td><td></td></tr>
<tr><td>20560</td><td>Yes</td><td>Yes</td><td><em><a href="https://en.wikipedia.org/wiki/Killing_Floor_(2009_video_game)">Killing Floor</a></em></td><td>Unofficial</td></tr>
<tr><td>20582</td><td></td><td>Yes</td><td>HW Development IoT comms</td><td>Unofficial</td></tr>
<tr><td>20583</td><td></td><td>Yes</td><td>HW Development IoT comms</td><td>Unofficial</td></tr>
<tr><td>20595</td><td></td><td>Yes</td><td><em><a href="https://en.wikipedia.org/wiki/0_A.D._(video_game)">0 A.D. Empires Ascendant</a></em></td><td>Unofficial</td></tr>
<tr><td>20808</td><td></td><td>Yes</td><td>Ableton Link</td><td>Unofficial</td></tr>
<tr><td>21025</td><td>Yes</td><td></td><td>Starbound Server (default), <a href="http://playstarbound.com/">Starbound</a></td><td>Unofficial</td></tr>
<tr><td>22000</td><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/Syncthing">Syncthing</a> (default)</td><td>Unofficial</td></tr>
<tr><td>22136</td><td>Yes</td><td></td><td><a href="http://www.flir.com/">FLIR Systems</a> Camera Resource Protocol</td><td>Unofficial</td></tr>
<tr><td>22222</td><td>Yes</td><td></td><td>Davis Instruments, <a href="http://davisnet.com/weather/products/weather_product.asp?pnum=06555">WeatherLink IP</a></td><td>Unofficial</td></tr>
<tr><td>23073</td><td></td><td></td><td><a href="https://en.wikipedia.org/wiki/Soldat_(video_game)">Soldat</a> Dedicated Server</td><td>Unofficial</td></tr>
<tr><td>23399</td><td></td><td></td><td><a href="https://en.wikipedia.org/wiki/Skype">Skype</a> default protocol</td><td>Unofficial</td></tr>
<tr><td>23513</td><td>?</td><td>?</td><td><a href="https://en.wikipedia.org/wiki/Duke_Nukem_3D#Source_ports"><em>Duke Nukem 3D</em> source ports</a></td><td>Unofficial</td></tr>
<tr><td>24441</td><td>Yes</td><td>Yes</td><td>Pyzor spam detection network</td><td>Unofficial</td></tr>
<tr><td>24444</td><td></td><td></td><td><a href="https://en.wikipedia.org/wiki/NetBeans">NetBeans</a> integrated development environment</td><td>Unofficial</td></tr>
<tr><td>24465</td><td>Yes</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/Tonido">Tonido Directory Server</a> for <a href="http://www.tonido.com/">Tonido</a> which is a Personal Web App and P2P platform</td><td>Official</td></tr>
<tr><td>24554</td><td>Yes</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/Binkp">BINKP</a>, <a href="https://en.wikipedia.org/wiki/Fidonet">Fidonet</a> mail transfers over <a href="https://en.wikipedia.org/wiki/TCP/IP">TCP/IP</a></td><td>Official</td></tr>
<tr><td>24800</td><td></td><td></td><td><a href="https://en.wikipedia.org/wiki/Synergy_(software)">Synergy</a>: keyboard/mouse sharing software</td><td>Unofficial</td></tr>
<tr><td>24842</td><td></td><td></td><td><em><a href="https://en.wikipedia.org/wiki/StepMania">StepMania: Online</a></em>: <em><a href="https://en.wikipedia.org/wiki/Dance_Dance_Revolution">Dance Dance Revolution</a></em> Simulator</td><td>Unofficial</td></tr>
<tr><td>25565</td><td>Yes</td><td></td><td><em><a href="https://en.wikipedia.org/wiki/Minecraft">Minecraft</a></em> (Java Edition) multiplayer server[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-333">332]</a>[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-334">333]</a></td><td>Unofficial</td></tr>
<tr><td></td><td>Yes</td><td><em>Minecraft (Java Edition)</em> multiplayer server query[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-335">334]</a></td><td>Unofficial</td><td></td></tr>
<tr><td>25575</td><td></td><td>Yes</td><td><em>Minecraft</em> (Java Edition) multiplayer server RCON[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-336">335]</a></td><td>Unofficial</td></tr>
<tr><td>25826</td><td></td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/Collectd">collectd</a> default port[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-337">336]</a></td><td>Unofficial</td></tr>
<tr><td>26000</td><td>Yes</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/Id_Software">id Software</a>'s <em><a href="https://en.wikipedia.org/wiki/Quake_(video_game)">Quake</a></em> server</td><td>Official</td></tr>
<tr><td>Yes</td><td></td><td><em><a href="https://en.wikipedia.org/wiki/EVE_Online">EVE Online</a></em></td><td>Unofficial</td><td></td></tr>
<tr><td></td><td>Yes</td><td><em><a href="https://en.wikipedia.org/wiki/Xonotic">Xonotic</a></em>, an <a href="https://en.wikipedia.org/wiki/Open-source_software">open-source</a> <a href="https://en.wikipedia.org/wiki/Arena_shooter">arena shooter</a></td><td>Unofficial</td><td></td></tr>
<tr><td>26900–26901</td><td>Yes</td><td></td><td><em>EVE Online</em></td><td>Unofficial</td></tr>
<tr><td>26909-26911</td><td>Yes</td><td></td><td><em>Action Tanks Online</em></td><td>Unofficial</td></tr>
<tr><td>27000</td><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/PowerBuilder">PowerBuilder</a> <em><a href="https://en.wikipedia.org/w/index.php?title=SySAM&amp;action=edit&amp;redlink=1">SySAM</a></em> license server</td><td>Unofficial</td></tr>
<tr><td>27000–27006</td><td></td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/Id_Software">id Software</a>'s <em><a href="https://en.wikipedia.org/wiki/QuakeWorld">QuakeWorld</a></em> master server</td><td>Unofficial</td></tr>
<tr><td>27000–27009</td><td>Yes</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/FlexNet_Publisher">FlexNet Publisher</a>'s License server (from the range of default ports)</td><td>Official</td></tr>
<tr><td>27000–27015</td><td>No</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/Steam_(software)">Steam</a> (game client traffic)[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-steam-support-8571-GLVN-8711-338">337]</a>[<em><a href="https://en.wikipedia.org/wiki/Wikipedia:Verifiability#Self-published_sources">self-published source</a></em>]</td><td>Unofficial</td></tr>
<tr><td>27015</td><td>No</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/GoldSrc">GoldSrc</a> and <a href="https://en.wikipedia.org/wiki/Source_engine">Source engine</a> dedicated server port[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-steam-support-8571-GLVN-8711-338">337]</a></td><td>Unofficial</td></tr>
<tr><td>27015-27018</td><td></td><td>Yes</td><td><em><a href="https://en.wikipedia.org/wiki/Unturned">Unturned</a></em>, a survival game</td><td>Unofficial</td></tr>
<tr><td>27015–27030</td><td>No</td><td>Yes</td><td>Steam (matchmaking and HLTV)[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-steam-support-8571-GLVN-8711-338">337]</a></td><td>Unofficial</td></tr>
<tr><td>Yes</td><td>Yes</td><td>Steam (downloads)[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-steam-support-8571-GLVN-8711-338">337]</a></td><td>Unofficial</td><td></td></tr>
<tr><td>27016</td><td></td><td></td><td><em><a href="https://en.wikipedia.org/wiki/Magicka">Magicka</a></em> server port</td><td>Unofficial</td></tr>
<tr><td>27017</td><td>Yes</td><td>No</td><td><a href="https://en.wikipedia.org/wiki/MongoDB">MongoDB</a> daemon process (<code>mongod</code>) and routing service (<code>mongos</code>)[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-mongodb-docs-reference-default-mongodb-port-339">338]</a></td><td>Unofficial</td></tr>
<tr><td>27031</td><td>Ports 27036 &amp; 27037</td><td>Yes</td><td>Steam (In-Home Streaming)[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-steam-support-8571-GLVN-8711-338">337]</a></td><td>Unofficial</td></tr>
<tr><td>27036</td><td>Yes</td><td>Yes</td><td>Steam (In-Home Streaming)[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-steam-support-8571-GLVN-8711-338">337]</a></td><td>Unofficial</td></tr>
<tr><td>27037</td><td>Yes</td><td>Ports 27031 &amp; 27036</td><td>Steam (In-Home Streaming)[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-steam-support-8571-GLVN-8711-338">337]</a></td><td>Unofficial</td></tr>
<tr><td>27374</td><td></td><td></td><td><a href="https://en.wikipedia.org/wiki/Sub7">Sub7</a> default.</td><td>Unofficial</td></tr>
<tr><td>27500–27900</td><td></td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/Id_Software">id Software</a>'s <em><a href="https://en.wikipedia.org/wiki/QuakeWorld">QuakeWorld</a></em></td><td>Unofficial</td></tr>
<tr><td>27888</td><td></td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/Kaillera">Kaillera</a> server</td><td>Unofficial</td></tr>
<tr><td>27901–27910</td><td></td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/Id_Software">id Software</a>'s <em><a href="https://en.wikipedia.org/wiki/Quake_II">Quake II</a></em> master server</td><td>Unofficial</td></tr>
<tr><td>27950</td><td></td><td>Yes</td><td><em><a href="https://en.wikipedia.org/wiki/OpenArena">OpenArena</a></em> outgoing</td><td>Unofficial</td></tr>
<tr><td>27960–27969</td><td></td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/Activision">Activision</a>'s <em><a href="https://en.wikipedia.org/wiki/Wolfenstein:_Enemy_Territory">Enemy Territory</a></em> and <a href="https://en.wikipedia.org/wiki/Id_Software">id Software</a>'s <em><a href="https://en.wikipedia.org/wiki/Quake_III_Arena">Quake III Arena</a></em>, <em>Quake III</em> and <em><a href="https://en.wikipedia.org/wiki/Quake_Live">Quake Live</a></em> and some ioquake3 derived games, such as <em>Urban Terror</em> (<em>OpenArena</em> incoming)</td><td>Unofficial</td></tr>
<tr><td>28001</td><td></td><td></td><td><em><a href="https://en.wikipedia.org/wiki/Starsiege:_Tribes">Starsiege: Tribes</a></em>[<em><a href="https://en.wikipedia.org/wiki/Wikipedia:Citation_needed">citation needed</a></em>]</td><td>Unofficial</td></tr>
<tr><td>28015</td><td></td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/Rust_(video_game)"><em>Rust</em> (video game)</a>[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-340">339]</a></td><td>Unofficial</td></tr>
<tr><td>28016</td><td></td><td>Yes</td><td><a href="https://en.wikipedia.org/w/index.php?title=Rust_RCON_(video_game)&amp;action=edit&amp;redlink=1"><em>Rust RCON</em> (video game)</a>[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-341">340]</a></td><td>Unofficial</td></tr>
<tr><td>28260</td><td>Yes</td><td></td><td>Palo Alto Networks' Panorama HA-1 backup unencrypted sync port.[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-PAN-OS_HALinksAndBackupLinks-25">25]</a></td><td>Unofficial</td></tr>
<tr><td>28443</td><td>Yes</td><td></td><td>Palo Alto Networks' Panorama-to-managed devices software updates, PAN-OS 8.0 and later.[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-EDU-120_10-183">182]</a></td><td>Unofficial</td></tr>
<tr><td>28769</td><td>Yes</td><td></td><td>Palo Alto Networks' Panorama HA unencrypted sync port.[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-PAN-OS_HALinksAndBackupLinks-25">25]</a></td><td>Unofficial</td></tr>
<tr><td>28770</td><td>Yes</td><td></td><td>Palo Alto Networks' Panorama HA-1 backup sync port.[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-PAN-OS_HALinksAndBackupLinks-25">25]</a></td><td>Unofficial</td></tr>
<tr><td>28770–28771</td><td></td><td>Yes</td><td><em><a href="https://en.wikipedia.org/w/index.php?title=AssaultCube_Reloaded&amp;action=edit&amp;redlink=1">AssaultCube Reloaded</a></em>, a video game based upon a modification of <em><a href="https://en.wikipedia.org/wiki/AssaultCube">AssaultCube</a></em>[<em><a href="https://en.wikipedia.org/wiki/Wikipedia:Citation_needed">citation needed</a></em>]</td><td>Unofficial</td></tr>
<tr><td>28785–28786</td><td></td><td>Yes</td><td><em><a href="https://en.wikipedia.org/wiki/Cube_2:_Sauerbraten">Cube 2: Sauerbraten</a></em>[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-Cube2Sauerbraten-342">341]</a>[<em><a href="https://en.wikipedia.org/wiki/Wikipedia:Verifiability#Self-published_sources">self-published source?</a></em>]</td><td>Unofficial</td></tr>
<tr><td>28852</td><td>Yes</td><td>Yes</td><td><em><a href="https://en.wikipedia.org/wiki/Killing_Floor_(2009_video_game)">Killing Floor</a></em>[<em><a href="https://en.wikipedia.org/wiki/Wikipedia:Citation_needed">citation needed</a></em>]</td><td>Unofficial</td></tr>
<tr><td>28910</td><td>Yes</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/Nintendo_Wi-Fi_Connection">Nintendo Wi-Fi Connection</a>[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-nintendo-wfc-instruction-booklet-343">342]</a></td><td>Unofficial</td></tr>
<tr><td>28960</td><td>Yes</td><td>Yes</td><td><em><a href="https://en.wikipedia.org/wiki/Call_of_Duty">Call of Duty</a></em>; <em><a href="https://en.wikipedia.org/wiki/Call_of_Duty:_United_Offensive">Call of Duty: United Offensive</a></em>; <em><a href="https://en.wikipedia.org/wiki/Call_of_Duty_2">Call of Duty 2</a></em>; <em><a href="https://en.wikipedia.org/wiki/Call_of_Duty_4:_Modern_Warfare">Call of Duty 4: Modern Warfare</a></em>;[<em><a href="https://en.wikipedia.org/wiki/Wikipedia:Citation_needed">citation needed</a></em>] <em><a href="https://en.wikipedia.org/wiki/Call_of_Duty:_World_at_War">Call of Duty: World at War</a></em> (PC platform)[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-activision-kb-cod-game-ports-344">343]</a></td><td>Unofficial</td></tr>
<tr><td>29000</td><td>?</td><td>?</td><td><em><a href="https://en.wikipedia.org/wiki/Perfect_World_(video_game)">Perfect World</a></em>, an adventure and fantasy <a href="https://en.wikipedia.org/wiki/MMORPG">MMORPG</a>[<em><a href="https://en.wikipedia.org/wiki/Wikipedia:Citation_needed">citation needed</a></em>]</td><td>Unofficial</td></tr>
<tr><td>29070</td><td>Yes</td><td>Yes</td><td><em><a href="https://en.wikipedia.org/wiki/Jedi_Knight:_Jedi_Academy">Jedi Knight: Jedi Academy</a></em> by <a href="https://en.wikipedia.org/wiki/Ravensoft">Ravensoft</a>[<em><a href="https://en.wikipedia.org/wiki/Wikipedia:Citation_needed">citation needed</a></em>]</td><td>Unofficial</td></tr>
<tr><td>29900–29901</td><td>Yes</td><td>Yes</td><td>Nintendo Wi-Fi Connection[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-nintendo-wfc-instruction-booklet-343">342]</a></td><td>Unofficial</td></tr>
<tr><td>29920</td><td>Yes</td><td>Yes</td><td>Nintendo Wi-Fi Connection[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-nintendo-wfc-instruction-booklet-343">342]</a></td><td>Unofficial</td></tr>
<tr><td>30000</td><td></td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/XLink_Kai">XLink Kai P2P</a></td><td>Unofficial</td></tr>
<tr><td>30033</td><td>?</td><td>?</td><td>Teamspeak3 Chat Server[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-hub.docker.com-308">307]</a></td><td>Unofficial</td></tr>
<tr><td>30564</td><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/Multiplicity_(software)">Multiplicity</a>: keyboard/mouse/clipboard sharing software[<em><a href="https://en.wikipedia.org/wiki/Wikipedia:Citation_needed">citation needed</a></em>]</td><td>Unofficial</td></tr>
<tr><td>31337</td><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/Back_Orifice">Back Orifice</a> and <a href="https://en.wikipedia.org/wiki/Back_Orifice_2000">Back Orifice 2000</a> remote administration tools[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-345">344]</a>[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-346">345]</a></td><td>Unofficial</td></tr>
<tr><td>31416</td><td>?</td><td>?</td><td><a href="https://en.wikipedia.org/wiki/BOINC">BOINC</a> <a href="https://en.wikipedia.org/wiki/Remote_procedure_call">RPC</a>[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-man-1-boinc-die.net-347">346]</a></td><td>Unofficial</td></tr>
<tr><td>31438</td><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/Rocket_U2">Rocket U2</a>[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-rocket-universe-installguide-v1123-348">347]</a>[<em><a href="https://en.wikipedia.org/wiki/Wikipedia:Verifiability#Self-published_sources">self-published source?</a></em>]</td><td>Unofficial</td></tr>
<tr><td>31457</td><td>Yes</td><td></td><td><em><a href="https://en.wikipedia.org/wiki/TetriNET">TetriNET</a></em></td><td>Official</td></tr>
<tr><td>32137</td><td>Yes</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/Immunet">Immunet Protect</a> (UDP in version 2.0,[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-immunet-support-tiki-4-349">348]</a> TCP since version 3.0[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-350">349]</a>)</td><td>Unofficial</td></tr>
<tr><td>32400</td><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/Plex_Media_Server">Plex Media Server</a>[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-plex-kb-201543147-351">350]</a></td><td>Official</td></tr>
<tr><td>32764</td><td>Yes</td><td></td><td>A <a href="https://en.wikipedia.org/wiki/Backdoor_(computing)">backdoor</a> found on certain Linksys, Netgear and other wireless DSL modems/combination routers[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-ars-security-2014-01-backdoor-dsl-352">351]</a></td><td>Unofficial</td></tr>
<tr><td>32887</td><td>Yes</td><td></td><td><em><a href="https://en.wikipedia.org/wiki/Ace_of_Spades_(video_game)">Ace of Spades</a></em>, a multiplayer <a href="https://en.wikipedia.org/wiki/First-person_shooter">FPS</a> video game[<em><a href="https://en.wikipedia.org/wiki/Wikipedia:Citation_needed">citation needed</a></em>]</td><td>Unofficial</td></tr>
<tr><td>32976</td><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/LogMeIn_Hamachi">LogMeIn Hamachi</a>, a <a href="https://en.wikipedia.org/wiki/Virtual_private_network">VPN</a> application; also TCP port 12975 and <a href="https://en.wikipedia.org/wiki/Secure_Sockets_Layer">SSL</a> (TCP 443).[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-logmein-kb-ports-protocols-353">352]</a></td><td>Unofficial</td></tr>
<tr><td>33434</td><td>Yes</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/Traceroute">traceroute</a></td><td>Official</td></tr>
<tr><td>33848</td><td></td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/Jenkins_(software)">Jenkins</a>, a <a href="https://en.wikipedia.org/wiki/Continuous_integration">continuous integration</a> (CI) tool[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-jenkins-wiki-remote-api-354">353]</a>[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-jenkins-wiki-auto-discovering-355">354]</a></td><td>Unofficial</td></tr>
<tr><td>34000</td><td></td><td>Yes</td><td><em><a href="https://en.wikipedia.org/wiki/Infestation:_Survivor_Stories">Infestation: Survivor Stories</a></em> (formerly known as <em>The War Z</em>), a multiplayer zombie video game[<em><a href="https://en.wikipedia.org/wiki/Wikipedia:Verifiability">verification needed</a></em>]</td><td>Unofficial</td></tr>
<tr><td>34197</td><td>No</td><td>Yes</td><td><em><a href="https://en.wikipedia.org/wiki/Factorio">Factorio</a></em>, a multiplayer survival and factory-building game[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-356">355]</a></td><td>Unofficial</td></tr>
<tr><td>35357</td><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/OpenStack#Identity_(Keystone)">OpenStack Identity</a> (Keystone) administration[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-openstack-docs-config-appendix-b-357">356]</a>[<em><a href="https://en.wikipedia.org/wiki/Wikipedia:Verifiability#Self-published_sources">self-published source?</a></em>]</td><td>Official</td></tr>
<tr><td>36330</td><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/Folding@home">Folding@home</a> Control Port</td><td>Unofficial</td></tr>
<tr><td>37008</td><td></td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/TZSP">TZSP</a> intrusion detection[<em><a href="https://en.wikipedia.org/wiki/Wikipedia:Citation_needed">citation needed</a></em>]</td><td>Unofficial</td></tr>
<tr><td>40000</td><td>Yes</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/SafetyNET_p">SafetyNET p</a> – a real-time <a href="https://en.wikipedia.org/wiki/Industrial_Ethernet">Industrial Ethernet</a> protocol</td><td>Official</td></tr>
<tr><td>41121</td><td>Yes</td><td>Yes</td><td>Tentacle Server[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-IANA_41121-358">357]</a> - <a href="https://en.wikipedia.org/wiki/Pandora_FMS">Pandora FMS</a></td><td>Official</td></tr>
<tr><td>41794</td><td>Yes</td><td>Yes</td><td>Crestron Control Port[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-IANA_41794-359">358]</a> - <a href="https://en.wikipedia.org/wiki/Crestron_Electronics">Crestron Electronics</a></td><td>Official</td></tr>
<tr><td>41795</td><td>Yes</td><td>Yes</td><td>Crestron Terminal Port[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-IANA_41795-360">359]</a> - <a href="https://en.wikipedia.org/wiki/Crestron_Electronics">Crestron Electronics</a></td><td>Official</td></tr>
<tr><td>41796</td><td>Yes</td><td>No</td><td>Crestron Secure Control Port[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-IANA_41796-361">360]</a> - <a href="https://en.wikipedia.org/wiki/Crestron_Electronics">Crestron Electronics</a></td><td>Official</td></tr>
<tr><td>41797</td><td>Yes</td><td>No</td><td>Crestron Secure Terminal Port[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-IANA_41797-362">361]</a> - <a href="https://en.wikipedia.org/wiki/Crestron_Electronics">Crestron Electronics</a></td><td>Official</td></tr>
<tr><td>43110</td><td>Yes</td><td></td><td><a href="https://en.wikipedia.org/wiki/ZeroNet">ZeroNet</a> web UI default port[<em><a href="https://en.wikipedia.org/wiki/Wikipedia:Citation_needed">citation needed</a></em>]</td><td>Unofficial</td></tr>
<tr><td>43594–43595</td><td>?</td><td>?</td><td><em><a href="https://en.wikipedia.org/wiki/RuneScape">RuneScape</a></em>[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-rs-support-205845152-363">362]</a></td><td>Unofficial</td></tr>
<tr><td>44405</td><td>Yes</td><td></td><td><em><a href="https://en.wikipedia.org/wiki/Mu_Online">Mu Online</a></em> Connect Server[<em><a href="https://en.wikipedia.org/wiki/Wikipedia:Citation_needed">citation needed</a></em>]</td><td>Unofficial</td></tr>
<tr><td>44818</td><td>Yes</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/EtherNet/IP">EtherNet/IP</a> explicit messaging</td><td>Official</td></tr>
<tr><td>47808–47823</td><td>Yes</td><td>Yes</td><td><a href="https://en.wikipedia.org/wiki/BACnet">BACnet</a> Building Automation and Control Networks (4780810 = BAC016 to 4782310 = BACF16)</td><td>Official</td></tr>
<tr><td>49151</td><td>Reserved</td><td>Reserved</td><td>Reserved[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-IANA-1">1]</a></td><td>Official</td></tr>
<tr><td>49160</td><td>Yes</td><td></td><td>Palo Alto Networks' Panorama.[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-EDU-120_10-183">182]</a></td><td>Unofficial</td></tr>
<tr><td>49190</td><td>Yes</td><td></td><td>Palo Alto Networks' Panorama.[<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#cite_note-EDU-120_10-183">182]</a></td><td>Unofficial</td></tr>
</tbody></table>
</div>
<h2 id="dynamic-private-or-ephemeral-ports"><a class="header" href="#dynamic-private-or-ephemeral-ports">Dynamic, private or ephemeral ports</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="list-of-ip-protocol-numbers"><a class="header" href="#list-of-ip-protocol-numbers">List of IP protocol numbers</a></h1>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Hex</th><th style="text-align: center">Protocol Number</th><th style="text-align: center">Keyword</th><th style="text-align: center">Protocol</th><th style="text-align: center">References/RFC</th></tr></thead><tbody>
<tr><td style="text-align: center">0x00</td><td style="text-align: center">0</td><td style="text-align: center">HOPOPT</td><td style="text-align: center"><a href="https://en.wikipedia.org/wiki/IPv6_Hop-by-Hop_Option">IPv6 Hop-by-Hop Option</a></td><td style="text-align: center"><a href="https://tools.ietf.org/html/rfc8200">RFC 8200</a></td></tr>
<tr><td style="text-align: center">0x01</td><td style="text-align: center">1</td><td style="text-align: center">ICMP</td><td style="text-align: center"><a href="https://en.wikipedia.org/wiki/Internet_Control_Message_Protocol">Internet Control Message Protocol</a></td><td style="text-align: center"><a href="https://tools.ietf.org/html/rfc792">RFC 792</a></td></tr>
<tr><td style="text-align: center">0x02</td><td style="text-align: center">2</td><td style="text-align: center">IGMP</td><td style="text-align: center"><a href="https://en.wikipedia.org/wiki/Internet_Group_Management_Protocol">Internet Group Management Protocol</a></td><td style="text-align: center"><a href="https://tools.ietf.org/html/rfc1112">RFC 1112</a></td></tr>
<tr><td style="text-align: center">0x03</td><td style="text-align: center">3</td><td style="text-align: center">GGP</td><td style="text-align: center"><a href="https://en.wikipedia.org/wiki/Gateway-to-Gateway_Protocol">Gateway-to-Gateway Protocol</a></td><td style="text-align: center"><a href="https://tools.ietf.org/html/rfc823">RFC 823</a></td></tr>
<tr><td style="text-align: center">0x04</td><td style="text-align: center">4</td><td style="text-align: center">IP-in-IP</td><td style="text-align: center"><a href="https://en.wikipedia.org/wiki/IP_in_IP">IP in IP</a> (encapsulation)</td><td style="text-align: center"><a href="https://tools.ietf.org/html/rfc2003">RFC 2003</a></td></tr>
<tr><td style="text-align: center">0x05</td><td style="text-align: center">5</td><td style="text-align: center">ST</td><td style="text-align: center"><a href="https://en.wikipedia.org/wiki/Internet_Stream_Protocol">Internet Stream Protocol</a></td><td style="text-align: center"><a href="https://tools.ietf.org/html/rfc1190">RFC 1190</a>, <a href="https://tools.ietf.org/html/rfc1819">RFC 1819</a></td></tr>
<tr><td style="text-align: center">0x06</td><td style="text-align: center">6</td><td style="text-align: center">TCP</td><td style="text-align: center"><a href="https://en.wikipedia.org/wiki/Transmission_Control_Protocol">Transmission Control Protocol</a></td><td style="text-align: center"><a href="https://tools.ietf.org/html/rfc793">RFC 793</a></td></tr>
<tr><td style="text-align: center">0x07</td><td style="text-align: center">7</td><td style="text-align: center">CBT</td><td style="text-align: center"><a href="https://en.wikipedia.org/wiki/Core-based_trees">Core-based trees</a></td><td style="text-align: center"><a href="https://tools.ietf.org/html/rfc2189">RFC 2189</a></td></tr>
<tr><td style="text-align: center">0x08</td><td style="text-align: center">8</td><td style="text-align: center">EGP</td><td style="text-align: center"><a href="https://en.wikipedia.org/wiki/Exterior_Gateway_Protocol">Exterior Gateway Protocol</a></td><td style="text-align: center"><a href="https://tools.ietf.org/html/rfc888">RFC 888</a></td></tr>
<tr><td style="text-align: center">0x09</td><td style="text-align: center">9</td><td style="text-align: center">IGP</td><td style="text-align: center"><a href="https://en.wikipedia.org/wiki/Interior_Gateway_Protocol">Interior Gateway Protocol</a></td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">0x0A</td><td style="text-align: center">10</td><td style="text-align: center">BBN-RCC-MON</td><td style="text-align: center">BBN RCC Monitoring</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">0x0B</td><td style="text-align: center">11</td><td style="text-align: center">NVP-II</td><td style="text-align: center"><a href="https://en.wikipedia.org/wiki/Network_Voice_Protocol">Network Voice Protocol</a></td><td style="text-align: center"><a href="https://tools.ietf.org/html/rfc741">RFC 741</a></td></tr>
<tr><td style="text-align: center">0x0C</td><td style="text-align: center">12</td><td style="text-align: center">PUP</td><td style="text-align: center"><a href="https://en.wikipedia.org/wiki/PARC_Universal_Packet">Xerox PUP</a></td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">0x0D</td><td style="text-align: center">13</td><td style="text-align: center">ARGUS</td><td style="text-align: center">ARGUS</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">0x0E</td><td style="text-align: center">14</td><td style="text-align: center">EMCON</td><td style="text-align: center">EMCON</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">0x0F</td><td style="text-align: center">15</td><td style="text-align: center">XNET</td><td style="text-align: center">Cross Net Debugger</td><td style="text-align: center">IEN 158[<a href="https://en.wikipedia.org/wiki/List_of_IP_protocol_numbers#cite_note-2">2]</a></td></tr>
<tr><td style="text-align: center">0x10</td><td style="text-align: center">16</td><td style="text-align: center">CHAOS</td><td style="text-align: center"><a href="https://en.wikipedia.org/wiki/Chaosnet">Chaos</a></td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">0x11</td><td style="text-align: center">17</td><td style="text-align: center">UDP</td><td style="text-align: center"><a href="https://en.wikipedia.org/wiki/User_Datagram_Protocol">User Datagram Protocol</a></td><td style="text-align: center"><a href="https://tools.ietf.org/html/rfc768">RFC 768</a></td></tr>
<tr><td style="text-align: center">0x12</td><td style="text-align: center">18</td><td style="text-align: center">MUX</td><td style="text-align: center"><a href="https://en.wikipedia.org/wiki/Multiplexing">Multiplexing</a></td><td style="text-align: center">IEN 90[<a href="https://en.wikipedia.org/wiki/List_of_IP_protocol_numbers#cite_note-3">3]</a></td></tr>
<tr><td style="text-align: center">0x13</td><td style="text-align: center">19</td><td style="text-align: center">DCN-MEAS</td><td style="text-align: center">DCN Measurement Subsystems</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">0x14</td><td style="text-align: center">20</td><td style="text-align: center">HMP</td><td style="text-align: center"><a href="https://en.wikipedia.org/wiki/Host_Monitoring_Protocol">Host Monitoring Protocol</a></td><td style="text-align: center"><a href="https://tools.ietf.org/html/rfc869">RFC 869</a></td></tr>
<tr><td style="text-align: center">0x15</td><td style="text-align: center">21</td><td style="text-align: center">PRM</td><td style="text-align: center">Packet Radio Measurement</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">0x16</td><td style="text-align: center">22</td><td style="text-align: center">XNS-IDP</td><td style="text-align: center">XEROX NS IDP</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">0x17</td><td style="text-align: center">23</td><td style="text-align: center">TRUNK-1</td><td style="text-align: center">Trunk-1</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">0x18</td><td style="text-align: center">24</td><td style="text-align: center">TRUNK-2</td><td style="text-align: center">Trunk-2</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">0x19</td><td style="text-align: center">25</td><td style="text-align: center">LEAF-1</td><td style="text-align: center">Leaf-1</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">0x1A</td><td style="text-align: center">26</td><td style="text-align: center">LEAF-2</td><td style="text-align: center">Leaf-2</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">0x1B</td><td style="text-align: center">27</td><td style="text-align: center">RDP</td><td style="text-align: center"><a href="https://en.wikipedia.org/wiki/Reliable_Data_Protocol">Reliable Data Protocol</a></td><td style="text-align: center"><a href="https://tools.ietf.org/html/rfc908">RFC 908</a></td></tr>
<tr><td style="text-align: center">0x1C</td><td style="text-align: center">28</td><td style="text-align: center">IRTP</td><td style="text-align: center"><a href="https://en.wikipedia.org/w/index.php?title=Internet_Reliable_Transaction_Protocol&amp;action=edit&amp;redlink=1">Internet Reliable Transaction Protocol</a></td><td style="text-align: center"><a href="https://tools.ietf.org/html/rfc938">RFC 938</a></td></tr>
<tr><td style="text-align: center">0x1D</td><td style="text-align: center">29</td><td style="text-align: center">ISO-TP4</td><td style="text-align: center">ISO Transport Protocol Class 4</td><td style="text-align: center"><a href="https://tools.ietf.org/html/rfc905">RFC 905</a></td></tr>
<tr><td style="text-align: center">0x1E</td><td style="text-align: center">30</td><td style="text-align: center">NETBLT</td><td style="text-align: center"><a href="https://en.wikipedia.org/w/index.php?title=Bulk_Data_Transfer_Protocol&amp;action=edit&amp;redlink=1">Bulk Data Transfer Protocol</a></td><td style="text-align: center"><a href="https://tools.ietf.org/html/rfc998">RFC 998</a></td></tr>
<tr><td style="text-align: center">0x1F</td><td style="text-align: center">31</td><td style="text-align: center">MFE-NSP</td><td style="text-align: center"><a href="https://en.wikipedia.org/w/index.php?title=MFE_Network_Services_Protocol&amp;action=edit&amp;redlink=1">MFE Network Services Protocol</a></td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">0x20</td><td style="text-align: center">32</td><td style="text-align: center">MERIT-INP</td><td style="text-align: center"><a href="https://en.wikipedia.org/w/index.php?title=MERIT_Internodal_Protocol&amp;action=edit&amp;redlink=1">MERIT Internodal Protocol</a></td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">0x21</td><td style="text-align: center">33</td><td style="text-align: center">DCCP</td><td style="text-align: center"><a href="https://en.wikipedia.org/wiki/Datagram_Congestion_Control_Protocol">Datagram Congestion Control Protocol</a></td><td style="text-align: center"><a href="https://tools.ietf.org/html/rfc4340">RFC 4340</a></td></tr>
<tr><td style="text-align: center">0x22</td><td style="text-align: center">34</td><td style="text-align: center">3PC</td><td style="text-align: center"><a href="https://en.wikipedia.org/w/index.php?title=Third_Party_Connect_Protocol&amp;action=edit&amp;redlink=1">Third Party Connect Protocol</a></td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">0x23</td><td style="text-align: center">35</td><td style="text-align: center">IDPR</td><td style="text-align: center"><a href="https://en.wikipedia.org/w/index.php?title=Inter-Domain_Policy_Routing_Protocol&amp;action=edit&amp;redlink=1">Inter-Domain Policy Routing Protocol</a></td><td style="text-align: center"><a href="https://tools.ietf.org/html/rfc1479">RFC 1479</a></td></tr>
<tr><td style="text-align: center">0x24</td><td style="text-align: center">36</td><td style="text-align: center">XTP</td><td style="text-align: center"><a href="https://en.wikipedia.org/wiki/Xpress_Transport_Protocol">Xpress Transport Protocol</a></td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">0x25</td><td style="text-align: center">37</td><td style="text-align: center">DDP</td><td style="text-align: center"><a href="https://en.wikipedia.org/wiki/Datagram_Delivery_Protocol">Datagram Delivery Protocol</a></td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">0x26</td><td style="text-align: center">38</td><td style="text-align: center">IDPR-CMTP</td><td style="text-align: center"><a href="https://en.wikipedia.org/w/index.php?title=IDPR_Control_Message_Transport_Protocol&amp;action=edit&amp;redlink=1">IDPR Control Message Transport Protocol</a></td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">0x27</td><td style="text-align: center">39</td><td style="text-align: center">TP++</td><td style="text-align: center"><a href="https://en.wikipedia.org/w/index.php?title=TP%2B%2B_Transport_Protocol&amp;action=edit&amp;redlink=1">TP++ Transport Protocol</a></td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">0x28</td><td style="text-align: center">40</td><td style="text-align: center">IL</td><td style="text-align: center"><a href="https://en.wikipedia.org/wiki/IL_(network_protocol)">IL Transport Protocol</a></td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">0x29</td><td style="text-align: center">41</td><td style="text-align: center">IPv6</td><td style="text-align: center">IPv6 Encapsulation</td><td style="text-align: center"><a href="https://tools.ietf.org/html/rfc2473">RFC 2473</a></td></tr>
<tr><td style="text-align: center">0x2A</td><td style="text-align: center">42</td><td style="text-align: center">SDRP</td><td style="text-align: center"><a href="https://en.wikipedia.org/w/index.php?title=Source_Demand_Routing_Protocol&amp;action=edit&amp;redlink=1">Source Demand Routing Protocol</a></td><td style="text-align: center"><a href="https://tools.ietf.org/html/rfc1940">RFC 1940</a></td></tr>
<tr><td style="text-align: center">0x2B</td><td style="text-align: center">43</td><td style="text-align: center">IPv6-Route</td><td style="text-align: center">Routing Header for <a href="https://en.wikipedia.org/wiki/IPv6">IPv6</a></td><td style="text-align: center"><a href="https://tools.ietf.org/html/rfc8200">RFC 8200</a></td></tr>
<tr><td style="text-align: center">0x2C</td><td style="text-align: center">44</td><td style="text-align: center">IPv6-Frag</td><td style="text-align: center">Fragment Header for <a href="https://en.wikipedia.org/wiki/IPv6">IPv6</a></td><td style="text-align: center"><a href="https://tools.ietf.org/html/rfc8200">RFC 8200</a></td></tr>
<tr><td style="text-align: center">0x2D</td><td style="text-align: center">45</td><td style="text-align: center">IDRP</td><td style="text-align: center"><a href="https://en.wikipedia.org/w/index.php?title=Inter-Domain_Routing_Protocol&amp;action=edit&amp;redlink=1">Inter-Domain Routing Protocol</a></td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">0x2E</td><td style="text-align: center">46</td><td style="text-align: center">RSVP</td><td style="text-align: center"><a href="https://en.wikipedia.org/wiki/Resource_Reservation_Protocol">Resource Reservation Protocol</a></td><td style="text-align: center"><a href="https://tools.ietf.org/html/rfc2205">RFC 2205</a></td></tr>
<tr><td style="text-align: center">0x2F</td><td style="text-align: center">47</td><td style="text-align: center">GREs</td><td style="text-align: center"><a href="https://en.wikipedia.org/wiki/Generic_Routing_Encapsulation">Generic Routing Encapsulation</a></td><td style="text-align: center"><a href="https://tools.ietf.org/html/rfc2784">RFC 2784</a>, <a href="https://tools.ietf.org/html/rfc2890">RFC 2890</a></td></tr>
<tr><td style="text-align: center">0x30</td><td style="text-align: center">48</td><td style="text-align: center">DSR</td><td style="text-align: center"><a href="https://en.wikipedia.org/wiki/Dynamic_Source_Routing">Dynamic Source Routing</a> Protocol</td><td style="text-align: center"><a href="https://tools.ietf.org/html/rfc4728">RFC 4728</a></td></tr>
<tr><td style="text-align: center">0x31</td><td style="text-align: center">49</td><td style="text-align: center">BNA</td><td style="text-align: center">Burroughs Network Architecture</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">0x32</td><td style="text-align: center">50</td><td style="text-align: center">ESP</td><td style="text-align: center"><a href="https://en.wikipedia.org/wiki/Encapsulating_Security_Payload">Encapsulating Security Payload</a></td><td style="text-align: center"><a href="https://tools.ietf.org/html/rfc4303">RFC 4303</a></td></tr>
<tr><td style="text-align: center">0x33</td><td style="text-align: center">51</td><td style="text-align: center">AH</td><td style="text-align: center"><a href="https://en.wikipedia.org/wiki/Authentication_Header">Authentication Header</a></td><td style="text-align: center"><a href="https://tools.ietf.org/html/rfc4302">RFC 4302</a></td></tr>
<tr><td style="text-align: center">0x34</td><td style="text-align: center">52</td><td style="text-align: center">I-NLSP</td><td style="text-align: center"><a href="https://en.wikipedia.org/w/index.php?title=Integrated_Net_Layer_Security_Protocol&amp;action=edit&amp;redlink=1">Integrated Net Layer Security Protocol</a></td><td style="text-align: center">TUBA</td></tr>
<tr><td style="text-align: center">0x35</td><td style="text-align: center">53</td><td style="text-align: center">SwIPe</td><td style="text-align: center"><a href="https://en.wikipedia.org/wiki/SwIPe_(protocol)">SwIPe</a></td><td style="text-align: center"><a href="https://tools.ietf.org/html/rfc5237">RFC 5237</a></td></tr>
<tr><td style="text-align: center">0x36</td><td style="text-align: center">54</td><td style="text-align: center">NARP</td><td style="text-align: center"><a href="https://en.wikipedia.org/w/index.php?title=NBMA_Address_Resolution_Protocol&amp;action=edit&amp;redlink=1">NBMA Address Resolution Protocol</a></td><td style="text-align: center"><a href="https://tools.ietf.org/html/rfc1735">RFC 1735</a></td></tr>
<tr><td style="text-align: center">0x37</td><td style="text-align: center">55</td><td style="text-align: center">MOBILE</td><td style="text-align: center"><a href="https://en.wikipedia.org/wiki/Mobile_IP">IP Mobility</a> (Min Encap)</td><td style="text-align: center"><a href="https://tools.ietf.org/html/rfc2004">RFC 2004</a></td></tr>
<tr><td style="text-align: center">0x38</td><td style="text-align: center">56</td><td style="text-align: center">TLSP</td><td style="text-align: center"><a href="https://en.wikipedia.org/wiki/Transport_Layer_Security_Protocol">Transport Layer Security Protocol</a> (using Kryptonet key management)</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">0x39</td><td style="text-align: center">57</td><td style="text-align: center">SKIP</td><td style="text-align: center"><a href="https://en.wikipedia.org/wiki/Simple_Key-Management_for_Internet_Protocol">Simple Key-Management for Internet Protocol</a></td><td style="text-align: center"><a href="https://tools.ietf.org/html/rfc2356">RFC 2356</a></td></tr>
<tr><td style="text-align: center">0x3A</td><td style="text-align: center">58</td><td style="text-align: center">IPv6-ICMP</td><td style="text-align: center"><a href="https://en.wikipedia.org/wiki/ICMPv6">ICMP for IPv6</a></td><td style="text-align: center"><a href="https://tools.ietf.org/html/rfc4443">RFC 4443</a>, <a href="https://tools.ietf.org/html/rfc4884">RFC 4884</a></td></tr>
<tr><td style="text-align: center">0x3B</td><td style="text-align: center">59</td><td style="text-align: center">IPv6-NoNxt</td><td style="text-align: center">No Next Header for <a href="https://en.wikipedia.org/wiki/IPv6">IPv6</a></td><td style="text-align: center"><a href="https://tools.ietf.org/html/rfc8200">RFC 8200</a></td></tr>
<tr><td style="text-align: center">0x3C</td><td style="text-align: center">60</td><td style="text-align: center">IPv6-Opts</td><td style="text-align: center">Destination Options for <a href="https://en.wikipedia.org/wiki/IPv6">IPv6</a></td><td style="text-align: center"><a href="https://tools.ietf.org/html/rfc8200">RFC 8200</a></td></tr>
<tr><td style="text-align: center">0x3D</td><td style="text-align: center">61</td><td style="text-align: center"></td><td style="text-align: center">Any host internal protocol</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">0x3E</td><td style="text-align: center">62</td><td style="text-align: center">CFTP</td><td style="text-align: center">CFTP</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">0x3F</td><td style="text-align: center">63</td><td style="text-align: center"></td><td style="text-align: center">Any local network</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">0x40</td><td style="text-align: center">64</td><td style="text-align: center">SAT-EXPAK</td><td style="text-align: center">SATNET and Backroom EXPAK</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">0x41</td><td style="text-align: center">65</td><td style="text-align: center">KRYPTOLAN</td><td style="text-align: center">Kryptolan</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">0x42</td><td style="text-align: center">66</td><td style="text-align: center">RVD</td><td style="text-align: center">MIT <a href="https://en.wikipedia.org/w/index.php?title=Remote_Virtual_Disk_Protocol&amp;action=edit&amp;redlink=1">Remote Virtual Disk Protocol</a></td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">0x43</td><td style="text-align: center">67</td><td style="text-align: center">IPPC</td><td style="text-align: center"><a href="https://en.wikipedia.org/w/index.php?title=Internet_Pluribus_Packet_Core&amp;action=edit&amp;redlink=1">Internet Pluribus Packet Core</a></td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">0x44</td><td style="text-align: center">68</td><td style="text-align: center"></td><td style="text-align: center">Any distributed file system</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">0x45</td><td style="text-align: center">69</td><td style="text-align: center">SAT-MON</td><td style="text-align: center">SATNET Monitoring</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">0x46</td><td style="text-align: center">70</td><td style="text-align: center">VISA</td><td style="text-align: center">VISA Protocol</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">0x47</td><td style="text-align: center">71</td><td style="text-align: center">IPCU</td><td style="text-align: center">Internet Packet Core Utility</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">0x48</td><td style="text-align: center">72</td><td style="text-align: center">CPNX</td><td style="text-align: center">Computer Protocol Network Executive</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">0x49</td><td style="text-align: center">73</td><td style="text-align: center">CPHB</td><td style="text-align: center"><a href="https://en.wikipedia.org/w/index.php?title=Computer_Protocol_Heart_Beat&amp;action=edit&amp;redlink=1">Computer Protocol Heart Beat</a></td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">0x4A</td><td style="text-align: center">74</td><td style="text-align: center">WSN</td><td style="text-align: center"><a href="https://en.wikipedia.org/w/index.php?title=Wang_Span_Network&amp;action=edit&amp;redlink=1">Wang Span Network</a></td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">0x4B</td><td style="text-align: center">75</td><td style="text-align: center">PVP</td><td style="text-align: center"><a href="https://en.wikipedia.org/w/index.php?title=Packet_Video_Protocol&amp;action=edit&amp;redlink=1">Packet Video Protocol</a></td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">0x4C</td><td style="text-align: center">76</td><td style="text-align: center">BR-SAT-MON</td><td style="text-align: center">Backroom SATNET Monitoring</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">0x4D</td><td style="text-align: center">77</td><td style="text-align: center">SUN-ND</td><td style="text-align: center">SUN ND PROTOCOL-Temporary</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">0x4E</td><td style="text-align: center">78</td><td style="text-align: center">WB-MON</td><td style="text-align: center">WIDEBAND Monitoring</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">0x4F</td><td style="text-align: center">79</td><td style="text-align: center">WB-EXPAK</td><td style="text-align: center">WIDEBAND EXPAK</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">0x50</td><td style="text-align: center">80</td><td style="text-align: center">ISO-IP</td><td style="text-align: center">International Organization for Standardization Internet Protocol</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">0x51</td><td style="text-align: center">81</td><td style="text-align: center">VMTP</td><td style="text-align: center"><a href="https://en.wikipedia.org/wiki/V_(operating_system)">Versatile Message Transaction Protocol</a></td><td style="text-align: center"><a href="https://tools.ietf.org/html/rfc1045">RFC 1045</a></td></tr>
<tr><td style="text-align: center">0x52</td><td style="text-align: center">82</td><td style="text-align: center">SECURE-VMTP</td><td style="text-align: center">Secure Versatile Message Transaction Protocol</td><td style="text-align: center"><a href="https://tools.ietf.org/html/rfc1045">RFC 1045</a></td></tr>
<tr><td style="text-align: center">0x53</td><td style="text-align: center">83</td><td style="text-align: center">VINES</td><td style="text-align: center">VINES</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">0x54</td><td style="text-align: center">84</td><td style="text-align: center">TTP</td><td style="text-align: center"><a href="https://en.wikipedia.org/wiki/Time-Triggered_Protocol">TTP</a></td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">0x54</td><td style="text-align: center">84</td><td style="text-align: center">IPTM</td><td style="text-align: center"><a href="https://en.wikipedia.org/w/index.php?title=Internet_Protocol_Traffic_Manager&amp;action=edit&amp;redlink=1">Internet Protocol Traffic Manager</a></td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">0x55</td><td style="text-align: center">85</td><td style="text-align: center">NSFNET-IGP</td><td style="text-align: center">NSFNET-IGP</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">0x56</td><td style="text-align: center">86</td><td style="text-align: center">DGP</td><td style="text-align: center"><a href="https://en.wikipedia.org/w/index.php?title=Dissimilar_Gateway_Protocol&amp;action=edit&amp;redlink=1">Dissimilar Gateway Protocol</a></td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">0x57</td><td style="text-align: center">87</td><td style="text-align: center">TCF</td><td style="text-align: center">TCF</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">0x58</td><td style="text-align: center">88</td><td style="text-align: center">EIGRP</td><td style="text-align: center"><a href="https://en.wikipedia.org/wiki/EIGRP">EIGRP</a></td><td style="text-align: center">Informational <a href="https://tools.ietf.org/html/rfc7868">RFC 7868</a></td></tr>
<tr><td style="text-align: center">0x59</td><td style="text-align: center">89</td><td style="text-align: center">OSPF</td><td style="text-align: center"><a href="https://en.wikipedia.org/wiki/Open_Shortest_Path_First">Open Shortest Path First</a></td><td style="text-align: center"><a href="https://tools.ietf.org/html/rfc2328">RFC 2328</a></td></tr>
<tr><td style="text-align: center">0x5A</td><td style="text-align: center">90</td><td style="text-align: center">Sprite-RPC</td><td style="text-align: center">Sprite RPC Protocol</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">0x5B</td><td style="text-align: center">91</td><td style="text-align: center">LARP</td><td style="text-align: center"><a href="https://en.wikipedia.org/w/index.php?title=Locus_Address_Resolution_Protocol&amp;action=edit&amp;redlink=1">Locus Address Resolution Protocol</a></td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">0x5C</td><td style="text-align: center">92</td><td style="text-align: center">MTP</td><td style="text-align: center"><a href="https://en.wikipedia.org/w/index.php?title=Multicast_Transport_Protocol&amp;action=edit&amp;redlink=1">Multicast Transport Protocol</a></td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">0x5D</td><td style="text-align: center">93</td><td style="text-align: center">AX.25</td><td style="text-align: center"><a href="https://en.wikipedia.org/wiki/AX.25">AX.25</a></td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">0x5E</td><td style="text-align: center">94</td><td style="text-align: center">OS</td><td style="text-align: center">KA9Q NOS compatible IP over IP tunneling</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">0x5F</td><td style="text-align: center">95</td><td style="text-align: center">MICP</td><td style="text-align: center"><a href="https://en.wikipedia.org/w/index.php?title=Mobile_Internetworking_Control_Protocol&amp;action=edit&amp;redlink=1">Mobile Internetworking Control Protocol</a></td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">0x60</td><td style="text-align: center">96</td><td style="text-align: center">SCC-SP</td><td style="text-align: center">Semaphore Communications Sec. Pro</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">0x61</td><td style="text-align: center">97</td><td style="text-align: center">ETHERIP</td><td style="text-align: center">Ethernet-within-IP Encapsulation</td><td style="text-align: center"><a href="https://tools.ietf.org/html/rfc3378">RFC 3378</a></td></tr>
<tr><td style="text-align: center">0x62</td><td style="text-align: center">98</td><td style="text-align: center">ENCAP</td><td style="text-align: center">Encapsulation Header</td><td style="text-align: center"><a href="https://tools.ietf.org/html/rfc1241">RFC 1241</a></td></tr>
<tr><td style="text-align: center">0x63</td><td style="text-align: center">99</td><td style="text-align: center"></td><td style="text-align: center">Any private encryption scheme</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">0x64</td><td style="text-align: center">100</td><td style="text-align: center">GMTP</td><td style="text-align: center">GMTP</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">0x65</td><td style="text-align: center">101</td><td style="text-align: center">IFMP</td><td style="text-align: center"><a href="https://en.wikipedia.org/w/index.php?title=Ipsilon_Flow_Management_Protocol&amp;action=edit&amp;redlink=1">Ipsilon Flow Management Protocol</a></td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">0x66</td><td style="text-align: center">102</td><td style="text-align: center">PNNI</td><td style="text-align: center">PNNI over IP</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">0x67</td><td style="text-align: center">103</td><td style="text-align: center">PIM</td><td style="text-align: center"><a href="https://en.wikipedia.org/wiki/Protocol_Independent_Multicast">Protocol Independent Multicast</a></td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">0x68</td><td style="text-align: center">104</td><td style="text-align: center">ARIS</td><td style="text-align: center">IBM's ARIS (Aggregate Route IP Switching) Protocol</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">0x69</td><td style="text-align: center">105</td><td style="text-align: center">SCPS</td><td style="text-align: center"><a href="https://en.wikipedia.org/wiki/Space_Communications_Protocol_Specifications">SCPS (Space Communications Protocol Standards)</a></td><td style="text-align: center">SCPS-TP[<a href="https://en.wikipedia.org/wiki/List_of_IP_protocol_numbers#cite_note-4">4]</a></td></tr>
<tr><td style="text-align: center">0x6A</td><td style="text-align: center">106</td><td style="text-align: center"><a href="https://en.wikipedia.org/wiki/QNX">QNX</a></td><td style="text-align: center">QNX</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">0x6B</td><td style="text-align: center">107</td><td style="text-align: center">A/N</td><td style="text-align: center">Active Networks</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">0x6C</td><td style="text-align: center">108</td><td style="text-align: center">IPComp</td><td style="text-align: center"><a href="https://en.wikipedia.org/wiki/IP_Payload_Compression_Protocol">IP Payload Compression Protocol</a></td><td style="text-align: center"><a href="https://tools.ietf.org/html/rfc3173">RFC 3173</a></td></tr>
<tr><td style="text-align: center">0x6D</td><td style="text-align: center">109</td><td style="text-align: center">SNP</td><td style="text-align: center"><a href="https://en.wikipedia.org/w/index.php?title=Sitara_Networks_Protocol&amp;action=edit&amp;redlink=1">Sitara Networks Protocol</a></td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">0x6E</td><td style="text-align: center">110</td><td style="text-align: center">Compaq-Peer</td><td style="text-align: center"><a href="https://en.wikipedia.org/w/index.php?title=Compaq_Peer_Protocol&amp;action=edit&amp;redlink=1">Compaq Peer Protocol</a></td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">0x6F</td><td style="text-align: center">111</td><td style="text-align: center">IPX-in-IP</td><td style="text-align: center"><a href="https://en.wikipedia.org/w/index.php?title=IPX_in_IP&amp;action=edit&amp;redlink=1">IPX in IP</a></td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">0x70</td><td style="text-align: center">112</td><td style="text-align: center">VRRP</td><td style="text-align: center"><a href="https://en.wikipedia.org/wiki/Virtual_Router_Redundancy_Protocol">Virtual Router Redundancy Protocol</a>, <a href="https://en.wikipedia.org/wiki/Common_Address_Redundancy_Protocol">Common Address Redundancy Protocol</a> (not <a href="https://en.wikipedia.org/wiki/Internet_Assigned_Numbers_Authority">IANA</a> assigned)</td><td style="text-align: center">VRRP:<a href="https://tools.ietf.org/html/rfc3768">RFC 3768</a></td></tr>
<tr><td style="text-align: center">0x71</td><td style="text-align: center">113</td><td style="text-align: center">PGM</td><td style="text-align: center"><a href="https://en.wikipedia.org/wiki/Pragmatic_General_Multicast">PGM Reliable Transport Protocol</a></td><td style="text-align: center"><a href="https://tools.ietf.org/html/rfc3208">RFC 3208</a></td></tr>
<tr><td style="text-align: center">0x72</td><td style="text-align: center">114</td><td style="text-align: center"></td><td style="text-align: center">Any 0-hop protocol</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">0x73</td><td style="text-align: center">115</td><td style="text-align: center">L2TP</td><td style="text-align: center"><a href="https://en.wikipedia.org/wiki/L2TPv3">Layer Two Tunneling Protocol Version 3</a></td><td style="text-align: center"><a href="https://tools.ietf.org/html/rfc3931">RFC 3931</a></td></tr>
<tr><td style="text-align: center">0x74</td><td style="text-align: center">116</td><td style="text-align: center">DDX</td><td style="text-align: center">D-II Data Exchange (DDX)</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">0x75</td><td style="text-align: center">117</td><td style="text-align: center">IATP</td><td style="text-align: center"><a href="https://en.wikipedia.org/w/index.php?title=Interactive_Agent_Transfer_Protocol&amp;action=edit&amp;redlink=1">Interactive Agent Transfer Protocol</a></td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">0x76</td><td style="text-align: center">118</td><td style="text-align: center">STP</td><td style="text-align: center"><a href="https://en.wikipedia.org/w/index.php?title=Schedule_Transfer_Protocol&amp;action=edit&amp;redlink=1">Schedule Transfer Protocol</a></td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">0x77</td><td style="text-align: center">119</td><td style="text-align: center">SRP</td><td style="text-align: center"><a href="https://en.wikipedia.org/w/index.php?title=SpectraLink_Radio_Protocol&amp;action=edit&amp;redlink=1">SpectraLink Radio Protocol</a></td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">0x78</td><td style="text-align: center">120</td><td style="text-align: center">UTI</td><td style="text-align: center">Universal Transport Interface Protocol</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">0x79</td><td style="text-align: center">121</td><td style="text-align: center">SMP</td><td style="text-align: center"><a href="https://en.wikipedia.org/w/index.php?title=Simple_Message_Protocol&amp;action=edit&amp;redlink=1">Simple Message Protocol</a></td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">0x7A</td><td style="text-align: center">122</td><td style="text-align: center">SM</td><td style="text-align: center">Simple Multicast Protocol</td><td style="text-align: center"><a href="http://tools.ietf.org/html/draft-perlman-simple-multicast-03">draft-perlman-simple-multicast-03</a></td></tr>
<tr><td style="text-align: center">0x7B</td><td style="text-align: center">123</td><td style="text-align: center">PTP</td><td style="text-align: center"><a href="https://en.wikipedia.org/w/index.php?title=Performance_Transparency_Protocol&amp;action=edit&amp;redlink=1">Performance Transparency Protocol</a></td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">0x7C</td><td style="text-align: center">124</td><td style="text-align: center">IS-IS over IPv4</td><td style="text-align: center"><a href="https://en.wikipedia.org/wiki/IS-IS">Intermediate System to Intermediate System (IS-IS) Protocol</a> over <a href="https://en.wikipedia.org/wiki/IPv4">IPv4</a></td><td style="text-align: center"><a href="https://tools.ietf.org/html/rfc1142">RFC 1142</a> and <a href="https://tools.ietf.org/html/rfc1195">RFC 1195</a></td></tr>
<tr><td style="text-align: center">0x7D</td><td style="text-align: center">125</td><td style="text-align: center">FIRE</td><td style="text-align: center">Flexible Intra-AS Routing Environment</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">0x7E</td><td style="text-align: center">126</td><td style="text-align: center">CRTP</td><td style="text-align: center"><a href="https://en.wikipedia.org/w/index.php?title=Combat_Radio_Transport_Protocol&amp;action=edit&amp;redlink=1">Combat Radio Transport Protocol</a></td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">0x7F</td><td style="text-align: center">127</td><td style="text-align: center">CRUDP</td><td style="text-align: center"><a href="https://en.wikipedia.org/w/index.php?title=Combat_Radio_User_Datagram&amp;action=edit&amp;redlink=1">Combat Radio User Datagram</a></td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">0x80</td><td style="text-align: center">128</td><td style="text-align: center">SSCOPMCE</td><td style="text-align: center">Service-Specific Connection-Oriented Protocol in a Multilink and Connectionless Environment</td><td style="text-align: center"><a href="http://www.itu.int/rec/T-REC-Q.2111-199912-I">ITU-T Q.2111 (1999)</a></td></tr>
<tr><td style="text-align: center">0x81</td><td style="text-align: center">129</td><td style="text-align: center">IPLT</td><td style="text-align: center"></td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">0x82</td><td style="text-align: center">130</td><td style="text-align: center">SPS</td><td style="text-align: center"><a href="https://en.wikipedia.org/w/index.php?title=Secure_Packet_Shield&amp;action=edit&amp;redlink=1">Secure Packet Shield</a></td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">0x83</td><td style="text-align: center">131</td><td style="text-align: center">PIPE</td><td style="text-align: center">Private IP Encapsulation within IP</td><td style="text-align: center"><a href="http://www.watersprings.org/pub/id/draft-petri-mobileip-pipe-00.txt">Expired I-D draft-petri-mobileip-pipe-00.txt</a></td></tr>
<tr><td style="text-align: center">0x84</td><td style="text-align: center">132</td><td style="text-align: center">SCTP</td><td style="text-align: center"><a href="https://en.wikipedia.org/wiki/Stream_Control_Transmission_Protocol">Stream Control Transmission Protocol</a></td><td style="text-align: center"><a href="https://tools.ietf.org/html/rfc4960">RFC 4960</a></td></tr>
<tr><td style="text-align: center">0x85</td><td style="text-align: center">133</td><td style="text-align: center">FC</td><td style="text-align: center"><a href="https://en.wikipedia.org/wiki/Fibre_Channel">Fibre Channel</a></td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">0x86</td><td style="text-align: center">134</td><td style="text-align: center">RSVP-E2E-IGNORE</td><td style="text-align: center">Reservation Protocol (RSVP) End-to-End Ignore</td><td style="text-align: center"><a href="https://tools.ietf.org/html/rfc3175">RFC 3175</a></td></tr>
<tr><td style="text-align: center">0x87</td><td style="text-align: center">135</td><td style="text-align: center">Mobility Header</td><td style="text-align: center">Mobility Extension Header for IPv6</td><td style="text-align: center"><a href="https://tools.ietf.org/html/rfc6275">RFC 6275</a></td></tr>
<tr><td style="text-align: center">0x88</td><td style="text-align: center">136</td><td style="text-align: center">UDPLite</td><td style="text-align: center"><a href="https://en.wikipedia.org/wiki/UDP_Lite">Lightweight User Datagram Protocol</a></td><td style="text-align: center"><a href="https://tools.ietf.org/html/rfc3828">RFC 3828</a></td></tr>
<tr><td style="text-align: center">0x89</td><td style="text-align: center">137</td><td style="text-align: center">MPLS-in-IP</td><td style="text-align: center"><a href="https://en.wikipedia.org/wiki/Multiprotocol_Label_Switching">Multiprotocol Label Switching</a> Encapsulated in IP</td><td style="text-align: center"><a href="https://tools.ietf.org/html/rfc4023">RFC 4023</a>, <a href="https://tools.ietf.org/html/rfc5332">RFC 5332</a></td></tr>
<tr><td style="text-align: center">0x8A</td><td style="text-align: center">138</td><td style="text-align: center">manet</td><td style="text-align: center"><a href="https://en.wikipedia.org/wiki/Mobile_ad_hoc_network">MANET</a> Protocols</td><td style="text-align: center"><a href="https://tools.ietf.org/html/rfc5498">RFC 5498</a></td></tr>
<tr><td style="text-align: center">0x8B</td><td style="text-align: center">139</td><td style="text-align: center">HIP</td><td style="text-align: center"><a href="https://en.wikipedia.org/wiki/Host_Identity_Protocol">Host Identity Protocol</a></td><td style="text-align: center"><a href="https://tools.ietf.org/html/rfc5201">RFC 5201</a></td></tr>
<tr><td style="text-align: center">0x8C</td><td style="text-align: center">140</td><td style="text-align: center">Shim6</td><td style="text-align: center"><a href="https://en.wikipedia.org/wiki/Site_Multihoming_by_IPv6_Intermediation">Site Multihoming by IPv6 Intermediation</a></td><td style="text-align: center"><a href="https://tools.ietf.org/html/rfc5533">RFC 5533</a></td></tr>
<tr><td style="text-align: center">0x8D</td><td style="text-align: center">141</td><td style="text-align: center">WESP</td><td style="text-align: center"><a href="https://en.wikipedia.org/w/index.php?title=Wrapped_Encapsulating_Security_Payload&amp;action=edit&amp;redlink=1">Wrapped Encapsulating Security Payload</a></td><td style="text-align: center"><a href="https://tools.ietf.org/html/rfc5840">RFC 5840</a></td></tr>
<tr><td style="text-align: center">0x8E</td><td style="text-align: center">142</td><td style="text-align: center">ROHC</td><td style="text-align: center"><a href="https://en.wikipedia.org/wiki/Robust_Header_Compression">Robust Header Compression</a></td><td style="text-align: center"><a href="https://tools.ietf.org/html/rfc5856">RFC 5856</a></td></tr>
<tr><td style="text-align: center">0x8F</td><td style="text-align: center">143</td><td style="text-align: center">Ethernet</td><td style="text-align: center">IPv6 Segment Routing (TEMPORARY - registered 2020-01-31, expires 2021-01-31)</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">0x90-0xFC</td><td style="text-align: center">144-252</td><td style="text-align: center">Unassigned</td><td style="text-align: center"></td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">0xFD-0xFE</td><td style="text-align: center">253-254</td><td style="text-align: center">Use for experimentation and testing</td><td style="text-align: center"><a href="https://tools.ietf.org/html/rfc3692">RFC 3692</a></td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">0xFF</td><td style="text-align: center">255</td><td style="text-align: center">Reserved</td><td style="text-align: center"></td><td style="text-align: center"></td></tr>
</tbody></table>
</div>
<blockquote>
<p>IGP: any private interior gateway (used by Cisco for their IGRP)</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rpc"><a class="header" href="#rpc">RPC</a></h1>
<h2 id="msrpc"><a class="header" href="#msrpc">MSRPC</a></h2>
<p>ports：<code>TCP/135</code>, <code>UDP/135</code>, SMB(<code>TCP/139</code>, <code>TCP/445</code>), web sevice (<code>TCP/593</code>)</p>
<p><img src="Protocols/RPC.assets/image.png" alt="img" /></p>
<p>https://book.hacktricks.xyz/pentesting/135-penstesting-msrpc</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="theme/pagetoc.js"></script>
        <script type="text/javascript" src="theme/MathJax.js"></script>
        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>
    </body>
</html>