<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Shell - Learning Programming Book</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="The example book covers examples.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../theme/pagetoc.css">
        <!-- MathJax -->
        <!-- <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script> -->
        <script async type="text/javascript" src="theme/MathJax.js"></script>
        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../prefix.html">Prefix</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">程序设计语言</li><li class="chapter-item expanded "><a href="../Python/Python编程基础.html">Python</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Python/Python编程基础.html">编程基础</a></li><li class="chapter-item expanded "><a href="../Python/Python开发环境.html">开发环境</a></li><li class="chapter-item expanded "><a href="../Python/Python数据类型.html">数据类型</a></li><li class="chapter-item expanded "><a href="../Python/Python输入输出.html">输入输出</a></li><li class="chapter-item expanded "><a href="../Python/Python编程应用.html">编程应用</a></li><li class="chapter-item expanded "><a href="../Python/Python数值计算.html">数值计算</a></li><li class="chapter-item expanded "><a href="../Python/Python系统编程.html">系统编程</a></li><li class="chapter-item expanded "><a href="../Python/Python高级编程.html">高级编程</a></li></ol></li><li class="chapter-item expanded "><a href="../Java/JAVA编程基础.html">Java</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Java/JAVA编程基础.html">编程基础</a></li><li class="chapter-item expanded "><a href="../Java/Java开发环境.html">开发环境</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Java/Maven POM.html">Maven 配置</a></li></ol></li><li class="chapter-item expanded "><a href="../Java/JAVA数据类型.html">数据类型</a></li><li class="chapter-item expanded "><a href="../Java/JAVA输入输出.html">输入输出</a></li><li class="chapter-item expanded "><a href="../Java/JAVA系统编程.html">系统编程</a></li><li class="chapter-item expanded "><a href="../Java/Scala.html">Scala</a></li><li class="chapter-item expanded "><a href="../Java/ScalaFrameworks.html">Scala 框架</a></li></ol></li><li class="chapter-item expanded "><a href="../CSharp.NET/CSharp编程基础.html">C#/.NET</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../CSharp.NET/CSharp编程基础.html">编程基础</a></li><li class="chapter-item expanded "><a href="../CSharp.NET/CSharp输入输出.html">输入输出</a></li><li class="chapter-item expanded "><a href="../CSharp.NET/CSharp数据容器.html">数据容器</a></li><li class="chapter-item expanded "><a href="../CSharp.NET/CSharp数值计算.html">数值计算</a></li><li class="chapter-item expanded "><a href="../CSharp.NET/dotnet开发.html">.NET 开发</a></li></ol></li><li class="chapter-item expanded "><a href="../CC++/Modern C++.html">C and C++</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../CC++/Modern C++.html">Modern C++</a></li><li class="chapter-item expanded "><a href="../CC++/C++开发环境.html">开发环境</a></li><li class="chapter-item expanded "><a href="../CC++/C++容器.html">数据容器</a></li><li class="chapter-item expanded "><a href="../CC++/输入输出.html">输入输出</a></li><li class="chapter-item expanded "><a href="../CC++/标准函数库.html">标准库</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../CC++/数学函数.html">数学函数</a></li></ol></li></ol></li><li class="chapter-item expanded "><div>Web开发</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../JavaScript/JavaScript.html">JavaScript</a></li><li class="chapter-item expanded "><a href="../JavaScript/TypeScript.html">TypeScript</a></li><li class="chapter-item expanded "><a href="../JavaScript/JS开发环境.html">开发环境</a></li></ol></li><li class="chapter-item expanded "><div>开发工具</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../开发环境/git.html">Git</a></li><li class="chapter-item expanded "><a href="../笔记/正则表达式.html">正则表达式</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><li class="part-title">操作系统</li><li class="chapter-item expanded "><a href="../Linux/Linux配置和管理.html">Linux</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Linux/Linux配置和管理.html">配置管理</a></li><li class="chapter-item expanded "><a href="../Linux/Linux-Shell.html">Shell Script</a></li><li class="chapter-item expanded "><a href="../Linux/Linux发行版.html">Linux 发行版</a></li><li class="chapter-item expanded "><a href="../Linux/操作系统原理.html">操作系统原理</a></li></ol></li><li class="chapter-item expanded "><a href="../Windows/Windows配置管理.html">Windows</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Windows/Windows配置管理.html">配置管理</a></li><li class="chapter-item expanded "><a href="../Windows/Windows Shell.html" class="active">Shell</a></li><li class="chapter-item expanded "><a href="../Windows/Windows Applications.html">应用软件</a></li></ol></li><li class="chapter-item expanded "><div>应用软件</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../应用软件/程序开发软件.html">程序开发</a></li><li class="chapter-item expanded "><a href="../应用软件/服务器管理软件.html">服务器管理</a></li><li class="chapter-item expanded "><a href="../应用软件/网络访问软件.html">网络访问</a></li><li class="chapter-item expanded "><a href="../应用软件/网络服务软件.html">网络服务</a></li><li class="chapter-item expanded "><a href="../应用软件/文档生成软件.html">文档生成</a></li><li class="chapter-item expanded "><a href="../应用软件/文件处理软件.html">文件处理</a></li><li class="chapter-item expanded "><a href="../应用软件/协作办公软件.html">协作办公</a></li><li class="chapter-item expanded "><a href="../应用软件/知识管理软件.html">知识管理</a></li><li class="chapter-item expanded "><a href="../应用软件/多媒体编辑软件.html">多媒体编辑</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><li class="part-title">机器学习</li><li class="chapter-item expanded "><a href="../机器学习/机器学习实践.html">机器学习实践</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../机器学习/ScikitLearn.html">scikit-learn</a></li><li class="chapter-item expanded "><a href="../机器学习/TensorFlow.html">TensorFlow</a></li><li class="chapter-item expanded "><a href="../机器学习/Pytorch.html">Pytorch</a></li><li class="chapter-item expanded "><a href="../机器学习/图神经网络.html">图神经网络</a></li></ol></li><li class="chapter-item expanded "><a href="../机器学习/机器学习原理与算法.html">原理与算法</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../机器学习/统计学习算法.html">统计学习算法</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><li class="part-title">数据库</li><li class="chapter-item expanded "><a href="../数据库/SQL语法.html">SQL</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../数据库/SQL DDL.html">SQL DDL</a></li><li class="chapter-item expanded "><a href="../数据库/SQL DML.html">SQL DML</a></li><li class="chapter-item expanded "><a href="../数据库/SQL数据类型.html">数据类型</a></li></ol></li><li class="chapter-item expanded "><a href="../数据库/MySQL.html">MySQL</a></li><li class="chapter-item expanded "><a href="../数据库/PostgreSQL.html">PostgreSQL</a></li><li class="chapter-item expanded "><a href="../数据库/HiveSQL.html">Hive SQL</a></li><li class="chapter-item expanded "><a href="../数据库/Elasticsearch.html">Elasticsearch</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../数据库/Elastic Datasource.html">数据源</a></li></ol></li><li class="chapter-item expanded "><a href="../数据库/Mongodb.html">Mongodb</a></li><li class="chapter-item expanded "><a href="../数据库/GraphDatabase.html">图数据库</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">服务和大数据平台</li><li class="chapter-item expanded "><a href="../服务器/分布式大数据处理.html">分布式大数据处理</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../服务器/CDH6大数据集群离线安装.html">CDH6 安装教程</a></li><li class="chapter-item expanded "><a href="../服务器/Spark Python API.html">Pyspark</a></li><li class="chapter-item expanded "><a href="../服务器/流数据处理.html">流数据处理</a></li></ol></li><li class="chapter-item expanded "><a href="../服务器/容器编排.html">容器编排</a></li><li class="chapter-item expanded "><a href="../服务器/虚拟化.html">虚拟化</a></li><li class="chapter-item expanded "><div>任务编排</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../服务器/Airflow.html">Airflow</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><li class="part-title">其他</li><li class="chapter-item expanded "><div>数据标记语言</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../数据交换语言/JSON and YAML.html">JSON and YAML</a></li><li class="chapter-item expanded "><a href="../数据交换语言/XML.html">XML</a></li><li class="chapter-item expanded "><a href="../数据交换语言/HTML.html">HTML</a></li></ol></li><li class="chapter-item expanded "><div>网络协议</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Protocols/http.html">HTTP</a></li><li class="chapter-item expanded "><a href="../Protocols/DNS.html">DNS</a></li><li class="chapter-item expanded "><a href="../Protocols/端口分配.html">端口分配</a></li><li class="chapter-item expanded "><a href="../Protocols/IP protocol numbers.html">IP 承载协议</a></li><li class="chapter-item expanded "><a href="../Protocols/RPC.html">RPC</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Learning Programming Book</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <!-- Page table of contents -->
                        <div class="sidetoc"><nav class="pagetoc"></nav></div>

                        <h1 id="windows-powershell"><a class="header" href="#windows-powershell">Windows PowerShell<img src="Windows Shell.assets/powershell.png" alt="powershell deep learning" align="right" style="zoom: 33%;float:right" /></a></h1>
<blockquote>
<p>PowerShell is built on .NET:</p>
<ul>
<li><em>Windows PowerShell 5.1 is built on top of the .NET Framework v4.5.</em></li>
<li><em>PowerShell is an open source project built on .NET Core.</em></li>
</ul>
</blockquote>
<h2 id="安装"><a class="header" href="#安装">安装</a></h2>
<h5 id="windows"><a class="header" href="#windows">Windows</a></h5>
<p>以下为安装PowerShell 7.x的方法（Windows内置PowerShell 5.1，PowerShell 7.x可与之并存）。</p>
<ol>
<li>
<p><code>msi</code>安装，<a href="https://github.com/PowerShell/PowerShell/releases/">下载安装包</a>点击执行或运行以下命令：</p>
<pre><code class="language-powershell">msiexec.exe /package PowerShell-7.2.4-win-x64.msi /quiet \
    USE_MU=1 ENABLE_MU=1 # 通过Windows Update自动更新PowerShell
</code></pre>
</li>
<li>
<p><code>winget</code>安装：</p>
<pre><code class="language-powershell">winget install Microsoft.PowerShell
</code></pre>
</li>
<li>
<p>安装为<a href="../CSharp.NET/dotnet%E5%BC%80%E5%8F%91.html#NET%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7"><code>.NET</code>全局工具</a>：</p>
<pre><code class="language-powershell">dotnet tool install|update --global PowerShell # [Admin] 安装PowerShell 7.x
</code></pre>
</li>
<li>
<p>通过应用商店安装（<a href="https://docs.microsoft.com/en-us/powershell/scripting/install/installing-powershell-on-windows?view=powershell-7.2#known-limitations">有运行权限限制</a>）。</p>
</li>
</ol>
<h5 id="linux"><a class="header" href="#linux">Linux</a></h5>
<ol>
<li>
<p>从软件源安装</p>
<pre><code class="language-shell">sudo apt install -y wget apt-transport-https software-properties-common
wget -q &quot;https://packages.microsoft.com/config/ubuntu/$(lsb_release -rs)/packages-microsoft-prod.deb&quot;
sudo dpkg -i packages-microsoft-prod.deb # Register the repository GPG keys
sudo apt update &amp;&amp; sudo apt install -y powershell
</code></pre>
</li>
<li>
<p>直接从<a href="https://github.com/PowerShell/PowerShell/releases/">发布页面下载</a>软件包安装。</p>
</li>
</ol>
<p>安装相关路径：</p>
<ul>
<li><code>$PSHOME=/opt/microsoft/powershell/7/</code>；</li>
<li>用户配置文件：<code>~/.config/powershell/profile.ps1</code>；</li>
<li>用户模块目录：<code>~/.local/share/powershell/Modules</code>；</li>
</ul>
<h3 id="powershell命令"><a class="header" href="#powershell命令">PowerShell命令</a></h3>
<p>PowerShell命令命名规则为<code>Verb-Noun</code>（动词-名词）形式。</p>
<h4 id="探索powershell命令"><a class="header" href="#探索powershell命令">探索PowerShell命令</a></h4>
<ul>
<li>
<p><code>Get-Verb</code>：获取命令库中多数命令的开头动词（有助于用户使用命令）；</p>
</li>
<li>
<p><code>Get-Command</code>：返回所有已安装的命令。也可以添加参数以过滤列举内容（参数支持通配符<code>*</code>）：</p>
<pre><code class="language-powershell">Get-Command -Name|Verb|Noun &lt;cmdlet&gt; \            # 按名称/动词/名词匹配
            -CommandType Cmdlet, Function, Alias  # 按命令类型匹配
            -Module &lt;module&gt;                      # 按模块匹配
            -ParameterType Process                # 根据命令接受的主要参数的类型筛选
Get-Command Get-Process -Syntax # 获取命令语法
</code></pre>
</li>
<li>
<p><code>Get-Alias</code>：获取命令别名的信息。</p>
<pre><code class="language-powershell">Get-Alias -Definition Get-Command,Get-Member # 获取别名
Get-Alias ls,dir                             # 获取全名
</code></pre>
<blockquote>
<p>在脚本中尽量使用全名而非别名，以增强可读性。</p>
</blockquote>
</li>
<li>
<p><code>Get-Member</code>：对输出对象进行操作，并返回<a href="#%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7">对象的属性和方法</a>（<em>可根据参数过滤</em>）。</p>
<pre><code class="language-powershell">$s = Get-Service -Name w32time
$s | Get-Member  # 返回对象的类型，及其包含属性的方法的名称、类型和定义
</code></pre>
</li>
<li>
<p><code>Get-Help &lt;cmdlet-name&gt;</code>：获取命令的<a href="#%E6%96%87%E6%A1%A3">文档信息</a>。</p>
</li>
</ul>
<h4 id="模块管理"><a class="header" href="#模块管理">模块管理</a></h4>
<h5 id="包管理模块"><a class="header" href="#包管理模块">包管理模块</a></h5>
<p><code>PowerShellGet</code>用于查找、安装、更新和发布模块、脚本等内容。</p>
<blockquote>
<p>错误：<em>A parameter cannot be found that matches parameter name <code>AllowPrerelease</code>.</em>：检查是否安装/导入<code>PowershellGet</code>模块。</p>
</blockquote>
<p>安装/更新<code>PowerShellGet</code>的两种方法：</p>
<ol>
<li>
<p>安装<code>Nuget</code>将自动安装<code>PowerShellGet</code>；</p>
<pre><code class="language-powershell">Install-PackageProvider -Name NuGet -Force # with Admin
</code></pre>
</li>
<li>
<p>直接安装<code>PowerShellGet</code>；</p>
<pre><code class="language-powershell">Install-Module -Name PowerShellGet -AllowClobber -Force
</code></pre>
</li>
</ol>
<h5 id="安装模块"><a class="header" href="#安装模块">安装模块</a></h5>
<pre><code class="language-powershell">Install-Module [-Name] &lt;ModuleName*&gt; 
  -Scope CurrentUser|AllUsers   # AllUsers needs Admin previllege
  -AllowPrerelease 
  -WhatIf
  -MinimumVersion 2.0.1 # -RequiredVersion -MaximumVersion
  -Force         # 安装同名不同版本模块
  -AllowClobber  # 覆盖同名模块  
Update-Module # 参数与Instal-Module相似
Uninstall-Module [-Name] &lt;ModuleName&gt;
</code></pre>
<p>安装模块前可以先进行搜索。首先查找本地是否已安装相应模块：</p>
<pre><code class="language-powershell">Get-Module -ListAvailable [-Name &lt;ModuleName&gt;]  # 从当前当前会话查找模块
</code></pre>
<blockquote>
<p><code>-ListAvailable</code>：列出指定模块的所有本地安装版本（可能包含系统内置版本和用户安装版本）。</p>
</blockquote>
<p>如果本地不存在指定模块，可查找<a href="https://www.powershellgallery.com/">Nuget仓库</a>（可使用Nexus搭建镜像仓库）。</p>
<pre><code class="language-powershell">Find-Module -Name &lt;ModuleName&gt;  # -&gt; PSRepositoryItemInfo
</code></pre>
<blockquote>
<p>如果本地存在指定模块，找到的模块会被加载到当前会话。</p>
</blockquote>
<pre><code class="language-powershell">Find-Command -Name &lt;CmdName&gt; -ModuleName &lt;ModName&gt; # -&gt; PSGetCommandInfo
	-AllowPrerelease 
	-RequiredVersion  # -MinimumVersion -MaximumVersion
</code></pre>
<p><code>Find-Module</code>，<code>Find-Command</code>的返回的结果可以传递给<code>Install-Module</code>执行安装。</p>
<h5 id="导入模块"><a class="header" href="#导入模块">导入模块</a></h5>
<p>位于<code>$env:PSModulePath</code>路径下加模块会自动被加载。其他模块，在命令行或脚本中执行导入：</p>
<pre><code class="language-powershell">Import-Module [-Name] &lt;ModuleName&gt;
$m = Get-Module -ListAvailable PowershellGet, Dism
Import-Module -ModuleInfo $m
Import-Module -Name c:\ps-test\modules\test -Verbose
</code></pre>
<p><a href="https://docs.microsoft.com/zh-cn/powershell/module/microsoft.powershell.core/import-module?view=powershell-7.1">Import-Module</a>。</p>
<h5 id="离线手工安装模块"><a class="header" href="#离线手工安装模块">离线手工安装模块</a></h5>
<p>可以从<a href="https://www.powershellgallery.com/packages/">PowerShell Gallery</a>下载模块的<code>nupkg</code>包。<code>.nupkg</code>以<code>zip</code>格式封装了模块数据以及NuGet相关的描述数据（非模块本身的数据）。NuGet相关数据包括：</p>
<ul>
<li><code>_rels/</code>：包含模块的依赖声明（<code>.rels</code>文件）；</li>
<li><code>package/</code>：NuGet相关数据；</li>
<li><code>[Content_Types].xml</code>：描述扩展模块如何与NuGet共同使用；</li>
<li><code>&lt;name&gt;.nuspec</code>：包的元数据。</li>
</ul>
<p>手工安装：将<code>.nupkg</code>中非NuGet相关数据解压到<code>$env:PSModulePath</code>中的一个路径下，并仅以包名命名该模块的文件夹<sup class="footnote-reference"><a href="#nuget">1</a></sup>。</p>
<h4 id="文档"><a class="header" href="#文档">文档</a></h4>
<p>PowerShell文档介绍了PowerShell的cmdlet、函数、脚本及模块，并解释了PowerShell 语言的元素等概念。在命令行中使用<code>Get-Help cmdlet</code>来显示帮助主题。</p>
<pre><code class="language-powershell">Get-Help cmdname -examples|detailed|full|online
help cmdname   # =&gt; Get-Help cmdname | more
help Get-Command -Full | Out-GridView  # 在独立的文档查看器中查看帮助文档
</code></pre>
<blockquote>
<p>如果本地没有帮助文件，<code>Get-Help</code> 会显示自动生成的有关 cmdlet、函数及脚本的帮助。</p>
<p><code>help</code>不是<code>Get-Help</code>的别名：每次仅显示一页内容，需要手动翻页。</p>
<p><code>Get-Help</code>会搜索与<code>cmdname</code>匹配的相关命令（类似于<code>Get-Command</code>），<code>cmdname</code>可包含通配符（==如果前后未添加<code>*</code>，则在名称中间添加<code>*</code>是无效的通配符==）。因此，当查找结果多于一条，将显示结果列表；反之显示查找结果的详细信息。</p>
</blockquote>
<p>获取命令的参数信息：</p>
<pre><code class="language-powershell">help cmdname -Parameter &lt;ParameterName&gt;
</code></pre>
<h5 id="获取本地文档"><a class="header" href="#获取本地文档">获取本地文档</a></h5>
<p>PowerShell 中默认不包含帮助文件，但可以联机查看帮助主题，或使用 <code>Update-Help cmdlet</code>将帮助文件下载到本地或在网站发布更新的时候更新本地文档。</p>
<blockquote>
<p><a href="https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/update-help?view=powershell-7.1">Update-Help (Microsoft.PowerShell.Core) - PowerShell | Microsoft Docs</a>。</p>
</blockquote>
<pre><code class="language-powershell">Update-Help \
	[-UICulture en-US,zh-CN]   # 指定文档语言
	[-Module Microsoft.PowerShell*] # 更新指定模块的文档（默认更新所有已安装的模块）
	-SourcePath path   # Save-Help
</code></pre>
<h3 id="开发环境"><a class="header" href="#开发环境">开发环境</a></h3>
<p><a href="https://docs.microsoft.com/en-us/powershell/scripting/dev-cross-plat/vscode/using-vscode?view=powershell-7.2#debugging-with-visual-studio-code">Debugging with Visual Studio Code</a></p>
<h2 id="变量"><a class="header" href="#变量">变量</a></h2>
<blockquote>
<p><em>PowerShell accepts and returns <strong>.NET objects</strong>, rather than text.</em></p>
</blockquote>
<p>设置变量：</p>
<pre><code class="language-powershell">$JAVA_HOME=&quot;C:\tools\java&quot;
Set-Variable -Name 'JAVA_HOME' -Value 'C:\tools\java'  # -&gt; set*
</code></pre>
<blockquote>
<p><code>*</code>：<code>set</code>是<code>Set-Variable</code>的别名，与<code>cmd</code>的变量设置<a href="#%E5%AE%9A%E4%B9%89console%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F">命令<code>set</code></a>无关。</p>
</blockquote>
<p>==变量名不区分大小写==。</p>
<p>输出变量：</p>
<pre><code class="language-powershell">$JAVA_HOME            # =&gt; echo $JAVA_HOME
$JAVA_HOME.ToUpper()  # 调用变量对象的属性或方法
$v=Get-Variable -Name 'JAVA_HOME'  # get (Name,Value) object
$v.Value
</code></pre>
<h3 id="数据类型"><a class="header" href="#数据类型">数据类型</a></h3>
<h4 id="空值"><a class="header" href="#空值">空值</a></h4>
<p><a href="https://docs.microsoft.com/en-us/powershell/scripting/learn/deep-dives/everything-about-null?view=powershell-7.2">Everything you wanted to know about $null - PowerShell | Microsoft Docs</a></p>
<h4 id="字符串"><a class="header" href="#字符串">字符串</a></h4>
<p>字符串需要使用<code>''</code>或<code>&quot;&quot;</code>进行表示，否则相应内容将被视为shell命令。==字符串使用<code>+</code>拼接==。</p>
<p><a href="https://docs.microsoft.com/en-us/powershell/scripting/learn/deep-dives/everything-about-string-substitutions?view=powershell-7.2">Everything you wanted to know about variable substitution in strings - PowerShell | Microsoft Docs</a></p>
<h5 id="裁剪字符串"><a class="header" href="#裁剪字符串">裁剪字符串</a></h5>
<pre><code class="language-powershell">str.Trim()          # TrimEnd/TrimStart
str.Trim(&quot;a&quot;, &quot; &quot;)  # 可指定多个裁剪模式(单个字符)
</code></pre>
<blockquote>
<p>返回新的对象。</p>
</blockquote>
<h5 id="分割字符串"><a class="header" href="#分割字符串">分割字符串</a></h5>
<pre><code class="language-powershell">$array=&quot;abcdefghi&quot;.split(&quot;de&quot;)  # -&gt; -split运算符
</code></pre>
<h4 id="数组"><a class="header" href="#数组">数组</a></h4>
<p>许多命令（如<code>Get-Process</code>）的返回值都是一个数组。手动构造数组方法：</p>
<pre><code class="language-powershell">$data=@('Zero','One','Two','Three')  # 空数组 $data = @()
$data=('Zero','One','Two','Three')   # =&gt; $data = 'Zero','One','Two','Three'
</code></pre>
<blockquote>
<p>数组元素可换行声明，此时两行间的元素不需要通过<code>,</code>分隔。</p>
</blockquote>
<p>通过迭代构造数组：</p>
<pre><code class="language-powershell">$array = 1..5 | ForEach-Object { &quot;ATX-SQL-$PSItem&quot; }
$array = foreach ( $node in (1..5)){ &quot;ATX-SQL-$node&quot; }
</code></pre>
<p>数组默认类型为<code>[PSObject[]]</code>，即其元素都继承自<code>PSObject</code>。在创建数组时可指定严格的类型限制：</p>
<pre><code class="language-powershell">[int[]] $numbers = 1,2,3
</code></pre>
<p>预分配内存的数组：</p>
<pre><code class="language-powershell">$data = [Object[]]::new(4)
</code></pre>
<p>嵌套数组：</p>
<pre><code class="language-powershell">$data = @(
    @(1,2,3),  # 嵌套数组元素换行时仍需&quot;,&quot;分隔
    @(4,5,6),
    @(7,8,9)
)
$data[1][2]  # -&gt; 6
</code></pre>
<p>多维数组：</p>
<pre><code class="language-powershell">[string[,]]$rank2 = [string[,]]::New(3,2)
</code></pre>
<h5 id="数组属性"><a class="header" href="#数组属性">数组属性</a></h5>
<pre><code class="language-powershell">Write-Output -NoEnumerate $data | Get-Member # 获取数组的属性和方法
$data | Get-Member  # 获取数组元素的属性和方法
</code></pre>
<pre><code class="language-shell">$data.Count  # 数组元素数量 =&gt; $data.Length
$data.Rank   # 数组维数
</code></pre>
<blockquote>
<p>不仅数组可以获取长度，标量对象也可（返回1），空数组长度为0（特别地<code>$null.count-&gt;0</code>，注意区别）。</p>
</blockquote>
<h5 id="访问元素"><a class="header" href="#访问元素">访问元素</a></h5>
<pre><code class="language-shell">$data[i]      # 0-based index
$data[0,2,3]  # 获取子数组（可添加重复编号以生成重复元素）
$data[1..3]   # 切片(区间可反向，即&quot;3..1:&quot;)
$data[-1]     # 负索引
$data[i,-j]   # =&gt; [i,i-1,...0,-1,...-j] (与Python负索引语义不同)
</code></pre>
<blockquote>
<p>访问不在数组长度范围内元素将返回<code>$null</code>而非产生异常。</p>
<p><code>i..j</code>将自动生成一个整数数组。</p>
</blockquote>
<p>访问数组元素属性（链式调用）：</p>
<pre><code class="language-shell">$data[0].PropName
$data.PropName   # 返回所有元素的PropName返回值组成的新数组
</code></pre>
<h5 id="更新数组"><a class="header" href="#更新数组">更新数组</a></h5>
<pre><code class="language-powershell">$data[2] = 'dos'  # 索引编号超过数组长度将产生异常
$data.Clear()     # 重置数组元素的值为默认值
</code></pre>
<h5 id="迭代数组"><a class="header" href="#迭代数组">迭代数组</a></h5>
<pre><code class="language-powershell">$data.foreach({&quot;Item [$PSItem]&quot;})          # =&gt; $data.foreach{&quot;Item [$PSItem]&quot;}
$data | ForEach-Object {&quot;Item: [$PSItem]&quot;} # $PSItem =&gt; $_
foreach ( $node in $data ){ &quot;Item: [$node]&quot; }
for ( $index = 0; $index -lt $data.count; $index++){
    &quot;Item: [{0}]&quot; -f $data[$index]
}
switch( $data ) {...}  # 对数组每个元素执行分支判断
</code></pre>
<p>当数组元素类型为值类型时，使用<code>for</code>语句块可在迭代数组时对其进行更新。反之，如果为引用类型，则其他迭代语句也可对数组元素的属性进行更改。</p>
<blockquote>
<p><code>ForEach-Object -Parallel</code>[7.x]：管道并行。</p>
</blockquote>
<h5 id="数组对象运算"><a class="header" href="#数组对象运算">数组对象运算</a></h5>
<p>数组对象运算都将产生新的数组对象。</p>
<ol>
<li>
<p>字符串拼接：使用连接符将数组内容拼接为一个字符串对象。</p>
<pre><code class="language-powershell">$data -join '-' 
</code></pre>
</li>
<li>
<p>替换：</p>
<pre><code class="language-powershell">$data -replace 'ATX','LAX'  # 对数组每个元素执行替换
</code></pre>
</li>
<li>
<p>查找：返回<code>True|False</code>。<code>-contains, -notcontains</code>，<code>-in, -notin</code></p>
<pre><code class="language-powershell">$data -contains 'green'  # =&gt; 'green' -in $data
</code></pre>
</li>
<li>
<p>比较或匹配过滤（<code>-eq</code>, <code>-ne</code>, <code>-match</code>）：数组与对象比较返回匹配对象（或子数组）：</p>
<pre><code class="language-powershell">$data -eq 'green'
$servers -match 'SQL' # =&gt; $servers | Select-String SQL
</code></pre>
<blockquote>
<p>判断数组对象是否为<code>$null</code>，应该使用<code>$null -eq $array</code>避免上述语法对数组的<code>$null</code>值的筛选。</p>
</blockquote>
</li>
<li>
<p>追加：</p>
<pre><code class="language-powershell">$data = $data + 'four'  # $data += 'four'
</code></pre>
</li>
<li>
<p>拼接：</p>
<pre><code class="language-powershell">$array=$array1+$array2
$array = $array * 3    # 复制并拼接(使用这种方法可构造初始值为固定值的数组)
</code></pre>
</li>
</ol>
<h5 id="数组过滤"><a class="header" href="#数组过滤">数组过滤</a></h5>
<p>基于数组元素或元素属性的值过滤元素。如果数组元素本身就是字符串对象，则直接在迭代语句中使用<code>$_</code>。</p>
<pre><code class="language-shell">$data | Where-Object {$_.Name -eq w32time}
$data.Where({$_.FirstName -eq 'Kevin'})   # 使用成员函数
$data | Select-Object -First 3
</code></pre>
<h5 id="分组统计"><a class="header" href="#分组统计">分组统计</a></h5>
<pre><code class="language-powershell">$data | Group-Object -Property ModuleName | 
        Sort-Object -Property Count -Descending
</code></pre>
<h4 id="字典hashtable"><a class="header" href="#字典hashtable">字典（hashtable）</a></h4>
<pre><code class="language-powershell">$hashtable = @{}
$hashtable['key'] = $value 
</code></pre>
<p>字典可传递给命令，以代替逐个传递命令行参数，方便动态构造传入参数。</p>
<p><a href="https://docs.microsoft.com/en-us/powershell/scripting/learn/deep-dives/everything-about-hashtable?view=powershell-7.2">Everything you wanted to know about hashtables - PowerShell | Microsoft Docs</a></p>
<h3 id="运算符"><a class="header" href="#运算符">运算符</a></h3>
<p>具有相同优先级的运算符从左到右依次计算。例外：赋值运算符、类型转换运算符、和取反运算符（<code>!</code>，<code>-not</code>，<code>-bnot</code>）从有至左计算。</p>
<p>可以使用<code>()</code>来显式限定优先计算的部分表达式。</p>
<p>运算符优先级从高到低<sup class="footnote-reference"><a href="#preced">2</a></sup>：</p>
<ul>
<li>
<p><code>$(), @(), (), @{}</code></p>
</li>
<li>
<p><code>. ?.</code> (member access)</p>
</li>
<li>
<p><code>::</code> (static)</p>
</li>
<li>
<p><code>[0] ?[0]</code> (index operator)</p>
</li>
<li>
<p><code>[int]</code> (cast operators)</p>
<pre><code class="language-powershell">[datetime]$birthday = &quot;1/10/66&quot;   # 将birthday转换为datetime类型
</code></pre>
</li>
<li>
<p><code>-split</code> (unary)</p>
</li>
<li>
<p><code>-join</code> (unary)</p>
</li>
<li>
<p><code>,</code> (comma operator)</p>
</li>
<li>
<p><code>++ --</code>：自增运算符，支持前置或后置。</p>
</li>
<li>
<p><code>! -not</code>：逻辑取反运算。</p>
</li>
<li>
<p><code>..</code> (range operator)</p>
</li>
<li>
<p><code>-f</code> (format operator)</p>
<pre><code class="language-powershell">&quot;{0:N2} - {1}&quot; -f 10 1.5
</code></pre>
</li>
<li>
<p><code>-</code> (unary/negative)</p>
</li>
<li>
<p><code>* / %</code></p>
</li>
<li>
<p><code>+ -</code></p>
</li>
<li>
<p>以下命令具有同等优先级：</p>
<ul>
<li>
<p><code>-split -join</code> (binary)：分割字符串（合并见数组运算）。</p>
<pre><code class="language-powershell">$array=&quot;abcdefghi&quot; -split &quot;de&quot; # -&gt; $array=&quot;abcdefghi&quot;.split(&quot;de&quot;)
</code></pre>
</li>
<li>
<p><code>-is -isnot</code>：判断是否为.Net Framework类型。</p>
<pre><code class="language-powershell">42 –is [int]
</code></pre>
</li>
<li>
<p><code>-as</code>：类型转换。</p>
<pre><code class="language-powershell">$a = 42 –as [String]
</code></pre>
</li>
<li>
<p><code>-eq -ne -gt -ge -lt -le</code>：比较运算符。涉及字符串比较的运算符默认为大小写不敏感的，带前缀<code>c</code>的运算符（<code>-ceq</code>）为大小写敏感的（具有同等优先级）。</p>
<blockquote>
<p>不支持<code>==,!=,&gt;,&lt;=,&lt;,&lt;=</code>。</p>
</blockquote>
</li>
<li>
<p><code>-match -notmatch</code>：正则表达式匹配，返回是否匹配；</p>
</li>
<li>
<p><code>-like -notlike</code>：通配符匹配；</p>
</li>
<li>
<p><code>-in -notIn</code>，<code>-contains -notContains</code></p>
</li>
<li>
<p><code>-replace</code>：字符串替换。</p>
<pre><code class="language-powershell">&quot;abcde&quot; -replace &quot;bc&quot;, &quot;TEST&quot;  # replace bc with TEST
# aTESTde
</code></pre>
</li>
</ul>
</li>
<li>
<p><code>-band -bnot -bor -bxor -shr -shl</code>：位运算，<code>-shl, -shr</code>（移位）。</p>
</li>
<li>
<p><code>-and -or -xor</code>：逻辑运算。</p>
</li>
<li>
<p>以下命令非真正的运算符而是PowerShell命令语法的一部分，在命令解释执行过程中具有最低优先级。</p>
<ul>
<li>
<p><code>.</code> (dot-source)</p>
</li>
<li>
<p><code>&amp;</code> (call)</p>
</li>
<li>
<p><code>? &lt;if-true&gt; : &lt;if-false&gt;</code> (Ternary operator)</p>
</li>
<li>
<p><code>??</code> (null-coalese operator)</p>
</li>
<li>
<p><code>|</code> (pipeline operator)</p>
</li>
<li>
<p><code>&gt; &gt;&gt; 2&gt; 2&gt;&gt; 2&gt;&amp;1</code></p>
</li>
<li>
<p><code>&amp;&amp; ||</code> (pipeline chain operators)</p>
</li>
<li>
<p><code>= += -= *= /= %= ??=</code>：赋值运算符。</p>
<pre><code class="language-powershell">$result=$a*$b
</code></pre>
</li>
</ul>
</li>
</ul>
<h3 id="容器类型"><a class="header" href="#容器类型">容器类型</a></h3>
<p>数组定义后无法增加元素，PowerShell可调用多种.NET容器类型以解决此问题。</p>
<h4 id="arraylist"><a class="header" href="#arraylist">ArrayList</a></h4>
<pre><code class="language-powershell">$myarray = [System.Collections.ArrayList]::new()
[void]$myArray.Add('Value')   # [void] to suppress return value.
</code></pre>
<h4 id="list"><a class="header" href="#list">List</a></h4>
<p><code> ArrayList</code>不支持泛型，因此类似于数组默认存储<code>PSObject</code>元素。<code>List</code>类型支持泛型（类似于数组声明时限定类型）：</p>
<pre><code class="language-powershell">$mylist = [System.Collections.Generic.List[int]]::new()
$mylist = [System.Collections.Generic.List[int]]@(1,2,3) # 将数组转换为List
</code></pre>
<blockquote>
<p>对于类型元素多样的情况，也可使用<code>PSObject</code>作为类型参数。</p>
</blockquote>
<p><code>List</code>和<code>ArrayList</code>都支持元素的的增加和删除。</p>
<pre><code class="language-powershell">[void]$myList.Remove(&quot;Two&quot;)      # -&gt; True|False: if element is found
[void]$drives.Remove($drives[2]) # remove reference type
</code></pre>
<h4 id="stringbuilder"><a class="header" href="#stringbuilder">StringBuilder</a></h4>
<p>https://powershellexplained.com/2017-11-20-Powershell-StringBuilder/</p>
<h4 id="其他容器类型"><a class="header" href="#其他容器类型">其他容器类型</a></h4>
<p><a href="https://gist.github.com/kevinblumenfeld/4a698dbc90272a336ed9367b11d91f1c">Types.md (github.com)</a></p>
<h3 id="时间日期"><a class="header" href="#时间日期">时间日期</a></h3>
<pre><code class="language-powershell">date=Get-Date \
	-Format &quot;dddd MM/dd/yyyy HH:mm K&quot; \  # 返回个格式化字符串。
   -UFormat &quot;%A %m/%d/%Y %R %Z&quot; \
	-DisplayHint Date \  # 仅显示日期
	-Year 2020 -Month 12 -Day 31 \ # 用户初始化
</code></pre>
<pre><code class="language-powershell"> | Specifier | Definition |
 | --- | --- |
 | `dddd` | Day of the week - full name |
 | `MM` | Month number |
 | `dd` | Day of the month - 2 digits |
 | `yyyy` | Year in 4-digit format |
 | `HH:mm` | Time in 24-hour format -no seconds |
 | `K` | Time zone offset from Universal Time Coordinate (UTC) |
 
 | Specifier | Definition |
 | --- | --- |
 | `%A` | Day of the week - full name |
 | `%m` | Month number |
 | `%d` | Day of the month - 2 digits |
 | `%Y` | Year in 4-digit format |
 | `%R` | Time in 24-hour format -no seconds |
 | `%Z` | Time zone offset from Universal Time Coordinate (UTC) |
</code></pre>
<p>.NET format specifiers (/dotnet/standard/ba
se-types/custom-date-and-time-format-strings?view=netframework-4.8)</p>
<pre><code class="language-powershell">date.DayOfYear
$timelabel = Get-Date -Format 'yyyy-MM-ddTHHmmss'
New-Item -Path C:\Test\$timelabel -Type Directory
</code></pre>
<h3 id="内置变量"><a class="header" href="#内置变量">内置变量</a></h3>
<pre><code class="language-powershell">$PSVersionTable   # Powershell版本信息
$PROFILE          # Powershell配置文件路径
</code></pre>
<h3 id="对象"><a class="header" href="#对象">对象</a></h3>
<p>使用<code>Get-Noun</code>方法获取对象，其中<code>None</code>代表对象类型。</p>
<h4 id="对象成员"><a class="header" href="#对象成员">对象成员</a></h4>
<p>获取对象类型，及其成员属性/方法信息。</p>
<pre><code class="language-powershell">$Obj | Get-Member
$Obj | Get-Member -MemberType {Method|Property...} -Name name
</code></pre>
<p><code>Get-Member</code>仅显示默认显示的成员。如果要显示所有成员，可使用<code>Select-Object</code>筛选对象属性<strong>值</strong>，返回仅包含指定属性（模式）的对象。</p>
<pre><code class="language-powershell">$Obj | Select-Object -Property {*|FriendlyName,Issuer}
                     -ExpandProperty SerialNumber  # 将返回值转换为字符串而非对象
</code></pre>
<blockquote>
<p><code>*</code>获取对象所有属性，反之给出要获取的属性名列表（可包含通配符）。</p>
<p>如果管道输入一个序列，则返回每个对象的属性值。</p>
</blockquote>
<h5 id="对象方法"><a class="header" href="#对象方法">对象方法</a></h5>
<p>对象方法通常用于修改对象。</p>
<h5 id="访问对象属性"><a class="header" href="#访问对象属性">访问对象属性</a></h5>
<pre><code class="language-powershell">$x=$myObject.PropertyName
</code></pre>
<p>动态访问对象的属性：</p>
<pre><code class="language-powershell">$PROP = 'Name'
$myObject.$PROP   # $myObject.&quot;Name&quot; =&gt; $myObject.Name
</code></pre>
<h4 id="providers"><a class="header" href="#providers">Providers</a></h4>
<p>提供访问数据的统一接口，数据以类似文件系统的树形结构组织。</p>
<p><code>Get-PSProvider</code>列出所有支持的数据接口<strong>类型</strong>，包括文件系统、证书目录、注册表等。特别地，==PowerShell的函数、环境变量==等也支持该接口。</p>
<pre><code class="language-powershell">Get-PSProvider
# Name           Capabilities                          Drives
# ----           ------------                          ------
# Registry       ShouldProcess, Transactions           {HKLM, HKCU}
# Alias          ShouldProcess                         {Alias}
# Environment    ShouldProcess                         {Env}
# FileSystem     Filter, ShouldProcess, Credentials    {C, D, E, F}
# Function       ShouldProcess                         {Function}
# Variable       ShouldProcess                         {Variable}
# Certificate    ShouldProcess                         {Cert}
# WSMan          Credentials                           {WSMan}
</code></pre>
<p><code>Get-PSDrive</code>获取所有<strong>支持类型</strong>的数据源<strong>实例</strong>信息。</p>
<pre><code class="language-powershell">Get-PSDrive
# Name      Used (GB)  Free (GB) Provider      Root               
# ----      ---------  --------- --------      ----               
# Alias                          Alias                            
# Cert                           Certificate   \                  
# C            256.94     674.00 FileSystem    C:\                
# D            310.46    1552.56 FileSystem    D:\                
# E            920.11    6531.80 FileSystem    E:\                
# F                              FileSystem    F:\                
# Env                            Environment                      
# Function                       Function                         
# HKCU                           Registry      HKEY_CURRENT_USER  
# HKLM                           Registry      HKEY_LOCAL_MACHINE 
# Variable                       Variable                         
# WSMan                          WSMan                            
</code></pre>
<blockquote>
<p>省略了<code>CurrentLocation</code>属性，调整了显示顺序。</p>
</blockquote>
<p>使用<code>Get-ChildItem</code>读取数据源路径下的数据。</p>
<pre><code class="language-powershell">Get-ChildItem -Path Cert:\LocalMachine\CA
Get-ChildItem -Path Function:
</code></pre>
<blockquote>
<p>路径的根为<code>Name:</code>，其中<code>Name</code>为数据源实例名称，如<code>C:</code>、<code>Cert:</code>等。</p>
</blockquote>
<h4 id="services"><a class="header" href="#services">Services</a></h4>
<pre><code class="language-powershell">Get-Service &lt;Name&gt;
</code></pre>
<p>调用服务的方法：</p>
<pre><code class="language-powershell">$service=$(Get-Service -Name w32time)
$service.Stop()
</code></pre>
<blockquote>
<p>成员方法可用于修改获取的对象，而通常没有相关<code>cmdlet</code>直接修改对象。</p>
</blockquote>
<h4 id="自定义对象类型"><a class="header" href="#自定义对象类型">自定义对象类型</a></h4>
<pre><code class="language-shell">$obj = [pscustomobject]@{
   FirstName='Kevin';
   LastName='Marquette'
}
</code></pre>
<h5 id="添加和删除属性"><a class="header" href="#添加和删除属性">添加和删除属性</a></h5>
<pre><code class="language-powershell">$myObject | Add-Member -MemberType NoteProperty -Name 'ID' -Value 'KevinMarquette'
$myObject.psobject.properties.remove('ID')
</code></pre>
<p>添加方法</p>
<pre><code class="language-powershell">$scriptBlock = {...}  # 使用this引用目标对象
Add-Member -MemberType ScriptMethod -InputObject $myObject -Name 'ToHashtable' -Value $scriptBlock
</code></pre>
<h2 id="语法"><a class="header" href="#语法">语法</a></h2>
<h3 id="语句"><a class="header" href="#语句">语句</a></h3>
<p>使用<code>;</code>在一行书写多条语句；</p>
<h5 id="换行"><a class="header" href="#换行">换行</a></h5>
<p><code>,</code>，<code>{}</code>，<code>[]</code>，<code>()</code>，<code>;</code>，<code>=</code>，<code>'</code>，<code>&quot;</code>可以支持命令跨行书写。</p>
<pre><code class="language-powershell">ps_cmd (expr)           # &quot;(...)&quot; 优先计算子表达式并返回值
</code></pre>
<p>如果命令中包含需要首先展开的参数，则使用<code>&amp;</code>对参数进行展开，然后执行展开后的命令语句。</p>
<pre><code class="language-powershell">&amp; $str_cmd $str_opts    # 执行字符串参数所表示的命令
</code></pre>
<p>==在行末使用<code>`</code>强制命令换行以增强可读性==，换行命令间可包含多行注释内容<code>&lt;#...#&gt;</code>。</p>
<h5 id="引号"><a class="header" href="#引号">引号</a></h5>
<blockquote>
<p><em>In PowerShell, you should always use single quotes instead of double quotes unless the contents of the quoted string contains a variable that needs to be expanded to its actual value. By using single quotes, PowerShell doesn't have to parse the contents contained within the quotes so your code runs a little faster.</em></p>
</blockquote>
<h5 id="注释"><a class="header" href="#注释">注释</a></h5>
<p>单行注释：<code>#</code>后续内容为注释；</p>
<p>多行注释：<code>&lt;# comment #&gt;</code>。</p>
<h4 id="管道"><a class="header" href="#管道">管道</a></h4>
<p>通过管道传递对象（变量、数组）将多个命令连接起来。</p>
<pre><code class="language-powershell">dir | Sort-Object -Descending | Select-Object -First 1
</code></pre>
<blockquote>
<p>使用管道操作符连接的命令可在操作符后换行，以方便阅读。</p>
</blockquote>
<p>命令必须产生输出才能传递给管道，使用<code>-PassThru</code>参数强制命令输出内容。通过帮助文档可查看命令的输入和输出要求（<code>INPUT</code>，<code>OUTPUT</code>），查看参数帮助文档以确定参数值是否接受管道输入以及接受输入的类型（<code>Accept pipeline input? True (ByValue, ByPropertyName)</code>）。</p>
<pre><code class="language-powershell">Get-Command -ParameterType ServiceController
</code></pre>
<blockquote>
<p>帮助文档中可能会给出命令的输入输出说明（是否接受管道输入）。</p>
</blockquote>
<p>非PowerShell命令输出的文本行会被自动转换为字符串对象，因此后续命令可基于字符串对象进行计算（如<a href="#%E6%95%B0%E7%BB%84%E8%BF%87%E6%BB%A4">过滤</a>）。</p>
<h5 id="左侧过滤优先"><a class="header" href="#左侧过滤优先">左侧过滤优先</a></h5>
<p>优先使用命令参数过滤返回结果（除非过滤条件没有对应参数支持）；对返回结果进行过滤（<a href="#%E6%95%B0%E7%BB%84%E5%AF%B9%E8%B1%A1%E8%BF%90%E7%AE%97"><code>Where-Object</code></a>）可能产生较大开销。</p>
<h5 id="右侧格式化优先"><a class="header" href="#右侧格式化优先">右侧格式化优先</a></h5>
<p>尽可能最后对数据执行<a href="#%E6%A0%BC%E5%BC%8F%E8%BE%93%E5%87%BA">格式化输出</a>（如<code>Format-Table</code>）。</p>
<h3 id="流程控制"><a class="header" href="#流程控制">流程控制</a></h3>
<h4 id="分支"><a class="header" href="#分支">分支</a></h4>
<pre><code class="language-powershell">if (&lt;result1-to-be-matched&gt; -eq (&lt;test-expression&gt;)) {&lt;action&gt;}
</code></pre>
<p><a href="https://docs.microsoft.com/en-us/powershell/scripting/learn/deep-dives/everything-about-if?view=powershell-7.2">Everything you wanted to know about the if statement - PowerShell | Microsoft Docs</a></p>
<pre><code class="language-powershell">switch [-regex| -wildcard| -exact] [-casesensitive](&lt;test-expression&gt;)
{
    &lt;result1-to-be-matched&gt; {&lt;action&gt;}
    &lt;result2-to-be-matched&gt; {&lt;action&gt;}
    default { &lt;action-scriptblock&gt; }
}
</code></pre>
<blockquote>
<p>默认为精确比较（<code>-exact</code>）。如果输入对象为数组，则<a href="#%E8%BF%AD%E4%BB%A3%E6%95%B0%E7%BB%84">对每个元素进行计算</a>。</p>
</blockquote>
<p><a href="https://docs.microsoft.com/en-us/powershell/scripting/learn/deep-dives/everything-about-switch?view=powershell-7.2">Everything you ever wanted to know about the switch statement - PowerShell | Microsoft Docs</a></p>
<h4 id="循环"><a class="header" href="#循环">循环</a></h4>
<pre><code class="language-powershell">for ($i = 1; $i -lt 5; $i++) {
	Write-Output &quot;Sleeping for $i seconds&quot;
	Start-Sleep -Seconds $i
}
</code></pre>
<blockquote>
<p><a href="#%E8%BF%AD%E4%BB%A3%E6%95%B0%E7%BB%84">数组迭代方法</a>。</p>
</blockquote>
<pre><code class="language-powershell">do{ statements } until (cond_expr)
do{ statements } while (cond_expr)
while (cond_expr) { statements }
</code></pre>
<h4 id="跳转"><a class="header" href="#跳转">跳转</a></h4>
<p>使用<code>break</code>，<code>continue</code>，<a href="https://mikefrobbins.com/2015/07/23/the-powershell-return-keyword/"><code>return</code></a>控制循环执行（loop, switch）。</p>
<h5 id="labeled-continue"><a class="header" href="#labeled-continue">labeled continue</a></h5>
<p>用于连续中断多层循环。</p>
<pre><code class="language-powershell">:labelA for ($i = 1; $i -le 10; $i++) {
    :labelB for ($j = 1; $j -le 10; $j++) {
        :labelC for ($k = 1; $k -le 10; $k++) {
            if ($conditionA) {
                continue labelA   # 连续中断
            else if ($conditionB) {
                continue labelB   # 等效于brek
            } else {
                $condition = Update-Condition
            }
        }
    }
}
</code></pre>
<h4 id="异常处理"><a class="header" href="#异常处理">异常处理</a></h4>
<pre><code class="language-powershell">try { CmdName -ErrorAction Stop } catch {...}
</code></pre>
<blockquote>
<p><em>Only terminating errors are caught.</em></p>
</blockquote>
<p><a href="https://docs.microsoft.com/en-us/powershell/scripting/learn/deep-dives/everything-about-exceptions?view=powershell-7.2">Everything you wanted to know about exceptions - PowerShell | Microsoft Docs</a></p>
<h3 id="函数"><a class="header" href="#函数">函数</a></h3>
<p>函数命名遵循<code>Verb-Noun</code>原则（通过<code>Get-Verb</code>查看常用动词）。</p>
<pre><code class="language-powershell">function Get-Version {
    [CmdletBinding()] # &lt;&lt; turns into an advanced function
    param (
      [Parameter(Mandatory)]                # 必须提供的参数
      [String[]]$ComputerName,              # 声明类型以在运行时自动执行参数类型校验
      
      [ValidateNotNullOrEmpty()]             # 可选参数
      [string[]]$ComputerName = $some_value, # 可选参数的默认值
      
      [Parameter(Mandatory,ValueFromPipeline)] # 接受管道传递参数(by value
      [String[]]$ComputerName, # ValueFromPipelineByPropertyName(by name)
	)
	dynamicparam {&lt;statement list&gt;}
	begin { begin_statements }
	process { process_statements }
	end { end_statements }
}
function Get-Version([type1]$param1[,[type2]$param2]) {}
</code></pre>
<p>通过<code>param</code>声明输入参数，参数命名尽量与内置标准命令方式一致，多个参数以<code>,</code>分隔；对于较为简单的参数声明，也可以直接在函数名后声明。</p>
<h4 id="输入参数"><a class="header" href="#输入参数">输入参数</a></h4>
<h5 id="参数类型"><a class="header" href="#参数类型">参数类型</a></h5>
<ul>
<li>命名参数：通过<code>param()</code>语句声明的参数，可以指定默认值，为指定默认值的参数在运行时必须提供参数值，否则函数报错。</li>
<li>位置参数：非命名参数，通过<code>$args[i]</code>数组访问。可通过<code>@args</code>将所有参数传递给其他函数或命令。</li>
<li>开关参数：通过<code>param()</code>声明类型为<code>[switch]</code>的参数。不需要为该参数提供值，当该参数选项出现在命令时，参数的的值为<code>True</code>。</li>
<li>动态参数：</li>
</ul>
<h5 id="从管道读取参数"><a class="header" href="#从管道读取参数">从管道读取参数</a></h5>
<p><code>begin</code>、<code>process</code>和<code>end</code>语句块用于处理管道输入。<code>begin</code>和<code>end</code>会在函数开始和结束时分别被执行一次，而<code>process</code>语句块则对每一个管道输入对象<code>$_</code>执行一次。</p>
<p>如果声明了以上语句块，则函数的所有语句都必须位于语句块中。未声明语句块的情况，所有语句相当于位于<code>end</code>语句块中。</p>
<h5 id="过滤器"><a class="header" href="#过滤器">过滤器</a></h5>
<p>过滤器(Filters)可被看作只有<code>process</code>代码块的函数。</p>
<h4 id="返回值"><a class="header" href="#返回值">返回值</a></h4>
<p>函数的返回值可以在终端显示、赋值给变量或转递给其他函数/命令。函数中可通过调用的命令返回数据，或通过调用<code>return</code>返回数据对象。<code>return</code>语句会立即令函数返回。</p>
<h4 id="高级函数"><a class="header" href="#高级函数">高级函数</a></h4>
<p>高级函数具有自动添加的公共参数，例如<code>Debug</code>和<code>Verbose</code>。</p>
<p><a href="https://docs.microsoft.com/en-us/powershell/scripting/learn/deep-dives/everything-about-shouldprocess?view=powershell-7.2">Everything you wanted to know about ShouldProcess - PowerShell | Microsoft Docs</a></p>
<h3 id="cmdlets"><a class="header" href="#cmdlets">cmdlets</a></h3>
<h4 id="注释文档"><a class="header" href="#注释文档">注释文档</a></h4>
<p>函数注释文档可位于：函数体开头（位于<code>{</code>之后的行）；函数体结束前（位于<code>}</code>之前），或==函数定义关键字前<code>function</code>的行（不可有空行隔开）==。</p>
<p>脚本注释文档位于脚本开始或结束。</p>
<p>脚本模块注释文档<code>.psm1</code>与函数注释文档语法一致。</p>
<pre><code class="language-powershell">&lt;#
.SYNOPSIS
    函数用途简要说明。

.DESCRIPTION
    函数功能的详细描述。

.PARAMETER ComputerName
    参数说明

.EXAMPLE
     使用示例。

.INPUTS
    输入类型

.OUTPUTS
    输出类型

.NOTES
    Author:  Mike F Robbins
    Website: http://mikefrobbins.com
    Twitter: @mikefrobbins
#&gt;
</code></pre>
<p><code>PARAMETER</code>和<code>EXAMPLE</code>可声明多次。</p>
<div class="footnote-definition" id="comment-keywords"><sup class="footnote-definition-label">3</sup>
<p> <a href="https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_comment_based_help?view=powershell-7.2#comment-based-help-keywords">Comment-based help keywords</a>。</p>
</div>
<h3 id="命名空间"><a class="header" href="#命名空间">命名空间</a></h3>
<p>在脚本开始位置引入命名空间，方便引用其中的类型和方法。</p>
<pre><code class="language-powershell">using namespace System.Collections.Generic
$myList = [List[int]]@(1,2,3)
</code></pre>
<h3 id="作用域"><a class="header" href="#作用域">作用域</a></h3>
<p><a href="https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_scopes?view=powershell-7.2">about Scopes - PowerShell | Microsoft Learn</a></p>
<h2 id="输入输出"><a class="header" href="#输入输出">输入输出</a></h2>
<pre><code class="language-powershell">Get-Content [-Path] filepath      # -&gt; cat, type
Write-Output 'message' &gt; filename # -&gt; echo
'message' &gt; filename
'message' | Out-File -FilePath filename
</code></pre>
<p>不同级别的输出函数：</p>
<pre><code class="language-powershell">Write-Verbose -Message &quot;message&quot;  # 仅在开启Verbose选项时输出
Write-Debug
Write-Information
Write-Warning
Write-Error
</code></pre>
<h3 id="重定向"><a class="header" href="#重定向">重定向</a></h3>
<h5 id="输出重定向"><a class="header" href="#输出重定向">输出重定向</a></h5>
<p><code>n&gt;, n&gt;&gt;</code>：输出流<code>n=</code>：<code>*</code> All output；<code>1</code> Success output；<code>2</code> Errors；<code>3</code> Warning messages；<code>4</code> Verbose output；<code>5</code> Debug messages。</p>
<h5 id="吸收输出"><a class="header" href="#吸收输出">吸收输出</a></h5>
<ul>
<li><code>expr | Out-Null</code>，<code>expr &gt; $null</code>；</li>
<li><code>[void] expr</code>；</li>
<li><code>$null=expr</code>；</li>
</ul>
<h3 id="格式输出"><a class="header" href="#格式输出">格式输出</a></h3>
<p>当输出为多个对象组成的列表格式（即<code>key:value</code>形式），可通过<code>Format-Table</code>将其转换为表格形式：</p>
<pre><code class="language-powershell">$obj | Select-Object -Property Name,Type,Status | Format-Table
</code></pre>
<p>反之，可以将表格输出转换为列表输出。</p>
<pre><code class="language-powershell">Format-List
</code></pre>
<p><code>Format-*</code>命令会将输出对象封装为<code>Foramt</code>对象，因此可能<a href="#%E5%8F%B3%E4%BE%A7%E6%A0%BC%E5%BC%8F%E5%8C%96%E4%BC%98%E5%85%88">不再能传递给其他命令</a>。</p>
<h5 id="文本模式输出"><a class="header" href="#文本模式输出">文本模式输出</a></h5>
<p>将对象转换为文本输出（可用于传统基于文本的命令进行后续处理）：</p>
<pre><code class="language-powershell">Find-Module *cim* | Out-String -Stream | grep CimSession
</code></pre>
<p><code>-Stream</code>将输出按行分解便于后续处理。</p>
<p><code>-Width</code>设置输出宽度，避免换行或截断。</p>
<h3 id="网络应用"><a class="header" href="#网络应用">网络应用</a></h3>
<blockquote>
<p>The <code>Invoke-WebRequest</code> cmdlet sends HTTP and HTTPS requests to a web page or web service. It parses the response and returns collections of links, images, and other significant HTML elements.</p>
</blockquote>
<pre><code class="language-powershell">Invoke-WebRequest # alias =&gt; curl,wget
	-Uri &lt;uri&gt;
	-Headers &lt;dict&gt;  # http header
	-Body &lt;obj&gt;      # http body
	-InFile &lt;file&gt;   # read request from file
	-OutFile &lt;filename&gt;  # 未指定则输出到管道
	-Method &lt;m&gt;      # http method: get/put/post...
</code></pre>
<h2 id="脚本"><a class="header" href="#脚本">脚本</a></h2>
<p>脚本文件类型<code>.ps1</code>。</p>
<p>在当前Shell环境执行脚本。</p>
<pre><code class="language-powershell">. 'c:\scripts\sample.ps1'
</code></pre>
<h5 id="脚本文件编码"><a class="header" href="#脚本文件编码">脚本文件编码</a></h5>
<p>PowerShell 5.x默认使用的是本地化编码方案（如GBK/936），因此如果包含非ASCII码文字的脚本应该使用对应区域的本地化编码方案保存。（例外：VS Code中的集成终端代码页为936，但能正确读取UTF-8编码）</p>
<p>PowerShell 7.x默认使用UTF-8/65001编码。</p>
<p>PowerShell解释器会首先读入整个脚本文件内容，并检查语法错误。如果出现编码问题导致语法错误，则会直接抛出语法错误而不执行文件。</p>
<p>通过启动配置<code>$Profile</code>修改终端的默认编码（<a href="https://stackoverflow.com/a/49481797/6571140">由于.NET缓存机制的原因，在启动后的PowerShell终端中调用<code>chcp</code>命令无效</a>，<code>chcp</code>在<code>cmd</code>中是有效的）：</p>
<pre><code class="language-powershell">$OutputEncoding = [console]::InputEncoding `
                = [console]::OutputEncoding `
                = New-Object System.Text.UTF8Encoding
</code></pre>
<h3 id="作用域-1"><a class="header" href="#作用域-1">作用域</a></h3>
<h4 id="全局作用域"><a class="header" href="#全局作用域">全局作用域</a></h4>
<p>位于脚本中的函数的作用域为脚本（<em>Script</em> scope），当脚本被加载或执行完后，脚本作用域中的函数不再可见。使用<code>.</code>命令加载脚本中的函数到全局作用域（<em>Global</em> scope）。</p>
<pre><code class="language-powershell">. .\My-Script.ps1
</code></pre>
<h4 id="脚本模块"><a class="header" href="#脚本模块">脚本模块</a></h4>
<p>以<code>.psm1</code>保存的脚本。如果脚本模块保存在PoweShell模块搜索路径下，<a href="#%E5%AF%BC%E5%85%A5%E6%A8%A1%E5%9D%97">则会被自动加载；反之，需要手动导入</a>。</p>
<pre><code class="language-powershell">Export-ModuleMember -Function Get-PublicFunction  # 在模块中导出定义公开函数
</code></pre>
<p>为模块创建元数据（元数据存储路径通常和模块位于同一路径下）：</p>
<pre><code class="language-powershell">New-ModuleManifest -Path $ModulePath\MyScriptModule\MyScriptModule.psd1 
                   -RootModule MyScriptModule      # 必须指定
                   -Author 'Mike F Robbins' 
                   -Description 'MyScriptModule' 
                   -CompanyName 'mikefrobbins.com'
Update-ModuleManifest # 更新元数据，重复调用New-ModuleManifest会导致GUID变化                   
</code></pre>
<p>导出的公开函数也可在元数据文件中指定：</p>
<pre><code class="language-powershell">FunctionsToExport = 'Get-PublicFunction'
</code></pre>
<h3 id="运行环境"><a class="header" href="#运行环境">运行环境</a></h3>
<h4 id="环境变量"><a class="header" href="#环境变量">环境变量</a></h4>
<h5 id="读取环境变量"><a class="header" href="#读取环境变量">读取环境变量</a></h5>
<pre><code class="language-powershell">Get-ChildItem env:  # 注意结尾的“:”
Get-ChildItem Env:JAVA_HOME # =&gt; Get-ChildItem Env:\JAVA_HOME
echo $Env:JAVA_HOME         # echo ${Env:JAVA_HOME} =&gt; echo ${Env:\JAVA_HOME}
Get-ChildItem Env: | Format-Table -Wrap -AutoSize
</code></pre>
<h5 id="设置环境变量"><a class="header" href="#设置环境变量">设置环境变量</a></h5>
<pre><code class="language-powershell">$Env:JAVA_HOME='C:\tools\jdk'  # 仅当前会话有效
$Env:Path='C:\tools\jdk;'+$Env:Path
</code></pre>
<blockquote>
<p>路径搜索优先级：从左至右搜索，将新路径置于左侧将覆盖已有配置。</p>
</blockquote>
<h4 id="脚本输入参数"><a class="header" href="#脚本输入参数">脚本输入参数</a></h4>
<p>脚本的输入参数格式与函数输入参数语法格式一致。</p>
<pre><code class="language-powershell">param (
    [string]$Target = '.\src',
    [string]$Source = '.\target'
)
</code></pre>
<p>定义的参数可在命令行中获得自动补全功能。</p>
<h4 id="语句的退出状态码"><a class="header" href="#语句的退出状态码">语句的退出状态码</a></h4>
<pre><code class="language-powershell">$?             # return 'True'/'False' for success/error
$LastExistCode # Return 0 for success
</code></pre>
<h4 id="执行策略"><a class="header" href="#执行策略">执行策略</a></h4>
<p>PowerShell 执行策略是一项安全功能，用于控制 PowerShell 加载配置文件和运行脚本的条件。 此功能有助于防止恶意脚本的执行。可以为本地计算机、当前用户或特定会话设置执行策略。 你还可以使用组策略设置为计算机和用户设置执行策略。本地计算机和当前用户的执行策略存储在注册表中。 不需要在 PowerShell 配置文件中设置执行策略。 特定会话的执行策略仅存储在内存中，并在会话关闭时丢失。</p>
<blockquote>
<p>执行策略不是限制用户操作的安全系统。 例如，当用户无法运行脚本时，可以通过在命令行中键入脚本内容来轻松地绕过策略。 相反，执行策略可帮助用户设置基本规则并防止无意中违反它们。</p>
</blockquote>
<div class="table-wrapper"><table><thead><tr><th>策略</th><th>详情</th></tr></thead><tbody>
<tr><td>AllSigned</td><td>脚本必须由信任发布方签名；在未确认的脚本运行前提示用户；==可能面临运行已签名的恶意脚本的风险==。</td></tr>
<tr><td>Bypass</td><td>不会阻止且不会产生警告或信息；</td></tr>
<tr><td>Default</td><td>默认策略：<strong>Restricted</strong> for Windows clients.<strong>RemoteSigned</strong> for Windows servers.</td></tr>
<tr><td>RemoteSigned</td><td>来自互联网的脚本需要来自信任发布方的数字签名；本地脚本允许执行。</td></tr>
<tr><td>Restricted</td><td>==允许单独执行命令，但不允许运行脚本==；</td></tr>
<tr><td>Undefined</td><td>If the policy in all scopes is <strong>Undefined</strong>, use <strong>Default</strong>.</td></tr>
<tr><td>Unrestricted</td><td>非Windows主机的默认策略；未签名脚本可以运行，非本地脚本运行前警告用户。</td></tr>
</tbody></table>
</div>
<h5 id="设置策略"><a class="header" href="#设置策略">设置策略</a></h5>
<pre><code class="language-powershell">Set-ExecutionPolicy &lt;policy&gt;
</code></pre>
<h2 id="标准库"><a class="header" href="#标准库">标准库</a></h2>
<h3 id="wmi和cim"><a class="header" href="#wmi和cim">WMI和CIM</a></h3>
<p>Windows Management Instrumentation (WMI)模块：弃用。</p>
<p>Common Information Model (CIM)模块：跨平台，通过CIM可访问WMI。</p>
<pre><code class="language-powershell">Get-Command -Module CimCmdlets
Get-CimInstance -Query 'Select * from Win32_BIOS'  # WMI Query Language (WQL)
Get-CimInstance -ClassName Win32_BIOS
</code></pre>
<p>远程管理（指定<code>ComputerName</code>参数）：以域管理员启动PowerShell并执行</p>
<pre><code class="language-powershell">Get-CimInstance -ComputerName dc01 -ClassName Win32_BIOS
</code></pre>
<p>或者首先提供凭据（密码）并创建CIM会话：</p>
<pre><code class="language-powershell">$CimSession = New-CimSession -ComputerName dc01 -Credential (Get-Credential)
Get-CimInstance -CimSession $CimSession -ClassName Win32_BIOS
</code></pre>
<h2 id="远程登录"><a class="header" href="#远程登录">远程登录</a></h2>
<p>从Windows可选功能中安装OpenSSH Server。</p>
<p><a href="https://docs.microsoft.com/en-us/windows-server/administration/openssh/openssh_install_firstuse">Installation of OpenSSH For Windows Server 2019 and Windows 10</a></p>
<p>远程登录后默认的Shell是<code>cmd.exe</code>，如果要启用<code>PowerShell</code>，可在命令窗口中运行<code>powershell</code>，或者直接在远程登录命令中运行该命令。</p>
<pre><code class="language-powershell">ssh user@host &quot;chcp65001 &amp;&amp; powershell&quot;
</code></pre>
<blockquote>
<p>直接进入Powershell会导致中文乱码，需要先切换编码到<code>UTF-8</code>。</p>
</blockquote>
<p><a href="https://docs.microsoft.com/en-us/powershell/scripting/learn/remoting/ssh-remoting-in-powershell-core?view=powershell-7.2">PowerShell Remoting Over SSH - PowerShell | Microsoft Docs</a></p>
<h2 id="附录"><a class="header" href="#附录">附录</a></h2>
<h3 id="cmd"><a class="header" href="#cmd">cmd</a></h3>
<p>注释语句：</p>
<pre><code class="language-bash">REM comment something
</code></pre>
<p>使用<code>^</code>对单条命令进行换行，<code>^</code>后不可包含任何符号。</p>
<h4 id="变量-1"><a class="header" href="#变量-1">变量</a></h4>
<p>变量名不区分大小写。查看变量：</p>
<pre><code class="language-powershell">set [ | more]
set var           # print: key=value
echo %variable%   # 使用`%%`读取变量的值，未定义的变量将打印变量名
</code></pre>
<h5 id="定义console环境变量"><a class="header" href="#定义console环境变量">定义console环境变量</a></h5>
<pre><code class="language-powershell">set variable=value   # 必须设用set，不支持VAR=VALUE
</code></pre>
<blockquote>
<p><code>PATH</code>既是环境变量，也是一个命令（单独使用<code>PATH</code>可显示<code>PATH</code>变量的值，也可使用<code>PATH=value</code>为<code>PATH</code>变量赋值，普通变量必须使用<code>set</code>命令）。</p>
</blockquote>
<p>参数变量：</p>
<pre><code class="language-sh">%1 %2 %3 %4 %5 %6 %7 %8 %9
</code></pre>
<pre><code class="language-sh">%~dp0
</code></pre>
<blockquote>
<p>获取当前执行文件所在目录。</p>
<p><a href="https://www.cnblogs.com/smwikipedia/archive/2009/03/30/1424749.html">扩充变量语法</a>。</p>
</blockquote>
<h5 id="字符串-1"><a class="header" href="#字符串-1">字符串</a></h5>
<p>字符串不需要使用引号表示，单双引号均为普通字符。将两个字符串连接即视为字符串拼接。</p>
<h5 id="环境变量-1"><a class="header" href="#环境变量-1">环境变量</a></h5>
<pre><code class="language-bash">echo %USERPROFILE%   # 用户目录
echo %PROGRAMDATA%   # 应用程序配置文件路径
chcp 65001  # 支持PowerShell
</code></pre>
<blockquote>
<p><strong>Windows Code page 936</strong>, is Microsoft's character encoding for <a href="https://en.wikipedia.org/wiki/Simplified_Chinese">simplified Chinese</a>, one of the four <a href="https://en.wikipedia.org/wiki/DBCS">DBCSs</a> for <a href="https://en.wikipedia.org/wiki/East_Asian_languages">East Asian languages</a>. Originally, Windows-936 covered <a href="https://en.wikipedia.org/wiki/GB_2312">GB 2312</a> (in its <a href="https://en.wikipedia.org/wiki/EUC-CN">EUC-CN</a> form), but it was expanded to cover most of <a href="https://en.wikipedia.org/wiki/GBK_(character_encoding)">GBK</a> with the release of <a href="https://en.wikipedia.org/wiki/Windows_95">Windows 95</a>.</p>
<p>https://en.wikipedia.org/wiki/UTF-8#Official_name_and_variants.</p>
</blockquote>
<p><a href="https://en.wikipedia.org/wiki/Windows_code_page">Windows Code Page</a>: <a href="936/1386">936/1386</a> (GBK), 950/1370 (Big5), 1200 (UTF-16LE), 1201 (UTF-16BE), 54936 (GB18030), 65001 (UTF-8).</p>
<h5 id="环境变量作用域"><a class="header" href="#环境变量作用域">环境变量作用域</a></h5>
<pre><code class="language-powershell">setlocal  # 执行之后所做的环境改动只限于批处理文件直到endlocal。
endlocal  # 脚本结束前隐式执行
</code></pre>
<h4 id="语句-1"><a class="header" href="#语句-1">语句</a></h4>
<pre><code class="language-powershell">dir &amp; echo foo
dir &amp;&amp; echo foo   # execute only if the first exited successfully
</code></pre>
<p><a href="https://stackoverflow.com/questions/8055371/how-do-i-run-two-commands-in-one-line-in-windows-cmd">batch file - How do I run two commands in one line in Windows CMD? - Stack Overflow</a></p>
<h4 id="常用命令"><a class="header" href="#常用命令">常用命令</a></h4>
<pre><code class="language-powershell">help [cmd]  # cmd /?
</code></pre>
<pre><code class="language-powershell">call jobname.bat
</code></pre>
<blockquote>
<p>调用脚本。</p>
</blockquote>
<pre><code class="language-powershell">pause
</code></pre>
<blockquote>
<p>暂停。</p>
</blockquote>
<pre><code class="language-powershell">exit
</code></pre>
<blockquote>
<p>退出。</p>
</blockquote>
<pre><code class="language-powershell">cd [/D] path 
</code></pre>
<blockquote>
<p>切换当前目录。</p>
</blockquote>
<pre><code class="language-powershell">type file
</code></pre>
<blockquote>
<p>输出文件内容。</p>
</blockquote>
<h3 id="流程控制-1"><a class="header" href="#流程控制-1">流程控制</a></h3>
<pre><code class="language-powershell">if [not] ERRORLEVEL &lt;number&gt; &lt;command&gt; [else &lt;expression&gt;]
if [not] &lt;string1&gt; == &lt;string2&gt; &lt;command&gt; [else &lt;expression&gt;]
if [not] exist &lt;filename&gt; &lt;command&gt; [else &lt;expression&gt;]
</code></pre>
<p><code>errorlevel</code>：上一条命令的执行状态。</p>
<p><a href="https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/if">if | Microsoft Docs</a></p>
<pre><code class="language-powershell">for {%% | %}&lt;variable&gt; in (&lt;set&gt;) do &lt;command&gt; [&lt;commandlineoptions&gt;]
# for %f in (*.doc *.txt) do type %f
</code></pre>
<p><a href="https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/for">for | Microsoft Docs</a></p>
<h3 id="控制台输入输出"><a class="header" href="#控制台输入输出">控制台输入输出</a></h3>
<pre><code class="language-powershell">echo on|off      # 控制是否回显命令行提示符
echo some string 
</code></pre>
<blockquote>
<p>字符串不需要使用引号表示，单双引号均为普通字符。</p>
</blockquote>
<h2 id="参考资料"><a class="header" href="#参考资料">参考资料</a></h2>
<div class="footnote-definition" id="pw101"><sup class="footnote-definition-label">4</sup>
<p><a href="https://docs.microsoft.com/en-us/powershell/scripting/learn/ps101/00-introduction">PowerShell 101</a>.
<sup class="footnote-reference"><a href="#nuget">1</a></sup>: <a href="https://docs.microsoft.com/en-us/powershell/scripting/gallery/how-to/working-with-packages/manual-download?view=powershell-7">Manual Package Download - PowerShell | Microsoft Docs</a></p>
</div>
<div class="footnote-definition" id="pwstd"><sup class="footnote-definition-label">5</sup>
<p><a href="https://docs.microsoft.com/en-us/powershell/scripting/lang-spec/chapter-01?view=powershell-7.2">Windows PowerShell Language Specification 3.0</a>
<sup class="footnote-reference"><a href="#pwcore">6</a></sup>: <a href="https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/?view=powershell-7.2">Reference - Microsoft.PowerShell.Core</a>
<sup class="footnote-reference"><a href="#preced">2</a></sup>: <a href="https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_operator_precedence?view=powershell-7.2">about Operator Precedence - PowerShell | Microsoft Docs</a></p>
</div>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../Windows/Windows配置管理.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="../Windows/Windows Applications.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../Windows/Windows配置管理.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="../Windows/Windows Applications.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="../theme/pagetoc.js"></script>
        <script type="text/javascript" src="../theme/MathJax.js"></script>
    </body>
</html>